/*
 * $Id: chipman.pm,v 1.5 Broadcom SDK n *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenUM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 */
#ifndef __BCM5607X_REGS_H__
#define __BCM5607X_REGS_H__

/* Blocks */
#define PGW_GE0_BLOCK_ID                4
#define PGW_GE1_BLOCK_ID                5
#define PGW_GE2_BLOCK_ID                6
#define TAF_BLOCK_ID                    9
#define IPIPE_BLOCK_ID                  10
#define EPIPE_BLOCK_ID                  11
#define MMU_BLOCK_ID                    12
#define OTPC_BLOCK_ID                   13
#define CMIC_BLOCK_ID                   14
#define IPROC_BLOCK_ID                  15
#define TOP_BLOCK_ID                    16
#define SER_BLOCK_ID                    17
#define AVS_BLOCK_ID                    18
#define MACSEC_BLOCK_ID                 19
#define CLPORT0_BLOCK_ID                20
#define CLPORT1_BLOCK_ID                21
#define CLPORT2_BLOCK_ID                22
#define CLPORT3_BLOCK_ID                23
#define XLPORT0_BLOCK_ID                32
#define GPORT0_BLOCK_ID                 33
#define GPORT1_BLOCK_ID                 34
#define PMQPORT0_BLOCK_ID               35
#define XLPORT1_BLOCK_ID                36
#define GPORT2_BLOCK_ID                 37
#define GPORT3_BLOCK_ID                 38
#define PMQPORT1_BLOCK_ID               39
#define XLPORT2_BLOCK_ID                40
#define GPORT4_BLOCK_ID                 41
#define GPORT5_BLOCK_ID                 42
#define PMQPORT2_BLOCK_ID               43

/* Physical Port */
#define PHY_PMQPORT0_BASE                   2 /* physical port 2 ~ 17 */
#define PHY_GPORT0_BASE                     2 /* physical port 2 ~ 9 */
#define PHY_GPORT1_BASE                     10 /* physical port 10 ~ 17 */
#define PHY_PMQPORT1_BASE                   18 /* physical port 18 ~ 33 */
#define PHY_GPORT2_BASE                     18 /* physical port 18 ~ 25 */
#define PHY_GPORT3_BASE                     26 /* physical port 26 ~ 33 */
#define PHY_PMQPORT2_BASE                   34 /* physical port 34 ~ 49 */
#define PHY_GPORT4_BASE                     34 /* physical port 34 ~ 41 */
#define PHY_GPORT5_BASE                     42 /* physical port 42 ~ 49 */
#define PHY_XLPORT0_BASE                    50 /* physical port 50 ~ 53 */
#define PHY_XLPORT1_BASE                    54 /* physical port 54 ~ 57 */
#define PHY_XLPORT2_BASE                    58 /* physical port 58 ~ 61 */
#define PHY_CLPORT0_BASE                    62 /* physical port 62 ~ 65 */
#define PHY_CLPORT1_BASE                    66 /* physical port 66 ~ 69 */
#define PHY_CLPORT2_BASE                    70 /* physical port 70 ~ 73 */
#define PHY_CLPORT3_BASE                    74 /* physical port 74 ~ 77 */

/* Low level register/memory access function */ 
extern uint32 *field_get(const uint32 *entbuf, int sbit, int ebit, uint32 *fbuf); 
extern void field_set(uint32 *entbuf, int sbit, int ebit, uint32 *fbuf); 
extern uint32 field32_get(const uint32 *entbuf, int sbit, int ebit); 
extern void field32_set(uint32 *entbuf, int sbit, int ebit, uint32 fval); 
extern sys_error_t bcm5607x_read32(uint8 unit, uint32 addr, uint32 *val); 
extern sys_error_t bcm5607x_write32(uint8 unit, uint32 addr, uint32 val);  
extern sys_error_t bcm5607x_reg_get(uint8 unit, uint8 block_id, uint32 addr, uint32 *val); 
extern sys_error_t bcm5607x_reg_set(uint8 unit, uint8 block_id, uint32 addr, uint32 val);  
extern sys_error_t bcm5607x_reg64_get(uint8 unit, uint8 block_id, uint32 addr, uint32 *val, int len); 
extern sys_error_t bcm5607x_reg64_set(uint8 unit, uint8 block_id, uint32 addr, uint32 *val, int len); 
extern sys_error_t bcm5607x_mem_get(uint8 unit, uint8 block_id, uint32 addr, uint32 *val, int len); 
extern sys_error_t bcm5607x_mem_set(uint8 unit, uint8 block_id, uint32 addr, uint32 *val, int len); 
extern sys_error_t bcm5607x_tcam_mem_get(uint8 unit, uint8 block_id, uint32 addr,  uint32 *val, int len, uint32 key_sp, uint32 mask_sp, int key_len); 
extern sys_error_t bcm5607x_tcam_mem_set(uint8 unit, uint8 block_id, uint32 addr, uint32 *val, int len, uint32 key_sp, uint32 mask_sp, int key_len); 
/* Port block mapping structure */ 
extern const char bcm5607x_xlport_pport_to_blockid[];
extern const char bcm5607x_xlport_pport_to_index_in_block[];
extern char bcm5607x_xlport_lport_to_blockid[];
extern char bcm5607x_xlport_lport_to_index_in_block[];
extern const char bcm5607x_pgw_ge_pport_to_blockid[];
extern const char bcm5607x_pgw_ge_pport_to_index_in_block[];
extern char bcm5607x_pgw_ge_lport_to_blockid[];
extern char bcm5607x_pgw_ge_lport_to_index_in_block[];
extern const char bcm5607x_clport_pport_to_blockid[];
extern const char bcm5607x_clport_pport_to_index_in_block[];
extern char bcm5607x_clport_lport_to_blockid[];
extern char bcm5607x_clport_lport_to_index_in_block[];
extern const char bcm5607x_pmqport_pport_to_blockid[];
extern const char bcm5607x_pmqport_pport_to_index_in_block[];
extern char bcm5607x_pmqport_lport_to_blockid[];
extern char bcm5607x_pmqport_lport_to_index_in_block[];
extern const char bcm5607x_gport_pport_to_blockid[];
extern const char bcm5607x_gport_pport_to_index_in_block[];
extern char bcm5607x_gport_lport_to_blockid[];
extern char bcm5607x_gport_lport_to_index_in_block[];

extern void bcm5607x_init_port_block_map(uint16 devid, uint16 revid);
/* AVS */
#define R_AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTR   AVS_BLOCK_ID, (0x02003c00)
/* XLPORT0 XLPORT1 XLPORT2 */
#define R_PGW_XL_CONFIG(port)                  (0x00080000 + (port))
#define R_PGW_XL_ECC_CONTROL                   (0x02080400)
#define R_PGW_XL_TXFIFO_CTRL(port)             (0x00080100 + (port))
#define R_XLMAC_CTRL(port)                     (0x00060000 + (port))
#define R_XLMAC_EEE_CTRL(port)                 (0x00061a00 + (port))
#define R_XLMAC_EEE_TIMERS(port)               (0x00061b00 + (port))
#define R_XLMAC_LLFC_CTRL(port)                (0x00061200 + (port))
#define R_XLMAC_MODE(port)                     (0x00060100 + (port))
#define R_XLMAC_PAUSE_CTRL(port)               (0x00060d00 + (port))
#define R_XLMAC_PFC_CTRL(port)                 (0x00060e00 + (port))
#define R_XLMAC_PFC_DA(port)                   (0x00061100 + (port))
#define R_XLMAC_PFC_OPCODE(port)               (0x00061000 + (port))
#define R_XLMAC_PFC_TYPE(port)                 (0x00060f00 + (port))
#define R_XLMAC_RX_CTRL(port)                  (0x00060600 + (port))
#define R_XLMAC_RX_LSS_CTRL(port)              (0x00060a00 + (port))
#define R_XLMAC_RX_LSS_STATUS(port)            (0x00060b00 + (port))
#define R_XLMAC_RX_MAC_SA(port)                (0x00060700 + (port))
#define R_XLMAC_RX_MAX_SIZE(port)              (0x00060800 + (port))
#define R_XLMAC_RX_VLAN_TAG(port)              (0x00060900 + (port))
#define R_XLMAC_TIMESTAMP_ADJUST(port)         (0x00062000 + (port))
#define R_XLMAC_TIMESTAMP_BYTE_ADJUST(port)    (0x00062100 + (port))
#define R_XLMAC_TXFIFO_CELL_CNT(port)          (0x00062c00 + (port))
#define R_XLMAC_TXFIFO_CELL_REQ_CNT(port)      (0x00062d00 + (port))
#define R_XLMAC_TX_CTRL(port)                  (0x00060400 + (port))
#define R_XLMAC_TX_MAC_SA(port)                (0x00060500 + (port))
#define R_XLMAC_TX_TIMESTAMP_FIFO_DATA(port)   (0x00061500 + (port))
#define R_XLMAC_TX_TIMESTAMP_FIFO_STATUS(port)   (0x00061600 + (port))
#define R_XLMIB_RBCA(port)                     (0x00000e00 + (port))
#define R_XLMIB_RBYT(port)                     (0x00003d00 + (port))
#define R_XLMIB_RFCS(port)                     (0x00000f00 + (port))
#define R_XLMIB_RMCA(port)                     (0x00000d00 + (port))
#define R_XLMIB_ROVR(port)                     (0x00001a00 + (port))
#define R_XLMIB_RPKT(port)                     (0x00000b00 + (port))
#define R_XLMIB_RUCA(port)                     (0x00000c00 + (port))
#define R_XLMIB_RXPF(port)                     (0x00001100 + (port))
#define R_XLMIB_RX_EEE_LPI_DURATION_COUNTER(port)   (0x00003700 + (port))
#define R_XLMIB_RX_EEE_LPI_EVENT_COUNTER(port)   (0x00003600 + (port))
#define R_XLMIB_TBCA(port)                     (0x00004f00 + (port))
#define R_XLMIB_TBYT(port)                     (0x00006f00 + (port))
#define R_XLMIB_TFCS(port)                     (0x00005300 + (port))
#define R_XLMIB_TMCA(port)                     (0x00004e00 + (port))
#define R_XLMIB_TOVR(port)                     (0x00005500 + (port))
#define R_XLMIB_TPKT(port)                     (0x00004c00 + (port))
#define R_XLMIB_TUCA(port)                     (0x00004d00 + (port))
#define R_XLMIB_TXPF(port)                     (0x00005000 + (port))
#define R_XLMIB_TX_EEE_LPI_DURATION_COUNTER(port)   (0x00006b00 + (port))
#define R_XLMIB_TX_EEE_LPI_EVENT_COUNTER(port)   (0x00006a00 + (port))
#define R_XLPORT_CNTMAXSIZE(port)              (0x00020100 + (port))
#define R_XLPORT_ENABLE_REG                    (0x02020b00)
#define R_XLPORT_FAULT_LINK_STATUS(port)       (0x00020500 + (port))
#define R_XLPORT_LED_CHAIN_CONFIG              (0x02022300)
#define R_XLPORT_MAC_CONTROL                   (0x02021000)
#define R_XLPORT_MAC_RSV_MASK(port)            (0x00020800 + (port))
#define R_XLPORT_MIB_RESET                     (0x02022400)
#define R_XLPORT_MODE_REG                      (0x02020a00)
#define R_XLPORT_SOFT_RESET                    (0x02020c00)
#define R_XLPORT_WC_UCMEM_CTRL                 (0x02021900)
#define M_XLPORT_WC_UCMEM_DATA(idx)            (0x00000000+(idx))
#define R_XLPORT_XGXS0_CTRL_REG                (0x02021400)
/* EPIPE */
#define R_EGR_CONFIG                           EPIPE_BLOCK_ID, (0x06000400)
#define M_EGR_EM_MTP_INDEX(idx)                EPIPE_BLOCK_ID, (0x144c0000+(idx))
#define M_EGR_ENABLE(idx)                      EPIPE_BLOCK_ID, (0x30b00000+(idx))
#define R_EGR_HW_RESET_CONTROL_0               EPIPE_BLOCK_ID, (0x02000000)
#define R_EGR_HW_RESET_CONTROL_1               EPIPE_BLOCK_ID, (0x02000100)
#define M_EGR_IM_MTP_INDEX(idx)                EPIPE_BLOCK_ID, (0x14480000+(idx))
#define R_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPING(port)   EPIPE_BLOCK_ID, (0x30001c00 + (port))
#define R_EGR_PORT_64(port)                    EPIPE_BLOCK_ID, (0x04000900 + (port))
#define R_EGR_PORT_BUFFER_CLK_SHUTDOWN         EPIPE_BLOCK_ID, (0x32012800)
#define M_EGR_PORT_CREDIT_RESET(idx)           EPIPE_BLOCK_ID, (0x30100000+(idx))
#define M_EGR_PORT_REQUESTS(idx)               EPIPE_BLOCK_ID, (0x30080000+(idx))
#define M_EGR_TDM_PORT_MAP                     EPIPE_BLOCK_ID, (0x30000000)
#define M_EGR_VLAN(idx)                        EPIPE_BLOCK_ID, (0x101c0000+(idx))
#define R_EGR_VLAN_CONTROL_1(port)             EPIPE_BLOCK_ID, (0x04000c00 + (port))
#define M_EGR_VLAN_STG(idx)                    EPIPE_BLOCK_ID, (0x10200000+(idx))
/* PGW_GE0 PGW_GE1 PGW_GE2 */
#define R_PGW_GE_RXFIFO_SOFT_RESET             (0x02090500)
/* CLPORT0 CLPORT1 CLPORT2 CLPORT3 */
#define R_CLMAC_CTRL(port)                     (0x00060100 + (port))
#define R_CLMAC_EEE_CTRL(port)                 (0x00061900 + (port))
#define R_CLMAC_EEE_TIMERS(port)               (0x00061a00 + (port))
#define R_CLMAC_LLFC_CTRL(port)                (0x00061100 + (port))
#define R_CLMAC_MODE(port)                     (0x00060200 + (port))
#define R_CLMAC_PAUSE_CTRL(port)               (0x00060c00 + (port))
#define R_CLMAC_PFC_CTRL(port)                 (0x00060d00 + (port))
#define R_CLMAC_PFC_DA(port)                   (0x00061000 + (port))
#define R_CLMAC_PFC_OPCODE(port)               (0x00060f00 + (port))
#define R_CLMAC_PFC_TYPE(port)                 (0x00060e00 + (port))
#define R_CLMAC_RX_CTRL(port)                  (0x00060500 + (port))
#define R_CLMAC_RX_LSS_CTRL(port)              (0x00060900 + (port))
#define R_CLMAC_RX_LSS_STATUS(port)            (0x00060a00 + (port))
#define R_CLMAC_RX_MAC_SA(port)                (0x00060600 + (port))
#define R_CLMAC_RX_MAX_SIZE(port)              (0x00060700 + (port))
#define R_CLMAC_TXFIFO_CELL_CNT(port)          (0x00062b00 + (port))
#define R_CLMAC_TX_CTRL(port)                  (0x00060300 + (port))
#define R_CLMAC_TX_MAC_SA(port)                (0x00060400 + (port))
#define R_CLMAC_TX_TIMESTAMP_FIFO_DATA(port)   (0x00061400 + (port))
#define R_CLMAC_TX_TIMESTAMP_FIFO_STATUS(port)   (0x00061500 + (port))
#define R_CLMIB_RBCA(port)                     (0x00000e00 + (port))
#define R_CLMIB_RBYT(port)                     (0x00003d00 + (port))
#define R_CLMIB_RFCS(port)                     (0x00000f00 + (port))
#define R_CLMIB_RMCA(port)                     (0x00000d00 + (port))
#define R_CLMIB_ROVR(port)                     (0x00001a00 + (port))
#define R_CLMIB_RPKT(port)                     (0x00000b00 + (port))
#define R_CLMIB_RUCA(port)                     (0x00000c00 + (port))
#define R_CLMIB_RXPF(port)                     (0x00001100 + (port))
#define R_CLMIB_RX_EEE_LPI_DURATION_COUNTER(port)   (0x00003700 + (port))
#define R_CLMIB_RX_EEE_LPI_EVENT_COUNTER(port)   (0x00003600 + (port))
#define R_CLMIB_TBCA(port)                     (0x00004f00 + (port))
#define R_CLMIB_TBYT(port)                     (0x00006f00 + (port))
#define R_CLMIB_TFCS(port)                     (0x00005300 + (port))
#define R_CLMIB_TMCA(port)                     (0x00004e00 + (port))
#define R_CLMIB_TOVR(port)                     (0x00005500 + (port))
#define R_CLMIB_TPKT(port)                     (0x00004c00 + (port))
#define R_CLMIB_TUCA(port)                     (0x00004d00 + (port))
#define R_CLMIB_TXPF(port)                     (0x00005000 + (port))
#define R_CLMIB_TX_EEE_LPI_DURATION_COUNTER(port)   (0x00006b00 + (port))
#define R_CLMIB_TX_EEE_LPI_EVENT_COUNTER(port)   (0x00006a00 + (port))
#define R_CLPORT_CNTMAXSIZE(port)              (0x00020100 + (port))
#define R_CLPORT_ENABLE_REG                    (0x02020b00)
#define R_CLPORT_FAULT_LINK_STATUS(port)       (0x00020500 + (port))
#define R_CLPORT_MAC_CONTROL                   (0x02021000)
#define R_CLPORT_MAC_RSV_MASK(port)            (0x00020800 + (port))
#define R_CLPORT_MIB_RESET                     (0x02022400)
#define R_CLPORT_MODE_REG                      (0x02020a00)
#define R_CLPORT_SOFT_RESET                    (0x02020c00)
#define R_CLPORT_WC_UCMEM_CTRL                 (0x02021900)
#define M_CLPORT_WC_UCMEM_DATA(idx)            (0x00000000+(idx))
#define R_CLPORT_XGXS0_CTRL_REG                (0x02021400)
#define R_PGW_CL_TXFIFO_CTRL(port)             (0x00080100 + (port))
/* TOP */
#define R_PGW_CTRL_0                           TOP_BLOCK_ID, (0x0200c100)
#define R_RESCAL_STATUS_0                      TOP_BLOCK_ID, (0x02006b00)
#define R_TOP_CLOCKING_ENFORCE_PSG             TOP_BLOCK_ID, (0x02000900)
#define R_TOP_CORE_PLL_CTRL3                   TOP_BLOCK_ID, (0x02000f00)
#define R_TOP_CORE_PLL_CTRL4                   TOP_BLOCK_ID, (0x02001000)
#define R_TOP_CORE_PLL_CTRL5                   TOP_BLOCK_ID, (0x02001100)
#define R_TOP_CORE_PLL_CTRL6                   TOP_BLOCK_ID, (0x02001200)
#define R_TOP_CORE_PLL_DEBUG_CTRL_2            TOP_BLOCK_ID, (0x02005500)
#define R_TOP_DEV_REV_ID                       TOP_BLOCK_ID, (0x02000000)
#define R_TOP_L1_RCVD_CLK_CONTROL              TOP_BLOCK_ID, (0x02009800)
#define R_TOP_MISC_CONTROL_1                   TOP_BLOCK_ID, (0x02000500)
#define R_TOP_MISC_CONTROL_2                   TOP_BLOCK_ID, (0x0200c400)
#define R_TOP_MISC_CONTROL_3                   TOP_BLOCK_ID, (0x0200c500)
#define R_TOP_MISC_STATUS                      TOP_BLOCK_ID, (0x02000600)
#define R_TOP_PVTMON_CTRL_0                    TOP_BLOCK_ID, (0x02007100)
#define R_TOP_SOFT_RESET_REG                   TOP_BLOCK_ID, (0x02000100)
#define R_TOP_SOFT_RESET_REG_2                 TOP_BLOCK_ID, (0x02000200)
#define R_TOP_STRAP_STATUS                     TOP_BLOCK_ID, (0x0200cd00)
#define R_TOP_STRAP_STATUS_1                   TOP_BLOCK_ID, (0x0200ce00)
#define R_TOP_XG1_LCPLL_FBDIV_CTRL_0           TOP_BLOCK_ID, (0x02003e00)
#define R_TOP_XG1_LCPLL_FBDIV_CTRL_1           TOP_BLOCK_ID, (0x02003f00)
#define R_TOP_XG_PLL0_CTRL_0                   TOP_BLOCK_ID, (0x02001400)
#define R_TOP_XG_PLL0_CTRL_1                   TOP_BLOCK_ID, (0x02001500)
#define R_TOP_XG_PLL0_CTRL_10                  TOP_BLOCK_ID, (0x02001e00)
#define R_TOP_XG_PLL0_CTRL_2                   TOP_BLOCK_ID, (0x02001600)
#define R_TOP_XG_PLL0_CTRL_3                   TOP_BLOCK_ID, (0x02001700)
#define R_TOP_XG_PLL0_CTRL_4                   TOP_BLOCK_ID, (0x02001800)
#define R_TOP_XG_PLL0_CTRL_5                   TOP_BLOCK_ID, (0x02001900)
#define R_TOP_XG_PLL0_CTRL_6                   TOP_BLOCK_ID, (0x02001a00)
#define R_TOP_XG_PLL0_CTRL_7                   TOP_BLOCK_ID, (0x02001b00)
#define R_TOP_XG_PLL0_CTRL_8                   TOP_BLOCK_ID, (0x02001c00)
#define R_TOP_XG_PLL0_CTRL_9                   TOP_BLOCK_ID, (0x02001d00)
#define R_TOP_XG_PLL0_STATUS                   TOP_BLOCK_ID, (0x02001f00)
#define R_TOP_XG_PLL1_CTRL_0                   TOP_BLOCK_ID, (0x02002000)
#define R_TOP_XG_PLL1_CTRL_1                   TOP_BLOCK_ID, (0x02002100)
#define R_TOP_XG_PLL1_CTRL_10                  TOP_BLOCK_ID, (0x02002a00)
#define R_TOP_XG_PLL1_CTRL_2                   TOP_BLOCK_ID, (0x02002200)
#define R_TOP_XG_PLL1_CTRL_3                   TOP_BLOCK_ID, (0x02002300)
#define R_TOP_XG_PLL1_CTRL_4                   TOP_BLOCK_ID, (0x02002400)
#define R_TOP_XG_PLL1_CTRL_5                   TOP_BLOCK_ID, (0x02002500)
#define R_TOP_XG_PLL1_CTRL_6                   TOP_BLOCK_ID, (0x02002600)
#define R_TOP_XG_PLL1_CTRL_7                   TOP_BLOCK_ID, (0x02002700)
#define R_TOP_XG_PLL1_CTRL_8                   TOP_BLOCK_ID, (0x02002800)
#define R_TOP_XG_PLL1_STATUS                   TOP_BLOCK_ID, (0x02002b00)
/* PMQPORT0 PMQPORT1 PMQPORT2 */
#define R_CHIP_CONFIG                          (0x02020000)
#define R_CHIP_SBUS_CFG                        (0x02020700)
#define R_CHIP_SWRST                           (0x02020800)
#define R_CHIP_UMACSPEED                       (0x02020900)
#define R_PMQ_XGXS0_CTRL_REG                   (0x02020100)
/* MMU */
#define R_CFAPCONFIG                           MMU_BLOCK_ID, (0x02044000)
#define R_CFAPFULLTHRESHOLD                    MMU_BLOCK_ID, (0x02045000)
#define R_CNGCOSPKTLIMIT0(cos, port)           MMU_BLOCK_ID, (0x00004800 + ((cos) << 8) + (port))
#define R_CNGCOSPKTLIMIT0_QGROUP(idx, port)    MMU_BLOCK_ID, (0x000b1900 + ((idx) << 8) + (port))
#define R_CNGCOSPKTLIMIT0_QLAYER(cos, port)    MMU_BLOCK_ID, (0x000ad900 + ((cos) << 8) + (port))
#define R_CNGCOSPKTLIMIT1(cos, port)           MMU_BLOCK_ID, (0x00005000 + ((cos) << 8) + (port))
#define R_CNGCOSPKTLIMIT1_QGROUP(idx, port)    MMU_BLOCK_ID, (0x000b9900 + ((idx) << 8) + (port))
#define R_CNGCOSPKTLIMIT1_QLAYER(cos, port)    MMU_BLOCK_ID, (0x000b5900 + ((cos) << 8) + (port))
#define R_CNGPORTPKTLIMIT0(port)               MMU_BLOCK_ID, (0x0000d000 + (port))
#define R_CNGPORTPKTLIMIT1(port)               MMU_BLOCK_ID, (0x0000d800 + (port))
#define R_COLOR_DROP_EN(port)                  MMU_BLOCK_ID, (0x00018800 + (port))
#define R_COLOR_DROP_EN_QGROUP(port)           MMU_BLOCK_ID, (0x00019800 + (port))
#define R_COLOR_DROP_EN_QLAYER(idx, port)      MMU_BLOCK_ID, (0x00019000 + ((idx) << 8) + (port))
#define R_COSLCCOUNT(cos, port)                MMU_BLOCK_ID, (0x00014000 + ((cos) << 8) + (port))
#define R_COSLCCOUNT_QGROUP(idx, port)         MMU_BLOCK_ID, (0x000cd900 + ((idx) << 8) + (port))
#define R_DYNCELLLIMIT(port)                   MMU_BLOCK_ID, (0x00018000 + (port))
#define R_DYNRESETLIMPORT(port)                MMU_BLOCK_ID, (0x0000e800 + (port))
#define R_DYNXQCNTPORT(port)                   MMU_BLOCK_ID, (0x0000e000 + (port))
#define R_E2ECC_HOL_EN                         MMU_BLOCK_ID, (0x020ffb00)
#define R_E2ECC_MAX_TX_TIMER                   MMU_BLOCK_ID, (0x02108700)
#define R_E2ECC_MIN_TX_TIMER                   MMU_BLOCK_ID, (0x02107f00)
#define R_E2ECC_MODE                           MMU_BLOCK_ID, (0x02100300)
#define R_E2ECC_PORT_CONFIG(port)              MMU_BLOCK_ID, (0x00100b00 + (port))
#define R_E2ECC_TX_ENABLE_BMP(idx)             MMU_BLOCK_ID, (0x02108f00 + ((idx) << 8))
#define R_E2ECC_TX_PORTS_NUM                   MMU_BLOCK_ID, (0x02109700)
#define R_E2EFC_IBP_EN                         MMU_BLOCK_ID, (0x0205c800)
#define R_EARLY_DYNCELLLIMIT(port)             MMU_BLOCK_ID, (0x00106f00 + (port))
#define R_EARLY_HOLCOSCELLMAXLIMIT(cos, port)   MMU_BLOCK_ID, (0x00107700 + ((cos) << 8) + (port))
#define R_EGRMETERINGBUCKET(port)              MMU_BLOCK_ID, (0x00025000 + (port))
#define R_EGRMETERINGCONFIG(port)              MMU_BLOCK_ID, (0x00024800 + (port))
#define R_GBLLIMITRESETLIMIT                   MMU_BLOCK_ID, (0x020fc900)
#define R_GBLLIMITSETLIMIT                     MMU_BLOCK_ID, (0x020fc100)
#define R_HOLCOSCELLMAXLIMIT(cos, port)        MMU_BLOCK_ID, (0x00010000 + ((cos) << 8) + (port))
#define R_HOLCOSCELLMAXLIMIT_QGROUP(idx, port)   MMU_BLOCK_ID, (0x000c9900 + ((idx) << 8) + (port))
#define R_HOLCOSCELLMAXLIMIT_QLAYER(cos, port)   MMU_BLOCK_ID, (0x000c5900 + ((cos) << 8) + (port))
#define R_HOLCOSMINXQCNT(cos, port)            MMU_BLOCK_ID, (0x00004000 + ((cos) << 8) + (port))
#define R_HOLCOSMINXQCNT_QLAYER(cos, port)     MMU_BLOCK_ID, (0x000a9900 + ((cos) << 8) + (port))
#define R_HOLCOSPKTRESETLIMIT(cos, port)       MMU_BLOCK_ID, (0x00003800 + ((cos) << 8) + (port))
#define R_HOLCOSPKTRESETLIMIT_QGROUP(idx, port)   MMU_BLOCK_ID, (0x000a5900 + ((idx) << 8) + (port))
#define R_HOLCOSPKTRESETLIMIT_QLAYER(cos, port)   MMU_BLOCK_ID, (0x000a1900 + ((cos) << 8) + (port))
#define R_HOLCOSPKTSETLIMIT(cos, port)         MMU_BLOCK_ID, (0x00003000 + ((cos) << 8) + (port))
#define R_HOLCOSPKTSETLIMIT_QGROUP(idx, port)   MMU_BLOCK_ID, (0x0009d900 + ((idx) << 8) + (port))
#define R_HOLCOSPKTSETLIMIT_QLAYER(cos, port)   MMU_BLOCK_ID, (0x00099900 + ((cos) << 8) + (port))
#define R_IBPPKTSETLIMIT(port)                 MMU_BLOCK_ID, (0x00000000 + (port))
#define R_LWMCOSCELLSETLIMIT(cos, port)        MMU_BLOCK_ID, (0x0000f800 + ((cos) << 8) + (port))
#define R_LWMCOSCELLSETLIMIT_QLAYER(cos, port)   MMU_BLOCK_ID, (0x000c1900 + ((cos) << 8) + (port))
#define R_MISCCONFIG                           MMU_BLOCK_ID, (0x02049000)
#define R_MMUFLUSHCONTROL(idx)                 MMU_BLOCK_ID, (0x0205b600 + ((idx) << 8))
#define R_MMUFLUSHCONTROL_0                    MMU_BLOCK_ID, (0x0205b600)
#define R_MMUFLUSHCONTROL_1                    MMU_BLOCK_ID, (0x0205b700)
#define R_MMUFLUSHCONTROL_2                    MMU_BLOCK_ID, (0x0205b800)
#define R_MMUPORTENABLE(idx)                   MMU_BLOCK_ID, (0x0204b000 + ((idx) << 8))
#define R_MMUPORTENABLE_0                      MMU_BLOCK_ID, (0x0204b000)
#define R_MMUPORTENABLE_1                      MMU_BLOCK_ID, (0x0204b100)
#define R_MMUPORTENABLE_2                      MMU_BLOCK_ID, (0x0204b200)
#define R_MMUPORTTXENABLE_0                    MMU_BLOCK_ID, (0x02057c00)
#define R_MMUPORTTXENABLE_1                    MMU_BLOCK_ID, (0x02057d00)
#define R_MMUPORTTXENABLE_2                    MMU_BLOCK_ID, (0x02057e00)
#define M_MMU_ARB_TDM_TABLE(idx)               MMU_BLOCK_ID, (0x2c410000+(idx))
#define M_MMU_CFAP(idx)                        MMU_BLOCK_ID, (0x28070000+(idx))
#define R_MMU_FC_RX_EN(port)                   MMU_BLOCK_ID, (0x000f5100 + (port))
#define R_MMU_FC_TX_EN(port)                   MMU_BLOCK_ID, (0x000f5900 + (port))
#define M_MMU_IPMC_GROUP_TBL(aidx, idx)        MMU_BLOCK_ID, (0x28090000+(((aidx)-2) * 0x4000)+(idx))
#define M_MMU_MAX_BUCKET_QGROUP(idx)           MMU_BLOCK_ID, (0x282b0000+(idx))
#define M_MMU_MAX_BUCKET_QLAYER(idx)           MMU_BLOCK_ID, (0x282a0000+(idx))
#define R_MMU_PORT_TO_LOGIC_PORT_MAPPING(port)   MMU_BLOCK_ID, (0x00082b00 + (port))
#define R_MMU_PORT_TO_PHY_PORT_MAPPING(port)   MMU_BLOCK_ID, (0x00082300 + (port))
#define R_PG2TC(idx, port)                     MMU_BLOCK_ID, (0x000f3900 + ((idx) << 8) + (port))
#define R_PGCELLLIMIT(idx, port)               MMU_BLOCK_ID, (0x000f8100 + ((idx) << 8) + (port))
#define R_PGDISCARDSETLIMIT(idx, port)         MMU_BLOCK_ID, (0x000f8900 + ((idx) << 8) + (port))
#define R_PG_CTRL0(port)                       MMU_BLOCK_ID, (0x000f2900 + (port))
#define R_PG_CTRL1(port)                       MMU_BLOCK_ID, (0x000f3100 + (port))
#define R_PKTAGINGTIMER                        MMU_BLOCK_ID, (0x02048000)
#define R_SHARED_POOL_CTRL(port)               MMU_BLOCK_ID, (0x000f6100 + (port))
#define R_SHARED_POOL_CTRL_EXT1(port)          MMU_BLOCK_ID, (0x000f6900 + (port))
#define R_SHARED_POOL_CTRL_EXT2(port)          MMU_BLOCK_ID, (0x000f7100 + (port))
#define R_TOTALDYNCELLRESETLIMIT               MMU_BLOCK_ID, (0x02058600)
#define R_TOTALDYNCELLSETLIMIT                 MMU_BLOCK_ID, (0x02049800)
#define R_TWO_LAYER_SCH_MODE(port)             MMU_BLOCK_ID, (0x0001d000 + (port))
#define R_WRRWEIGHT_COS0(port)                 MMU_BLOCK_ID, (0x0001c800 + (port))
#define R_WRRWEIGHT_COS1(port)                 MMU_BLOCK_ID, (0x0001c900 + (port))
#define R_WRRWEIGHT_COS2(port)                 MMU_BLOCK_ID, (0x0001ca00 + (port))
#define R_WRRWEIGHT_COS3(port)                 MMU_BLOCK_ID, (0x0001cb00 + (port))
#define R_WRRWEIGHT_COS4(port)                 MMU_BLOCK_ID, (0x0001cc00 + (port))
#define R_WRRWEIGHT_COS5(port)                 MMU_BLOCK_ID, (0x0001cd00 + (port))
#define R_WRRWEIGHT_COS6(port)                 MMU_BLOCK_ID, (0x0001ce00 + (port))
#define R_WRRWEIGHT_COS7(port)                 MMU_BLOCK_ID, (0x0001cf00 + (port))
#define R_WRRWEIGHT_COS_QLAYER(cos, port)      MMU_BLOCK_ID, (0x0001e800 + ((cos) << 8) + (port))
#define R_XQCOSARBSEL(port)                    MMU_BLOCK_ID, (0x0001c000 + (port))
#define R_XQCOSARBSEL_QLAYER(idx, port)        MMU_BLOCK_ID, (0x0001d800 + ((idx) << 8) + (port))
/* GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5 */
#define R_COMMAND_CONFIG(port)                 (0x00010200 + (port))
#define R_FLUSH_CONTROL(port)                  (0x0001cd00 + (port))
#define R_FRM_LENGTH(port)                     (0x00010500 + (port))
#define R_GMII_EEE_DELAY_ENTRY_TIMER(port)     (0x00011b00 + (port))
#define R_GMII_EEE_WAKE_TIMER(port)            (0x00012100 + (port))
#define R_GPORT_CONFIG                         (0x02020000)
#define R_GPORT_LINK_STATUS_TO_CMIC            (0x02020500)
#define R_GPORT_RSV_MASK                       (0x02020600)
#define R_GPORT_STAT_UPDATE_MASK               (0x02020700)
#define R_GRALN(port)                          (0x00000400 + (port))
#define R_GRBCA(port)                          (0x00001000 + (port))
#define R_GRBYT(port)                          (0x00001c00 + (port))
#define R_GRFCS(port)                          (0x00000000 + (port))
#define R_GRMCA(port)                          (0x00000f00 + (port))
#define R_GROVR(port)                          (0x00000800 + (port))
#define R_GRPKT(port)                          (0x00001b00 + (port))
#define R_GRUC(port)                           (0x00001d00 + (port))
#define R_GRXPF(port)                          (0x00000200 + (port))
#define R_GRX_EEE_LPI_DURATION_COUNTER(port)   (0x00003f00 + (port))
#define R_GRX_EEE_LPI_EVENT_COUNTER(port)      (0x00003e00 + (port))
#define R_GTBCA(port)                          (0x00002e00 + (port))
#define R_GTBYT(port)                          (0x00003a00 + (port))
#define R_GTFCS(port)                          (0x00002200 + (port))
#define R_GTMCA(port)                          (0x00002d00 + (port))
#define R_GTOVR(port)                          (0x00002400 + (port))
#define R_GTPKT(port)                          (0x00003900 + (port))
#define R_GTUC(port)                           (0x00003b00 + (port))
#define R_GTXPF(port)                          (0x00002000 + (port))
#define R_GTX_EEE_LPI_DURATION_COUNTER(port)   (0x00004100 + (port))
#define R_GTX_EEE_LPI_EVENT_COUNTER(port)      (0x00004000 + (port))
#define R_IPG_HD_BKP_CNTL(port)                (0x00010100 + (port))
#define R_MAC_0(port)                          (0x00010300 + (port))
#define R_MAC_1(port)                          (0x00010400 + (port))
#define R_MAC_PFC_CTRL(port)                   (0x0001d000 + (port))
#define R_MAC_PFC_DA_0(port)                   (0x0001c200 + (port))
#define R_MAC_PFC_DA_1(port)                   (0x0001c300 + (port))
#define R_MAC_PFC_OPCODE(port)                 (0x0001c100 + (port))
#define R_MAC_PFC_REFRESH_CTRL(port)           (0x0001d100 + (port))
#define R_MAC_PFC_TYPE(port)                   (0x0001c000 + (port))
#define R_MII_EEE_DELAY_ENTRY_TIMER(port)      (0x00011a00 + (port))
#define R_MII_EEE_WAKE_TIMER(port)             (0x00012000 + (port))
#define R_PFC_XOFF_TIMER(port)                 (0x00011800 + (port))
#define R_TS_STATUS_CNTRL(port)                (0x0001c600 + (port))
#define R_TX_IPG_LENGTH(port)                  (0x00011700 + (port))
#define R_TX_TS_DATA(port)                     (0x0001c700 + (port))
#define R_TX_TS_SEQ_ID(port)                   (0x00010f00 + (port))
#define R_UMAC_EEE_CTRL(port)                  (0x00011900 + (port))
#define R_UMAC_EEE_REF_COUNT(port)             (0x00011c00 + (port))
/* IPIPE */
#define R_AUX_ARB_CONTROL                      IPIPE_BLOCK_ID, (0x02000000)
#define R_AUX_ARB_CONTROL_2                    IPIPE_BLOCK_ID, (0x02000100)
#define M_COS_MAP(idx)                         IPIPE_BLOCK_ID, (0x404c0000+(idx))
#define R_DOS_CONTROL                          IPIPE_BLOCK_ID, (0x06000100)
#define R_DOS_CONTROL2                         IPIPE_BLOCK_ID, (0x06000200)
#define M_DSCP_TB(idx)                         IPIPE_BLOCK_ID, (0x24000000+(idx))
#define M_EGR_MASK(idx)                        IPIPE_BLOCK_ID, (0x40040000+(idx))
#define R_EMIRROR_CONTROL_HI_64(port)          IPIPE_BLOCK_ID, (0x40003100 + (port))
#define R_EMIRROR_CONTROL_LO_64(port)          IPIPE_BLOCK_ID, (0x40003000 + (port))
#define M_EM_MTP_INDEX(idx)                    IPIPE_BLOCK_ID, (0x40340000+(idx))
#define R_EPC_LINK_BMAP_HI_64                  IPIPE_BLOCK_ID, (0x42005e00)
#define R_EPC_LINK_BMAP_LO_64                  IPIPE_BLOCK_ID, (0x42005d00)
#define M_FP_COUNTER_TABLE(idx)                IPIPE_BLOCK_ID, (0x38140000+(idx))
#define M_FP_GLOBAL_MASK_TCAM(idx)             IPIPE_BLOCK_ID, (0x38180000+(idx))
#define M_FP_METER_TABLE(idx)                  IPIPE_BLOCK_ID, (0x38100000+(idx))
#define M_FP_POLICY_TABLE(idx)                 IPIPE_BLOCK_ID, (0x380c0000+(idx))
#define M_FP_PORT_FIELD_SEL(idx)               IPIPE_BLOCK_ID, (0x34000000+(idx))
#define R_FP_SLICE_ENABLE                      IPIPE_BLOCK_ID, (0x3a000000)
#define M_FP_SLICE_MAP                         IPIPE_BLOCK_ID, (0x38080000)
#define M_FP_STORM_CONTROL_METERS(idx)         IPIPE_BLOCK_ID, (0x381c0000+(idx))
#define M_FP_TCAM(idx)                         IPIPE_BLOCK_ID, (0x38040000+(idx))
#define M_FP_UDF_OFFSET(idx)                   IPIPE_BLOCK_ID, (0x08080000+(idx))
#define R_HASH_CONTROL                         IPIPE_BLOCK_ID, (0x06000400)
#define R_IARB_TDM_CONTROL                     IPIPE_BLOCK_ID, (0x02000900)
#define M_IARB_TDM_TABLE(idx)                  IPIPE_BLOCK_ID, (0x00080000+(idx))
#define M_IFP_REDIRECTION_PROFILE(idx)         IPIPE_BLOCK_ID, (0x3c040000+(idx))
#define R_IGMP_MLD_PKT_CONTROL(port)           IPIPE_BLOCK_ID, (0x1c000500 + (port))
#define R_IING_EGRMSKBMAP_HI(port)             IPIPE_BLOCK_ID, (0x40003b00 + (port))
#define R_IING_EGRMSKBMAP_LO(port)             IPIPE_BLOCK_ID, (0x40003a00 + (port))
#define M_IM_MTP_INDEX(idx)                    IPIPE_BLOCK_ID, (0x40300000+(idx))
#define R_ING_CONFIG_64                        IPIPE_BLOCK_ID, (0x06000000)
#define R_ING_EGRMSKBMAP_HI(port)              IPIPE_BLOCK_ID, (0x40003900 + (port))
#define R_ING_EGRMSKBMAP_LO(port)              IPIPE_BLOCK_ID, (0x40003800 + (port))
#define R_ING_HW_RESET_CONTROL_1               IPIPE_BLOCK_ID, (0x02000200)
#define R_ING_HW_RESET_CONTROL_2               IPIPE_BLOCK_ID, (0x02000300)
#define R_ING_MISC_CONFIG                      IPIPE_BLOCK_ID, (0x42006800)
#define M_ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLE(idx)   IPIPE_BLOCK_ID, (0x000c0000+(idx))
#define M_ING_PRI_CNG_MAP(idx)                 IPIPE_BLOCK_ID, (0x302c0000+(idx))
#define M_ING_VLAN_TAG_ACTION_PROFILE(idx)     IPIPE_BLOCK_ID, (0x0c2c0000+(idx))
#define R_IP_TO_CMICM_CREDIT_TRANSFER          IPIPE_BLOCK_ID, (0x02002000)
#define R_IUNKNOWN_MCAST_BLOCK_MASK_HI_64(port)   IPIPE_BLOCK_ID, (0x40002900 + (port))
#define R_IUNKNOWN_MCAST_BLOCK_MASK_LO_64(port)   IPIPE_BLOCK_ID, (0x40002800 + (port))
#define R_IUNKNOWN_UCAST_BLOCK_MASK_HI_64(port)   IPIPE_BLOCK_ID, (0x40002500 + (port))
#define R_IUNKNOWN_UCAST_BLOCK_MASK_LO_64(port)   IPIPE_BLOCK_ID, (0x40002400 + (port))
#define M_L2MC(idx)                            IPIPE_BLOCK_ID, (0x3c140000+(idx))
#define R_L2_AGE_TIMER                         IPIPE_BLOCK_ID, (0x02000400)
#define R_L2_AUX_HASH_CONTROL                  IPIPE_BLOCK_ID, (0x1e000100)
#define M_L2_ENTRY(idx)                        IPIPE_BLOCK_ID, (0x1c040000+(idx))
#define M_L2_USER_ENTRY(idx)                   IPIPE_BLOCK_ID, (0x1c140000+(idx))
#define R_L2_USER_ENTRY_CAM_DBGCTRL            IPIPE_BLOCK_ID, (0x1e010000)
#define R_L3_AUX_HASH_CONTROL                  IPIPE_BLOCK_ID, (0x26000000)
#define R_MIRROR_CONTROL(port)                 IPIPE_BLOCK_ID, (0x40002e00 + (port))
#define M_NONUCAST_TRUNK_BLOCK_MASK(idx)       IPIPE_BLOCK_ID, (0x40280000+(idx))
#define R_PER_PORT_AGE_CONTROL_64              IPIPE_BLOCK_ID, (0x02000500)
#define M_PORT(idx)                            IPIPE_BLOCK_ID, (0x04000000+(idx))
#define R_PROTOCOL_PKT_CONTROL(port)           IPIPE_BLOCK_ID, (0x1c000400 + (port))
#define M_SOURCE_TRUNK_MAP(idx)                IPIPE_BLOCK_ID, (0x08040000+(idx))
#define M_SOURCE_TRUNK_MAP_MODBASE(idx)        IPIPE_BLOCK_ID, (0x08000000+(idx))
#define R_STORM_CONTROL_METER_CONFIG(port)     IPIPE_BLOCK_ID, (0x34000100 + (port))
#define R_SW2_FP_DST_ACTION_CONTROL            IPIPE_BLOCK_ID, (0x42007000)
#define R_SW2_RAM_CONTROL_4_64                 IPIPE_BLOCK_ID, (0x42010c00)
#define M_SYSTEM_CONFIG_TABLE(idx)             IPIPE_BLOCK_ID, (0x040c0000+(idx))
#define M_TRUNK32_CONFIG_TABLE(idx)            IPIPE_BLOCK_ID, (0x04100000+(idx))
#define M_TRUNK32_PORT_TABLE(idx)              IPIPE_BLOCK_ID, (0x081c0000+(idx))
#define M_TRUNK_BITMAP(idx)                    IPIPE_BLOCK_ID, (0x40100000+(idx))
#define M_TRUNK_GROUP(idx)                     IPIPE_BLOCK_ID, (0x400c0000+(idx))
#define R_UNKNOWN_MCAST_BLOCK_MASK_HI_64(port)   IPIPE_BLOCK_ID, (0x40002700 + (port))
#define R_UNKNOWN_MCAST_BLOCK_MASK_LO_64(port)   IPIPE_BLOCK_ID, (0x40002600 + (port))
#define R_UNKNOWN_UCAST_BLOCK_MASK_HI_64(port)   IPIPE_BLOCK_ID, (0x40002300 + (port))
#define R_UNKNOWN_UCAST_BLOCK_MASK_LO_64(port)   IPIPE_BLOCK_ID, (0x40002200 + (port))
#define R_VFP_CAM_CONTROL_TM_7_THRU_0          IPIPE_BLOCK_ID, (0x0e011e00)
#define M_VLAN(idx)                            IPIPE_BLOCK_ID, (0x10000000+(idx))
#define R_VLAN_CTRL                            IPIPE_BLOCK_ID, (0x06000300)
#define R_VLAN_DEFAULT_PBM_HI                  IPIPE_BLOCK_ID, (0x12000100)
#define R_VLAN_DEFAULT_PBM_LO                  IPIPE_BLOCK_ID, (0x12000000)
#define M_VLAN_PROFILE(idx)                    IPIPE_BLOCK_ID, (0x10080000+(idx))
#define M_VLAN_STG(idx)                        IPIPE_BLOCK_ID, (0x10040000+(idx))
#define R_VLAN_SUBNET_CAM_DBGCTRL              IPIPE_BLOCK_ID, (0x0e010200)
/* CMIC */
#define CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0(_cmc, _ch)   (0x03202118 + ((_cmc) * 0x3000) + ((_ch) * 0x80))
#define CMIC_CMC_PKTDMA_CH_CTRL(_cmc, _ch)     (0x03202100 + ((_cmc) * 0x3000) + ((_ch) * 0x80))
#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_HI(_cmc, _ch)   (0x03202108 + ((_cmc) * 0x3000) + ((_ch) * 0x80))
#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_LO(_cmc, _ch)   (0x03202104 + ((_cmc) * 0x3000) + ((_ch) * 0x80))
#define CMIC_CMC_PKTDMA_CH_STAT(_cmc, _ch)     (0x03202114 + ((_cmc) * 0x3000) + ((_ch) * 0x80))
#define CMIC_CMC_SHARED_IRQ_STAT0(idx)         (0x0320106c + ((idx) * 0x3000))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0(idx)     (0x03201074 + ((idx) * 0x3000))
#define CMIC_CMC_SHARED_PKT_COUNT_TXPKT(idx)   (0x0320108c + ((idx) * 0x3000))
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STAT   (0x03211020)
#define CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNT   (0x03210004)
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRL        (0x03210000)
#define CMIC_COMMON_POOL_SCHAN_CH0_ERR         (0x03210008)
#define CMIC_COMMON_POOL_SCHAN_CH0_MESSAGE(idx)   (0x0321000c + ((idx)*0x4))
#define CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNT   (0x03210104)
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRL        (0x03210100)
#define CMIC_COMMON_POOL_SCHAN_CH1_ERR         (0x03210108)
#define CMIC_COMMON_POOL_SCHAN_CH1_MESSAGE(idx)   (0x0321010c + ((idx)*0x4))
#define CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNT   (0x03210204)
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRL        (0x03210200)
#define CMIC_COMMON_POOL_SCHAN_CH2_ERR         (0x03210208)
#define CMIC_COMMON_POOL_SCHAN_CH2_MESSAGE(idx)   (0x0321020c + ((idx)*0x4))
#define CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNT   (0x03210304)
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRL        (0x03210300)
#define CMIC_COMMON_POOL_SCHAN_CH3_ERR         (0x03210308)
#define CMIC_COMMON_POOL_SCHAN_CH3_MESSAGE(idx)   (0x0321030c + ((idx)*0x4))
#define CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNT   (0x03210404)
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRL        (0x03210400)
#define CMIC_COMMON_POOL_SCHAN_CH4_ERR         (0x03210408)
#define CMIC_COMMON_POOL_SCHAN_CH4_MESSAGE(idx)   (0x0321040c + ((idx)*0x4))
#define CMIC_TOP_CONFIG                        (0x03200008)
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITS   (0x03200070)
#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITS    (0x0320006c)
#define CMIC_TOP_EP_TO_CPU_HEADER_SIZE         (0x03200004)
#define CMIC_TOP_SBUS_RING_MAP_0_7             (0x0320000c)
#define CMIC_TOP_SBUS_RING_MAP_16_23           (0x03200014)
#define CMIC_TOP_SBUS_RING_MAP_24_31           (0x03200018)
#define CMIC_TOP_SBUS_RING_MAP_32_39           (0x0320001c)
#define CMIC_TOP_SBUS_RING_MAP_40_47           (0x03200020)
#define CMIC_TOP_SBUS_RING_MAP_8_15            (0x03200010)
#define CMIC_TOP_SBUS_TIMEOUT                  (0x03200000)
/* IPROC */
#define R_CMICX_M0_IDM_IO_CONTROL_DIRECT       (0x18103408)
#define R_CMIC_SEMAPHORE_1                     (0x03230000)
#define R_CMIC_SEMAPHORE_1_SHADOW              (0x03230004)
#define R_CMIC_SEMAPHORE_2                     (0x03230008)
#define R_CMIC_SEMAPHORE_2_SHADOW              (0x0323000c)
#define R_CMIC_SEMAPHORE_3                     (0x03230010)
#define R_CMIC_SEMAPHORE_3_SHADOW              (0x03230014)
#define R_DMU_CRU_RESET                        (0x03240200)
#define R_DMU_PCU_OTP_CONFIG_0                 (0x03240048)
#define R_DMU_PCU_OTP_CONFIG_1                 (0x0324004c)
#define R_DMU_PCU_OTP_CONFIG_10                (0x03240070)
#define R_DMU_PCU_OTP_CONFIG_11                (0x03240074)
#define R_DMU_PCU_OTP_CONFIG_12                (0x03240078)
#define R_DMU_PCU_OTP_CONFIG_13                (0x0324007c)
#define R_DMU_PCU_OTP_CONFIG_14                (0x03240080)
#define R_DMU_PCU_OTP_CONFIG_15                (0x03240084)
#define R_DMU_PCU_OTP_CONFIG_16                (0x03240088)
#define R_DMU_PCU_OTP_CONFIG_17                (0x0324008c)
#define R_DMU_PCU_OTP_CONFIG_18                (0x03240090)
#define R_DMU_PCU_OTP_CONFIG_19                (0x03240094)
#define R_DMU_PCU_OTP_CONFIG_2                 (0x03240050)
#define R_DMU_PCU_OTP_CONFIG_20                (0x03240098)
#define R_DMU_PCU_OTP_CONFIG_21                (0x0324009c)
#define R_DMU_PCU_OTP_CONFIG_22                (0x032400a0)
#define R_DMU_PCU_OTP_CONFIG_23                (0x032400a4)
#define R_DMU_PCU_OTP_CONFIG_24                (0x032400a8)
#define R_DMU_PCU_OTP_CONFIG_25                (0x032400ac)
#define R_DMU_PCU_OTP_CONFIG_26                (0x032400b0)
#define R_DMU_PCU_OTP_CONFIG_27                (0x032400b4)
#define R_DMU_PCU_OTP_CONFIG_28                (0x032400b8)
#define R_DMU_PCU_OTP_CONFIG_29                (0x032400bc)
#define R_DMU_PCU_OTP_CONFIG_3                 (0x03240054)
#define R_DMU_PCU_OTP_CONFIG_30                (0x032400c0)
#define R_DMU_PCU_OTP_CONFIG_31                (0x032400c4)
#define R_DMU_PCU_OTP_CONFIG_4                 (0x03240058)
#define R_DMU_PCU_OTP_CONFIG_5                 (0x0324005c)
#define R_DMU_PCU_OTP_CONFIG_6                 (0x03240060)
#define R_DMU_PCU_OTP_CONFIG_7                 (0x03240064)
#define R_DMU_PCU_OTP_CONFIG_8                 (0x03240068)
#define R_DMU_PCU_OTP_CONFIG_9                 (0x0324006c)
#define R_GPIO_AUX_SEL                         (0x03225028)
#define R_GPIO_DATA_IN                         (0x03225000)
#define R_GPIO_DATA_OUT                        (0x03225004)
#define R_GPIO_INIT_VAL                        (0x03225030)
#define R_GPIO_INT_CLR                         (0x03225024)
#define R_GPIO_INT_DE                          (0x03225010)
#define R_GPIO_INT_EDGE                        (0x03225014)
#define R_GPIO_INT_MSK                         (0x03225018)
#define R_GPIO_INT_MSTAT                       (0x03225020)
#define R_GPIO_INT_STAT                        (0x0322501c)
#define R_GPIO_INT_TYPE                        (0x0322500c)
#define R_GPIO_OUT_EN                          (0x03225008)
#define R_GPIO_PAD_RES                         (0x03225034)
#define R_GPIO_PRB_ENABLE                      (0x03225048)
#define R_GPIO_PRB_OE                          (0x0322504c)
#define R_GPIO_RES_EN                          (0x03225038)
#define R_IPROCPERIPH_UART0_UART_RBR_THR_DLL   (0x03220000)
#define R_IPROCPERIPH_UART1_UART_RBR_THR_DLL   (0x03221000)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_0_127_96   (0x03240d0c)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_0_31_0    (0x03240d00)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_0_63_32   (0x03240d04)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_0_95_64   (0x03240d08)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_1_127_96   (0x03240d1c)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_1_31_0    (0x03240d10)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_1_63_32   (0x03240d14)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_1_95_64   (0x03240d18)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_2_127_96   (0x03240d2c)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_2_31_0    (0x03240d20)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_2_63_32   (0x03240d24)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_2_95_64   (0x03240d28)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_3_127_96   (0x03240d3c)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_3_31_0    (0x03240d30)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_3_63_32   (0x03240d34)
#define R_IPROC_WRAP_CHIP_OTP_STATUS_3_95_64   (0x03240d38)
#define R_QSPI_BSPI_REGISTERS_REVISION_ID      (0x18021000)
#define R_MHOST_0_CR5_RST_CTRL                 (0x18320000)
#define R_MHOST_0_MHOST_DEBUG_CTRL             (0x183200e4)
#define R_MHOST_0_MHOST_INTR_MASK(idx)         (0x18320090 + (idx)*4)
#define R_MHOST_0_MHOST_INTR_STATUS(idx)       (0x183200b0 + (idx)*4)
#define R_MHOST_0_MHOST_RAW_INTR_STATUS(idx)   (0x18320070 + (idx)*4)
#define R_MHOST_VICADDRESS                     (0x00080f00)
#define R_MHOST_VICFIQSTATUS                   (0x00080004)
#define R_MHOST_VICINTENABLE                   (0x00080010)
#define R_MHOST_VICINTENCLEAR                  (0x00080014)
#define R_MHOST_VICINTSELECT                   (0x0008000c)
#define R_MHOST_VICIRQSTATUS                   (0x00080000)
/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  AUX_ARB_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     IP auxilary arbiter control register for L2 table
 * SIZE:     32
 * FIELDS:
 *     L2_MOD_FIFO_ENABLE_MEMWR Enable L2_MOD_FIFO recording for MEMWR.
 *     L2_MOD_FIFO_ENABLE_LEARN Enable L2_MOD_FIFO recording for LEARN.
 *     L2_MOD_FIFO_ENABLE_PPA_REPLACE Enable L2_MOD_FIFO recording for PPA_REPLACE.
 *     L2_MOD_FIFO_ENABLE_L2_INSERT Enable L2_MOD_FIFO recording for L2_INSERT.
 *     L2_MOD_FIFO_ENABLE_AGE Enable L2_MOD_FIFO recording for AGE.
 *     L2_MOD_FIFO_ENABLE_PPA_DELETE Enable L2_MOD_FIFO recording for PPA_DELETE.
 *     L2_MOD_FIFO_ENABLE_L2_DELETE Enable L2_MOD_FIFO recording for L2_DELETE.
 */
#define AUX_ARB_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program AUX_ARB_CONTROL.
 */
typedef union AUX_ARB_CONTROLr_s {
	uint32 v[1];
	uint32 aux_arb_control[1];
	uint32 _aux_arb_control;
} AUX_ARB_CONTROLr_t;

#define AUX_ARB_CONTROLr_CLR(r) (r).aux_arb_control[0] = 0
#define AUX_ARB_CONTROLr_SET(r,d) (r).aux_arb_control[0] = d
#define AUX_ARB_CONTROLr_GET(r) (r).aux_arb_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_MEMWRf_GET(r) (((r).aux_arb_control[0]) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_MEMWRf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_LEARNf_GET(r) ((((r).aux_arb_control[0]) >> 1) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_LEARNf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_PPA_REPLACEf_GET(r) ((((r).aux_arb_control[0]) >> 2) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_PPA_REPLACEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_L2_INSERTf_GET(r) ((((r).aux_arb_control[0]) >> 3) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_L2_INSERTf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_AGEf_GET(r) ((((r).aux_arb_control[0]) >> 4) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_AGEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_PPA_DELETEf_GET(r) ((((r).aux_arb_control[0]) >> 5) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_PPA_DELETEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_L2_DELETEf_GET(r) ((((r).aux_arb_control[0]) >> 6) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_L2_DELETEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))

/*
 * These macros can be used to access AUX_ARB_CONTROL.
 */
#define WRITE_AUX_ARB_CONTROLr(u,r) bcm5607x_reg_set(u,R_AUX_ARB_CONTROL,(r._aux_arb_control))
#define READ_AUX_ARB_CONTROLr(u,r) bcm5607x_reg_get(u,R_AUX_ARB_CONTROL,&(r._aux_arb_control))

/*******************************************************************************
 * End of 'AUX_ARB_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  AUX_ARB_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     IP auxilary arbiter control register for FP functions.
 * SIZE:     32
 * FIELDS:
 *     CLK_GRAN         clock granularity for ages (speed up for simulation use only)
 *     SBUS_SPACING     specifies minimum spacing between sbus ops
 *     SBUS_ARB_BLOCK_CNT specifies cycles hi-priority sbus arb slot is blocked out after every s-bus trans
 *     FP_REFRESH_ENABLE 1 - Iarb will send out refresh_ticks for IFP meters
 */
#define AUX_ARB_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program AUX_ARB_CONTROL_2.
 */
typedef union AUX_ARB_CONTROL_2r_s {
	uint32 v[1];
	uint32 aux_arb_control_2[1];
	uint32 _aux_arb_control_2;
} AUX_ARB_CONTROL_2r_t;

#define AUX_ARB_CONTROL_2r_CLR(r) (r).aux_arb_control_2[0] = 0
#define AUX_ARB_CONTROL_2r_SET(r,d) (r).aux_arb_control_2[0] = d
#define AUX_ARB_CONTROL_2r_GET(r) (r).aux_arb_control_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define AUX_ARB_CONTROL_2r_CLK_GRANf_GET(r) (((r).aux_arb_control_2[0]) & 0x3)
#define AUX_ARB_CONTROL_2r_CLK_GRANf_SET(r,f) (r).aux_arb_control_2[0]=(((r).aux_arb_control_2[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define AUX_ARB_CONTROL_2r_SBUS_SPACINGf_GET(r) ((((r).aux_arb_control_2[0]) >> 3) & 0xff)
#define AUX_ARB_CONTROL_2r_SBUS_SPACINGf_SET(r,f) (r).aux_arb_control_2[0]=(((r).aux_arb_control_2[0] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define AUX_ARB_CONTROL_2r_SBUS_ARB_BLOCK_CNTf_GET(r) ((((r).aux_arb_control_2[0]) >> 11) & 0x3ff)
#define AUX_ARB_CONTROL_2r_SBUS_ARB_BLOCK_CNTf_SET(r,f) (r).aux_arb_control_2[0]=(((r).aux_arb_control_2[0] & ~((uint32)0x3ff << 11)) | ((((uint32)f) & 0x3ff) << 11))
#define AUX_ARB_CONTROL_2r_FP_REFRESH_ENABLEf_GET(r) ((((r).aux_arb_control_2[0]) >> 26) & 0x1)
#define AUX_ARB_CONTROL_2r_FP_REFRESH_ENABLEf_SET(r,f) (r).aux_arb_control_2[0]=(((r).aux_arb_control_2[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))

/*
 * These macros can be used to access AUX_ARB_CONTROL_2.
 */
#define WRITE_AUX_ARB_CONTROL_2r(u,r) bcm5607x_reg_set(u,R_AUX_ARB_CONTROL_2,(r._aux_arb_control_2))
#define READ_AUX_ARB_CONTROL_2r(u,r) bcm5607x_reg_get(u,R_AUX_ARB_CONTROL_2,&(r._aux_arb_control_2))

/*******************************************************************************
 * End of 'AUX_ARB_CONTROL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTR
 * BLOCKS:   AVS
 * DESC:     Indicate which PVT Monitor measurements should  be masked(skipped) in the measurement sequence
 * SIZE:     32
 * FIELDS:
 *     SEQ_MASK_PVT_MNTR For PVT monitor measurements1 = The sensor will be skipped0 = The sensor will be measure
 *     RESERVED         Reserved bits write has no effect and read always returns 0
 */
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_SIZE 4

/*
 * This structure should be used to declare and program AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTR.
 */
typedef union AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_s {
	uint32 v[1];
	uint32 avs_reg_hw_mntr_sequencer_mask_pvt_mntr[1];
	uint32 _avs_reg_hw_mntr_sequencer_mask_pvt_mntr;
} AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_t;

#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_CLR(r) (r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0] = 0
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_SET(r,d) (r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0] = d
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_GET(r) (r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0]

/*
 * These macros can be used to access individual fields.
 */
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_SEQ_MASK_PVT_MNTRf_GET(r) (((r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0]) & 0x7f)
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_SEQ_MASK_PVT_MNTRf_SET(r,f) (r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0]=(((r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_RESERVEDf_GET(r) ((((r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0]) >> 7) & 0x1ffffff)
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_RESERVEDf_SET(r,f) (r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0]=(((r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0] & ~((uint32)0x1ffffff << 7)) | ((((uint32)f) & 0x1ffffff) << 7))

/*
 * These macros can be used to access AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTR.
 */
#define READ_AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr(u,r) bcm5607x_read32(u, R_AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTR, &(r._avs_reg_hw_mntr_sequencer_mask_pvt_mntr))
#define WRITE_AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr(u,r) bcm5607x_write32(u, R_AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTR, (r._avs_reg_hw_mntr_sequencer_mask_pvt_mntr))

/*******************************************************************************
 * End of 'AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CFAPCONFIG
 * BLOCKS:   MMU
 * DESC:     Controls the CFAP behavior
 * SIZE:     32
 * FIELDS:
 *     CFAPPOOLSIZE     Maximum number of cell pointers of CBP memory.Number of cells supported is 16K Note: Do NOT set this below the CFAPFULLTHRESHOLD.CFAPFULLRESETPOINT and CFAPFULLSETPOINT values, or it will cause unexpected behavior in the MMU. 
 *     CFAPINIT         Re-Initialize CFAP Memory.Set this bit for the MMU to re-initialize CFAP pointer pre-fetch process after user has rearranged CFAP memory.This bit is also used for XQ prefetching. 
 */
#define CFAPCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CFAPCONFIG.
 */
typedef union CFAPCONFIGr_s {
	uint32 v[1];
	uint32 cfapconfig[1];
	uint32 _cfapconfig;
} CFAPCONFIGr_t;

#define CFAPCONFIGr_CLR(r) (r).cfapconfig[0] = 0
#define CFAPCONFIGr_SET(r,d) (r).cfapconfig[0] = d
#define CFAPCONFIGr_GET(r) (r).cfapconfig[0]

/*
 * These macros can be used to access individual fields.
 */
#define CFAPCONFIGr_CFAPPOOLSIZEf_GET(r) (((r).cfapconfig[0]) & 0x3fff)
#define CFAPCONFIGr_CFAPPOOLSIZEf_SET(r,f) (r).cfapconfig[0]=(((r).cfapconfig[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define CFAPCONFIGr_CFAPINITf_GET(r) ((((r).cfapconfig[0]) >> 14) & 0x1)
#define CFAPCONFIGr_CFAPINITf_SET(r,f) (r).cfapconfig[0]=(((r).cfapconfig[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))

/*
 * These macros can be used to access CFAPCONFIG.
 */
#define WRITE_CFAPCONFIGr(u,r) bcm5607x_reg_set(u,R_CFAPCONFIG,(r._cfapconfig))
#define READ_CFAPCONFIGr(u,r) bcm5607x_reg_get(u,R_CFAPCONFIG,&(r._cfapconfig))

/*******************************************************************************
 * End of 'CFAPCONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CFAPFULLTHRESHOLD
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPFULLSETPOINT CFAP FULL Set PointDefine the threshold of entering CFAP FULL condition. CFAP is full when CFAP Read Pointer is above this limit.User should at least reaserve the total port number number*2 cell to prevent underflow!!
 *     CFAPFULLRESETPOINT CFAP FULL Reset PointDefine the threshold of exiting CFAP FULL condition. CFAP is not full when CFAP Read Pointer is below this limit.
 */
#define CFAPFULLTHRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program CFAPFULLTHRESHOLD.
 */
typedef union CFAPFULLTHRESHOLDr_s {
	uint32 v[1];
	uint32 cfapfullthreshold[1];
	uint32 _cfapfullthreshold;
} CFAPFULLTHRESHOLDr_t;

#define CFAPFULLTHRESHOLDr_CLR(r) (r).cfapfullthreshold[0] = 0
#define CFAPFULLTHRESHOLDr_SET(r,d) (r).cfapfullthreshold[0] = d
#define CFAPFULLTHRESHOLDr_GET(r) (r).cfapfullthreshold[0]

/*
 * These macros can be used to access individual fields.
 */
#define CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET(r) (((r).cfapfullthreshold[0]) & 0x3fff)
#define CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET(r,f) (r).cfapfullthreshold[0]=(((r).cfapfullthreshold[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET(r) ((((r).cfapfullthreshold[0]) >> 14) & 0x3fff)
#define CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET(r,f) (r).cfapfullthreshold[0]=(((r).cfapfullthreshold[0] & ~((uint32)0x3fff << 14)) | ((((uint32)f) & 0x3fff) << 14))

/*
 * These macros can be used to access CFAPFULLTHRESHOLD.
 */
#define WRITE_CFAPFULLTHRESHOLDr(u,r) bcm5607x_reg_set(u,R_CFAPFULLTHRESHOLD,(r._cfapfullthreshold))
#define READ_CFAPFULLTHRESHOLDr(u,r) bcm5607x_reg_get(u,R_CFAPFULLTHRESHOLD,&(r._cfapfullthreshold))

/*******************************************************************************
 * End of 'CFAPFULLTHRESHOLDr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CHIP_CONFIG
 * BLOCKS:   PMQPORT0 PMQPORT1 PMQPORT2
 * DESC:     Configuration and Status register for PM4x10Q Top
 * SIZE:     32
 * FIELDS:
 *     QMODE            1 = QSGMII Mode, 0 = Ethernet Mode
 *     IP_TDM           This configuration field enforces a specific minimum GPORT/IP TDM gap for gpN_to_ip_pkt_data_valid cycles. 0 = Consecutive gpN_to_ip_pkt_data_valid data valid cycles can happen with 0 idle cycles     between them. [valid - valid - valid etc.]1 = Consecutive gpN_to_ip_pkt_data_valid data valid cycles can happen with     minimum of 1 idle cycles between data valid cycles. [valid - idle -valid]2 = Consecutive gpN_to_ip_pkt_data_valid data valid cycles can happen with     minimum of 2 idle cycles between data valid cycles. [valid - idle - idle - valid]3 = Consecutive gpN_to_ip_pkt_data_valid data valid cycles can happen with     minimum of 3 idle cycles between data valid cycles. [valid - idle - idle - idle - valid]
 *     PAUSE_PFC_SEL    Configure UniMAC PAUSE or Serial PFC mode at the gp*_to_mmu_bkp[] and mmu_to_gp*_bkp[] interfaces.This configuration bit only enables the selected mode of operation at the interfaces to UniMAC. The regular UniMAC programming must still be done by software for PAUSE or PFC operation.0 = Backpressure/PAUSE Mode.1 = Serial PFC Mode.If this bit is 0, the UniMAC PAUSE mode is enabled. The mmu_to_gp_bkp[] will be used for rx backpressure_on TX. The "mac_in_pause" tx status will be provided on gp_to_mmu_bkp[]. Each assertion of the mmu_to_gp_bkp[] signal per port toggles the XON/XOFF status of Unimac.If this bit is 1, the Serial PFC mode is enabled. The mmu_to_gp_bkp[] will be used for the Serial PFC Request interface, and gp_to_mmu_bkp[] will be used for the Serial PFC Reporting interface.
 *     PCS_USXGMII_MODE_EN This bit sets the strap_usxgmii input high to QTC_PCS. The USXGMII mode enabled requires this bit set to 1 and the otp_port_bond_option[14] set to 1. If otp_port_bond_option[14] is 0, the USXGMII mode is not enabled regardless of the setting of the PCS_USXGMII_MODE_EN config bit.otp_port_bond_option[14]    0        0       1      1PCS_USXGMII_MODE_EN         0        1       0      1Resulting mode            QSGMII  QSGMII  QSGMII  USGMII
 *     PMD_PLL_CTRL_REFCLK_TERM_SEL            For use in Q-mode, Input refclk termination select control from the pin.      This signal goes through a register override mux before connecting to the i_pll_ctrl[85:84] bus.      00 : each reference clock pairs input termination is 100 Ohm differential      01 : each reference clock pairs input termination is 200 Ohm differential      10 : unused      11 : each reference clock pairs input termination is 300 Ohm differential
 *     PMD_PLL_CTRL_REFCLK_DIV2 For use in Q-mode, Enable Divide by 2 on refclk input
 *     PMD_PLL_CTRL_REFCLK_DIV4 For use in Q-mode, Enable Divide by 4 on refclk input
 *     POWERSAVE        If this bit is 1, enable PMQ power-save mode. When set, the core clk to the GPORTs is gated.In powersave mode the qtc_pwrdwn pin is also high which turns off all QTC clocks except refclk. QTC MDIO is operational. The GPORT LED scan chain will drive 0 for all status bits. The SBUS interface will remain operation.
 */
#define CHIP_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_CONFIG.
 */
typedef union CHIP_CONFIGr_s {
	uint32 v[1];
	uint32 chip_config[1];
	uint32 _chip_config;
} CHIP_CONFIGr_t;

#define CHIP_CONFIGr_CLR(r) (r).chip_config[0] = 0
#define CHIP_CONFIGr_SET(r,d) (r).chip_config[0] = d
#define CHIP_CONFIGr_GET(r) (r).chip_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIP_CONFIGr_QMODEf_GET(r) (((r).chip_config[0]) & 0x1)
#define CHIP_CONFIGr_QMODEf_SET(r,f) (r).chip_config[0]=(((r).chip_config[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CHIP_CONFIGr_IP_TDMf_GET(r) ((((r).chip_config[0]) >> 1) & 0x7)
#define CHIP_CONFIGr_IP_TDMf_SET(r,f) (r).chip_config[0]=(((r).chip_config[0] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define CHIP_CONFIGr_PAUSE_PFC_SELf_GET(r) ((((r).chip_config[0]) >> 4) & 0x1)
#define CHIP_CONFIGr_PAUSE_PFC_SELf_SET(r,f) (r).chip_config[0]=(((r).chip_config[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CHIP_CONFIGr_PCS_USXGMII_MODE_ENf_GET(r) ((((r).chip_config[0]) >> 5) & 0x1)
#define CHIP_CONFIGr_PCS_USXGMII_MODE_ENf_SET(r,f) (r).chip_config[0]=(((r).chip_config[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CHIP_CONFIGr_PMD_PLL_CTRL_REFCLK_TERM_SELf_GET(r) ((((r).chip_config[0]) >> 6) & 0x3)
#define CHIP_CONFIGr_PMD_PLL_CTRL_REFCLK_TERM_SELf_SET(r,f) (r).chip_config[0]=(((r).chip_config[0] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define CHIP_CONFIGr_PMD_PLL_CTRL_REFCLK_DIV2f_GET(r) ((((r).chip_config[0]) >> 8) & 0x1)
#define CHIP_CONFIGr_PMD_PLL_CTRL_REFCLK_DIV2f_SET(r,f) (r).chip_config[0]=(((r).chip_config[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CHIP_CONFIGr_PMD_PLL_CTRL_REFCLK_DIV4f_GET(r) ((((r).chip_config[0]) >> 9) & 0x1)
#define CHIP_CONFIGr_PMD_PLL_CTRL_REFCLK_DIV4f_SET(r,f) (r).chip_config[0]=(((r).chip_config[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CHIP_CONFIGr_POWERSAVEf_GET(r) ((((r).chip_config[0]) >> 31) & 0x1)
#define CHIP_CONFIGr_POWERSAVEf_SET(r,f) (r).chip_config[0]=(((r).chip_config[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access CHIP_CONFIG.
 */
#define WRITE_CHIP_CONFIGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_pmqport_lport_to_blockid[p], R_CHIP_CONFIG, (r._chip_config))
#define READ_CHIP_CONFIGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_pmqport_lport_to_blockid[p], R_CHIP_CONFIG, &(r._chip_config))

/*******************************************************************************
 * End of 'CHIP_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * SWFORMAT:  CHIP_CONFIG_OTP
 * BLOCKS:  
 * DESC:     Chip config otp ROM image
 * SIZE:     1024
 * FIELDS:
 *     REV_ID                              8-bit Revision ID
 *     DEV_ID                              16-bit Device ID
 *     RSVD_24                             
 *     CORE_PLL_CH0_MDIV                    Core PLL ch0 mdiv value.
 *     CORE_PLL_CH1_MDIV                    Core  PLL ch1 mdiv value.
 *     CORE_PLL_NDIV                       Core PLL ndiv value.
 *     CORE_PLL_PDIV                       Core PLL pdiv value.
 *     CORE_PLL_KA                         Core PLL ka value.
 *     CORE_PLL_KI                         Core PLL ki value.
 *     CORE_PLL_KP                         Core PLL kp value.
 *     CORE_PLL_VCO_DIV2                    Core PLL vco_div2 value.
 *     CORE_PLL_CH2_MDIV                    Core PLL ch2 mdiv value.
 *     GEN_PLL_CH0_MDIV                    GEN  PLL ch0 mdiv value.
 *     RSVD_94                             
 *     GEN_PLL_CH2_MDIV                    GEN  PLL ch2 mdiv value.
 *     GEN_PLL_CH3_MDIV                    GEN  PLL ch3 mdiv value.
 *     GEN_PLL_NDIV                        GEN  PLL ndiv value.
 *     RSVD_124                            
 *     L3_ENABLE                           When this bit is set, L3 related functions are enabled.
 *     VFP_SLICE_ENABLE                    VFP slice enables.1'b1: enable vfp slice1'b0: disable vfp slice
 *     IFP_SLICE_ENABLE                    IFP slice enables.1'b1: enable Ifp slice1'b0: disable Ifp slice
 *     IFP_SLICE_DEPTH                     IFP slice depth.2'b10: 128 ACL's per slice2'b01: 64 ACL's per slice2'b00: 32 ACL's per slice
 *     EFP_SLICE_ENABLE                    EFP slice enables.1'b1: enable Efp slice1'b0: disable Efp slice
 *     OAM_ENABLE                          When this bit is set, OAM feature is enabled.
 *     L2_ENTRY_SIZE                       Bond L2 entry table size select                       2'b00: 2k2'b01: 4k2'b10: 8k2'b11: 16k
 *     LPM_SIZE                            Controls LPM Table Size.1'b1: 64 IPV4/IPV6 Entries.1'b0: 64 IPV4/IPV6 Entries.
 *     L3_NEXT_HOP_SIZE                    Controls NEXT_HOP and L3MC Table Size.NHOP: 1'b1: 512 Entries; 1'b0: 128 Entries.L3MC:1'b1: 128 Entries; 1'b0: 64 Entries.
 *     FP_ROUTE_ENABLE                     When this bit is set, enables Routing by IFP.
 *     CBP_BUFFER_SIZE                     Selects CBP Buffer size in MMU2'b11: 2.0MB2'b10: 1.0 MB2'b01: 2.0 MB 2'b00: 1.0 MB 
 *     TS_1588_DISABLE                     When this bit is set, disable 1588 TimeSync.1'b1: Disable TimeSync 15881'b0: Enable TimeSync 1588
 *     RSVD_156                            
 *     RSVD_161                            Was for GH2 QTC#1, #0, NA for FL
 *     PM4X10Q_DISABLE                     When the bit is set, shuts off PM_4X10Q instances. [0] - control PM_4X10 #0.[1] - control PM_4X10 #1.[2] - control PM_4X10 #2.
 *     PM4X25_DISABLE                      PM4x25 mode selection: 1'b1: shut down mode.1'b0: enable mode.[0] - control PM_4X25 #0.[1] - control PM_4X25 #1.[2] - control PM_4X25 #2.[3] - control PM_4X25 #3.
 *     PM4X10Q_QSGMII_ENABLE                    When the bit is set, enables QSGMII capability on PM_4X10Q instances.[0] - control PM_4X10Q #0[1] - control PM_4X10Q #1.[2] - control PM_4X10Q #2.[3] - RSVD, default to 1'b0
 *     PM4X10Q_QXGMII_ENABLE                    When the bit is set, enables QXGMII capability on PM_4X10Q instances.[0] - control PM_4X10Q #0[1] - control PM_4X10Q #1.[2] - control PM_4X10Q #2.[3] - RSVD, default to 1'b0
 *     PM4X10Q_0_LANE_DISABLE                    [1] - control PM_4X10 #1.
 *     PM4X10Q_1_LANE_DISABLE                    [2] - control PM_4X10 #2.
 *     PM4X10Q_2_LANE_DISABLE                    PM_4X10Q #2 per lane disable[0] - lane #0, [1] -  lane #1,  [2] -  lane #2,  [3] -  lane #3.  1'b1: Lane disable1'b0: Lane enable
 *     RSVD_189                            
 *     RSVD_195                            
 *     PM4X25_0_LANE_DISABLE                    PM_4X25 #0 per lane disable[0] - lane #0, [1] -  lane #1,  [2] -  lane #2,  [3] -  lane #3.  1'b1: Lane disable1'b0: Lane enable
 *     PM4X25_1_LANE_DISABLE                    PM_4X25 #1 per lane disable[0] - lane #0, [1] -  lane #1,  [2] -  lane #2,  [3] -  lane #3.  1'b1: Lane disable1'b0: Lane enable
 *     PM4X25_2_LANE_DISABLE                    PM_4X25 #2 per lane disable[0] - lane #0, [1] -  lane #1,  [2] -  lane #2,  [3] -  lane #3.  1'b1: Lane disable1'b0: Lane enable
 *     PM4X25_3_LANE_DISABLE                    PM_4X25 #3 per lane disable[0] - lane #0, [1] -  lane #1,  [2] -  lane #2,  [3] -  lane #3.  1'b1: Lane disable1'b0: Lane enable
 *     AVS_PROCESS_CODE                    AVS value. 
 *     MACSEC_ENABLE                       1'b0: DISABLE (all PMs bypass MACSEC)1'b1: ENABLE
 *     PM4X25_MACSEC_BYP                    1'b0: ENABLE(non-bypass)1'b1: DISABLE (bypass MACSEC)
 *     PM4X10Q_MACSEC_BYP                    1'b0: ENABLE(non-bypass)1'b1: DISABLE (bypass MACSEC)
 *     RSVD_223                            
 *     RSVD_224                            
 *     RSVD_246                            Move CFG_VALID to 895 for 16nm
 *     RSVD_247                            Remove OTP Chip CFG 1st 256 bits ECC
 *     RSVD_255                            Remove OTP Chip CFG 1st 256 bits parity
 *     IHOST_LIMIT_VCO_FREQ                    Limit VCO frequency.
 *     IHOST_A9_POWER_DOWN                    iHost A9 Power down (greyhound new requirement)
 *     BOND_DISABLE_BSYNC                    Each bit disable on broadsync1'b1: disable broadsync#0, 1.1'b0: enable broadsync#0, 1.
 *     BOND_DISABLE_PERIPHERAL                    Disable Peripheral1'b1: disable parallel flash (NOR/NAND), USB, SDIO, DDR1'b0: enable parallel flash (NOR/NAND), USB, SDIO, DDR
 *     IHOST_OTP_DISABLE_MRDTEN_INVERSION                    1'b1: disable ihost read assist on sub-bank1'b0: enable ihost read assist on sub-bank
 *     IHOST_OTP_DISABLE_MRDTEN_INVERSION_SELECT                    1'b1: select inverse of IHOST_OTP_DISABLE_MRDTEN_INVERSION for ihost1'b0: ihost will use enable_mrdten_inversion from avs_top.
 *     OTP_DISABLE_MRDTEN_INVERSION                    1'b1: disable read assist on sub-bank1'b0: enable read assist on sub-bank
 *     OTP_DISABLE_MLVM                    1'b1: disable micro low voltage mode1'b0: enable micro low voltage mode
 *     OTP_DISABLE_LVM                     1'b1: disable static low voltage mode1'b0: enable static low voltage mode
 *     RSVD_266                            
 *     PORT_XL_SPEED_LIMIT                    Port XL speed limit[0] - Physical Port Mapping Table entry 0 enable bit, [1] - Physical Port MappingTable entry 1 enable bit, ...1'b1: port speed: In PM4X25, <= 25G, In PM4X10, <= 5G. In QTC, < 2.5G1'b0: No limited.
 *     PORT_CL_SPEED_LIMIT                    Port CL speed limit[0] - Physical Port Mapping Table entry 0 enable bit, [1] - Physical Port MappingTable entry 1 enable bit, ...1'b1: port speed: In PM4X25, <= 25G, In PM4X10, <= 5G. In QTC, < 2.5G1'b0: No limited.
 *     PORT_CL_TSN_ENABLE                    CL Port TSN Enable1'b1: Enable1'b0: Disable
 *     RSVD_320                            Port sgmii speed limit[0] - Physical Port Mapping Table1 entry 0 enable bit, [1] - Physical Port MappingTable1 entry 1 enable bit, ...1'b1: port speed: In SGMII < 2.5G1'b0: No limited.
 *     VXLAN_LITE_ENABLE                    Vxlan Lite Enable1'b1: Enable1'b0: Disable
 *     RROCE_ENABLE                        RROCE Enable1'b1: Enable1'b0: Disable
 *     PREEMPTION_ENABLE                    Preemption Enable1'b1: Enable1'b0: Disable
 *     TAS_ENABLE                          Time-Aware Scheduling Enable1'b1: Enable1'b0: Disable
 *     HSR_ENABLE                          HSR (IEC 62439-3) Enable1'b1: Enable1'b0: Disable
 *     PRP_ENABLE                          PRP (IEC 62439-3) Enable1'b1: Enable1'b0: Disable
 *     IEEE_802_1CB_ENABLE                    IEEE 802.1CB Enable1'b1: Enable1'b0: Disable
 *     MAX_XQS_NUMBER                      NA for FLFor Port 34~65:1'b0: 2K Entries1'b1: 6K Entries
 *     OTP_2_DISABLE                       2nd chance OTP DISABLE
 *     SECURITY_ENABLE                     Security enable bit[0]: normal bit; [1]: resundant bit.1'b1: Enable security feature1'b0: Disable Security feature
 *     TAF_ENABLE                          Time Aware Stream Filtering and Policing (802.1Qci) Enable1'b1: Enable1'b0: Disable
 *     RSVD_364                            
 *     L2MC_SIZE                           L2_MC size:1'b1: 1024 entries.1'b0: 256 entries.
 *     SPAN_TREE_GROUPS_SIZE                    SPAN_TREE_GROUP size:1'b1: 128 entries.1'b0: 32 entries.
 *     VLAN_TRANSLATION_SIZE                    VLAN TRANSLATION TABLE size: (Ingress/ Egress)1'b1: 1k/1k entries.1'b0: 256/256 entries.
 *     VFP_SLICE_DEPTH                     VFP slice depth.1'b1: 64 ACL's per slice1'b0: 32 ACL's per slice
 *     L3_HOST_SIZE                        L3_HOST table depth.1'b1: 512/256 entries.1'b0: 256/128 entries.
 *     EFP_SLICE_DEPTH                     EFP slice depth.1'b1: 64 ACL's per slice1'b0: 32 ACL's per slice
 *     SR_FLOWID_SIZE                      Seamless Redundancy FlowID size:1'b1: 256 entries.1'b0: 64 entries.
 *     RSVD_391                            
 *     RSVD_416                            
 *     RSVD_439                            Remove ECC for section1 fields.
 *     RSVD_447                            Remove Parity for section1 fields including ECC.
 *     HASH                                Hash code
 *     RSVD_608                            
 *     RSVD_640                            
 *     RSVD_672                            
 *     RSVD_695                            Remove ECC for section2 fields.
 *     RSVD_703                            Remove Parity for section2 fields including ECC.
 *     RSVD_704                            
 *     RSVD_736                            
 *     RSVD_768                            
 *     RSVD_800                            
 *     RSVD_832                            
 *     RSVD_864                            
 *     CFG_VALID                           OTP CFG valid.
 *     PCIE_SERDES_TM                      PCIE_SERDES_TM
 *     IPROC_PCIE_SP_TM                    IPROC_PCIE_SP_TM
 *     IPROC_PCIE_SRF_TM                    IPROC_PCIE_SRF_TM
 *     IPROC_ROM0_TM                       IPROC ROM TM bit
 *     RSVD_922                            
 *     RSVD_928                            
 *     RSVD_960                            
 *     RSVD_992                            
 */
#define CHIP_CONFIG_OTP_SIZE 128

/*
 * This structure should be used to declare and program CHIP_CONFIG_OTP.
 */
typedef union CHIP_CONFIG_OTP_s {
	uint32 v[32];
	uint32 chip_config_otp[32];
	uint32 _chip_config_otp;
} CHIP_CONFIG_OTP_t;

#define CHIP_CONFIG_OTP_CLR(r) sal_memset(&((r)._chip_config_otp), 0, sizeof(CHIP_CONFIG_OTP_t))
#define CHIP_CONFIG_OTP_SET(r,i,d) (r).chip_config_otp[i] = d
#define CHIP_CONFIG_OTP_GET(r,i) (r).chip_config_otp[i]

/*
 * These macros can be used to access individual fields.
 */
#define CHIP_CONFIG_OTP_REV_IDf_GET(r) (((r).chip_config_otp[0]) & 0xff)
#define CHIP_CONFIG_OTP_REV_IDf_SET(r,f) (r).chip_config_otp[0]=(((r).chip_config_otp[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define CHIP_CONFIG_OTP_DEV_IDf_GET(r) ((((r).chip_config_otp[0]) >> 8) & 0xffff)
#define CHIP_CONFIG_OTP_DEV_IDf_SET(r,f) (r).chip_config_otp[0]=(((r).chip_config_otp[0] & ~((uint32)0xffff << 8)) | ((((uint32)f) & 0xffff) << 8))
#define CHIP_CONFIG_OTP_RSVD_24f_GET(r) ((((r).chip_config_otp[0]) >> 24) & 0xff)
#define CHIP_CONFIG_OTP_RSVD_24f_SET(r,f) (r).chip_config_otp[0]=(((r).chip_config_otp[0] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define CHIP_CONFIG_OTP_CORE_PLL_CH0_MDIVf_GET(r) (((r).chip_config_otp[1]) & 0x1ff)
#define CHIP_CONFIG_OTP_CORE_PLL_CH0_MDIVf_SET(r,f) (r).chip_config_otp[1]=(((r).chip_config_otp[1] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define CHIP_CONFIG_OTP_CORE_PLL_CH1_MDIVf_GET(r) ((((r).chip_config_otp[1]) >> 9) & 0x1ff)
#define CHIP_CONFIG_OTP_CORE_PLL_CH1_MDIVf_SET(r,f) (r).chip_config_otp[1]=(((r).chip_config_otp[1] & ~((uint32)0x1ff << 9)) | ((((uint32)f) & 0x1ff) << 9))
#define CHIP_CONFIG_OTP_CORE_PLL_NDIVf_GET(r) ((((r).chip_config_otp[1]) >> 18) & 0x3ff)
#define CHIP_CONFIG_OTP_CORE_PLL_NDIVf_SET(r,f) (r).chip_config_otp[1]=(((r).chip_config_otp[1] & ~((uint32)0x3ff << 18)) | ((((uint32)f) & 0x3ff) << 18))
#define CHIP_CONFIG_OTP_CORE_PLL_PDIVf_GET(r) ((((r).chip_config_otp[1]) >> 28) & 0xf)
#define CHIP_CONFIG_OTP_CORE_PLL_PDIVf_SET(r,f) (r).chip_config_otp[1]=(((r).chip_config_otp[1] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define CHIP_CONFIG_OTP_CORE_PLL_KAf_GET(r) (((r).chip_config_otp[2]) & 0xf)
#define CHIP_CONFIG_OTP_CORE_PLL_KAf_SET(r,f) (r).chip_config_otp[2]=(((r).chip_config_otp[2] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CHIP_CONFIG_OTP_CORE_PLL_KIf_GET(r) ((((r).chip_config_otp[2]) >> 4) & 0x7)
#define CHIP_CONFIG_OTP_CORE_PLL_KIf_SET(r,f) (r).chip_config_otp[2]=(((r).chip_config_otp[2] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define CHIP_CONFIG_OTP_CORE_PLL_KPf_GET(r) ((((r).chip_config_otp[2]) >> 7) & 0xf)
#define CHIP_CONFIG_OTP_CORE_PLL_KPf_SET(r,f) (r).chip_config_otp[2]=(((r).chip_config_otp[2] & ~((uint32)0xf << 7)) | ((((uint32)f) & 0xf) << 7))
#define CHIP_CONFIG_OTP_CORE_PLL_VCO_DIV2f_GET(r) ((((r).chip_config_otp[2]) >> 11) & 0x1)
#define CHIP_CONFIG_OTP_CORE_PLL_VCO_DIV2f_SET(r,f) (r).chip_config_otp[2]=(((r).chip_config_otp[2] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define CHIP_CONFIG_OTP_CORE_PLL_CH2_MDIVf_GET(r) ((((r).chip_config_otp[2]) >> 12) & 0x1ff)
#define CHIP_CONFIG_OTP_CORE_PLL_CH2_MDIVf_SET(r,f) (r).chip_config_otp[2]=(((r).chip_config_otp[2] & ~((uint32)0x1ff << 12)) | ((((uint32)f) & 0x1ff) << 12))
#define CHIP_CONFIG_OTP_GEN_PLL_CH0_MDIVf_GET(r) ((((r).chip_config_otp[2]) >> 21) & 0x1ff)
#define CHIP_CONFIG_OTP_GEN_PLL_CH0_MDIVf_SET(r,f) (r).chip_config_otp[2]=(((r).chip_config_otp[2] & ~((uint32)0x1ff << 21)) | ((((uint32)f) & 0x1ff) << 21))
#define CHIP_CONFIG_OTP_RSVD_94f_GET(r) ((((r).chip_config_otp[2]) >> 30) & 0x3)
#define CHIP_CONFIG_OTP_RSVD_94f_SET(r,f) (r).chip_config_otp[2]=(((r).chip_config_otp[2] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define CHIP_CONFIG_OTP_GEN_PLL_CH2_MDIVf_GET(r) (((r).chip_config_otp[3]) & 0x1ff)
#define CHIP_CONFIG_OTP_GEN_PLL_CH2_MDIVf_SET(r,f) (r).chip_config_otp[3]=(((r).chip_config_otp[3] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define CHIP_CONFIG_OTP_GEN_PLL_CH3_MDIVf_GET(r) ((((r).chip_config_otp[3]) >> 9) & 0x1ff)
#define CHIP_CONFIG_OTP_GEN_PLL_CH3_MDIVf_SET(r,f) (r).chip_config_otp[3]=(((r).chip_config_otp[3] & ~((uint32)0x1ff << 9)) | ((((uint32)f) & 0x1ff) << 9))
#define CHIP_CONFIG_OTP_GEN_PLL_NDIVf_GET(r) ((((r).chip_config_otp[3]) >> 18) & 0x3ff)
#define CHIP_CONFIG_OTP_GEN_PLL_NDIVf_SET(r,f) (r).chip_config_otp[3]=(((r).chip_config_otp[3] & ~((uint32)0x3ff << 18)) | ((((uint32)f) & 0x3ff) << 18))
#define CHIP_CONFIG_OTP_RSVD_124f_GET(r) ((((r).chip_config_otp[3]) >> 28) & 0xf)
#define CHIP_CONFIG_OTP_RSVD_124f_SET(r,f) (r).chip_config_otp[3]=(((r).chip_config_otp[3] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define CHIP_CONFIG_OTP_L3_ENABLEf_GET(r) (((r).chip_config_otp[4]) & 0x1)
#define CHIP_CONFIG_OTP_L3_ENABLEf_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CHIP_CONFIG_OTP_VFP_SLICE_ENABLEf_GET(r) ((((r).chip_config_otp[4]) >> 1) & 0xf)
#define CHIP_CONFIG_OTP_VFP_SLICE_ENABLEf_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0xf << 1)) | ((((uint32)f) & 0xf) << 1))
#define CHIP_CONFIG_OTP_IFP_SLICE_ENABLEf_GET(r) ((((r).chip_config_otp[4]) >> 5) & 0xff)
#define CHIP_CONFIG_OTP_IFP_SLICE_ENABLEf_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0xff << 5)) | ((((uint32)f) & 0xff) << 5))
#define CHIP_CONFIG_OTP_IFP_SLICE_DEPTHf_GET(r) ((((r).chip_config_otp[4]) >> 13) & 0x3)
#define CHIP_CONFIG_OTP_IFP_SLICE_DEPTHf_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define CHIP_CONFIG_OTP_EFP_SLICE_ENABLEf_GET(r) ((((r).chip_config_otp[4]) >> 15) & 0xf)
#define CHIP_CONFIG_OTP_EFP_SLICE_ENABLEf_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0xf << 15)) | ((((uint32)f) & 0xf) << 15))
#define CHIP_CONFIG_OTP_OAM_ENABLEf_GET(r) ((((r).chip_config_otp[4]) >> 19) & 0x1)
#define CHIP_CONFIG_OTP_OAM_ENABLEf_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define CHIP_CONFIG_OTP_L2_ENTRY_SIZEf_GET(r) ((((r).chip_config_otp[4]) >> 20) & 0x3)
#define CHIP_CONFIG_OTP_L2_ENTRY_SIZEf_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define CHIP_CONFIG_OTP_LPM_SIZEf_GET(r) ((((r).chip_config_otp[4]) >> 22) & 0x1)
#define CHIP_CONFIG_OTP_LPM_SIZEf_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CHIP_CONFIG_OTP_L3_NEXT_HOP_SIZEf_GET(r) ((((r).chip_config_otp[4]) >> 23) & 0x1)
#define CHIP_CONFIG_OTP_L3_NEXT_HOP_SIZEf_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define CHIP_CONFIG_OTP_FP_ROUTE_ENABLEf_GET(r) ((((r).chip_config_otp[4]) >> 24) & 0x1)
#define CHIP_CONFIG_OTP_FP_ROUTE_ENABLEf_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define CHIP_CONFIG_OTP_CBP_BUFFER_SIZEf_GET(r) ((((r).chip_config_otp[4]) >> 25) & 0x3)
#define CHIP_CONFIG_OTP_CBP_BUFFER_SIZEf_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0x3 << 25)) | ((((uint32)f) & 0x3) << 25))
#define CHIP_CONFIG_OTP_TS_1588_DISABLEf_GET(r) ((((r).chip_config_otp[4]) >> 27) & 0x1)
#define CHIP_CONFIG_OTP_TS_1588_DISABLEf_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define CHIP_CONFIG_OTP_RSVD_156f_GET(r) ((((r).chip_config_otp[4]) >> 28) & 0xf)
#define CHIP_CONFIG_OTP_RSVD_156f_SET(r,f) (r).chip_config_otp[4]=(((r).chip_config_otp[4] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define CHIP_CONFIG_OTP_RSVD_161f_GET(r) (((r).chip_config_otp[5]) & 0x3)
#define CHIP_CONFIG_OTP_RSVD_161f_SET(r,f) (r).chip_config_otp[5]=(((r).chip_config_otp[5] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define CHIP_CONFIG_OTP_PM4X10Q_DISABLEf_GET(r) ((((r).chip_config_otp[5]) >> 2) & 0x7)
#define CHIP_CONFIG_OTP_PM4X10Q_DISABLEf_SET(r,f) (r).chip_config_otp[5]=(((r).chip_config_otp[5] & ~((uint32)0x7 << 2)) | ((((uint32)f) & 0x7) << 2))
#define CHIP_CONFIG_OTP_PM4X25_DISABLEf_GET(r) ((((r).chip_config_otp[5]) >> 5) & 0xf)
#define CHIP_CONFIG_OTP_PM4X25_DISABLEf_SET(r,f) (r).chip_config_otp[5]=(((r).chip_config_otp[5] & ~((uint32)0xf << 5)) | ((((uint32)f) & 0xf) << 5))
#define CHIP_CONFIG_OTP_PM4X10Q_QSGMII_ENABLEf_GET(r) ((((r).chip_config_otp[5]) >> 9) & 0xf)
#define CHIP_CONFIG_OTP_PM4X10Q_QSGMII_ENABLEf_SET(r,f) (r).chip_config_otp[5]=(((r).chip_config_otp[5] & ~((uint32)0xf << 9)) | ((((uint32)f) & 0xf) << 9))
#define CHIP_CONFIG_OTP_PM4X10Q_QXGMII_ENABLEf_GET(r) ((((r).chip_config_otp[5]) >> 13) & 0xf)
#define CHIP_CONFIG_OTP_PM4X10Q_QXGMII_ENABLEf_SET(r,f) (r).chip_config_otp[5]=(((r).chip_config_otp[5] & ~((uint32)0xf << 13)) | ((((uint32)f) & 0xf) << 13))
#define CHIP_CONFIG_OTP_PM4X10Q_0_LANE_DISABLEf_GET(r) ((((r).chip_config_otp[5]) >> 17) & 0xf)
#define CHIP_CONFIG_OTP_PM4X10Q_0_LANE_DISABLEf_SET(r,f) (r).chip_config_otp[5]=(((r).chip_config_otp[5] & ~((uint32)0xf << 17)) | ((((uint32)f) & 0xf) << 17))
#define CHIP_CONFIG_OTP_PM4X10Q_1_LANE_DISABLEf_GET(r) ((((r).chip_config_otp[5]) >> 21) & 0xf)
#define CHIP_CONFIG_OTP_PM4X10Q_1_LANE_DISABLEf_SET(r,f) (r).chip_config_otp[5]=(((r).chip_config_otp[5] & ~((uint32)0xf << 21)) | ((((uint32)f) & 0xf) << 21))
#define CHIP_CONFIG_OTP_PM4X10Q_2_LANE_DISABLEf_GET(r) ((((r).chip_config_otp[5]) >> 25) & 0xf)
#define CHIP_CONFIG_OTP_PM4X10Q_2_LANE_DISABLEf_SET(r,f) (r).chip_config_otp[5]=(((r).chip_config_otp[5] & ~((uint32)0xf << 25)) | ((((uint32)f) & 0xf) << 25))
#define CHIP_CONFIG_OTP_RSVD_189f_GET(r) ((((r).chip_config_otp[5]) >> 29) & 0x7)
#define CHIP_CONFIG_OTP_RSVD_189f_SET(r,f) (r).chip_config_otp[5]=(((r).chip_config_otp[5] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))
#define CHIP_CONFIG_OTP_RSVD_195f_GET(r) (((r).chip_config_otp[6]) & 0xf)
#define CHIP_CONFIG_OTP_RSVD_195f_SET(r,f) (r).chip_config_otp[6]=(((r).chip_config_otp[6] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CHIP_CONFIG_OTP_PM4X25_0_LANE_DISABLEf_GET(r) ((((r).chip_config_otp[6]) >> 4) & 0xf)
#define CHIP_CONFIG_OTP_PM4X25_0_LANE_DISABLEf_SET(r,f) (r).chip_config_otp[6]=(((r).chip_config_otp[6] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CHIP_CONFIG_OTP_PM4X25_1_LANE_DISABLEf_GET(r) ((((r).chip_config_otp[6]) >> 8) & 0xf)
#define CHIP_CONFIG_OTP_PM4X25_1_LANE_DISABLEf_SET(r,f) (r).chip_config_otp[6]=(((r).chip_config_otp[6] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CHIP_CONFIG_OTP_PM4X25_2_LANE_DISABLEf_GET(r) ((((r).chip_config_otp[6]) >> 12) & 0xf)
#define CHIP_CONFIG_OTP_PM4X25_2_LANE_DISABLEf_SET(r,f) (r).chip_config_otp[6]=(((r).chip_config_otp[6] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CHIP_CONFIG_OTP_PM4X25_3_LANE_DISABLEf_GET(r) ((((r).chip_config_otp[6]) >> 16) & 0xf)
#define CHIP_CONFIG_OTP_PM4X25_3_LANE_DISABLEf_SET(r,f) (r).chip_config_otp[6]=(((r).chip_config_otp[6] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CHIP_CONFIG_OTP_AVS_PROCESS_CODEf_GET(r) ((((r).chip_config_otp[6]) >> 20) & 0x7)
#define CHIP_CONFIG_OTP_AVS_PROCESS_CODEf_SET(r,f) (r).chip_config_otp[6]=(((r).chip_config_otp[6] & ~((uint32)0x7 << 20)) | ((((uint32)f) & 0x7) << 20))
#define CHIP_CONFIG_OTP_MACSEC_ENABLEf_GET(r) ((((r).chip_config_otp[6]) >> 23) & 0x1)
#define CHIP_CONFIG_OTP_MACSEC_ENABLEf_SET(r,f) (r).chip_config_otp[6]=(((r).chip_config_otp[6] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define CHIP_CONFIG_OTP_PM4X25_MACSEC_BYPf_GET(r) ((((r).chip_config_otp[6]) >> 24) & 0xf)
#define CHIP_CONFIG_OTP_PM4X25_MACSEC_BYPf_SET(r,f) (r).chip_config_otp[6]=(((r).chip_config_otp[6] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CHIP_CONFIG_OTP_PM4X10Q_MACSEC_BYPf_GET(r) ((((r).chip_config_otp[6]) >> 28) & 0x7)
#define CHIP_CONFIG_OTP_PM4X10Q_MACSEC_BYPf_SET(r,f) (r).chip_config_otp[6]=(((r).chip_config_otp[6] & ~((uint32)0x7 << 28)) | ((((uint32)f) & 0x7) << 28))
#define CHIP_CONFIG_OTP_RSVD_223f_GET(r) ((((r).chip_config_otp[6]) >> 31) & 0x1)
#define CHIP_CONFIG_OTP_RSVD_223f_SET(r,f) (r).chip_config_otp[6]=(((r).chip_config_otp[6] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define CHIP_CONFIG_OTP_RSVD_224f_GET(r) (((r).chip_config_otp[7]) & 0x3fffff)
#define CHIP_CONFIG_OTP_RSVD_224f_SET(r,f) (r).chip_config_otp[7]=(((r).chip_config_otp[7] & ~((uint32)0x3fffff)) | (((uint32)f) & 0x3fffff))
#define CHIP_CONFIG_OTP_RSVD_246f_GET(r) ((((r).chip_config_otp[7]) >> 22) & 0x1)
#define CHIP_CONFIG_OTP_RSVD_246f_SET(r,f) (r).chip_config_otp[7]=(((r).chip_config_otp[7] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CHIP_CONFIG_OTP_RSVD_247f_GET(r) ((((r).chip_config_otp[7]) >> 23) & 0xff)
#define CHIP_CONFIG_OTP_RSVD_247f_SET(r,f) (r).chip_config_otp[7]=(((r).chip_config_otp[7] & ~((uint32)0xff << 23)) | ((((uint32)f) & 0xff) << 23))
#define CHIP_CONFIG_OTP_RSVD_255f_GET(r) ((((r).chip_config_otp[7]) >> 31) & 0x1)
#define CHIP_CONFIG_OTP_RSVD_255f_SET(r,f) (r).chip_config_otp[7]=(((r).chip_config_otp[7] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define CHIP_CONFIG_OTP_IHOST_LIMIT_VCO_FREQf_GET(r) (((r).chip_config_otp[8]) & 0x3)
#define CHIP_CONFIG_OTP_IHOST_LIMIT_VCO_FREQf_SET(r,f) (r).chip_config_otp[8]=(((r).chip_config_otp[8] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define CHIP_CONFIG_OTP_IHOST_A9_POWER_DOWNf_GET(r) ((((r).chip_config_otp[8]) >> 2) & 0x1)
#define CHIP_CONFIG_OTP_IHOST_A9_POWER_DOWNf_SET(r,f) (r).chip_config_otp[8]=(((r).chip_config_otp[8] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CHIP_CONFIG_OTP_BOND_DISABLE_BSYNCf_GET(r) ((((r).chip_config_otp[8]) >> 3) & 0x1)
#define CHIP_CONFIG_OTP_BOND_DISABLE_BSYNCf_SET(r,f) (r).chip_config_otp[8]=(((r).chip_config_otp[8] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CHIP_CONFIG_OTP_BOND_DISABLE_PERIPHERALf_GET(r) ((((r).chip_config_otp[8]) >> 4) & 0x1)
#define CHIP_CONFIG_OTP_BOND_DISABLE_PERIPHERALf_SET(r,f) (r).chip_config_otp[8]=(((r).chip_config_otp[8] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CHIP_CONFIG_OTP_IHOST_OTP_DISABLE_MRDTEN_INVERSIONf_GET(r) ((((r).chip_config_otp[8]) >> 5) & 0x1)
#define CHIP_CONFIG_OTP_IHOST_OTP_DISABLE_MRDTEN_INVERSIONf_SET(r,f) (r).chip_config_otp[8]=(((r).chip_config_otp[8] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CHIP_CONFIG_OTP_IHOST_OTP_DISABLE_MRDTEN_INVERSION_SELECTf_GET(r) ((((r).chip_config_otp[8]) >> 6) & 0x1)
#define CHIP_CONFIG_OTP_IHOST_OTP_DISABLE_MRDTEN_INVERSION_SELECTf_SET(r,f) (r).chip_config_otp[8]=(((r).chip_config_otp[8] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CHIP_CONFIG_OTP_OTP_DISABLE_MRDTEN_INVERSIONf_GET(r) ((((r).chip_config_otp[8]) >> 7) & 0x1)
#define CHIP_CONFIG_OTP_OTP_DISABLE_MRDTEN_INVERSIONf_SET(r,f) (r).chip_config_otp[8]=(((r).chip_config_otp[8] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CHIP_CONFIG_OTP_OTP_DISABLE_MLVMf_GET(r) ((((r).chip_config_otp[8]) >> 8) & 0x1)
#define CHIP_CONFIG_OTP_OTP_DISABLE_MLVMf_SET(r,f) (r).chip_config_otp[8]=(((r).chip_config_otp[8] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CHIP_CONFIG_OTP_OTP_DISABLE_LVMf_GET(r) ((((r).chip_config_otp[8]) >> 9) & 0x1)
#define CHIP_CONFIG_OTP_OTP_DISABLE_LVMf_SET(r,f) (r).chip_config_otp[8]=(((r).chip_config_otp[8] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CHIP_CONFIG_OTP_RSVD_266f_GET(r) ((((r).chip_config_otp[8]) >> 10) & 0x3fffff)
#define CHIP_CONFIG_OTP_RSVD_266f_SET(r,f) (r).chip_config_otp[8]=(((r).chip_config_otp[8] & ~((uint32)0x3fffff << 10)) | ((((uint32)f) & 0x3fffff) << 10))
#define CHIP_CONFIG_OTP_PORT_XL_SPEED_LIMITf_GET(r) (((r).chip_config_otp[9]) & 0xfff)
#define CHIP_CONFIG_OTP_PORT_XL_SPEED_LIMITf_SET(r,f) (r).chip_config_otp[9]=(((r).chip_config_otp[9] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define CHIP_CONFIG_OTP_PORT_CL_SPEED_LIMITf_GET(r) ((((r).chip_config_otp[9]) >> 12) & 0xffff)
#define CHIP_CONFIG_OTP_PORT_CL_SPEED_LIMITf_SET(r,f) (r).chip_config_otp[9]=(((r).chip_config_otp[9] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define CHIP_CONFIG_OTP_PORT_CL_TSN_ENABLEf_GET(r) ((((r).chip_config_otp[9]) >> 28) & 0xf)
#define CHIP_CONFIG_OTP_PORT_CL_TSN_ENABLEf_SET(r,f) (r).chip_config_otp[9]=(((r).chip_config_otp[9] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define CHIP_CONFIG_OTP_RSVD_320f_GET(r) ((r).chip_config_otp[10])
#define CHIP_CONFIG_OTP_RSVD_320f_SET(r,f) (r).chip_config_otp[10]=((uint32)f)
#define CHIP_CONFIG_OTP_VXLAN_LITE_ENABLEf_GET(r) (((r).chip_config_otp[11]) & 0x1)
#define CHIP_CONFIG_OTP_VXLAN_LITE_ENABLEf_SET(r,f) (r).chip_config_otp[11]=(((r).chip_config_otp[11] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CHIP_CONFIG_OTP_RROCE_ENABLEf_GET(r) ((((r).chip_config_otp[11]) >> 1) & 0x1)
#define CHIP_CONFIG_OTP_RROCE_ENABLEf_SET(r,f) (r).chip_config_otp[11]=(((r).chip_config_otp[11] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CHIP_CONFIG_OTP_PREEMPTION_ENABLEf_GET(r) ((((r).chip_config_otp[11]) >> 2) & 0x1)
#define CHIP_CONFIG_OTP_PREEMPTION_ENABLEf_SET(r,f) (r).chip_config_otp[11]=(((r).chip_config_otp[11] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CHIP_CONFIG_OTP_TAS_ENABLEf_GET(r) ((((r).chip_config_otp[11]) >> 3) & 0x1)
#define CHIP_CONFIG_OTP_TAS_ENABLEf_SET(r,f) (r).chip_config_otp[11]=(((r).chip_config_otp[11] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CHIP_CONFIG_OTP_HSR_ENABLEf_GET(r) ((((r).chip_config_otp[11]) >> 4) & 0x1)
#define CHIP_CONFIG_OTP_HSR_ENABLEf_SET(r,f) (r).chip_config_otp[11]=(((r).chip_config_otp[11] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CHIP_CONFIG_OTP_PRP_ENABLEf_GET(r) ((((r).chip_config_otp[11]) >> 5) & 0x1)
#define CHIP_CONFIG_OTP_PRP_ENABLEf_SET(r,f) (r).chip_config_otp[11]=(((r).chip_config_otp[11] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CHIP_CONFIG_OTP_IEEE_802_1CB_ENABLEf_GET(r) ((((r).chip_config_otp[11]) >> 6) & 0x1)
#define CHIP_CONFIG_OTP_IEEE_802_1CB_ENABLEf_SET(r,f) (r).chip_config_otp[11]=(((r).chip_config_otp[11] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CHIP_CONFIG_OTP_MAX_XQS_NUMBERf_GET(r) ((((r).chip_config_otp[11]) >> 7) & 0x1)
#define CHIP_CONFIG_OTP_MAX_XQS_NUMBERf_SET(r,f) (r).chip_config_otp[11]=(((r).chip_config_otp[11] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CHIP_CONFIG_OTP_OTP_2_DISABLEf_GET(r) ((((r).chip_config_otp[11]) >> 8) & 0x1)
#define CHIP_CONFIG_OTP_OTP_2_DISABLEf_SET(r,f) (r).chip_config_otp[11]=(((r).chip_config_otp[11] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CHIP_CONFIG_OTP_SECURITY_ENABLEf_GET(r) ((((r).chip_config_otp[11]) >> 9) & 0x3)
#define CHIP_CONFIG_OTP_SECURITY_ENABLEf_SET(r,f) (r).chip_config_otp[11]=(((r).chip_config_otp[11] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define CHIP_CONFIG_OTP_TAF_ENABLEf_GET(r) ((((r).chip_config_otp[11]) >> 11) & 0x1)
#define CHIP_CONFIG_OTP_TAF_ENABLEf_SET(r,f) (r).chip_config_otp[11]=(((r).chip_config_otp[11] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define CHIP_CONFIG_OTP_RSVD_364f_GET(r) ((((r).chip_config_otp[11]) >> 12) & 0xfffff)
#define CHIP_CONFIG_OTP_RSVD_364f_SET(r,f) (r).chip_config_otp[11]=(((r).chip_config_otp[11] & ~((uint32)0xfffff << 12)) | ((((uint32)f) & 0xfffff) << 12))
#define CHIP_CONFIG_OTP_L2MC_SIZEf_GET(r) (((r).chip_config_otp[12]) & 0x1)
#define CHIP_CONFIG_OTP_L2MC_SIZEf_SET(r,f) (r).chip_config_otp[12]=(((r).chip_config_otp[12] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CHIP_CONFIG_OTP_SPAN_TREE_GROUPS_SIZEf_GET(r) ((((r).chip_config_otp[12]) >> 1) & 0x1)
#define CHIP_CONFIG_OTP_SPAN_TREE_GROUPS_SIZEf_SET(r,f) (r).chip_config_otp[12]=(((r).chip_config_otp[12] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CHIP_CONFIG_OTP_VLAN_TRANSLATION_SIZEf_GET(r) ((((r).chip_config_otp[12]) >> 2) & 0x1)
#define CHIP_CONFIG_OTP_VLAN_TRANSLATION_SIZEf_SET(r,f) (r).chip_config_otp[12]=(((r).chip_config_otp[12] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CHIP_CONFIG_OTP_VFP_SLICE_DEPTHf_GET(r) ((((r).chip_config_otp[12]) >> 3) & 0x1)
#define CHIP_CONFIG_OTP_VFP_SLICE_DEPTHf_SET(r,f) (r).chip_config_otp[12]=(((r).chip_config_otp[12] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CHIP_CONFIG_OTP_L3_HOST_SIZEf_GET(r) ((((r).chip_config_otp[12]) >> 4) & 0x1)
#define CHIP_CONFIG_OTP_L3_HOST_SIZEf_SET(r,f) (r).chip_config_otp[12]=(((r).chip_config_otp[12] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CHIP_CONFIG_OTP_EFP_SLICE_DEPTHf_GET(r) ((((r).chip_config_otp[12]) >> 5) & 0x1)
#define CHIP_CONFIG_OTP_EFP_SLICE_DEPTHf_SET(r,f) (r).chip_config_otp[12]=(((r).chip_config_otp[12] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CHIP_CONFIG_OTP_SR_FLOWID_SIZEf_GET(r) ((((r).chip_config_otp[12]) >> 6) & 0x1)
#define CHIP_CONFIG_OTP_SR_FLOWID_SIZEf_SET(r,f) (r).chip_config_otp[12]=(((r).chip_config_otp[12] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CHIP_CONFIG_OTP_RSVD_391f_GET(r) ((((r).chip_config_otp[12]) >> 7) & 0x1ffffff)
#define CHIP_CONFIG_OTP_RSVD_391f_SET(r,f) (r).chip_config_otp[12]=(((r).chip_config_otp[12] & ~((uint32)0x1ffffff << 7)) | ((((uint32)f) & 0x1ffffff) << 7))
#define CHIP_CONFIG_OTP_RSVD_416f_GET(r) (((r).chip_config_otp[13]) & 0x7fffff)
#define CHIP_CONFIG_OTP_RSVD_416f_SET(r,f) (r).chip_config_otp[13]=(((r).chip_config_otp[13] & ~((uint32)0x7fffff)) | (((uint32)f) & 0x7fffff))
#define CHIP_CONFIG_OTP_RSVD_439f_GET(r) ((((r).chip_config_otp[13]) >> 23) & 0xff)
#define CHIP_CONFIG_OTP_RSVD_439f_SET(r,f) (r).chip_config_otp[13]=(((r).chip_config_otp[13] & ~((uint32)0xff << 23)) | ((((uint32)f) & 0xff) << 23))
#define CHIP_CONFIG_OTP_RSVD_447f_GET(r) ((((r).chip_config_otp[13]) >> 31) & 0x1)
#define CHIP_CONFIG_OTP_RSVD_447f_SET(r,f) (r).chip_config_otp[13]=(((r).chip_config_otp[13] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define CHIP_CONFIG_OTP_HASHf_GET(r,a) field_get((r).chip_config_otp,448,607,a)
#define CHIP_CONFIG_OTP_HASHf_SET(r,a) field_set((r).chip_config_otp,448,607,a)
#define CHIP_CONFIG_OTP_RSVD_608f_GET(r) ((r).chip_config_otp[19])
#define CHIP_CONFIG_OTP_RSVD_608f_SET(r,f) (r).chip_config_otp[19]=((uint32)f)
#define CHIP_CONFIG_OTP_RSVD_640f_GET(r) ((r).chip_config_otp[20])
#define CHIP_CONFIG_OTP_RSVD_640f_SET(r,f) (r).chip_config_otp[20]=((uint32)f)
#define CHIP_CONFIG_OTP_RSVD_672f_GET(r) (((r).chip_config_otp[21]) & 0x7fffff)
#define CHIP_CONFIG_OTP_RSVD_672f_SET(r,f) (r).chip_config_otp[21]=(((r).chip_config_otp[21] & ~((uint32)0x7fffff)) | (((uint32)f) & 0x7fffff))
#define CHIP_CONFIG_OTP_RSVD_695f_GET(r) ((((r).chip_config_otp[21]) >> 23) & 0xff)
#define CHIP_CONFIG_OTP_RSVD_695f_SET(r,f) (r).chip_config_otp[21]=(((r).chip_config_otp[21] & ~((uint32)0xff << 23)) | ((((uint32)f) & 0xff) << 23))
#define CHIP_CONFIG_OTP_RSVD_703f_GET(r) ((((r).chip_config_otp[21]) >> 31) & 0x1)
#define CHIP_CONFIG_OTP_RSVD_703f_SET(r,f) (r).chip_config_otp[21]=(((r).chip_config_otp[21] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define CHIP_CONFIG_OTP_RSVD_704f_GET(r) ((r).chip_config_otp[22])
#define CHIP_CONFIG_OTP_RSVD_704f_SET(r,f) (r).chip_config_otp[22]=((uint32)f)
#define CHIP_CONFIG_OTP_RSVD_736f_GET(r) ((r).chip_config_otp[23])
#define CHIP_CONFIG_OTP_RSVD_736f_SET(r,f) (r).chip_config_otp[23]=((uint32)f)
#define CHIP_CONFIG_OTP_RSVD_768f_GET(r) ((r).chip_config_otp[24])
#define CHIP_CONFIG_OTP_RSVD_768f_SET(r,f) (r).chip_config_otp[24]=((uint32)f)
#define CHIP_CONFIG_OTP_RSVD_800f_GET(r) ((r).chip_config_otp[25])
#define CHIP_CONFIG_OTP_RSVD_800f_SET(r,f) (r).chip_config_otp[25]=((uint32)f)
#define CHIP_CONFIG_OTP_RSVD_832f_GET(r) ((r).chip_config_otp[26])
#define CHIP_CONFIG_OTP_RSVD_832f_SET(r,f) (r).chip_config_otp[26]=((uint32)f)
#define CHIP_CONFIG_OTP_RSVD_864f_GET(r) (((r).chip_config_otp[27]) & 0x7fffffff)
#define CHIP_CONFIG_OTP_RSVD_864f_SET(r,f) (r).chip_config_otp[27]=(((r).chip_config_otp[27] & ~((uint32)0x7fffffff)) | (((uint32)f) & 0x7fffffff))
#define CHIP_CONFIG_OTP_CFG_VALIDf_GET(r) ((((r).chip_config_otp[27]) >> 31) & 0x1)
#define CHIP_CONFIG_OTP_CFG_VALIDf_SET(r,f) (r).chip_config_otp[27]=(((r).chip_config_otp[27] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define CHIP_CONFIG_OTP_PCIE_SERDES_TMf_GET(r) (((r).chip_config_otp[28]) & 0x7f)
#define CHIP_CONFIG_OTP_PCIE_SERDES_TMf_SET(r,f) (r).chip_config_otp[28]=(((r).chip_config_otp[28] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define CHIP_CONFIG_OTP_IPROC_PCIE_SP_TMf_GET(r) ((((r).chip_config_otp[28]) >> 7) & 0x7f)
#define CHIP_CONFIG_OTP_IPROC_PCIE_SP_TMf_SET(r,f) (r).chip_config_otp[28]=(((r).chip_config_otp[28] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define CHIP_CONFIG_OTP_IPROC_PCIE_SRF_TMf_GET(r) ((((r).chip_config_otp[28]) >> 14) & 0x1f)
#define CHIP_CONFIG_OTP_IPROC_PCIE_SRF_TMf_SET(r,f) (r).chip_config_otp[28]=(((r).chip_config_otp[28] & ~((uint32)0x1f << 14)) | ((((uint32)f) & 0x1f) << 14))
#define CHIP_CONFIG_OTP_IPROC_ROM0_TMf_GET(r) ((((r).chip_config_otp[28]) >> 19) & 0x7f)
#define CHIP_CONFIG_OTP_IPROC_ROM0_TMf_SET(r,f) (r).chip_config_otp[28]=(((r).chip_config_otp[28] & ~((uint32)0x7f << 19)) | ((((uint32)f) & 0x7f) << 19))
#define CHIP_CONFIG_OTP_RSVD_922f_GET(r) ((((r).chip_config_otp[28]) >> 26) & 0x3f)
#define CHIP_CONFIG_OTP_RSVD_922f_SET(r,f) (r).chip_config_otp[28]=(((r).chip_config_otp[28] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))
#define CHIP_CONFIG_OTP_RSVD_928f_GET(r) ((r).chip_config_otp[29])
#define CHIP_CONFIG_OTP_RSVD_928f_SET(r,f) (r).chip_config_otp[29]=((uint32)f)
#define CHIP_CONFIG_OTP_RSVD_960f_GET(r) ((r).chip_config_otp[30])
#define CHIP_CONFIG_OTP_RSVD_960f_SET(r,f) (r).chip_config_otp[30]=((uint32)f)
#define CHIP_CONFIG_OTP_RSVD_992f_GET(r) ((r).chip_config_otp[31])
#define CHIP_CONFIG_OTP_RSVD_992f_SET(r,f) (r).chip_config_otp[31]=((uint32)f)

/*******************************************************************************
 * End of 'CHIP_CONFIG_OTP'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CHIP_SBUS_CFG
 * BLOCKS:   PMQPORT0 PMQPORT1 PMQPORT2
 * DESC:     SBUS Configuration register for PM4x10Q SBUS.
 * SIZE:     32
 * FIELDS:
 *     SBUS_BCST_BLKID_GP0 SBUS Broadcast BLKID[6:0] for GPORT0.
 *     SBUS_CHAIN_LAST_GP0 SBUS Chain Last for GPORT0. Defaults to 1.
 *     SBUS_BCST_BLKID_GP1 SBUS Broadcast BLKID[6:0] for GPORT1.
 *     SBUS_CHAIN_LAST_GP1 SBUS Chain Last for GPORT1. Defaults to 1.
 *     SBUS_BCST_BLKID_PMQREGS SBUS Broadcast BLKID[6:0] for PMQ top level register set.
 *     SBUS_CHAIN_LAST_PMQREGS SBUS Chain Last for PMQ register set. Defaults to 1.
 *     SBUS_BCST_BLKID_PM SBUS Broadcast BLKID[6:0] for PM4x10 port register set. This value should match the programmed value in the PM4x10 core.
 *     SBUS_CHAIN_LAST  This is configured within the pm4x10_core register set. SBUS Chain Last for PM4x10 port macro. Defaults to 0. This value should match the programmed value in the PM4x10 core.
 */
#define CHIP_SBUS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_SBUS_CFG.
 */
typedef union CHIP_SBUS_CFGr_s {
	uint32 v[1];
	uint32 chip_sbus_cfg[1];
	uint32 _chip_sbus_cfg;
} CHIP_SBUS_CFGr_t;

#define CHIP_SBUS_CFGr_CLR(r) (r).chip_sbus_cfg[0] = 0
#define CHIP_SBUS_CFGr_SET(r,d) (r).chip_sbus_cfg[0] = d
#define CHIP_SBUS_CFGr_GET(r) (r).chip_sbus_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_GP0f_GET(r) (((r).chip_sbus_cfg[0]) & 0x7f)
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_GP0f_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LAST_GP0f_GET(r) ((((r).chip_sbus_cfg[0]) >> 7) & 0x1)
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LAST_GP0f_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_GP1f_GET(r) ((((r).chip_sbus_cfg[0]) >> 8) & 0x7f)
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_GP1f_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x7f << 8)) | ((((uint32)f) & 0x7f) << 8))
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LAST_GP1f_GET(r) ((((r).chip_sbus_cfg[0]) >> 15) & 0x1)
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LAST_GP1f_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_PMQREGSf_GET(r) ((((r).chip_sbus_cfg[0]) >> 16) & 0x7f)
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_PMQREGSf_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x7f << 16)) | ((((uint32)f) & 0x7f) << 16))
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LAST_PMQREGSf_GET(r) ((((r).chip_sbus_cfg[0]) >> 23) & 0x1)
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LAST_PMQREGSf_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_PMf_GET(r) ((((r).chip_sbus_cfg[0]) >> 24) & 0x7f)
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_PMf_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x7f << 24)) | ((((uint32)f) & 0x7f) << 24))
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LASTf_GET(r) ((((r).chip_sbus_cfg[0]) >> 31) & 0x1)
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LASTf_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access CHIP_SBUS_CFG.
 */
#define WRITE_CHIP_SBUS_CFGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_pmqport_lport_to_blockid[p], R_CHIP_SBUS_CFG, (r._chip_sbus_cfg))
#define READ_CHIP_SBUS_CFGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_pmqport_lport_to_blockid[p], R_CHIP_SBUS_CFG, &(r._chip_sbus_cfg))

/*******************************************************************************
 * End of 'CHIP_SBUS_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CHIP_SWRST
 * BLOCKS:   PMQPORT0 PMQPORT1 PMQPORT2
 * DESC:     Soft Reset register for PM4x10Q Top
 * SIZE:     32
 * FIELDS:
 *     SOFT_RESET_GPORT0 Soft Reset for submodules. 0= normal, 1 = reset.
 *     SOFT_RESET_GPORT1 Soft Reset for submodules. 0= normal, 1 = reset.
 *     SOFT_RESET_QSGMII_PCS Soft Reset for submodules. 0= normal, 1 = reset.
 *     FLUSH            NOT USED in Gen 2.
 *     ILKN_BYPASS_RSTN NOT USED in Gen2.
 */
#define CHIP_SWRSTr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_SWRST.
 */
typedef union CHIP_SWRSTr_s {
	uint32 v[1];
	uint32 chip_swrst[1];
	uint32 _chip_swrst;
} CHIP_SWRSTr_t;

#define CHIP_SWRSTr_CLR(r) (r).chip_swrst[0] = 0
#define CHIP_SWRSTr_SET(r,d) (r).chip_swrst[0] = d
#define CHIP_SWRSTr_GET(r) (r).chip_swrst[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIP_SWRSTr_SOFT_RESET_GPORT0f_GET(r) (((r).chip_swrst[0]) & 0x1)
#define CHIP_SWRSTr_SOFT_RESET_GPORT0f_SET(r,f) (r).chip_swrst[0]=(((r).chip_swrst[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CHIP_SWRSTr_SOFT_RESET_GPORT1f_GET(r) ((((r).chip_swrst[0]) >> 1) & 0x1)
#define CHIP_SWRSTr_SOFT_RESET_GPORT1f_SET(r,f) (r).chip_swrst[0]=(((r).chip_swrst[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CHIP_SWRSTr_SOFT_RESET_QSGMII_PCSf_GET(r) ((((r).chip_swrst[0]) >> 2) & 0x1)
#define CHIP_SWRSTr_SOFT_RESET_QSGMII_PCSf_SET(r,f) (r).chip_swrst[0]=(((r).chip_swrst[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CHIP_SWRSTr_FLUSHf_GET(r) ((((r).chip_swrst[0]) >> 3) & 0x1)
#define CHIP_SWRSTr_FLUSHf_SET(r,f) (r).chip_swrst[0]=(((r).chip_swrst[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CHIP_SWRSTr_ILKN_BYPASS_RSTNf_GET(r) ((((r).chip_swrst[0]) >> 4) & 0xf)
#define CHIP_SWRSTr_ILKN_BYPASS_RSTNf_SET(r,f) (r).chip_swrst[0]=(((r).chip_swrst[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))

/*
 * These macros can be used to access CHIP_SWRST.
 */
#define WRITE_CHIP_SWRSTr(u,p,r) bcm5607x_reg_set(u, bcm5607x_pmqport_lport_to_blockid[p], R_CHIP_SWRST, (r._chip_swrst))
#define READ_CHIP_SWRSTr(u,p,r) bcm5607x_reg_get(u, bcm5607x_pmqport_lport_to_blockid[p], R_CHIP_SWRST, &(r._chip_swrst))

/*******************************************************************************
 * End of 'CHIP_SWRSTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CHIP_UMACSPEED
 * BLOCKS:   PMQPORT0 PMQPORT1 PMQPORT2
 * DESC:     Status register for UMAC SPEED
 * SIZE:     32
 * FIELDS:
 *     UMAC_SPEED_00    Link speed status for lane 0; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_01    Link speed status for lane 1; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_02    Link speed status for lane 2; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_03    Link speed status for lane 3; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_04    Link speed status for lane 4; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_05    Link speed status for lane 5; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_06    Link speed status for lane 6; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_07    Link speed status for lane 7; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_08    Link speed status for lane 8; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_09    Link speed status for lane 8; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_10    Link speed status for lane 10; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_11    Link speed status for lane 11; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_12    Link speed status for lane 12; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_13    Link speed status for lane 13; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_14    Link speed status for lane 14; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5GM
 *     UMAC_SPEED_15    Link speed status for lane 15; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 2.5G
 */
#define CHIP_UMACSPEEDr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_UMACSPEED.
 */
typedef union CHIP_UMACSPEEDr_s {
	uint32 v[1];
	uint32 chip_umacspeed[1];
	uint32 _chip_umacspeed;
} CHIP_UMACSPEEDr_t;

#define CHIP_UMACSPEEDr_CLR(r) (r).chip_umacspeed[0] = 0
#define CHIP_UMACSPEEDr_SET(r,d) (r).chip_umacspeed[0] = d
#define CHIP_UMACSPEEDr_GET(r) (r).chip_umacspeed[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIP_UMACSPEEDr_UMAC_SPEED_00f_GET(r) (((r).chip_umacspeed[0]) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_00f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define CHIP_UMACSPEEDr_UMAC_SPEED_01f_GET(r) ((((r).chip_umacspeed[0]) >> 2) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_01f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define CHIP_UMACSPEEDr_UMAC_SPEED_02f_GET(r) ((((r).chip_umacspeed[0]) >> 4) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_02f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define CHIP_UMACSPEEDr_UMAC_SPEED_03f_GET(r) ((((r).chip_umacspeed[0]) >> 6) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_03f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define CHIP_UMACSPEEDr_UMAC_SPEED_04f_GET(r) ((((r).chip_umacspeed[0]) >> 8) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_04f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define CHIP_UMACSPEEDr_UMAC_SPEED_05f_GET(r) ((((r).chip_umacspeed[0]) >> 10) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_05f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define CHIP_UMACSPEEDr_UMAC_SPEED_06f_GET(r) ((((r).chip_umacspeed[0]) >> 12) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_06f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define CHIP_UMACSPEEDr_UMAC_SPEED_07f_GET(r) ((((r).chip_umacspeed[0]) >> 14) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_07f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define CHIP_UMACSPEEDr_UMAC_SPEED_08f_GET(r) ((((r).chip_umacspeed[0]) >> 16) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_08f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define CHIP_UMACSPEEDr_UMAC_SPEED_09f_GET(r) ((((r).chip_umacspeed[0]) >> 18) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_09f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define CHIP_UMACSPEEDr_UMAC_SPEED_10f_GET(r) ((((r).chip_umacspeed[0]) >> 20) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_10f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define CHIP_UMACSPEEDr_UMAC_SPEED_11f_GET(r) ((((r).chip_umacspeed[0]) >> 22) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_11f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define CHIP_UMACSPEEDr_UMAC_SPEED_12f_GET(r) ((((r).chip_umacspeed[0]) >> 24) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_12f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define CHIP_UMACSPEEDr_UMAC_SPEED_13f_GET(r) ((((r).chip_umacspeed[0]) >> 26) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_13f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define CHIP_UMACSPEEDr_UMAC_SPEED_14f_GET(r) ((((r).chip_umacspeed[0]) >> 28) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_14f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define CHIP_UMACSPEEDr_UMAC_SPEED_15f_GET(r) ((((r).chip_umacspeed[0]) >> 30) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_15f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))

/*
 * These macros can be used to access CHIP_UMACSPEED.
 */
#define WRITE_CHIP_UMACSPEEDr(u,p,r) bcm5607x_reg_set(u, bcm5607x_pmqport_lport_to_blockid[p], R_CHIP_UMACSPEED, (r._chip_umacspeed))
#define READ_CHIP_UMACSPEEDr(u,p,r) bcm5607x_reg_get(u, bcm5607x_pmqport_lport_to_blockid[p], R_CHIP_UMACSPEED, &(r._chip_umacspeed))

/*******************************************************************************
 * End of 'CHIP_UMACSPEEDr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_CTRL
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     MAC control.
 * SIZE:     64
 * FIELDS:
 *     TX_EN            If set, enables MAC transmit datapath and flowcontrol logic. When disabled, MAC will respond to TSC credits with IDLE codewords.
 *     RX_EN            If set, enables MAC receive datapath and flowcontrol logic.
 *     LOCAL_LPBK       If set, enables local loopback from TX to RX. This loopback is on the line side after clock domain crossing - from the last TX pipeline stage to the first RX pipeline stage. Hence, TSC clock and TSC credits must be active for loopback. LAG_FAILOVER_EN should be disabled for this bit to work. 
 *     RSVD_1            Reserved
 *     REMOVE_FAILOVER_LPBK If set, CLMAC will move from lag failover state to normal operation. This bit should be set after link is up.
 *     LAG_FAILOVER_EN  If set, enable LAG Failover. This bit has priority over LOCAL_LPBK. The lag failover kicks in when the link status selected by LINK_STATUS_SELECT transitions from 1 to 0. TSC clock and TSC credits must be active for lag failover. 
 *     SOFT_RESET       If set, disables the corresponding port logic and status registers only. Packet data and flow control logic is disabled. Fault handling is active and the MAC will continue to respond to credits from TSC. When the soft reset is cleared MAC will issue a fresh set of credits to EP in transmit side.
 *     RSVD_4           Reserved
 *     LOCAL_LPBK_LEAK_ENB If set, during the local loopback mode, the transmit packets are also sent to the transmit line interface, apart from the loopback operation
 *     RSVD_5           Reserved
 *     RS_SOFT_RESET    Resets the RS layer functionality - Fault detection and related responses are disabled and IDLEs are sent on line 
 *     XGMII_IPG_CHECK_DISABLE If set, this will override the one column idle/sequence ordered set check before SOP in XGMII mode - effectively supporting  reception of packets with 1 byte IPG in XGMII mode
 *     SW_LINK_STATUS   Link status indication from Software. If set, indicates that link is active.
 *     LINK_STATUS_SELECT This configuration chooses between link status indication from software (SW_LINK_STATUS) or the hardware link status (hw_link_status)indication from the TSC. If reset, it selects the software link status
 *     ALLOW_40B_AND_GREATER_PKTS In Rx, if this bit is set, this allow 40Bytes and greater length packets to go through in CLMAC. If not set, 49Bytes and greater length packets will got through in CLMAC.                               In Tx, if this bit is reset, only packets that are >= 49 bytes are accepted from the EP. If this bit is set, packets that are >= 36 bytes are accepted from the EP. This is irrespective of CRCMODE and/or padding mode
 *     EXTENDED_HIG2_EN Extended Higig 2 header is also known as sirius header. Setting this bit to 0 will disable parsing for the extended header bit(5th bit of 8th header byte) in HG2 header and hence all the Higig 2 packets will be treated as normal Higig2 packets irrespective of extended header bit value. Default value of this field is 1 which will enable parsing extended header bit in every Higig 2 header.
 */
#define CLMAC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_CTRL.
 */
typedef union CLMAC_CTRLr_s {
	uint32 v[2];
	uint32 clmac_ctrl[2];
	uint32 _clmac_ctrl;
} CLMAC_CTRLr_t;

#define CLMAC_CTRLr_CLR(r) sal_memset(&((r)._clmac_ctrl), 0, sizeof(CLMAC_CTRLr_t))
#define CLMAC_CTRLr_SET(r,i,d) (r).clmac_ctrl[i] = d
#define CLMAC_CTRLr_GET(r,i) (r).clmac_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_CTRLr_TX_ENf_GET(r) (((r).clmac_ctrl[0]) & 0x1)
#define CLMAC_CTRLr_TX_ENf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLMAC_CTRLr_RX_ENf_GET(r) ((((r).clmac_ctrl[0]) >> 1) & 0x1)
#define CLMAC_CTRLr_RX_ENf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CLMAC_CTRLr_LOCAL_LPBKf_GET(r) ((((r).clmac_ctrl[0]) >> 2) & 0x1)
#define CLMAC_CTRLr_LOCAL_LPBKf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CLMAC_CTRLr_RSVD_1f_GET(r) ((((r).clmac_ctrl[0]) >> 3) & 0x1)
#define CLMAC_CTRLr_RSVD_1f_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CLMAC_CTRLr_REMOVE_FAILOVER_LPBKf_GET(r) ((((r).clmac_ctrl[0]) >> 4) & 0x1)
#define CLMAC_CTRLr_REMOVE_FAILOVER_LPBKf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CLMAC_CTRLr_LAG_FAILOVER_ENf_GET(r) ((((r).clmac_ctrl[0]) >> 5) & 0x1)
#define CLMAC_CTRLr_LAG_FAILOVER_ENf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CLMAC_CTRLr_SOFT_RESETf_GET(r) ((((r).clmac_ctrl[0]) >> 6) & 0x1)
#define CLMAC_CTRLr_SOFT_RESETf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CLMAC_CTRLr_RSVD_4f_GET(r) ((((r).clmac_ctrl[0]) >> 7) & 0x1)
#define CLMAC_CTRLr_RSVD_4f_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CLMAC_CTRLr_LOCAL_LPBK_LEAK_ENBf_GET(r) ((((r).clmac_ctrl[0]) >> 8) & 0x1)
#define CLMAC_CTRLr_LOCAL_LPBK_LEAK_ENBf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CLMAC_CTRLr_RSVD_5f_GET(r) ((((r).clmac_ctrl[0]) >> 9) & 0x1)
#define CLMAC_CTRLr_RSVD_5f_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CLMAC_CTRLr_RS_SOFT_RESETf_GET(r) ((((r).clmac_ctrl[0]) >> 10) & 0x1)
#define CLMAC_CTRLr_RS_SOFT_RESETf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define CLMAC_CTRLr_XGMII_IPG_CHECK_DISABLEf_GET(r) ((((r).clmac_ctrl[0]) >> 11) & 0x1)
#define CLMAC_CTRLr_XGMII_IPG_CHECK_DISABLEf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define CLMAC_CTRLr_SW_LINK_STATUSf_GET(r) ((((r).clmac_ctrl[0]) >> 12) & 0x1)
#define CLMAC_CTRLr_SW_LINK_STATUSf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define CLMAC_CTRLr_LINK_STATUS_SELECTf_GET(r) ((((r).clmac_ctrl[0]) >> 13) & 0x1)
#define CLMAC_CTRLr_LINK_STATUS_SELECTf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define CLMAC_CTRLr_ALLOW_40B_AND_GREATER_PKTSf_GET(r) ((((r).clmac_ctrl[0]) >> 14) & 0x1)
#define CLMAC_CTRLr_ALLOW_40B_AND_GREATER_PKTSf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define CLMAC_CTRLr_EXTENDED_HIG2_ENf_GET(r) ((((r).clmac_ctrl[0]) >> 15) & 0x1)
#define CLMAC_CTRLr_EXTENDED_HIG2_ENf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))

/*
 * These macros can be used to access CLMAC_CTRL.
 */
#define WRITE_CLMAC_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_ctrl),2)
#define READ_CLMAC_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_ctrl),2)

/*******************************************************************************
 * End of 'CLMAC_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_EEE_CTRL
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Register for EEE Control 
 * SIZE:     64
 * FIELDS:
 *     EEE_EN           When set, enables EEE state machine in the transmit direction and LPI detection/prediction in the receive direction 
 *     RSVD             Reserved
 */
#define CLMAC_EEE_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_EEE_CTRL.
 */
typedef union CLMAC_EEE_CTRLr_s {
	uint32 v[2];
	uint32 clmac_eee_ctrl[2];
	uint32 _clmac_eee_ctrl;
} CLMAC_EEE_CTRLr_t;

#define CLMAC_EEE_CTRLr_CLR(r) sal_memset(&((r)._clmac_eee_ctrl), 0, sizeof(CLMAC_EEE_CTRLr_t))
#define CLMAC_EEE_CTRLr_SET(r,i,d) (r).clmac_eee_ctrl[i] = d
#define CLMAC_EEE_CTRLr_GET(r,i) (r).clmac_eee_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_EEE_CTRLr_EEE_ENf_GET(r) (((r).clmac_eee_ctrl[0]) & 0x1)
#define CLMAC_EEE_CTRLr_EEE_ENf_SET(r,f) (r).clmac_eee_ctrl[0]=(((r).clmac_eee_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLMAC_EEE_CTRLr_RSVDf_GET(r) ((((r).clmac_eee_ctrl[0]) >> 1) & 0x1)
#define CLMAC_EEE_CTRLr_RSVDf_SET(r,f) (r).clmac_eee_ctrl[0]=(((r).clmac_eee_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access CLMAC_EEE_CTRL.
 */
#define WRITE_CLMAC_EEE_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_EEE_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_eee_ctrl),2)
#define READ_CLMAC_EEE_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_EEE_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_eee_ctrl),2)

/*******************************************************************************
 * End of 'CLMAC_EEE_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_EEE_TIMERS
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     EEE Timers
 * SIZE:     64
 * FIELDS:
 *     CLMAC_EEE_TIMERS_LO 32 lower bits of the EEE Timer
 *     EEE_DELAY_ENTRY_TIMER This is the duration for which the MAC must wait in EMPTY state before transitioning to LPI state. Unit is micro seconds 
 *     CLMAC_EEE_TIMERS_HI 32 upper bits of the EEE timer register  
 *     EEE_WAKE_TIMER   This is the duration for which MAC must wait to go back to ACTIVE state from LPI state when it receives packet/flow-control frames for transmission. Unit is micro seconds 
 *     EEE_REF_COUNT    This field controls clock divider used to generate ~1us reference pulses used by EEE timers. It specifies integer number of clock cycles for 1us reference using tsc_clk
 */
#define CLMAC_EEE_TIMERSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_EEE_TIMERS.
 */
typedef union CLMAC_EEE_TIMERSr_s {
	uint32 v[2];
	uint32 clmac_eee_timers[2];
	uint32 _clmac_eee_timers;
} CLMAC_EEE_TIMERSr_t;

#define CLMAC_EEE_TIMERSr_CLR(r) sal_memset(&((r)._clmac_eee_timers), 0, sizeof(CLMAC_EEE_TIMERSr_t))
#define CLMAC_EEE_TIMERSr_SET(r,i,d) (r).clmac_eee_timers[i] = d
#define CLMAC_EEE_TIMERSr_GET(r,i) (r).clmac_eee_timers[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_EEE_TIMERSr_CLMAC_EEE_TIMERS_LOf_GET(r) ((r).clmac_eee_timers[0])
#define CLMAC_EEE_TIMERSr_CLMAC_EEE_TIMERS_LOf_SET(r,f) (r).clmac_eee_timers[0]=((uint32)f)
#define CLMAC_EEE_TIMERSr_EEE_DELAY_ENTRY_TIMERf_GET(r) ((r).clmac_eee_timers[0])
#define CLMAC_EEE_TIMERSr_EEE_DELAY_ENTRY_TIMERf_SET(r,f) (r).clmac_eee_timers[0]=((uint32)f)
#define CLMAC_EEE_TIMERSr_CLMAC_EEE_TIMERS_HIf_GET(r) ((r).clmac_eee_timers[1])
#define CLMAC_EEE_TIMERSr_CLMAC_EEE_TIMERS_HIf_SET(r,f) (r).clmac_eee_timers[1]=((uint32)f)
#define CLMAC_EEE_TIMERSr_EEE_WAKE_TIMERf_GET(r) (((r).clmac_eee_timers[1]) & 0xffff)
#define CLMAC_EEE_TIMERSr_EEE_WAKE_TIMERf_SET(r,f) (r).clmac_eee_timers[1]=(((r).clmac_eee_timers[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CLMAC_EEE_TIMERSr_EEE_REF_COUNTf_GET(r) ((((r).clmac_eee_timers[1]) >> 16) & 0xffff)
#define CLMAC_EEE_TIMERSr_EEE_REF_COUNTf_SET(r,f) (r).clmac_eee_timers[1]=(((r).clmac_eee_timers[1] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access CLMAC_EEE_TIMERS.
 */
#define WRITE_CLMAC_EEE_TIMERSr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_EEE_TIMERS(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_eee_timers),2)
#define READ_CLMAC_EEE_TIMERSr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_EEE_TIMERS(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_eee_timers),2)

/*******************************************************************************
 * End of 'CLMAC_EEE_TIMERSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_LLFC_CTRL
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     LLFC Control Register
 * SIZE:     64
 * FIELDS:
 *     TX_LLFC_EN       When set, enables the generation and transmission of LLFC frames in the transmit direction
 *     RX_LLFC_EN       When set, enables processing of LLFC frames in the receive direction and generation of COSMAPs to MMU
 *     LLFC_IN_IPG_ONLY When set, all LLFC messages are transmitted during IPGWhen reset, the mode of insertion of LLFC messages is controlled by LLFC_CUT_THROUGH_MODE
 *     LLFC_CUT_THROUGH_MODE When LLFC_IN_IPG_ONLY is reset, the mode of transmission of LLFC messages is controlled by this bit depending upon whether the LLFC message is XON or XOFFWhen LLFC_CUT_THROUGH_MODE is reset, all LLFC messages are transmitted pre-emptively (within a packet)When LLFC_CUT_THROUGH_MODE is set, only XOFF LLFC messages are transmitted pre-emptively, XON LLFC messages are transmitted during IPG
 *     LLFC_CRC_IGNORE  When set, disables the CRC check for LLFC messages in the receive direction
 *     NO_SOM_FOR_CRC_LLFC When set, LLFC CRC computation does not include the SOM character
 *     LLFC_IMG         This field indicates the minimum Inter Message Gap that is enforced by the MAC between 2 LLFC messages in the transmit direction (unit is 1 credit)
 */
#define CLMAC_LLFC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_LLFC_CTRL.
 */
typedef union CLMAC_LLFC_CTRLr_s {
	uint32 v[2];
	uint32 clmac_llfc_ctrl[2];
	uint32 _clmac_llfc_ctrl;
} CLMAC_LLFC_CTRLr_t;

#define CLMAC_LLFC_CTRLr_CLR(r) sal_memset(&((r)._clmac_llfc_ctrl), 0, sizeof(CLMAC_LLFC_CTRLr_t))
#define CLMAC_LLFC_CTRLr_SET(r,i,d) (r).clmac_llfc_ctrl[i] = d
#define CLMAC_LLFC_CTRLr_GET(r,i) (r).clmac_llfc_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_LLFC_CTRLr_TX_LLFC_ENf_GET(r) (((r).clmac_llfc_ctrl[0]) & 0x1)
#define CLMAC_LLFC_CTRLr_TX_LLFC_ENf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLMAC_LLFC_CTRLr_RX_LLFC_ENf_GET(r) ((((r).clmac_llfc_ctrl[0]) >> 1) & 0x1)
#define CLMAC_LLFC_CTRLr_RX_LLFC_ENf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CLMAC_LLFC_CTRLr_LLFC_IN_IPG_ONLYf_GET(r) ((((r).clmac_llfc_ctrl[0]) >> 2) & 0x1)
#define CLMAC_LLFC_CTRLr_LLFC_IN_IPG_ONLYf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CLMAC_LLFC_CTRLr_LLFC_CUT_THROUGH_MODEf_GET(r) ((((r).clmac_llfc_ctrl[0]) >> 3) & 0x1)
#define CLMAC_LLFC_CTRLr_LLFC_CUT_THROUGH_MODEf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CLMAC_LLFC_CTRLr_LLFC_CRC_IGNOREf_GET(r) ((((r).clmac_llfc_ctrl[0]) >> 4) & 0x1)
#define CLMAC_LLFC_CTRLr_LLFC_CRC_IGNOREf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CLMAC_LLFC_CTRLr_NO_SOM_FOR_CRC_LLFCf_GET(r) ((((r).clmac_llfc_ctrl[0]) >> 5) & 0x1)
#define CLMAC_LLFC_CTRLr_NO_SOM_FOR_CRC_LLFCf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CLMAC_LLFC_CTRLr_LLFC_IMGf_GET(r) ((((r).clmac_llfc_ctrl[0]) >> 6) & 0xff)
#define CLMAC_LLFC_CTRLr_LLFC_IMGf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))

/*
 * These macros can be used to access CLMAC_LLFC_CTRL.
 */
#define WRITE_CLMAC_LLFC_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_LLFC_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_llfc_ctrl),2)
#define READ_CLMAC_LLFC_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_LLFC_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_llfc_ctrl),2)

/*******************************************************************************
 * End of 'CLMAC_LLFC_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_MODE
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     CLMAC Mode register
 * SIZE:     64
 * FIELDS:
 *     HDR_MODE         Packet Header mode.
 *     NO_SOP_FOR_CRC_HG If set, excludes the SOP byte for CRC calculation in HIGIG modes
 *     SPEED_MODE       Port Speed, used for LED indications and internal buffer sizing.
 */
#define CLMAC_MODEr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_MODE.
 */
typedef union CLMAC_MODEr_s {
	uint32 v[2];
	uint32 clmac_mode[2];
	uint32 _clmac_mode;
} CLMAC_MODEr_t;

#define CLMAC_MODEr_CLR(r) sal_memset(&((r)._clmac_mode), 0, sizeof(CLMAC_MODEr_t))
#define CLMAC_MODEr_SET(r,i,d) (r).clmac_mode[i] = d
#define CLMAC_MODEr_GET(r,i) (r).clmac_mode[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_MODEr_HDR_MODEf_GET(r) (((r).clmac_mode[0]) & 0x7)
#define CLMAC_MODEr_HDR_MODEf_SET(r,f) (r).clmac_mode[0]=(((r).clmac_mode[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define CLMAC_MODEr_NO_SOP_FOR_CRC_HGf_GET(r) ((((r).clmac_mode[0]) >> 3) & 0x1)
#define CLMAC_MODEr_NO_SOP_FOR_CRC_HGf_SET(r,f) (r).clmac_mode[0]=(((r).clmac_mode[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CLMAC_MODEr_SPEED_MODEf_GET(r) ((((r).clmac_mode[0]) >> 4) & 0x7)
#define CLMAC_MODEr_SPEED_MODEf_SET(r,f) (r).clmac_mode[0]=(((r).clmac_mode[0] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))

/*
 * These macros can be used to access CLMAC_MODE.
 */
#define WRITE_CLMAC_MODEr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_MODE(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_mode),2)
#define READ_CLMAC_MODEr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_MODE(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_mode),2)

/*******************************************************************************
 * End of 'CLMAC_MODEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_PAUSE_CTRL
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     PAUSE control register
 * SIZE:     64
 * FIELDS:
 *     CLMAC_PAUSE_CTRL_LO 32 lower bits of the CLMAC Pause CTRL register
 *     PAUSE_REFRESH_TIMER This field specifies the interval at which pause frames are re-generated during XOFF state, provided PAUSE_REFRESH_EN is set (unit is 512 bit-times)
 *     PAUSE_REFRESH_EN When set, enables the periodic re-generation of XOFF pause frames based on the interval specified in PAUSE_REFRESH_TIMER
 *     TX_PAUSE_EN      When set, enables the transmission of pause frames whenever there is a transition on txbkp input to MAC from MMU
 *     RX_PAUSE_EN      When set, enables detection of pause frames in the receive direction and pause/resume the transmit data path
 *     RSVD_1           Reserved
 *     RSVD_2           Reserved
 *     PAUSE_XOFF_TIMER Pause time value sent in the timer field for XOFF state (unit is 512 bit-times)
 *     CLMAC_PAUSE_CTRL_HI 5 upper bits of the CLMAC Pause CTRL register
 */
#define CLMAC_PAUSE_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_PAUSE_CTRL.
 */
typedef union CLMAC_PAUSE_CTRLr_s {
	uint32 v[2];
	uint32 clmac_pause_ctrl[2];
	uint32 _clmac_pause_ctrl;
} CLMAC_PAUSE_CTRLr_t;

#define CLMAC_PAUSE_CTRLr_CLR(r) sal_memset(&((r)._clmac_pause_ctrl), 0, sizeof(CLMAC_PAUSE_CTRLr_t))
#define CLMAC_PAUSE_CTRLr_SET(r,i,d) (r).clmac_pause_ctrl[i] = d
#define CLMAC_PAUSE_CTRLr_GET(r,i) (r).clmac_pause_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_PAUSE_CTRLr_CLMAC_PAUSE_CTRL_LOf_GET(r) ((r).clmac_pause_ctrl[0])
#define CLMAC_PAUSE_CTRLr_CLMAC_PAUSE_CTRL_LOf_SET(r,f) (r).clmac_pause_ctrl[0]=((uint32)f)
#define CLMAC_PAUSE_CTRLr_PAUSE_REFRESH_TIMERf_GET(r) (((r).clmac_pause_ctrl[0]) & 0xffff)
#define CLMAC_PAUSE_CTRLr_PAUSE_REFRESH_TIMERf_SET(r,f) (r).clmac_pause_ctrl[0]=(((r).clmac_pause_ctrl[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CLMAC_PAUSE_CTRLr_PAUSE_REFRESH_ENf_GET(r) ((((r).clmac_pause_ctrl[0]) >> 16) & 0x1)
#define CLMAC_PAUSE_CTRLr_PAUSE_REFRESH_ENf_SET(r,f) (r).clmac_pause_ctrl[0]=(((r).clmac_pause_ctrl[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define CLMAC_PAUSE_CTRLr_TX_PAUSE_ENf_GET(r) ((((r).clmac_pause_ctrl[0]) >> 17) & 0x1)
#define CLMAC_PAUSE_CTRLr_TX_PAUSE_ENf_SET(r,f) (r).clmac_pause_ctrl[0]=(((r).clmac_pause_ctrl[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define CLMAC_PAUSE_CTRLr_RX_PAUSE_ENf_GET(r) ((((r).clmac_pause_ctrl[0]) >> 18) & 0x1)
#define CLMAC_PAUSE_CTRLr_RX_PAUSE_ENf_SET(r,f) (r).clmac_pause_ctrl[0]=(((r).clmac_pause_ctrl[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define CLMAC_PAUSE_CTRLr_RSVD_1f_GET(r) ((((r).clmac_pause_ctrl[0]) >> 19) & 0x1)
#define CLMAC_PAUSE_CTRLr_RSVD_1f_SET(r,f) (r).clmac_pause_ctrl[0]=(((r).clmac_pause_ctrl[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define CLMAC_PAUSE_CTRLr_RSVD_2f_GET(r) ((((r).clmac_pause_ctrl[0]) >> 20) & 0x1)
#define CLMAC_PAUSE_CTRLr_RSVD_2f_SET(r,f) (r).clmac_pause_ctrl[0]=(((r).clmac_pause_ctrl[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define CLMAC_PAUSE_CTRLr_PAUSE_XOFF_TIMERf_GET(r) field32_get((r).clmac_pause_ctrl,21,36)
#define CLMAC_PAUSE_CTRLr_PAUSE_XOFF_TIMERf_SET(r,f) field32_set((r).clmac_pause_ctrl,21,36,f)
#define CLMAC_PAUSE_CTRLr_CLMAC_PAUSE_CTRL_HIf_GET(r) (((r).clmac_pause_ctrl[1]) & 0x1f)
#define CLMAC_PAUSE_CTRLr_CLMAC_PAUSE_CTRL_HIf_SET(r,f) (r).clmac_pause_ctrl[1]=(((r).clmac_pause_ctrl[1] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))

/*
 * These macros can be used to access CLMAC_PAUSE_CTRL.
 */
#define WRITE_CLMAC_PAUSE_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_PAUSE_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_pause_ctrl),2)
#define READ_CLMAC_PAUSE_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_PAUSE_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_pause_ctrl),2)

/*******************************************************************************
 * End of 'CLMAC_PAUSE_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_PFC_CTRL
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     PFC control register
 * SIZE:     64
 * FIELDS:
 *     LLFC_REFRESH_TIMER This field specifies the interval at which LLFC frames are re-generated for a class of service in XOFF state, provided LLFC_REFRESH_EN is set (unit is 512 bit-times)
 *     PFC_REFRESH_TIMER This field specifies the interval at which PFC frames are re-generated for a class of service in XOFF state, provided PFC_REFRESH_EN is set (unit is 512 bit-times)
 *     PFC_XOFF_TIMER   Pause time value sent in the timer field for classes in XOFF state (unit is 512 bit-times)
 *     LLFC_REFRESH_EN  When set, enables the periodic re-generation of LLFC frames based on the interval specified in LLFC_REFRESH_TIMER
 *     PFC_REFRESH_EN   When set, enables the periodic re-generation of PFC frames based on the interval specified in PFC_REFRESH_TIMER
 *     FORCE_PFC_XON    When set, forces the MAC to generate an XON indication to the MMU for all classes of service in the receive direction
 *     RSVD             Reserved
 *     PFC_STATS_EN     When set, enables the generation of receive and transmit PFC events into the corresponding statistics vectors (RSV and TSV)
 *     RX_PFC_EN        When set, enables detection of PFC frames in the receive direction and generation of COSMAPs to MMU based on incoming timer values
 *     TX_PFC_EN        When set, enables the transmission of PFC frames
 */
#define CLMAC_PFC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_PFC_CTRL.
 */
typedef union CLMAC_PFC_CTRLr_s {
	uint32 v[2];
	uint32 clmac_pfc_ctrl[2];
	uint32 _clmac_pfc_ctrl;
} CLMAC_PFC_CTRLr_t;

#define CLMAC_PFC_CTRLr_CLR(r) sal_memset(&((r)._clmac_pfc_ctrl), 0, sizeof(CLMAC_PFC_CTRLr_t))
#define CLMAC_PFC_CTRLr_SET(r,i,d) (r).clmac_pfc_ctrl[i] = d
#define CLMAC_PFC_CTRLr_GET(r,i) (r).clmac_pfc_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_PFC_CTRLr_LLFC_REFRESH_TIMERf_GET(r) (((r).clmac_pfc_ctrl[0]) & 0xffff)
#define CLMAC_PFC_CTRLr_LLFC_REFRESH_TIMERf_SET(r,f) (r).clmac_pfc_ctrl[0]=(((r).clmac_pfc_ctrl[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CLMAC_PFC_CTRLr_PFC_REFRESH_TIMERf_GET(r) (((r).clmac_pfc_ctrl[0]) & 0xffff)
#define CLMAC_PFC_CTRLr_PFC_REFRESH_TIMERf_SET(r,f) (r).clmac_pfc_ctrl[0]=(((r).clmac_pfc_ctrl[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CLMAC_PFC_CTRLr_PFC_XOFF_TIMERf_GET(r) ((((r).clmac_pfc_ctrl[0]) >> 16) & 0xffff)
#define CLMAC_PFC_CTRLr_PFC_XOFF_TIMERf_SET(r,f) (r).clmac_pfc_ctrl[0]=(((r).clmac_pfc_ctrl[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))
#define CLMAC_PFC_CTRLr_LLFC_REFRESH_ENf_GET(r) (((r).clmac_pfc_ctrl[1]) & 0x1)
#define CLMAC_PFC_CTRLr_LLFC_REFRESH_ENf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLMAC_PFC_CTRLr_PFC_REFRESH_ENf_GET(r) (((r).clmac_pfc_ctrl[1]) & 0x1)
#define CLMAC_PFC_CTRLr_PFC_REFRESH_ENf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLMAC_PFC_CTRLr_FORCE_PFC_XONf_GET(r) ((((r).clmac_pfc_ctrl[1]) >> 1) & 0x1)
#define CLMAC_PFC_CTRLr_FORCE_PFC_XONf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CLMAC_PFC_CTRLr_RSVDf_GET(r) ((((r).clmac_pfc_ctrl[1]) >> 2) & 0x1)
#define CLMAC_PFC_CTRLr_RSVDf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CLMAC_PFC_CTRLr_PFC_STATS_ENf_GET(r) ((((r).clmac_pfc_ctrl[1]) >> 3) & 0x1)
#define CLMAC_PFC_CTRLr_PFC_STATS_ENf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CLMAC_PFC_CTRLr_RX_PFC_ENf_GET(r) ((((r).clmac_pfc_ctrl[1]) >> 4) & 0x1)
#define CLMAC_PFC_CTRLr_RX_PFC_ENf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CLMAC_PFC_CTRLr_TX_PFC_ENf_GET(r) ((((r).clmac_pfc_ctrl[1]) >> 5) & 0x1)
#define CLMAC_PFC_CTRLr_TX_PFC_ENf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))

/*
 * These macros can be used to access CLMAC_PFC_CTRL.
 */
#define WRITE_CLMAC_PFC_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_PFC_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_pfc_ctrl),2)
#define READ_CLMAC_PFC_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_PFC_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_pfc_ctrl),2)

/*******************************************************************************
 * End of 'CLMAC_PFC_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_PFC_DA
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     PFC Destination Address.
 * SIZE:     64
 * FIELDS:
 *     PFC_MACDA        This field is used in the destination-address field of the PFC frame that is generated and transmitted by the MAC and also used for detection in the receive direction
 *     PFC_MACDA_LO     32 lower bits of the PFC DA 
 *     PFC_MACDA_HI     16 upper bits of the PFC DA 
 */
#define CLMAC_PFC_DAr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_PFC_DA.
 */
typedef union CLMAC_PFC_DAr_s {
	uint32 v[2];
	uint32 clmac_pfc_da[2];
	uint32 _clmac_pfc_da;
} CLMAC_PFC_DAr_t;

#define CLMAC_PFC_DAr_CLR(r) sal_memset(&((r)._clmac_pfc_da), 0, sizeof(CLMAC_PFC_DAr_t))
#define CLMAC_PFC_DAr_SET(r,i,d) (r).clmac_pfc_da[i] = d
#define CLMAC_PFC_DAr_GET(r,i) (r).clmac_pfc_da[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_PFC_DAr_PFC_MACDAf_GET(r,a) field_get((r).clmac_pfc_da,0,47,a)
#define CLMAC_PFC_DAr_PFC_MACDAf_SET(r,a) field_set((r).clmac_pfc_da,0,47,a)
#define CLMAC_PFC_DAr_PFC_MACDA_LOf_GET(r) ((r).clmac_pfc_da[0])
#define CLMAC_PFC_DAr_PFC_MACDA_LOf_SET(r,f) (r).clmac_pfc_da[0]=((uint32)f)
#define CLMAC_PFC_DAr_PFC_MACDA_HIf_GET(r) (((r).clmac_pfc_da[1]) & 0xffff)
#define CLMAC_PFC_DAr_PFC_MACDA_HIf_SET(r,f) (r).clmac_pfc_da[1]=(((r).clmac_pfc_da[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access CLMAC_PFC_DA.
 */
#define WRITE_CLMAC_PFC_DAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_PFC_DA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_pfc_da),2)
#define READ_CLMAC_PFC_DAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_PFC_DA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_pfc_da),2)

/*******************************************************************************
 * End of 'CLMAC_PFC_DAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_PFC_OPCODE
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     PFC Opcode
 * SIZE:     64
 * FIELDS:
 *     PFC_OPCODE       This field is used in the OPCODE field of the PFC frame that is generated and transmitted by the MAC and also used for detection in the receive direction
 */
#define CLMAC_PFC_OPCODEr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_PFC_OPCODE.
 */
typedef union CLMAC_PFC_OPCODEr_s {
	uint32 v[2];
	uint32 clmac_pfc_opcode[2];
	uint32 _clmac_pfc_opcode;
} CLMAC_PFC_OPCODEr_t;

#define CLMAC_PFC_OPCODEr_CLR(r) sal_memset(&((r)._clmac_pfc_opcode), 0, sizeof(CLMAC_PFC_OPCODEr_t))
#define CLMAC_PFC_OPCODEr_SET(r,i,d) (r).clmac_pfc_opcode[i] = d
#define CLMAC_PFC_OPCODEr_GET(r,i) (r).clmac_pfc_opcode[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_PFC_OPCODEr_PFC_OPCODEf_GET(r) (((r).clmac_pfc_opcode[0]) & 0xffff)
#define CLMAC_PFC_OPCODEr_PFC_OPCODEf_SET(r,f) (r).clmac_pfc_opcode[0]=(((r).clmac_pfc_opcode[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access CLMAC_PFC_OPCODE.
 */
#define WRITE_CLMAC_PFC_OPCODEr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_PFC_OPCODE(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_pfc_opcode),2)
#define READ_CLMAC_PFC_OPCODEr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_PFC_OPCODE(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_pfc_opcode),2)

/*******************************************************************************
 * End of 'CLMAC_PFC_OPCODEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_PFC_TYPE
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     PFC Ethertype
 * SIZE:     64
 * FIELDS:
 *     PFC_ETH_TYPE     This field is used in the ETHERTYPE field of the PFC frame that is generated and transmitted by the MAC and also used for detection in the receive direction
 */
#define CLMAC_PFC_TYPEr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_PFC_TYPE.
 */
typedef union CLMAC_PFC_TYPEr_s {
	uint32 v[2];
	uint32 clmac_pfc_type[2];
	uint32 _clmac_pfc_type;
} CLMAC_PFC_TYPEr_t;

#define CLMAC_PFC_TYPEr_CLR(r) sal_memset(&((r)._clmac_pfc_type), 0, sizeof(CLMAC_PFC_TYPEr_t))
#define CLMAC_PFC_TYPEr_SET(r,i,d) (r).clmac_pfc_type[i] = d
#define CLMAC_PFC_TYPEr_GET(r,i) (r).clmac_pfc_type[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_PFC_TYPEr_PFC_ETH_TYPEf_GET(r) (((r).clmac_pfc_type[0]) & 0xffff)
#define CLMAC_PFC_TYPEr_PFC_ETH_TYPEf_SET(r,f) (r).clmac_pfc_type[0]=(((r).clmac_pfc_type[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access CLMAC_PFC_TYPE.
 */
#define WRITE_CLMAC_PFC_TYPEr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_PFC_TYPE(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_pfc_type),2)
#define READ_CLMAC_PFC_TYPEr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_PFC_TYPE(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_pfc_type),2)

/*******************************************************************************
 * End of 'CLMAC_PFC_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_RX_CTRL
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Receive control.
 * SIZE:     64
 * FIELDS:
 *     RSVD_1            Reserved
 *     RX_ANY_START     If set, MAC allows any undefined control character to start a packet
 *     STRIP_CRC        If set, CRC is stripped from the received packet 
 *     STRICT_PREAMBLE  If set, MAC checks for IEEE Ethernet preamble - K.SOP +  6 "0x55" preamble bytes + "0xD5" SFD character - if this sequence is missing it is treated as an errored packet. This bit should not be set if PROCESS_VARIABLE_PREAMBLE is set.
 *     RUNT_THRESHOLD   The runt threshold, below which the packets are dropped (CDC mode) or marked as runt (Low latency mode). Should be programmed <= 96 bytes (decimal)
 *     RSVD_2            Reserved
 *     PROCESS_VARIABLE_PREAMBLE If set, the MAC parses the frame from K.SOP onwards to look for the SFD character and then processes the packet.                                If disabled, treats the first 8 bytes of packet as preamble.                               Should be set only if HDR_MODE == IEEE and speed is non-GMII/MII
 *     RX_PASS_CTRL     This configuration is used to drop or pass all control frames (with ether type 0x8808) except pause packets.If set, all control frames are passed to system side. Otherwise, control frames (including pfc frames wih ether type 0x8808) are dropped in CLMAC.
 *     RX_PASS_PAUSE    If set, PAUSE frames are passed to sytem side. Otherwise, PAUSE frames are dropped in CLMAC
 *     RX_PASS_PFC      This configuration is used to pass or drop pfc packetw when pfc_ether_type is not equal to 0x8808.              If set, PFC frames are passed to system side. Otherwise, PFC frames are dropped in CLMAC.
 */
#define CLMAC_RX_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_CTRL.
 */
typedef union CLMAC_RX_CTRLr_s {
	uint32 v[2];
	uint32 clmac_rx_ctrl[2];
	uint32 _clmac_rx_ctrl;
} CLMAC_RX_CTRLr_t;

#define CLMAC_RX_CTRLr_CLR(r) sal_memset(&((r)._clmac_rx_ctrl), 0, sizeof(CLMAC_RX_CTRLr_t))
#define CLMAC_RX_CTRLr_SET(r,i,d) (r).clmac_rx_ctrl[i] = d
#define CLMAC_RX_CTRLr_GET(r,i) (r).clmac_rx_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_CTRLr_RSVD_1f_GET(r) (((r).clmac_rx_ctrl[0]) & 0x1)
#define CLMAC_RX_CTRLr_RSVD_1f_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLMAC_RX_CTRLr_RX_ANY_STARTf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 1) & 0x1)
#define CLMAC_RX_CTRLr_RX_ANY_STARTf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CLMAC_RX_CTRLr_STRIP_CRCf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 2) & 0x1)
#define CLMAC_RX_CTRLr_STRIP_CRCf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CLMAC_RX_CTRLr_STRICT_PREAMBLEf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 3) & 0x1)
#define CLMAC_RX_CTRLr_STRICT_PREAMBLEf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CLMAC_RX_CTRLr_RUNT_THRESHOLDf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 4) & 0x7f)
#define CLMAC_RX_CTRLr_RUNT_THRESHOLDf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32)0x7f << 4)) | ((((uint32)f) & 0x7f) << 4))
#define CLMAC_RX_CTRLr_RSVD_2f_GET(r) ((((r).clmac_rx_ctrl[0]) >> 11) & 0x1)
#define CLMAC_RX_CTRLr_RSVD_2f_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define CLMAC_RX_CTRLr_PROCESS_VARIABLE_PREAMBLEf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 12) & 0x1)
#define CLMAC_RX_CTRLr_PROCESS_VARIABLE_PREAMBLEf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define CLMAC_RX_CTRLr_RX_PASS_CTRLf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 13) & 0x1)
#define CLMAC_RX_CTRLr_RX_PASS_CTRLf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define CLMAC_RX_CTRLr_RX_PASS_PAUSEf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 14) & 0x1)
#define CLMAC_RX_CTRLr_RX_PASS_PAUSEf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define CLMAC_RX_CTRLr_RX_PASS_PFCf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 15) & 0x1)
#define CLMAC_RX_CTRLr_RX_PASS_PFCf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))

/*
 * These macros can be used to access CLMAC_RX_CTRL.
 */
#define WRITE_CLMAC_RX_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_RX_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_rx_ctrl),2)
#define READ_CLMAC_RX_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_RX_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_rx_ctrl),2)

/*******************************************************************************
 * End of 'CLMAC_RX_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_RX_LSS_CTRL
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Control for LSS (ordered set) messages
 * SIZE:     64
 * FIELDS:
 *     LOCAL_FAULT_DISABLE This bit determines the transmit response during local fault state. The LOCAL_FAULT_STATUS bit is always updated irrespective of this configuration.If set, MAC will continue to transmit data irrespective of LOCAL_FAULT_STATUS.If reset, MAC transmit behavior is governed by DROP_TX_DATA_ON_LOCAL_FAULT configuration.
 *     REMOTE_FAULT_DISABLE This bit determines the transmit response during remote fault state. The REMOTE_FAULT_STATUS bit is always updated irrespective of this configuration.If set, MAC will continue to transmit data irrespective of REMOTE_FAULT_STATUS.If reset, MAC transmit behavior is governed by DROP_TX_DATA_ON_REMOTE_FAULT configuration.
 *     RSVD             Reserved
 *     LINK_INTERRUPTION_DISABLE This bit determines the transmit response during link interruption state. The LINK_INTERRUPTION_STATUS bit is always updated irrespective of this configuration.If set, MAC will continue to transmit data irrespective of LINK_INTERRUPTION_STATUS.If reset, MAC transmit behavior is governed by DROP_TX_DATA_ON_LINK_INTERRUPT configuration.
 *     DROP_TX_DATA_ON_LOCAL_FAULT This bit determines the way MAC handles data during local fault state, if LOCAL_FAULT_DISABLE is reset.If set, during local fault state, MAC drops transmit-data (statistics are updated) and sends remote faults on the wire.If reset, transmit data is stalled in the internal FIFO under local fault state.
 *     DROP_TX_DATA_ON_REMOTE_FAULT This bit determines the way MAC handles data during remote fault state, if REMOTE_FAULT_DISABLE is reset.If set, during remote fault state, MAC drops transmit-data (statistics are updated) and sends IDLEs on the wire.If reset, transmit data is stalled in the internal FIFO under remote fault state.
 *     DROP_TX_DATA_ON_LINK_INTERRUPT This bit determines the way MAC handles data during link interruption state, if LINK_INTERRUPTION_DISABLE is reset.If set, during link interruption state, MAC drops transmit-data (statistics are updated) and sends IDLEs on the wire.If reset, transmit data is stalled in the internal FIFO under link interruption state.
 *     RESET_FLOW_CONTROL_TIMERS_ON_LINK_DOWN If set, the Receive Pause, PFC & LLFC timers are reset whenever the link status is down, or local or remote faults are received. 
 *     FORCE_LOCAL_FAULT_OS If set, and if the FAULT_SOURCE_FOR_TX = SW_CNFG_REG, LOCAL_FAULT ordered-sets are sent in the Tx direction.
 *     FORCE_REMOTE_FAULT_OS If set, and if the FAULT_SOURCE_FOR_TX = SW_CNFG_REG, REMOTE_FAULT ordered-sets are sent in the Tx direction.
 *     FORCE_LINK_INTERRUPT_OS If set, and if the FAULT_SOURCE_FOR_TX = SW_CNFG_REG, LINK_INTERRUPTION ordered-sets are sent in the Tx direction.
 *     FAULT_SOURCE_FOR_TX Indicates the source from where the transmit fault responses are determined
 */
#define CLMAC_RX_LSS_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_LSS_CTRL.
 */
typedef union CLMAC_RX_LSS_CTRLr_s {
	uint32 v[2];
	uint32 clmac_rx_lss_ctrl[2];
	uint32 _clmac_rx_lss_ctrl;
} CLMAC_RX_LSS_CTRLr_t;

#define CLMAC_RX_LSS_CTRLr_CLR(r) sal_memset(&((r)._clmac_rx_lss_ctrl), 0, sizeof(CLMAC_RX_LSS_CTRLr_t))
#define CLMAC_RX_LSS_CTRLr_SET(r,i,d) (r).clmac_rx_lss_ctrl[i] = d
#define CLMAC_RX_LSS_CTRLr_GET(r,i) (r).clmac_rx_lss_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_LSS_CTRLr_LOCAL_FAULT_DISABLEf_GET(r) (((r).clmac_rx_lss_ctrl[0]) & 0x1)
#define CLMAC_RX_LSS_CTRLr_LOCAL_FAULT_DISABLEf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLMAC_RX_LSS_CTRLr_REMOTE_FAULT_DISABLEf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 1) & 0x1)
#define CLMAC_RX_LSS_CTRLr_REMOTE_FAULT_DISABLEf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CLMAC_RX_LSS_CTRLr_RSVDf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 2) & 0x1)
#define CLMAC_RX_LSS_CTRLr_RSVDf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CLMAC_RX_LSS_CTRLr_LINK_INTERRUPTION_DISABLEf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 3) & 0x1)
#define CLMAC_RX_LSS_CTRLr_LINK_INTERRUPTION_DISABLEf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LOCAL_FAULTf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 4) & 0x1)
#define CLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LOCAL_FAULTf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_REMOTE_FAULTf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 5) & 0x1)
#define CLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_REMOTE_FAULTf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LINK_INTERRUPTf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 6) & 0x1)
#define CLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LINK_INTERRUPTf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CLMAC_RX_LSS_CTRLr_RESET_FLOW_CONTROL_TIMERS_ON_LINK_DOWNf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 7) & 0x1)
#define CLMAC_RX_LSS_CTRLr_RESET_FLOW_CONTROL_TIMERS_ON_LINK_DOWNf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CLMAC_RX_LSS_CTRLr_FORCE_LOCAL_FAULT_OSf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 8) & 0x1)
#define CLMAC_RX_LSS_CTRLr_FORCE_LOCAL_FAULT_OSf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CLMAC_RX_LSS_CTRLr_FORCE_REMOTE_FAULT_OSf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 9) & 0x1)
#define CLMAC_RX_LSS_CTRLr_FORCE_REMOTE_FAULT_OSf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CLMAC_RX_LSS_CTRLr_FORCE_LINK_INTERRUPT_OSf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 10) & 0x1)
#define CLMAC_RX_LSS_CTRLr_FORCE_LINK_INTERRUPT_OSf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define CLMAC_RX_LSS_CTRLr_FAULT_SOURCE_FOR_TXf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 11) & 0x3)
#define CLMAC_RX_LSS_CTRLr_FAULT_SOURCE_FOR_TXf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32)0x3 << 11)) | ((((uint32)f) & 0x3) << 11))

/*
 * These macros can be used to access CLMAC_RX_LSS_CTRL.
 */
#define WRITE_CLMAC_RX_LSS_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_RX_LSS_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_rx_lss_ctrl),2)
#define READ_CLMAC_RX_LSS_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_RX_LSS_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_rx_lss_ctrl),2)

/*******************************************************************************
 * End of 'CLMAC_RX_LSS_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_RX_LSS_STATUS
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Status for RS layer. These bits are sticky by nature, and can be cleared by writing to the clear register
 * SIZE:     64
 * FIELDS:
 *     LOCAL_FAULT_STATUS True when local fault state is detected as per RS layer state machine. Sticky bit is cleared by CLEAR_LOCAL_FAULT_STATUS
 *     REMOTE_FAULT_STATUS True when remote fault state is detected as per RS layer state machine. Sticky bit is cleared by CLEAR_REMOTE_FAULT_STATUS.
 *     LINK_INTERRUPTION_STATUS True when link interruption state is detected as per RS layer state machine. Sticky bit is cleared by CLEAR_LINK_INTERRUPTION_STATUS.
 */
#define CLMAC_RX_LSS_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_LSS_STATUS.
 */
typedef union CLMAC_RX_LSS_STATUSr_s {
	uint32 v[2];
	uint32 clmac_rx_lss_status[2];
	uint32 _clmac_rx_lss_status;
} CLMAC_RX_LSS_STATUSr_t;

#define CLMAC_RX_LSS_STATUSr_CLR(r) sal_memset(&((r)._clmac_rx_lss_status), 0, sizeof(CLMAC_RX_LSS_STATUSr_t))
#define CLMAC_RX_LSS_STATUSr_SET(r,i,d) (r).clmac_rx_lss_status[i] = d
#define CLMAC_RX_LSS_STATUSr_GET(r,i) (r).clmac_rx_lss_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_LSS_STATUSr_LOCAL_FAULT_STATUSf_GET(r) (((r).clmac_rx_lss_status[0]) & 0x1)
#define CLMAC_RX_LSS_STATUSr_LOCAL_FAULT_STATUSf_SET(r,f) (r).clmac_rx_lss_status[0]=(((r).clmac_rx_lss_status[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLMAC_RX_LSS_STATUSr_REMOTE_FAULT_STATUSf_GET(r) ((((r).clmac_rx_lss_status[0]) >> 1) & 0x1)
#define CLMAC_RX_LSS_STATUSr_REMOTE_FAULT_STATUSf_SET(r,f) (r).clmac_rx_lss_status[0]=(((r).clmac_rx_lss_status[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CLMAC_RX_LSS_STATUSr_LINK_INTERRUPTION_STATUSf_GET(r) ((((r).clmac_rx_lss_status[0]) >> 2) & 0x1)
#define CLMAC_RX_LSS_STATUSr_LINK_INTERRUPTION_STATUSf_SET(r,f) (r).clmac_rx_lss_status[0]=(((r).clmac_rx_lss_status[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))

/*
 * These macros can be used to access CLMAC_RX_LSS_STATUS.
 */
#define WRITE_CLMAC_RX_LSS_STATUSr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_RX_LSS_STATUS(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_rx_lss_status),2)
#define READ_CLMAC_RX_LSS_STATUSr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_RX_LSS_STATUS(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_rx_lss_status),2)

/*******************************************************************************
 * End of 'CLMAC_RX_LSS_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_RX_MAC_SA
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Receive source address.
 * SIZE:     64
 * FIELDS:
 *     RX_SA            Source Address recognized for MAC control packets in addition to the standard 0x0180C2000001 
 *     SA_LO            32 lower bits of the receive SA 
 *     SA_HI            16 upper bits of the receive SA 
 */
#define CLMAC_RX_MAC_SAr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_MAC_SA.
 */
typedef union CLMAC_RX_MAC_SAr_s {
	uint32 v[2];
	uint32 clmac_rx_mac_sa[2];
	uint32 _clmac_rx_mac_sa;
} CLMAC_RX_MAC_SAr_t;

#define CLMAC_RX_MAC_SAr_CLR(r) sal_memset(&((r)._clmac_rx_mac_sa), 0, sizeof(CLMAC_RX_MAC_SAr_t))
#define CLMAC_RX_MAC_SAr_SET(r,i,d) (r).clmac_rx_mac_sa[i] = d
#define CLMAC_RX_MAC_SAr_GET(r,i) (r).clmac_rx_mac_sa[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_MAC_SAr_RX_SAf_GET(r,a) field_get((r).clmac_rx_mac_sa,0,47,a)
#define CLMAC_RX_MAC_SAr_RX_SAf_SET(r,a) field_set((r).clmac_rx_mac_sa,0,47,a)
#define CLMAC_RX_MAC_SAr_SA_LOf_GET(r) ((r).clmac_rx_mac_sa[0])
#define CLMAC_RX_MAC_SAr_SA_LOf_SET(r,f) (r).clmac_rx_mac_sa[0]=((uint32)f)
#define CLMAC_RX_MAC_SAr_SA_HIf_GET(r) (((r).clmac_rx_mac_sa[1]) & 0xffff)
#define CLMAC_RX_MAC_SAr_SA_HIf_SET(r,f) (r).clmac_rx_mac_sa[1]=(((r).clmac_rx_mac_sa[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access CLMAC_RX_MAC_SA.
 */
#define WRITE_CLMAC_RX_MAC_SAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_RX_MAC_SA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_rx_mac_sa),2)
#define READ_CLMAC_RX_MAC_SAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_RX_MAC_SA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_rx_mac_sa),2)

/*******************************************************************************
 * End of 'CLMAC_RX_MAC_SAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_RX_MAX_SIZE
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Receive maximum packet size.
 * SIZE:     64
 * FIELDS:
 *     RX_MAX_SIZE      Maximum packet size in receive direction, exclusive of preamble & CRC in strip mode. Packets greater than this size are truncated to this value.
 */
#define CLMAC_RX_MAX_SIZEr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_MAX_SIZE.
 */
typedef union CLMAC_RX_MAX_SIZEr_s {
	uint32 v[2];
	uint32 clmac_rx_max_size[2];
	uint32 _clmac_rx_max_size;
} CLMAC_RX_MAX_SIZEr_t;

#define CLMAC_RX_MAX_SIZEr_CLR(r) sal_memset(&((r)._clmac_rx_max_size), 0, sizeof(CLMAC_RX_MAX_SIZEr_t))
#define CLMAC_RX_MAX_SIZEr_SET(r,i,d) (r).clmac_rx_max_size[i] = d
#define CLMAC_RX_MAX_SIZEr_GET(r,i) (r).clmac_rx_max_size[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_MAX_SIZEr_RX_MAX_SIZEf_GET(r) (((r).clmac_rx_max_size[0]) & 0x3fff)
#define CLMAC_RX_MAX_SIZEr_RX_MAX_SIZEf_SET(r,f) (r).clmac_rx_max_size[0]=(((r).clmac_rx_max_size[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))

/*
 * These macros can be used to access CLMAC_RX_MAX_SIZE.
 */
#define WRITE_CLMAC_RX_MAX_SIZEr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_RX_MAX_SIZE(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_rx_max_size),2)
#define READ_CLMAC_RX_MAX_SIZEr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_RX_MAX_SIZE(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_rx_max_size),2)

/*******************************************************************************
 * End of 'CLMAC_RX_MAX_SIZEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_TXFIFO_CELL_CNT
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     CLMAC TX FIFO Cell Count register
 * SIZE:     64
 * FIELDS:
 *     CELL_CNT         Number of cell counts in CLMAC TX FIFO.Should range from 0 to 32 for CLMAC core in single port mode, or 0 to 16 if CLMAC core is in dual port mode, or 0 to 8 if CLMAC core is in quad port mode during traffic.This should reset to 0 after the traffic has stopped for all port modes.
 */
#define CLMAC_TXFIFO_CELL_CNTr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TXFIFO_CELL_CNT.
 */
typedef union CLMAC_TXFIFO_CELL_CNTr_s {
	uint32 v[2];
	uint32 clmac_txfifo_cell_cnt[2];
	uint32 _clmac_txfifo_cell_cnt;
} CLMAC_TXFIFO_CELL_CNTr_t;

#define CLMAC_TXFIFO_CELL_CNTr_CLR(r) sal_memset(&((r)._clmac_txfifo_cell_cnt), 0, sizeof(CLMAC_TXFIFO_CELL_CNTr_t))
#define CLMAC_TXFIFO_CELL_CNTr_SET(r,i,d) (r).clmac_txfifo_cell_cnt[i] = d
#define CLMAC_TXFIFO_CELL_CNTr_GET(r,i) (r).clmac_txfifo_cell_cnt[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TXFIFO_CELL_CNTr_CELL_CNTf_GET(r) (((r).clmac_txfifo_cell_cnt[0]) & 0x3f)
#define CLMAC_TXFIFO_CELL_CNTr_CELL_CNTf_SET(r,f) (r).clmac_txfifo_cell_cnt[0]=(((r).clmac_txfifo_cell_cnt[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))

/*
 * These macros can be used to access CLMAC_TXFIFO_CELL_CNT.
 */
#define WRITE_CLMAC_TXFIFO_CELL_CNTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_TXFIFO_CELL_CNT(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_txfifo_cell_cnt),2)
#define READ_CLMAC_TXFIFO_CELL_CNTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_TXFIFO_CELL_CNT(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_txfifo_cell_cnt),2)

/*******************************************************************************
 * End of 'CLMAC_TXFIFO_CELL_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_TX_CTRL
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Transmit control.
 * SIZE:     64
 * FIELDS:
 *     CLMAC_TX_CTRL_LO 32 lower bits of the TX CTRL register
 *     CRC_MODE         CRC mode for Transmit Side
 *     DISCARD          If set, MAC accepts packets from the EP and discards them on the line side.  The statistics are updated.
 *     TX_ANY_START     In GMII mode, this may be used to enable DIC compensation of +/-1 byte, irrespective of speed.In non-GMII modes, if reset, MAC forces the first byte of a packet to be /S/ character (0xFB) irrespective of incoming EP data at SOP location in HIGIG modes
 *     PAD_EN           If set, enable CLMAC to pad packets smaller than PAD_THRESHOLD on the Tx
 *     PAD_THRESHOLD    If padding is enabled, packets smaller than PAD_THRESHOLD are padded to this size. This must be set to a value >= 36 (decimal) and <= 96 (decimal)
 *     AVERAGE_IPG      Average interpacket gap. Must be programmed >= 8. Per packet IPG will vary based on DIC for 10G+ speeds. If WAN mode IPG throttling is enabled, this must be set to a value <= 64.In TSN/Preemption mode, TX average IPG should be set to 12(decimal).
 *     THROT_NUM        Number of bytes of extra IPG added whenever THROT_DENOM bytes have been transmitted. This configuration is used for WAN IPG throttling. Refer MAC specs for more details.
 *     THROT_DENOM      Number of bytes to transmit before adding THROT_NUM bytes to the IPG.  This configuration is used for WAN IPG throttling. Must be >= 32. Refer MAC specs for more details.
 *     CLMAC_TX_CTRL_HI 10 upper bits of the TX CTRL Register 
 *     TX_PREAMBLE_LENGTH Number of preamble bytes for transmit IEEE packets, this value should include the K.SOP & SFD character as well.In TSN/Preemption mode, TX preamble length should be set to 8.
 *     EP_DISCARD       If set, MAC accepts packets from the EP but does not write to the CDC FIFO and discards them on the core side without updating the statistics.
 *     TX_THRESHOLD     Indicates the number of 48-byte cells that are buffered per packet in the Tx CDC FIFO, before starting transmission of the packet on the line side.                               This setting is useful to prevent underflow issues if the EP logic pumps in data at port rate, rather than bursting at full rate.                               This mode will increase the overall latency.                               In quad port mode, this field should be set >= 1 and <= 8 for each port.                               In single port mode, this field should be set >= 1 and <= 32 for the four lane port (port0).                               In dual port mode, this field should be set >= 1 and <= 16 for each two lane port (port0 and port2).                               In tri1/tri2, this field should be set >= 1 and <= 8 for each single lane port, and >= 1 and <= 16 for the two lane port.
 *     STALL_TX         When asserted, if the MAC Tx is in the middle of transmitting a packet, it waits for the next packet boundary to stop transmitting any more packets.
 */
#define CLMAC_TX_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TX_CTRL.
 */
typedef union CLMAC_TX_CTRLr_s {
	uint32 v[2];
	uint32 clmac_tx_ctrl[2];
	uint32 _clmac_tx_ctrl;
} CLMAC_TX_CTRLr_t;

#define CLMAC_TX_CTRLr_CLR(r) sal_memset(&((r)._clmac_tx_ctrl), 0, sizeof(CLMAC_TX_CTRLr_t))
#define CLMAC_TX_CTRLr_SET(r,i,d) (r).clmac_tx_ctrl[i] = d
#define CLMAC_TX_CTRLr_GET(r,i) (r).clmac_tx_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TX_CTRLr_CLMAC_TX_CTRL_LOf_GET(r) ((r).clmac_tx_ctrl[0])
#define CLMAC_TX_CTRLr_CLMAC_TX_CTRL_LOf_SET(r,f) (r).clmac_tx_ctrl[0]=((uint32)f)
#define CLMAC_TX_CTRLr_CRC_MODEf_GET(r) (((r).clmac_tx_ctrl[0]) & 0x3)
#define CLMAC_TX_CTRLr_CRC_MODEf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define CLMAC_TX_CTRLr_DISCARDf_GET(r) ((((r).clmac_tx_ctrl[0]) >> 2) & 0x1)
#define CLMAC_TX_CTRLr_DISCARDf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CLMAC_TX_CTRLr_TX_ANY_STARTf_GET(r) ((((r).clmac_tx_ctrl[0]) >> 3) & 0x1)
#define CLMAC_TX_CTRLr_TX_ANY_STARTf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CLMAC_TX_CTRLr_PAD_ENf_GET(r) ((((r).clmac_tx_ctrl[0]) >> 4) & 0x1)
#define CLMAC_TX_CTRLr_PAD_ENf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CLMAC_TX_CTRLr_PAD_THRESHOLDf_GET(r) ((((r).clmac_tx_ctrl[0]) >> 5) & 0x7f)
#define CLMAC_TX_CTRLr_PAD_THRESHOLDf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32)0x7f << 5)) | ((((uint32)f) & 0x7f) << 5))
#define CLMAC_TX_CTRLr_AVERAGE_IPGf_GET(r) ((((r).clmac_tx_ctrl[0]) >> 12) & 0x7f)
#define CLMAC_TX_CTRLr_AVERAGE_IPGf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32)0x7f << 12)) | ((((uint32)f) & 0x7f) << 12))
#define CLMAC_TX_CTRLr_THROT_NUMf_GET(r) ((((r).clmac_tx_ctrl[0]) >> 19) & 0x3f)
#define CLMAC_TX_CTRLr_THROT_NUMf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32)0x3f << 19)) | ((((uint32)f) & 0x3f) << 19))
#define CLMAC_TX_CTRLr_THROT_DENOMf_GET(r) field32_get((r).clmac_tx_ctrl,25,32)
#define CLMAC_TX_CTRLr_THROT_DENOMf_SET(r,f) field32_set((r).clmac_tx_ctrl,25,32,f)
#define CLMAC_TX_CTRLr_CLMAC_TX_CTRL_HIf_GET(r) (((r).clmac_tx_ctrl[1]) & 0x3ff)
#define CLMAC_TX_CTRLr_CLMAC_TX_CTRL_HIf_SET(r,f) (r).clmac_tx_ctrl[1]=(((r).clmac_tx_ctrl[1] & ~((uint32)0x3ff)) | (((uint32)f) & 0x3ff))
#define CLMAC_TX_CTRLr_TX_PREAMBLE_LENGTHf_GET(r) ((((r).clmac_tx_ctrl[1]) >> 1) & 0xf)
#define CLMAC_TX_CTRLr_TX_PREAMBLE_LENGTHf_SET(r,f) (r).clmac_tx_ctrl[1]=(((r).clmac_tx_ctrl[1] & ~((uint32)0xf << 1)) | ((((uint32)f) & 0xf) << 1))
#define CLMAC_TX_CTRLr_EP_DISCARDf_GET(r) ((((r).clmac_tx_ctrl[1]) >> 5) & 0x1)
#define CLMAC_TX_CTRLr_EP_DISCARDf_SET(r,f) (r).clmac_tx_ctrl[1]=(((r).clmac_tx_ctrl[1] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CLMAC_TX_CTRLr_TX_THRESHOLDf_GET(r) ((((r).clmac_tx_ctrl[1]) >> 6) & 0x1f)
#define CLMAC_TX_CTRLr_TX_THRESHOLDf_SET(r,f) (r).clmac_tx_ctrl[1]=(((r).clmac_tx_ctrl[1] & ~((uint32)0x1f << 6)) | ((((uint32)f) & 0x1f) << 6))
#define CLMAC_TX_CTRLr_STALL_TXf_GET(r) ((((r).clmac_tx_ctrl[1]) >> 11) & 0x1)
#define CLMAC_TX_CTRLr_STALL_TXf_SET(r,f) (r).clmac_tx_ctrl[1]=(((r).clmac_tx_ctrl[1] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))

/*
 * These macros can be used to access CLMAC_TX_CTRL.
 */
#define WRITE_CLMAC_TX_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_TX_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_tx_ctrl),2)
#define READ_CLMAC_TX_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_TX_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_tx_ctrl),2)

/*******************************************************************************
 * End of 'CLMAC_TX_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_TX_MAC_SA
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Transmit Source Address.
 * SIZE:     64
 * FIELDS:
 *     CTRL_SA          Source Address for PAUSE/PFC packets generated by the MAC 
 *     SA_LO            32 lower bits of the SA
 *     SA_HI            16 upper bits of the SA
 */
#define CLMAC_TX_MAC_SAr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TX_MAC_SA.
 */
typedef union CLMAC_TX_MAC_SAr_s {
	uint32 v[2];
	uint32 clmac_tx_mac_sa[2];
	uint32 _clmac_tx_mac_sa;
} CLMAC_TX_MAC_SAr_t;

#define CLMAC_TX_MAC_SAr_CLR(r) sal_memset(&((r)._clmac_tx_mac_sa), 0, sizeof(CLMAC_TX_MAC_SAr_t))
#define CLMAC_TX_MAC_SAr_SET(r,i,d) (r).clmac_tx_mac_sa[i] = d
#define CLMAC_TX_MAC_SAr_GET(r,i) (r).clmac_tx_mac_sa[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TX_MAC_SAr_CTRL_SAf_GET(r,a) field_get((r).clmac_tx_mac_sa,0,47,a)
#define CLMAC_TX_MAC_SAr_CTRL_SAf_SET(r,a) field_set((r).clmac_tx_mac_sa,0,47,a)
#define CLMAC_TX_MAC_SAr_SA_LOf_GET(r) ((r).clmac_tx_mac_sa[0])
#define CLMAC_TX_MAC_SAr_SA_LOf_SET(r,f) (r).clmac_tx_mac_sa[0]=((uint32)f)
#define CLMAC_TX_MAC_SAr_SA_HIf_GET(r) (((r).clmac_tx_mac_sa[1]) & 0xffff)
#define CLMAC_TX_MAC_SAr_SA_HIf_SET(r,f) (r).clmac_tx_mac_sa[1]=(((r).clmac_tx_mac_sa[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access CLMAC_TX_MAC_SA.
 */
#define WRITE_CLMAC_TX_MAC_SAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_TX_MAC_SA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_tx_mac_sa),2)
#define READ_CLMAC_TX_MAC_SAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_TX_MAC_SA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_tx_mac_sa),2)

/*******************************************************************************
 * End of 'CLMAC_TX_MAC_SAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_TX_TIMESTAMP_FIFO_DATA
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     The TimeStamp value of the Tx two-step packets.
 * SIZE:     64
 * FIELDS:
 *     TIME_STAMP       The TimeStamp value of the Tx two-step enabled packet.
 *     SEQUENCE_ID      The Sequence Identifier extracted from the Timesync packet based on the header offset 
 *     TS_ENTRY_VALID   Active high qualifier for the TimeStamp & SEQUENCE_ID fields.
 */
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TX_TIMESTAMP_FIFO_DATA.
 */
typedef union CLMAC_TX_TIMESTAMP_FIFO_DATAr_s {
	uint32 v[2];
	uint32 clmac_tx_timestamp_fifo_data[2];
	uint32 _clmac_tx_timestamp_fifo_data;
} CLMAC_TX_TIMESTAMP_FIFO_DATAr_t;

#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_CLR(r) sal_memset(&((r)._clmac_tx_timestamp_fifo_data), 0, sizeof(CLMAC_TX_TIMESTAMP_FIFO_DATAr_t))
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_SET(r,i,d) (r).clmac_tx_timestamp_fifo_data[i] = d
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_GET(r,i) (r).clmac_tx_timestamp_fifo_data[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_TIME_STAMPf_GET(r) ((r).clmac_tx_timestamp_fifo_data[0])
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_TIME_STAMPf_SET(r,f) (r).clmac_tx_timestamp_fifo_data[0]=((uint32)f)
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_SEQUENCE_IDf_GET(r) (((r).clmac_tx_timestamp_fifo_data[1]) & 0xffff)
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_SEQUENCE_IDf_SET(r,f) (r).clmac_tx_timestamp_fifo_data[1]=(((r).clmac_tx_timestamp_fifo_data[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_TS_ENTRY_VALIDf_GET(r) ((((r).clmac_tx_timestamp_fifo_data[1]) >> 16) & 0x1)
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_TS_ENTRY_VALIDf_SET(r,f) (r).clmac_tx_timestamp_fifo_data[1]=(((r).clmac_tx_timestamp_fifo_data[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))

/*
 * These macros can be used to access CLMAC_TX_TIMESTAMP_FIFO_DATA.
 */
#define WRITE_CLMAC_TX_TIMESTAMP_FIFO_DATAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_TX_TIMESTAMP_FIFO_DATA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_tx_timestamp_fifo_data),2)
#define READ_CLMAC_TX_TIMESTAMP_FIFO_DATAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_TX_TIMESTAMP_FIFO_DATA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_tx_timestamp_fifo_data),2)

/*******************************************************************************
 * End of 'CLMAC_TX_TIMESTAMP_FIFO_DATAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMAC_TX_TIMESTAMP_FIFO_STATUS
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Tx TimeStamp FIFO Status.
 * SIZE:     64
 * FIELDS:
 *     ENTRY_COUNT      Number of TX time stamps currently buffered in TX Time Stamp FIFO. A valid entry is popped out whenever CLMAC_TX_TIMESTMAP_FIFO_DATA is read
 */
#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TX_TIMESTAMP_FIFO_STATUS.
 */
typedef union CLMAC_TX_TIMESTAMP_FIFO_STATUSr_s {
	uint32 v[2];
	uint32 clmac_tx_timestamp_fifo_status[2];
	uint32 _clmac_tx_timestamp_fifo_status;
} CLMAC_TX_TIMESTAMP_FIFO_STATUSr_t;

#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_CLR(r) sal_memset(&((r)._clmac_tx_timestamp_fifo_status), 0, sizeof(CLMAC_TX_TIMESTAMP_FIFO_STATUSr_t))
#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_SET(r,i,d) (r).clmac_tx_timestamp_fifo_status[i] = d
#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_GET(r,i) (r).clmac_tx_timestamp_fifo_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_ENTRY_COUNTf_GET(r) (((r).clmac_tx_timestamp_fifo_status[0]) & 0x7)
#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_ENTRY_COUNTf_SET(r,f) (r).clmac_tx_timestamp_fifo_status[0]=(((r).clmac_tx_timestamp_fifo_status[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))

/*
 * These macros can be used to access CLMAC_TX_TIMESTAMP_FIFO_STATUS.
 */
#define WRITE_CLMAC_TX_TIMESTAMP_FIFO_STATUSr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_TX_TIMESTAMP_FIFO_STATUS(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_tx_timestamp_fifo_status),2)
#define READ_CLMAC_TX_TIMESTAMP_FIFO_STATUSr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMAC_TX_TIMESTAMP_FIFO_STATUS(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmac_tx_timestamp_fifo_status),2)

/*******************************************************************************
 * End of 'CLMAC_TX_TIMESTAMP_FIFO_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_RBCA
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Receive Broadcast Frame Counter
 * SIZE:     64
 */
#define CLMIB_RBCAr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_RBCA.
 */
typedef union CLMIB_RBCAr_s {
	uint32 v[2];
	uint32 clmib_rbca[2];
	uint32 _clmib_rbca;
} CLMIB_RBCAr_t;

#define CLMIB_RBCAr_CLR(r) sal_memset(&((r)._clmib_rbca), 0, sizeof(CLMIB_RBCAr_t))
#define CLMIB_RBCAr_SET(r,i,d) (r).clmib_rbca[i] = d
#define CLMIB_RBCAr_GET(r,i) (r).clmib_rbca[i]


/*
 * These macros can be used to access CLMIB_RBCA.
 */
#define WRITE_CLMIB_RBCAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RBCA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rbca),2)
#define READ_CLMIB_RBCAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RBCA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rbca),2)

/*******************************************************************************
 * End of 'CLMIB_RBCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_RBYT
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Receive Byte Counter
 * SIZE:     64
 */
#define CLMIB_RBYTr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_RBYT.
 */
typedef union CLMIB_RBYTr_s {
	uint32 v[2];
	uint32 clmib_rbyt[2];
	uint32 _clmib_rbyt;
} CLMIB_RBYTr_t;

#define CLMIB_RBYTr_CLR(r) sal_memset(&((r)._clmib_rbyt), 0, sizeof(CLMIB_RBYTr_t))
#define CLMIB_RBYTr_SET(r,i,d) (r).clmib_rbyt[i] = d
#define CLMIB_RBYTr_GET(r,i) (r).clmib_rbyt[i]


/*
 * These macros can be used to access CLMIB_RBYT.
 */
#define WRITE_CLMIB_RBYTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RBYT(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rbyt),2)
#define READ_CLMIB_RBYTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RBYT(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rbyt),2)

/*******************************************************************************
 * End of 'CLMIB_RBYTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_RFCS
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Receive FCS Error Frame Counter
 * SIZE:     64
 */
#define CLMIB_RFCSr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_RFCS.
 */
typedef union CLMIB_RFCSr_s {
	uint32 v[2];
	uint32 clmib_rfcs[2];
	uint32 _clmib_rfcs;
} CLMIB_RFCSr_t;

#define CLMIB_RFCSr_CLR(r) sal_memset(&((r)._clmib_rfcs), 0, sizeof(CLMIB_RFCSr_t))
#define CLMIB_RFCSr_SET(r,i,d) (r).clmib_rfcs[i] = d
#define CLMIB_RFCSr_GET(r,i) (r).clmib_rfcs[i]


/*
 * These macros can be used to access CLMIB_RFCS.
 */
#define WRITE_CLMIB_RFCSr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RFCS(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rfcs),2)
#define READ_CLMIB_RFCSr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RFCS(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rfcs),2)

/*******************************************************************************
 * End of 'CLMIB_RFCSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_RMCA
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Receive Multicast Frame Counter
 * SIZE:     64
 */
#define CLMIB_RMCAr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_RMCA.
 */
typedef union CLMIB_RMCAr_s {
	uint32 v[2];
	uint32 clmib_rmca[2];
	uint32 _clmib_rmca;
} CLMIB_RMCAr_t;

#define CLMIB_RMCAr_CLR(r) sal_memset(&((r)._clmib_rmca), 0, sizeof(CLMIB_RMCAr_t))
#define CLMIB_RMCAr_SET(r,i,d) (r).clmib_rmca[i] = d
#define CLMIB_RMCAr_GET(r,i) (r).clmib_rmca[i]


/*
 * These macros can be used to access CLMIB_RMCA.
 */
#define WRITE_CLMIB_RMCAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RMCA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rmca),2)
#define READ_CLMIB_RMCAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RMCA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rmca),2)

/*******************************************************************************
 * End of 'CLMIB_RMCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_ROVR
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Receive Oversized Frame Counter
 * SIZE:     64
 */
#define CLMIB_ROVRr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_ROVR.
 */
typedef union CLMIB_ROVRr_s {
	uint32 v[2];
	uint32 clmib_rovr[2];
	uint32 _clmib_rovr;
} CLMIB_ROVRr_t;

#define CLMIB_ROVRr_CLR(r) sal_memset(&((r)._clmib_rovr), 0, sizeof(CLMIB_ROVRr_t))
#define CLMIB_ROVRr_SET(r,i,d) (r).clmib_rovr[i] = d
#define CLMIB_ROVRr_GET(r,i) (r).clmib_rovr[i]


/*
 * These macros can be used to access CLMIB_ROVR.
 */
#define WRITE_CLMIB_ROVRr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_ROVR(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rovr),2)
#define READ_CLMIB_ROVRr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_ROVR(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rovr),2)

/*******************************************************************************
 * End of 'CLMIB_ROVRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_RPKT
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Receive frame/packet Counter
 * SIZE:     64
 */
#define CLMIB_RPKTr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_RPKT.
 */
typedef union CLMIB_RPKTr_s {
	uint32 v[2];
	uint32 clmib_rpkt[2];
	uint32 _clmib_rpkt;
} CLMIB_RPKTr_t;

#define CLMIB_RPKTr_CLR(r) sal_memset(&((r)._clmib_rpkt), 0, sizeof(CLMIB_RPKTr_t))
#define CLMIB_RPKTr_SET(r,i,d) (r).clmib_rpkt[i] = d
#define CLMIB_RPKTr_GET(r,i) (r).clmib_rpkt[i]


/*
 * These macros can be used to access CLMIB_RPKT.
 */
#define WRITE_CLMIB_RPKTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RPKT(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rpkt),2)
#define READ_CLMIB_RPKTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RPKT(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rpkt),2)

/*******************************************************************************
 * End of 'CLMIB_RPKTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_RUCA
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Receive Unicast Frame Counter
 * SIZE:     64
 */
#define CLMIB_RUCAr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_RUCA.
 */
typedef union CLMIB_RUCAr_s {
	uint32 v[2];
	uint32 clmib_ruca[2];
	uint32 _clmib_ruca;
} CLMIB_RUCAr_t;

#define CLMIB_RUCAr_CLR(r) sal_memset(&((r)._clmib_ruca), 0, sizeof(CLMIB_RUCAr_t))
#define CLMIB_RUCAr_SET(r,i,d) (r).clmib_ruca[i] = d
#define CLMIB_RUCAr_GET(r,i) (r).clmib_ruca[i]


/*
 * These macros can be used to access CLMIB_RUCA.
 */
#define WRITE_CLMIB_RUCAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RUCA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_ruca),2)
#define READ_CLMIB_RUCAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RUCA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_ruca),2)

/*******************************************************************************
 * End of 'CLMIB_RUCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_RXPF
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Receive PAUSE Frame Counter
 * SIZE:     64
 */
#define CLMIB_RXPFr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_RXPF.
 */
typedef union CLMIB_RXPFr_s {
	uint32 v[2];
	uint32 clmib_rxpf[2];
	uint32 _clmib_rxpf;
} CLMIB_RXPFr_t;

#define CLMIB_RXPFr_CLR(r) sal_memset(&((r)._clmib_rxpf), 0, sizeof(CLMIB_RXPFr_t))
#define CLMIB_RXPFr_SET(r,i,d) (r).clmib_rxpf[i] = d
#define CLMIB_RXPFr_GET(r,i) (r).clmib_rxpf[i]


/*
 * These macros can be used to access CLMIB_RXPF.
 */
#define WRITE_CLMIB_RXPFr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RXPF(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rxpf),2)
#define READ_CLMIB_RXPFr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RXPF(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rxpf),2)

/*******************************************************************************
 * End of 'CLMIB_RXPFr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_RX_EEE_LPI_DURATION_COUNTER
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     RX EEE LPI Duration Counter
 * SIZE:     64
 */
#define CLMIB_RX_EEE_LPI_DURATION_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_RX_EEE_LPI_DURATION_COUNTER.
 */
typedef union CLMIB_RX_EEE_LPI_DURATION_COUNTERr_s {
	uint32 v[2];
	uint32 clmib_rx_eee_lpi_duration_counter[2];
	uint32 _clmib_rx_eee_lpi_duration_counter;
} CLMIB_RX_EEE_LPI_DURATION_COUNTERr_t;

#define CLMIB_RX_EEE_LPI_DURATION_COUNTERr_CLR(r) sal_memset(&((r)._clmib_rx_eee_lpi_duration_counter), 0, sizeof(CLMIB_RX_EEE_LPI_DURATION_COUNTERr_t))
#define CLMIB_RX_EEE_LPI_DURATION_COUNTERr_SET(r,i,d) (r).clmib_rx_eee_lpi_duration_counter[i] = d
#define CLMIB_RX_EEE_LPI_DURATION_COUNTERr_GET(r,i) (r).clmib_rx_eee_lpi_duration_counter[i]


/*
 * These macros can be used to access CLMIB_RX_EEE_LPI_DURATION_COUNTER.
 */
#define WRITE_CLMIB_RX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RX_EEE_LPI_DURATION_COUNTER(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rx_eee_lpi_duration_counter),2)
#define READ_CLMIB_RX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RX_EEE_LPI_DURATION_COUNTER(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rx_eee_lpi_duration_counter),2)

/*******************************************************************************
 * End of 'CLMIB_RX_EEE_LPI_DURATION_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_RX_EEE_LPI_EVENT_COUNTER
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     RX EEE LPI Event Counter
 * SIZE:     64
 */
#define CLMIB_RX_EEE_LPI_EVENT_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_RX_EEE_LPI_EVENT_COUNTER.
 */
typedef union CLMIB_RX_EEE_LPI_EVENT_COUNTERr_s {
	uint32 v[2];
	uint32 clmib_rx_eee_lpi_event_counter[2];
	uint32 _clmib_rx_eee_lpi_event_counter;
} CLMIB_RX_EEE_LPI_EVENT_COUNTERr_t;

#define CLMIB_RX_EEE_LPI_EVENT_COUNTERr_CLR(r) sal_memset(&((r)._clmib_rx_eee_lpi_event_counter), 0, sizeof(CLMIB_RX_EEE_LPI_EVENT_COUNTERr_t))
#define CLMIB_RX_EEE_LPI_EVENT_COUNTERr_SET(r,i,d) (r).clmib_rx_eee_lpi_event_counter[i] = d
#define CLMIB_RX_EEE_LPI_EVENT_COUNTERr_GET(r,i) (r).clmib_rx_eee_lpi_event_counter[i]


/*
 * These macros can be used to access CLMIB_RX_EEE_LPI_EVENT_COUNTER.
 */
#define WRITE_CLMIB_RX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RX_EEE_LPI_EVENT_COUNTER(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rx_eee_lpi_event_counter),2)
#define READ_CLMIB_RX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_RX_EEE_LPI_EVENT_COUNTER(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_rx_eee_lpi_event_counter),2)

/*******************************************************************************
 * End of 'CLMIB_RX_EEE_LPI_EVENT_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_TBCA
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Transmit Broadcast Frame Counter
 * SIZE:     64
 */
#define CLMIB_TBCAr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_TBCA.
 */
typedef union CLMIB_TBCAr_s {
	uint32 v[2];
	uint32 clmib_tbca[2];
	uint32 _clmib_tbca;
} CLMIB_TBCAr_t;

#define CLMIB_TBCAr_CLR(r) sal_memset(&((r)._clmib_tbca), 0, sizeof(CLMIB_TBCAr_t))
#define CLMIB_TBCAr_SET(r,i,d) (r).clmib_tbca[i] = d
#define CLMIB_TBCAr_GET(r,i) (r).clmib_tbca[i]


/*
 * These macros can be used to access CLMIB_TBCA.
 */
#define WRITE_CLMIB_TBCAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TBCA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tbca),2)
#define READ_CLMIB_TBCAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TBCA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tbca),2)

/*******************************************************************************
 * End of 'CLMIB_TBCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_TBYT
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Transmit Byte Counter
 * SIZE:     64
 */
#define CLMIB_TBYTr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_TBYT.
 */
typedef union CLMIB_TBYTr_s {
	uint32 v[2];
	uint32 clmib_tbyt[2];
	uint32 _clmib_tbyt;
} CLMIB_TBYTr_t;

#define CLMIB_TBYTr_CLR(r) sal_memset(&((r)._clmib_tbyt), 0, sizeof(CLMIB_TBYTr_t))
#define CLMIB_TBYTr_SET(r,i,d) (r).clmib_tbyt[i] = d
#define CLMIB_TBYTr_GET(r,i) (r).clmib_tbyt[i]


/*
 * These macros can be used to access CLMIB_TBYT.
 */
#define WRITE_CLMIB_TBYTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TBYT(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tbyt),2)
#define READ_CLMIB_TBYTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TBYT(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tbyt),2)

/*******************************************************************************
 * End of 'CLMIB_TBYTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_TFCS
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Transmit FCS Error Counter
 * SIZE:     64
 */
#define CLMIB_TFCSr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_TFCS.
 */
typedef union CLMIB_TFCSr_s {
	uint32 v[2];
	uint32 clmib_tfcs[2];
	uint32 _clmib_tfcs;
} CLMIB_TFCSr_t;

#define CLMIB_TFCSr_CLR(r) sal_memset(&((r)._clmib_tfcs), 0, sizeof(CLMIB_TFCSr_t))
#define CLMIB_TFCSr_SET(r,i,d) (r).clmib_tfcs[i] = d
#define CLMIB_TFCSr_GET(r,i) (r).clmib_tfcs[i]


/*
 * These macros can be used to access CLMIB_TFCS.
 */
#define WRITE_CLMIB_TFCSr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TFCS(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tfcs),2)
#define READ_CLMIB_TFCSr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TFCS(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tfcs),2)

/*******************************************************************************
 * End of 'CLMIB_TFCSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_TMCA
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Transmit Multicast Frame Counter
 * SIZE:     64
 */
#define CLMIB_TMCAr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_TMCA.
 */
typedef union CLMIB_TMCAr_s {
	uint32 v[2];
	uint32 clmib_tmca[2];
	uint32 _clmib_tmca;
} CLMIB_TMCAr_t;

#define CLMIB_TMCAr_CLR(r) sal_memset(&((r)._clmib_tmca), 0, sizeof(CLMIB_TMCAr_t))
#define CLMIB_TMCAr_SET(r,i,d) (r).clmib_tmca[i] = d
#define CLMIB_TMCAr_GET(r,i) (r).clmib_tmca[i]


/*
 * These macros can be used to access CLMIB_TMCA.
 */
#define WRITE_CLMIB_TMCAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TMCA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tmca),2)
#define READ_CLMIB_TMCAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TMCA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tmca),2)

/*******************************************************************************
 * End of 'CLMIB_TMCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_TOVR
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Transmit Oversize Packet Counter
 * SIZE:     64
 */
#define CLMIB_TOVRr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_TOVR.
 */
typedef union CLMIB_TOVRr_s {
	uint32 v[2];
	uint32 clmib_tovr[2];
	uint32 _clmib_tovr;
} CLMIB_TOVRr_t;

#define CLMIB_TOVRr_CLR(r) sal_memset(&((r)._clmib_tovr), 0, sizeof(CLMIB_TOVRr_t))
#define CLMIB_TOVRr_SET(r,i,d) (r).clmib_tovr[i] = d
#define CLMIB_TOVRr_GET(r,i) (r).clmib_tovr[i]


/*
 * These macros can be used to access CLMIB_TOVR.
 */
#define WRITE_CLMIB_TOVRr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TOVR(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tovr),2)
#define READ_CLMIB_TOVRr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TOVR(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tovr),2)

/*******************************************************************************
 * End of 'CLMIB_TOVRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_TPKT
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Transmit Packet/Frame Counter
 * SIZE:     64
 */
#define CLMIB_TPKTr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_TPKT.
 */
typedef union CLMIB_TPKTr_s {
	uint32 v[2];
	uint32 clmib_tpkt[2];
	uint32 _clmib_tpkt;
} CLMIB_TPKTr_t;

#define CLMIB_TPKTr_CLR(r) sal_memset(&((r)._clmib_tpkt), 0, sizeof(CLMIB_TPKTr_t))
#define CLMIB_TPKTr_SET(r,i,d) (r).clmib_tpkt[i] = d
#define CLMIB_TPKTr_GET(r,i) (r).clmib_tpkt[i]


/*
 * These macros can be used to access CLMIB_TPKT.
 */
#define WRITE_CLMIB_TPKTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TPKT(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tpkt),2)
#define READ_CLMIB_TPKTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TPKT(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tpkt),2)

/*******************************************************************************
 * End of 'CLMIB_TPKTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_TUCA
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Transmit Unicast Frame Counter
 * SIZE:     64
 */
#define CLMIB_TUCAr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_TUCA.
 */
typedef union CLMIB_TUCAr_s {
	uint32 v[2];
	uint32 clmib_tuca[2];
	uint32 _clmib_tuca;
} CLMIB_TUCAr_t;

#define CLMIB_TUCAr_CLR(r) sal_memset(&((r)._clmib_tuca), 0, sizeof(CLMIB_TUCAr_t))
#define CLMIB_TUCAr_SET(r,i,d) (r).clmib_tuca[i] = d
#define CLMIB_TUCAr_GET(r,i) (r).clmib_tuca[i]


/*
 * These macros can be used to access CLMIB_TUCA.
 */
#define WRITE_CLMIB_TUCAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TUCA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tuca),2)
#define READ_CLMIB_TUCAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TUCA(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tuca),2)

/*******************************************************************************
 * End of 'CLMIB_TUCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_TXPF
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Transmit Pause Control Frame Counter
 * SIZE:     64
 */
#define CLMIB_TXPFr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_TXPF.
 */
typedef union CLMIB_TXPFr_s {
	uint32 v[2];
	uint32 clmib_txpf[2];
	uint32 _clmib_txpf;
} CLMIB_TXPFr_t;

#define CLMIB_TXPFr_CLR(r) sal_memset(&((r)._clmib_txpf), 0, sizeof(CLMIB_TXPFr_t))
#define CLMIB_TXPFr_SET(r,i,d) (r).clmib_txpf[i] = d
#define CLMIB_TXPFr_GET(r,i) (r).clmib_txpf[i]


/*
 * These macros can be used to access CLMIB_TXPF.
 */
#define WRITE_CLMIB_TXPFr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TXPF(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_txpf),2)
#define READ_CLMIB_TXPFr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TXPF(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_txpf),2)

/*******************************************************************************
 * End of 'CLMIB_TXPFr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_TX_EEE_LPI_DURATION_COUNTER
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     TX EEE LPI Duration Counter
 * SIZE:     64
 */
#define CLMIB_TX_EEE_LPI_DURATION_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_TX_EEE_LPI_DURATION_COUNTER.
 */
typedef union CLMIB_TX_EEE_LPI_DURATION_COUNTERr_s {
	uint32 v[2];
	uint32 clmib_tx_eee_lpi_duration_counter[2];
	uint32 _clmib_tx_eee_lpi_duration_counter;
} CLMIB_TX_EEE_LPI_DURATION_COUNTERr_t;

#define CLMIB_TX_EEE_LPI_DURATION_COUNTERr_CLR(r) sal_memset(&((r)._clmib_tx_eee_lpi_duration_counter), 0, sizeof(CLMIB_TX_EEE_LPI_DURATION_COUNTERr_t))
#define CLMIB_TX_EEE_LPI_DURATION_COUNTERr_SET(r,i,d) (r).clmib_tx_eee_lpi_duration_counter[i] = d
#define CLMIB_TX_EEE_LPI_DURATION_COUNTERr_GET(r,i) (r).clmib_tx_eee_lpi_duration_counter[i]


/*
 * These macros can be used to access CLMIB_TX_EEE_LPI_DURATION_COUNTER.
 */
#define WRITE_CLMIB_TX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TX_EEE_LPI_DURATION_COUNTER(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tx_eee_lpi_duration_counter),2)
#define READ_CLMIB_TX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TX_EEE_LPI_DURATION_COUNTER(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tx_eee_lpi_duration_counter),2)

/*******************************************************************************
 * End of 'CLMIB_TX_EEE_LPI_DURATION_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLMIB_TX_EEE_LPI_EVENT_COUNTER
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     TX EEE LPI Event Counter
 * SIZE:     64
 */
#define CLMIB_TX_EEE_LPI_EVENT_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program CLMIB_TX_EEE_LPI_EVENT_COUNTER.
 */
typedef union CLMIB_TX_EEE_LPI_EVENT_COUNTERr_s {
	uint32 v[2];
	uint32 clmib_tx_eee_lpi_event_counter[2];
	uint32 _clmib_tx_eee_lpi_event_counter;
} CLMIB_TX_EEE_LPI_EVENT_COUNTERr_t;

#define CLMIB_TX_EEE_LPI_EVENT_COUNTERr_CLR(r) sal_memset(&((r)._clmib_tx_eee_lpi_event_counter), 0, sizeof(CLMIB_TX_EEE_LPI_EVENT_COUNTERr_t))
#define CLMIB_TX_EEE_LPI_EVENT_COUNTERr_SET(r,i,d) (r).clmib_tx_eee_lpi_event_counter[i] = d
#define CLMIB_TX_EEE_LPI_EVENT_COUNTERr_GET(r,i) (r).clmib_tx_eee_lpi_event_counter[i]


/*
 * These macros can be used to access CLMIB_TX_EEE_LPI_EVENT_COUNTER.
 */
#define WRITE_CLMIB_TX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TX_EEE_LPI_EVENT_COUNTER(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tx_eee_lpi_event_counter),2)
#define READ_CLMIB_TX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLMIB_TX_EEE_LPI_EVENT_COUNTER(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clmib_tx_eee_lpi_event_counter),2)

/*******************************************************************************
 * End of 'CLMIB_TX_EEE_LPI_EVENT_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLPORT_CNTMAXSIZE
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     PORT MIB logic CNTMAXSIZE register
 * SIZE:     32
 * FIELDS:
 *     CNTMAXSIZE       The max packet size that is used in statistic counter update. Default to 1518.
 */
#define CLPORT_CNTMAXSIZEr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_CNTMAXSIZE.
 */
typedef union CLPORT_CNTMAXSIZEr_s {
	uint32 v[1];
	uint32 clport_cntmaxsize[1];
	uint32 _clport_cntmaxsize;
} CLPORT_CNTMAXSIZEr_t;

#define CLPORT_CNTMAXSIZEr_CLR(r) (r).clport_cntmaxsize[0] = 0
#define CLPORT_CNTMAXSIZEr_SET(r,d) (r).clport_cntmaxsize[0] = d
#define CLPORT_CNTMAXSIZEr_GET(r) (r).clport_cntmaxsize[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET(r) (((r).clport_cntmaxsize[0]) & 0x3fff)
#define CLPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET(r,f) (r).clport_cntmaxsize[0]=(((r).clport_cntmaxsize[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))

/*
 * These macros can be used to access CLPORT_CNTMAXSIZE.
 */
#define WRITE_CLPORT_CNTMAXSIZEr(u,p,r) bcm5607x_reg_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_CNTMAXSIZE(bcm5607x_clport_lport_to_index_in_block[p]), (r._clport_cntmaxsize))
#define READ_CLPORT_CNTMAXSIZEr(u,p,r) bcm5607x_reg_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_CNTMAXSIZE(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clport_cntmaxsize))

/*******************************************************************************
 * End of 'CLPORT_CNTMAXSIZEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLPORT_ENABLE_REG
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     CLPORT Enable Register.  In an CLPORT instance, enables subports 0..3 
 * SIZE:     32
 * FIELDS:
 *     PORT0            Enable Sub-Port 0.  
 *     PORT1            Enable Sub-Port 1.  
 *     PORT2            Enable Sub-Port 2.  
 *     PORT3            Enable Sub-Port 3.  
 */
#define CLPORT_ENABLE_REGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_ENABLE_REG.
 */
typedef union CLPORT_ENABLE_REGr_s {
	uint32 v[1];
	uint32 clport_enable_reg[1];
	uint32 _clport_enable_reg;
} CLPORT_ENABLE_REGr_t;

#define CLPORT_ENABLE_REGr_CLR(r) (r).clport_enable_reg[0] = 0
#define CLPORT_ENABLE_REGr_SET(r,d) (r).clport_enable_reg[0] = d
#define CLPORT_ENABLE_REGr_GET(r) (r).clport_enable_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_ENABLE_REGr_PORT0f_GET(r) (((r).clport_enable_reg[0]) & 0x1)
#define CLPORT_ENABLE_REGr_PORT0f_SET(r,f) (r).clport_enable_reg[0]=(((r).clport_enable_reg[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLPORT_ENABLE_REGr_PORT1f_GET(r) ((((r).clport_enable_reg[0]) >> 1) & 0x1)
#define CLPORT_ENABLE_REGr_PORT1f_SET(r,f) (r).clport_enable_reg[0]=(((r).clport_enable_reg[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CLPORT_ENABLE_REGr_PORT2f_GET(r) ((((r).clport_enable_reg[0]) >> 2) & 0x1)
#define CLPORT_ENABLE_REGr_PORT2f_SET(r,f) (r).clport_enable_reg[0]=(((r).clport_enable_reg[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CLPORT_ENABLE_REGr_PORT3f_GET(r) ((((r).clport_enable_reg[0]) >> 3) & 0x1)
#define CLPORT_ENABLE_REGr_PORT3f_SET(r,f) (r).clport_enable_reg[0]=(((r).clport_enable_reg[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))

/*
 * These macros can be used to access CLPORT_ENABLE_REG.
 */
#define WRITE_CLPORT_ENABLE_REGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_ENABLE_REG, (r._clport_enable_reg))
#define READ_CLPORT_ENABLE_REGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_ENABLE_REG, &(r._clport_enable_reg))

/*******************************************************************************
 * End of 'CLPORT_ENABLE_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLPORT_FAULT_LINK_STATUS
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Config to use Fault to gate external Link Status signals to CMIC
 * SIZE:     32
 * FIELDS:
 *     REMOTE_FAULT     If enabled, allows external Remote Fault signal to indicate link is down to CMIC.
 *     LOCAL_FAULT      If enabled, allows Local Fault signal to indicate link is down to CMIC.
 */
#define CLPORT_FAULT_LINK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_FAULT_LINK_STATUS.
 */
typedef union CLPORT_FAULT_LINK_STATUSr_s {
	uint32 v[1];
	uint32 clport_fault_link_status[1];
	uint32 _clport_fault_link_status;
} CLPORT_FAULT_LINK_STATUSr_t;

#define CLPORT_FAULT_LINK_STATUSr_CLR(r) (r).clport_fault_link_status[0] = 0
#define CLPORT_FAULT_LINK_STATUSr_SET(r,d) (r).clport_fault_link_status[0] = d
#define CLPORT_FAULT_LINK_STATUSr_GET(r) (r).clport_fault_link_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_FAULT_LINK_STATUSr_REMOTE_FAULTf_GET(r) (((r).clport_fault_link_status[0]) & 0x1)
#define CLPORT_FAULT_LINK_STATUSr_REMOTE_FAULTf_SET(r,f) (r).clport_fault_link_status[0]=(((r).clport_fault_link_status[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLPORT_FAULT_LINK_STATUSr_LOCAL_FAULTf_GET(r) ((((r).clport_fault_link_status[0]) >> 1) & 0x1)
#define CLPORT_FAULT_LINK_STATUSr_LOCAL_FAULTf_SET(r,f) (r).clport_fault_link_status[0]=(((r).clport_fault_link_status[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access CLPORT_FAULT_LINK_STATUS.
 */
#define WRITE_CLPORT_FAULT_LINK_STATUSr(u,p,r) bcm5607x_reg_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_FAULT_LINK_STATUS(bcm5607x_clport_lport_to_index_in_block[p]), (r._clport_fault_link_status))
#define READ_CLPORT_FAULT_LINK_STATUSr(u,p,r) bcm5607x_reg_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_FAULT_LINK_STATUS(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clport_fault_link_status))

/*******************************************************************************
 * End of 'CLPORT_FAULT_LINK_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLPORT_MAC_CONTROL
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     CLPORT MAC Control Register
 * SIZE:     32
 * FIELDS:
 *     XMAC0_RESET      Software control CLMAC in CLPORT core0 reset (active High).
 *     XMAC0_BYPASS_OSTS Bypass OSTS path in CLMAC to improve latency.
 *     RX_FLEX_TDM_ENABLE Enable CLMAC flexible tdm for less latency.
 *     RX_NON_LINEAR_QUAD_TDM_EN Enable CLMAC non-linear tdm order 0-2-1-3.
 *     SYS_16B_INTF_MODE Enable CLMAC 16 Byte interface mode.
 *     RX_DUAL_CYCLE_TDM_EN When set, RX CDC FIFO port ID read TDM order will change only on even cycles, ie each port is valid for 2 consecutive cycles.ie When set, order is 0 -> 0 -> 1 -> 1 -> 2 -> 2 -> 3 -> 3. Else, order is 0 -> 1 -> 2 -> 3 -> 0 -> 1 -> 2 -> 3.
 *     CLMAC_TS_DISABLE CLMAC timestamp disable. 1 = disable MAC timestamp, use TSC for timestamp instead. 0 = legacy mode, use MAC for timestamp
 */
#define CLPORT_MAC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_MAC_CONTROL.
 */
typedef union CLPORT_MAC_CONTROLr_s {
	uint32 v[1];
	uint32 clport_mac_control[1];
	uint32 _clport_mac_control;
} CLPORT_MAC_CONTROLr_t;

#define CLPORT_MAC_CONTROLr_CLR(r) (r).clport_mac_control[0] = 0
#define CLPORT_MAC_CONTROLr_SET(r,d) (r).clport_mac_control[0] = d
#define CLPORT_MAC_CONTROLr_GET(r) (r).clport_mac_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_MAC_CONTROLr_XMAC0_RESETf_GET(r) (((r).clport_mac_control[0]) & 0x1)
#define CLPORT_MAC_CONTROLr_XMAC0_RESETf_SET(r,f) (r).clport_mac_control[0]=(((r).clport_mac_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLPORT_MAC_CONTROLr_XMAC0_BYPASS_OSTSf_GET(r) ((((r).clport_mac_control[0]) >> 1) & 0x1)
#define CLPORT_MAC_CONTROLr_XMAC0_BYPASS_OSTSf_SET(r,f) (r).clport_mac_control[0]=(((r).clport_mac_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CLPORT_MAC_CONTROLr_RX_FLEX_TDM_ENABLEf_GET(r) ((((r).clport_mac_control[0]) >> 2) & 0x1)
#define CLPORT_MAC_CONTROLr_RX_FLEX_TDM_ENABLEf_SET(r,f) (r).clport_mac_control[0]=(((r).clport_mac_control[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CLPORT_MAC_CONTROLr_RX_NON_LINEAR_QUAD_TDM_ENf_GET(r) ((((r).clport_mac_control[0]) >> 3) & 0x1)
#define CLPORT_MAC_CONTROLr_RX_NON_LINEAR_QUAD_TDM_ENf_SET(r,f) (r).clport_mac_control[0]=(((r).clport_mac_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CLPORT_MAC_CONTROLr_SYS_16B_INTF_MODEf_GET(r) ((((r).clport_mac_control[0]) >> 4) & 0x1)
#define CLPORT_MAC_CONTROLr_SYS_16B_INTF_MODEf_SET(r,f) (r).clport_mac_control[0]=(((r).clport_mac_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CLPORT_MAC_CONTROLr_RX_DUAL_CYCLE_TDM_ENf_GET(r) ((((r).clport_mac_control[0]) >> 5) & 0x1)
#define CLPORT_MAC_CONTROLr_RX_DUAL_CYCLE_TDM_ENf_SET(r,f) (r).clport_mac_control[0]=(((r).clport_mac_control[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CLPORT_MAC_CONTROLr_CLMAC_TS_DISABLEf_GET(r) ((((r).clport_mac_control[0]) >> 6) & 0x1)
#define CLPORT_MAC_CONTROLr_CLMAC_TS_DISABLEf_SET(r,f) (r).clport_mac_control[0]=(((r).clport_mac_control[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))

/*
 * These macros can be used to access CLPORT_MAC_CONTROL.
 */
#define WRITE_CLPORT_MAC_CONTROLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_MAC_CONTROL, (r._clport_mac_control))
#define READ_CLPORT_MAC_CONTROLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_MAC_CONTROL, &(r._clport_mac_control))

/*******************************************************************************
 * End of 'CLPORT_MAC_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLPORT_MAC_RSV_MASK
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     MAC RSV MASK Register
 * SIZE:     32
 * FIELDS:
 *     MASK             Control which RSV event cause "purge" event that triggers RXERR to be set for the packet by the MAC.Valid for CLMAC .  Drives rsv_err_mask[46:16] for CLMAC .Below is one snapshot of how MASK bits are mapped to each MAC.  Please refer to CLMAC spec for latest RSV bit definitions.bit[31:31]            --> Reservedadded for gen3:bit[30] masks RSV[46] --> MacMerge Frame SAS (sop after sop) errorbit[29] masks RSV[45] --> MM_discardbit[28] masks RSV[44] --> Final mframebit[27] masks RSV[43] --> MacMerge Frame OOS (out of sequence) errorbit[26] masks RSV[42] --> MacMerge SMD errorbit[25] masks RSV[41] --> Reply mframebit[24] masks RSV[40] --> Verify mframebit[23] masks RSV[39] --> Fragmentbit[22] masks RSV[38] --> Pre-emptable mframeoriginal gen2:bit[21] masks RSV[37] --> Dribble Nibble Error detectedbit[20] masks RSV[36] --> MACSEC CRC Match detectedbit[19] masks RSV[35] --> SCH CRC Error detectedbit[18] masks RSV[34] --> PFC frame detectedbit[17] masks RSV[33] --> RUNT detectedbit[16] masks RSV[32] --> RX FIFO fullbit[15] masks RSV[31] --> Unicast detectedbit[14] masks RSV[30] --> VLAN tag detectedbit[13] masks RSV[29] --> Unsupported opcode detectedbit[12] masks RSV[28] --> Pause frame receivedbit[11] masks RSV[27] --> Control frame receivedbit[10] masks RSV[26] --> Promiscuous packet detectedbit[ 9] masks RSV[25] --> Broadcast detectedbit[ 8] masks RSV[24] --> Multicast detectedbit[ 7] masks RSV[23] --> Receive OKbit[ 6] masks RSV[22] --> Truncated/Frame out of Rangebit[ 5] masks RSV[21] --> Frame length not out of range, but incorrect -- IEEE length check failedbit[ 4] masks RSV[20] --> CRC errorbit[ 3] masks RSV[19] --> Receive terminate/code errorbit[ 2] masks RSV[18] --> Unsupported DA for pause/PFC packets detectedbit[ 1] masks RSV[17] --> Stack VLAN detectedbit[ 0] masks RSV[16] --> Wrong SA
 */
#define CLPORT_MAC_RSV_MASKr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_MAC_RSV_MASK.
 */
typedef union CLPORT_MAC_RSV_MASKr_s {
	uint32 v[1];
	uint32 clport_mac_rsv_mask[1];
	uint32 _clport_mac_rsv_mask;
} CLPORT_MAC_RSV_MASKr_t;

#define CLPORT_MAC_RSV_MASKr_CLR(r) (r).clport_mac_rsv_mask[0] = 0
#define CLPORT_MAC_RSV_MASKr_SET(r,d) (r).clport_mac_rsv_mask[0] = d
#define CLPORT_MAC_RSV_MASKr_GET(r) (r).clport_mac_rsv_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_MAC_RSV_MASKr_MASKf_GET(r) (((r).clport_mac_rsv_mask[0]) & 0x7fffffff)
#define CLPORT_MAC_RSV_MASKr_MASKf_SET(r,f) (r).clport_mac_rsv_mask[0]=(((r).clport_mac_rsv_mask[0] & ~((uint32)0x7fffffff)) | (((uint32)f) & 0x7fffffff))

/*
 * These macros can be used to access CLPORT_MAC_RSV_MASK.
 */
#define WRITE_CLPORT_MAC_RSV_MASKr(u,p,r) bcm5607x_reg_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_MAC_RSV_MASK(bcm5607x_clport_lport_to_index_in_block[p]), (r._clport_mac_rsv_mask))
#define READ_CLPORT_MAC_RSV_MASKr(u,p,r) bcm5607x_reg_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_MAC_RSV_MASK(bcm5607x_clport_lport_to_index_in_block[p]), &(r._clport_mac_rsv_mask))

/*******************************************************************************
 * End of 'CLPORT_MAC_RSV_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLPORT_MIB_RESET
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     CLPORT MIB Counters Reset
 * SIZE:     32
 * FIELDS:
 *     CLR_CNT          Reset for CLPORT per subport MIB Statistic Countersbit[3]  = Port 3 MIB all counters resetbit[2]  = Port 2 MIB all counters resetbit[1]  = Port 1 MIB all counters resetbit[0]  = Port 0 MIB all counters reset
 */
#define CLPORT_MIB_RESETr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_MIB_RESET.
 */
typedef union CLPORT_MIB_RESETr_s {
	uint32 v[1];
	uint32 clport_mib_reset[1];
	uint32 _clport_mib_reset;
} CLPORT_MIB_RESETr_t;

#define CLPORT_MIB_RESETr_CLR(r) (r).clport_mib_reset[0] = 0
#define CLPORT_MIB_RESETr_SET(r,d) (r).clport_mib_reset[0] = d
#define CLPORT_MIB_RESETr_GET(r) (r).clport_mib_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_MIB_RESETr_CLR_CNTf_GET(r) (((r).clport_mib_reset[0]) & 0xf)
#define CLPORT_MIB_RESETr_CLR_CNTf_SET(r,f) (r).clport_mib_reset[0]=(((r).clport_mib_reset[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))

/*
 * These macros can be used to access CLPORT_MIB_RESET.
 */
#define WRITE_CLPORT_MIB_RESETr(u,p,r) bcm5607x_reg_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_MIB_RESET, (r._clport_mib_reset))
#define READ_CLPORT_MIB_RESETr(u,p,r) bcm5607x_reg_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_MIB_RESET, &(r._clport_mib_reset))

/*******************************************************************************
 * End of 'CLPORT_MIB_RESETr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLPORT_MODE_REG
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     PORT Mode Register
 * SIZE:     32
 * FIELDS:
 *     XPORT0_PHY_PORT_MODE XLPort PHY Side Port Mode.  Applies to one of xlport0..3 depending on sbus block id. This has no effect in CPORT
 *     XPORT0_CORE_PORT_MODE XLPort Core CORE Side Port Mode.  Applies to one of xlport0..3 depending on sbus block id.
 *     EGR_1588_TIMESTAMPING_MODE enables legacy sign-extension of 32-bit timestamp or enables 48-bit time-stamping. default is 32-bit.
 *     OSTS_TIMER_DISABLE This active high signal is used to disable the OSTS time-stamping function in the MAC when asserted during the time the CPU Is initializing the local counters
 *     TS_TIMER_OVERRIDE DEBUG only.  Leave at 0 for regular operation.  Write 1 to select TS_TIMER_OVERRIDE_VALUE[31:0] to CLMAC, instead of TS_TIMER_VALUE from CMIC, the ts_counter loads TS_TIMER_OVERRIDE_VALUE when setting this bit to 1, ts_counter continue to incremet with ts_clk, set this bit to 0 to use original TS_TIMER_VALUE[31:0] from CMIC
 *     EGR_1588_TIMESTAMPING_CMIC_48_EN write 1 to select CMIC's TS_TIMER_OVERRIDE_VALUE[47:0] to CLMAC. When set to 1, it will override TS_TIMER_OVERRIDE function.
 *     SINGLE_PORT_MODE_SPEED_100G At single port mode, write 1 to indicate 100G/120G speed.
 */
#define CLPORT_MODE_REGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_MODE_REG.
 */
typedef union CLPORT_MODE_REGr_s {
	uint32 v[1];
	uint32 clport_mode_reg[1];
	uint32 _clport_mode_reg;
} CLPORT_MODE_REGr_t;

#define CLPORT_MODE_REGr_CLR(r) (r).clport_mode_reg[0] = 0
#define CLPORT_MODE_REGr_SET(r,d) (r).clport_mode_reg[0] = d
#define CLPORT_MODE_REGr_GET(r) (r).clport_mode_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_MODE_REGr_XPORT0_PHY_PORT_MODEf_GET(r) (((r).clport_mode_reg[0]) & 0x7)
#define CLPORT_MODE_REGr_XPORT0_PHY_PORT_MODEf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define CLPORT_MODE_REGr_XPORT0_CORE_PORT_MODEf_GET(r) ((((r).clport_mode_reg[0]) >> 3) & 0x7)
#define CLPORT_MODE_REGr_XPORT0_CORE_PORT_MODEf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define CLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_MODEf_GET(r) ((((r).clport_mode_reg[0]) >> 6) & 0x1)
#define CLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_MODEf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CLPORT_MODE_REGr_OSTS_TIMER_DISABLEf_GET(r) ((((r).clport_mode_reg[0]) >> 7) & 0x1)
#define CLPORT_MODE_REGr_OSTS_TIMER_DISABLEf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CLPORT_MODE_REGr_TS_TIMER_OVERRIDEf_GET(r) ((((r).clport_mode_reg[0]) >> 8) & 0x1)
#define CLPORT_MODE_REGr_TS_TIMER_OVERRIDEf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_CMIC_48_ENf_GET(r) ((((r).clport_mode_reg[0]) >> 9) & 0x1)
#define CLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_CMIC_48_ENf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CLPORT_MODE_REGr_SINGLE_PORT_MODE_SPEED_100Gf_GET(r) ((((r).clport_mode_reg[0]) >> 10) & 0x1)
#define CLPORT_MODE_REGr_SINGLE_PORT_MODE_SPEED_100Gf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))

/*
 * These macros can be used to access CLPORT_MODE_REG.
 */
#define WRITE_CLPORT_MODE_REGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_MODE_REG, (r._clport_mode_reg))
#define READ_CLPORT_MODE_REGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_MODE_REG, &(r._clport_mode_reg))

/*******************************************************************************
 * End of 'CLPORT_MODE_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLPORT_SOFT_RESET
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Deprecated. PORT Soft Reset per subport CLPORT CORE block.  Active high signal. 
 * SIZE:     32
 * FIELDS:
 *     PORT0            Reset Sub-Port 0.  
 *     PORT1            Reset Sub-Port 1.  
 *     PORT2            Reset Sub-Port 2.  
 *     PORT3            Reset Sub-Port 3.  
 *     RESERVED4        Reserved.
 */
#define CLPORT_SOFT_RESETr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_SOFT_RESET.
 */
typedef union CLPORT_SOFT_RESETr_s {
	uint32 v[1];
	uint32 clport_soft_reset[1];
	uint32 _clport_soft_reset;
} CLPORT_SOFT_RESETr_t;

#define CLPORT_SOFT_RESETr_CLR(r) (r).clport_soft_reset[0] = 0
#define CLPORT_SOFT_RESETr_SET(r,d) (r).clport_soft_reset[0] = d
#define CLPORT_SOFT_RESETr_GET(r) (r).clport_soft_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_SOFT_RESETr_PORT0f_GET(r) (((r).clport_soft_reset[0]) & 0x1)
#define CLPORT_SOFT_RESETr_PORT0f_SET(r,f) (r).clport_soft_reset[0]=(((r).clport_soft_reset[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLPORT_SOFT_RESETr_PORT1f_GET(r) ((((r).clport_soft_reset[0]) >> 1) & 0x1)
#define CLPORT_SOFT_RESETr_PORT1f_SET(r,f) (r).clport_soft_reset[0]=(((r).clport_soft_reset[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CLPORT_SOFT_RESETr_PORT2f_GET(r) ((((r).clport_soft_reset[0]) >> 2) & 0x1)
#define CLPORT_SOFT_RESETr_PORT2f_SET(r,f) (r).clport_soft_reset[0]=(((r).clport_soft_reset[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CLPORT_SOFT_RESETr_PORT3f_GET(r) ((((r).clport_soft_reset[0]) >> 3) & 0x1)
#define CLPORT_SOFT_RESETr_PORT3f_SET(r,f) (r).clport_soft_reset[0]=(((r).clport_soft_reset[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CLPORT_SOFT_RESETr_RESERVED4f_GET(r) ((((r).clport_soft_reset[0]) >> 4) & 0x1)
#define CLPORT_SOFT_RESETr_RESERVED4f_SET(r,f) (r).clport_soft_reset[0]=(((r).clport_soft_reset[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))

/*
 * These macros can be used to access CLPORT_SOFT_RESET.
 */
#define WRITE_CLPORT_SOFT_RESETr(u,p,r) bcm5607x_reg_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_SOFT_RESET, (r._clport_soft_reset))
#define READ_CLPORT_SOFT_RESETr(u,p,r) bcm5607x_reg_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_SOFT_RESET, &(r._clport_soft_reset))

/*******************************************************************************
 * End of 'CLPORT_SOFT_RESETr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLPORT_WC_UCMEM_CTRL
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     PORT to TSC micro-controller Memory (extmem) Control Register.  Configures FSM in Port.
 * SIZE:     32
 * FIELDS:
 *     ACCESS_MODE      External Memory Controls Access   1'b0 - access registers in TSC   1'b1 - access ucode memory in TSC
 *     RSVD3_1          reserved
 */
#define CLPORT_WC_UCMEM_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_WC_UCMEM_CTRL.
 */
typedef union CLPORT_WC_UCMEM_CTRLr_s {
	uint32 v[1];
	uint32 clport_wc_ucmem_ctrl[1];
	uint32 _clport_wc_ucmem_ctrl;
} CLPORT_WC_UCMEM_CTRLr_t;

#define CLPORT_WC_UCMEM_CTRLr_CLR(r) (r).clport_wc_ucmem_ctrl[0] = 0
#define CLPORT_WC_UCMEM_CTRLr_SET(r,d) (r).clport_wc_ucmem_ctrl[0] = d
#define CLPORT_WC_UCMEM_CTRLr_GET(r) (r).clport_wc_ucmem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_WC_UCMEM_CTRLr_ACCESS_MODEf_GET(r) (((r).clport_wc_ucmem_ctrl[0]) & 0x1)
#define CLPORT_WC_UCMEM_CTRLr_ACCESS_MODEf_SET(r,f) (r).clport_wc_ucmem_ctrl[0]=(((r).clport_wc_ucmem_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLPORT_WC_UCMEM_CTRLr_RSVD3_1f_GET(r) ((((r).clport_wc_ucmem_ctrl[0]) >> 1) & 0x7)
#define CLPORT_WC_UCMEM_CTRLr_RSVD3_1f_SET(r,f) (r).clport_wc_ucmem_ctrl[0]=(((r).clport_wc_ucmem_ctrl[0] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))

/*
 * These macros can be used to access CLPORT_WC_UCMEM_CTRL.
 */
#define WRITE_CLPORT_WC_UCMEM_CTRLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_WC_UCMEM_CTRL, (r._clport_wc_ucmem_ctrl))
#define READ_CLPORT_WC_UCMEM_CTRLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_WC_UCMEM_CTRL, &(r._clport_wc_ucmem_ctrl))

/*******************************************************************************
 * End of 'CLPORT_WC_UCMEM_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  CLPORT_WC_UCMEM_DATA
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Warpcore External Memory Interface to program micro-controller memory
 * SIZE:     128
 * FIELDS:
 *     UC_DATA           16-Bytes of data for TSC uC memory or TSC registers. In TSC ucode mem access mode (CLPORT_WC_UCMEM_CTRL == 1), the memory write to the UCMEM address zero contains 128b (16Bytes) of data to be written to PMD uC memory.  Logic  external to the UCMEM mechanism maintains the address of the PMD uC memory that is updated with the data carried with  the memory write to the UCMEM.  Therefore, all accesses are to address zero of the UCMEM.  TSC regsiter mode accesses (CLPORT_WC_UCMEM_CTRL == 0) do not use the sbus address, so extra steps must be taken to perform TSC reg reads.  Another difference from ucode mem accesses is that rd/wr data is only 2B.  TSC register reads are indirect and must be done in two steps:  write followed by read.  The write is used to save the needed TSC register address for the subsequent TSC reg read. TSC register writes are done in one step. While in TSC reg mode ( CLPORT_WC_UCMEM_CTRL == 0), an sbus write to this memory, with bit [64] == 1 indicates single step TSC reg write. If  bit [64] == 0, a two-step read is indicated, and the address in bits[31:0] is saved. A subsequent sbus read will perform the TSC reg read using the saved address.  The read data will be stored in bits [47:32].  
 */
#define CLPORT_WC_UCMEM_DATAm_MIN 0
#define CLPORT_WC_UCMEM_DATAm_MAX 4095
#define CLPORT_WC_UCMEM_DATAm_CMAX(u) 4095
#define CLPORT_WC_UCMEM_DATAm_SIZE 16

/*
 * This structure should be used to declare and program CLPORT_WC_UCMEM_DATA.
 */
typedef union CLPORT_WC_UCMEM_DATAm_s {
	uint32 v[4];
	uint32 clport_wc_ucmem_data[4];
	uint32 _clport_wc_ucmem_data;
} CLPORT_WC_UCMEM_DATAm_t;

#define CLPORT_WC_UCMEM_DATAm_CLR(r) sal_memset(&((r)._clport_wc_ucmem_data), 0, sizeof(CLPORT_WC_UCMEM_DATAm_t))
#define CLPORT_WC_UCMEM_DATAm_SET(r,i,d) (r).clport_wc_ucmem_data[i] = d
#define CLPORT_WC_UCMEM_DATAm_GET(r,i) (r).clport_wc_ucmem_data[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_WC_UCMEM_DATAm_UC_DATAf_GET(r,a) field_get((r).clport_wc_ucmem_data,0,127,a)
#define CLPORT_WC_UCMEM_DATAm_UC_DATAf_SET(r,a) field_set((r).clport_wc_ucmem_data,0,127,a)

/*
 * These macros can be used to access CLPORT_WC_UCMEM_DATA.
 */
#define WRITE_CLPORT_WC_UCMEM_DATAm(u,p,i,r) bcm5607x_mem_set(u, bcm5607x_clport_lport_to_blockid[p], M_CLPORT_WC_UCMEM_DATA(i), &(r._clport_wc_ucmem_data), 4)
#define READ_CLPORT_WC_UCMEM_DATAm(u,p,i,r) bcm5607x_mem_get(u, bcm5607x_clport_lport_to_blockid[p], M_CLPORT_WC_UCMEM_DATA(i), &(r._clport_wc_ucmem_data), 4)

/*******************************************************************************
 * End of 'CLPORT_WC_UCMEM_DATAm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CLPORT_XGXS0_CTRL_REG
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     Controls for TSC.  CLPORT_XGXS0_CTRL_REG exists on a per port macro basis to control each TSC. 
 * SIZE:     32
 * FIELDS:
 *     RSTB_HW          Hard reset (active low).  Resets everything.
 *     REFOUT_EN        Enables LCREFOUT to be driven by this TSC.
 *     REFIN_EN         Selects between pad and LCREF as source of refclk into this TSC PLL
 *     PWRDWN           TSC Power Down. Powers down TSC analog circuits.
 *     IDDQ             Shutdown analog clocks but leave analog section powered.
 *     PLL0_REFOUT_EN   PLL0: Enables the refclk to drive pll0_refoutp/n. 0 = hiZ, 1 = pad_pll0_refclkp/n. Valid only for Gen3(28nm), don't care for Gen3(16nm).
 *     PLL0_REFIN_EN    PLL0: Selects between pad and LCREF mux as source of refclk into this TSC PLL. 0 = pad_pll0_refclkp/n, 1 = output of mux controlled by PLL0_LC_RefSel. Valid only for Gen3(28nm), don't care for Gen3(16nm).
 *     PLL0_LC_REFSEL   PLL0: LC reference clock select. 0 = pll0_lcref, 1 = pll1_lcref. Valid only for Gen3(28nm), don't care for Gen3(16nm).
 *     PLL1_REFOUT_EN   PLL1: Enables the refclk to drive pll1_refoutp/n. 0 = hiZ, 1 = pad_pll1_refclkp/n. Valid only for Gen3(28nm), don't care for Gen3(16nm).
 *     PLL1_REFIN_EN    PLL1: Selects between pad and LCREF mux as source of refclk into this TSC PLL. 0 = pad_pll1_refclkp/n, 1 = output of mux controlled by PLL1_LC_RefSel. Valid only for Gen3(28nm), don't care for Gen3(16nm).
 *     PLL1_LC_REFSEL   PLL1: LC reference clock select. 0 = pll1_lcref, 1 = pll0_lcref (note: reverse behavior of PLL0_LC_RefSel). Valid only for Gen3(28nm), don't care for Gen3(16nm).
 *     TSC_CLK_SEL      TSC clock select between pll0 and pll1. 0 = pmd_pll0_vcoclk4pcs, 1 = pmd_pll1_vcoclk4pcs. Valid only for Gen3(28nm), don't care for Gen3(16nm).
 *     EXT_TSC_CLK_EN   TSC clock select between internal tsc_clk and external tscf_dp_clk (688Mhz). 0 = pmd_pll0_vcoclk4pcs/pmd_pll1_vcoclk4pcs, 1 = tscf_dp_clk. Valid only for Gen3(28nm), don't care for Gen3(16nm)
 */
#define CLPORT_XGXS0_CTRL_REGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_XGXS0_CTRL_REG.
 */
typedef union CLPORT_XGXS0_CTRL_REGr_s {
	uint32 v[1];
	uint32 clport_xgxs0_ctrl_reg[1];
	uint32 _clport_xgxs0_ctrl_reg;
} CLPORT_XGXS0_CTRL_REGr_t;

#define CLPORT_XGXS0_CTRL_REGr_CLR(r) (r).clport_xgxs0_ctrl_reg[0] = 0
#define CLPORT_XGXS0_CTRL_REGr_SET(r,d) (r).clport_xgxs0_ctrl_reg[0] = d
#define CLPORT_XGXS0_CTRL_REGr_GET(r) (r).clport_xgxs0_ctrl_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_XGXS0_CTRL_REGr_RSTB_HWf_GET(r) (((r).clport_xgxs0_ctrl_reg[0]) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_RSTB_HWf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CLPORT_XGXS0_CTRL_REGr_REFOUT_ENf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 1) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_REFOUT_ENf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CLPORT_XGXS0_CTRL_REGr_REFIN_ENf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 2) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_REFIN_ENf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CLPORT_XGXS0_CTRL_REGr_PWRDWNf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 3) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_PWRDWNf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CLPORT_XGXS0_CTRL_REGr_IDDQf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 4) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_IDDQf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CLPORT_XGXS0_CTRL_REGr_PLL0_REFOUT_ENf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 5) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_PLL0_REFOUT_ENf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CLPORT_XGXS0_CTRL_REGr_PLL0_REFIN_ENf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 6) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_PLL0_REFIN_ENf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CLPORT_XGXS0_CTRL_REGr_PLL0_LC_REFSELf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 7) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_PLL0_LC_REFSELf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CLPORT_XGXS0_CTRL_REGr_PLL1_REFOUT_ENf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 8) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_PLL1_REFOUT_ENf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CLPORT_XGXS0_CTRL_REGr_PLL1_REFIN_ENf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 9) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_PLL1_REFIN_ENf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CLPORT_XGXS0_CTRL_REGr_PLL1_LC_REFSELf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 10) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_PLL1_LC_REFSELf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define CLPORT_XGXS0_CTRL_REGr_TSC_CLK_SELf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 11) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_TSC_CLK_SELf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define CLPORT_XGXS0_CTRL_REGr_EXT_TSC_CLK_ENf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 12) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_EXT_TSC_CLK_ENf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))

/*
 * These macros can be used to access CLPORT_XGXS0_CTRL_REG.
 */
#define WRITE_CLPORT_XGXS0_CTRL_REGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_XGXS0_CTRL_REG, (r._clport_xgxs0_ctrl_reg))
#define READ_CLPORT_XGXS0_CTRL_REGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_clport_lport_to_blockid[p], R_CLPORT_XGXS0_CTRL_REG, &(r._clport_xgxs0_ctrl_reg))

/*******************************************************************************
 * End of 'CLPORT_XGXS0_CTRL_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMICX_M0_IDM_IO_CONTROL_DIRECT
 * BLOCKS:   IPROC
 * DESC:     IO Control Direct register
 * SIZE:     32
 * FIELDS:
 *     RESET_ENABLE_FROM_NIC If set, resetn from NIC will be driven to CMICD. Otherwise it is always out of reset.
 *     ARPROT           ARPROT setting
 *     AWCACHE          AXI AWCACHE 
 *     AWPROT           AWPROT setting
 *     ARCACHE          AXI ARCACHE 
 *     AWUSER           AXI AWUSER
 *     ARUSER           AXI ARUSER
 */
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_SIZE 4

/*
 * This structure should be used to declare and program CMICX_M0_IDM_IO_CONTROL_DIRECT.
 */
typedef union CMICX_M0_IDM_IO_CONTROL_DIRECTr_s {
	uint32 v[1];
	uint32 cmicx_m0_idm_io_control_direct[1];
	uint32 _cmicx_m0_idm_io_control_direct;
} CMICX_M0_IDM_IO_CONTROL_DIRECTr_t;

#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_CLR(r) (r).cmicx_m0_idm_io_control_direct[0] = 0
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_SET(r,d) (r).cmicx_m0_idm_io_control_direct[0] = d
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_GET(r) (r).cmicx_m0_idm_io_control_direct[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_RESET_ENABLE_FROM_NICf_GET(r) ((((r).cmicx_m0_idm_io_control_direct[0]) >> 2) & 0x1)
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_RESET_ENABLE_FROM_NICf_SET(r,f) (r).cmicx_m0_idm_io_control_direct[0]=(((r).cmicx_m0_idm_io_control_direct[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_ARPROTf_GET(r) ((((r).cmicx_m0_idm_io_control_direct[0]) >> 3) & 0x7)
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_ARPROTf_SET(r,f) (r).cmicx_m0_idm_io_control_direct[0]=(((r).cmicx_m0_idm_io_control_direct[0] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_AWCACHEf_GET(r) ((((r).cmicx_m0_idm_io_control_direct[0]) >> 7) & 0xf)
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_AWCACHEf_SET(r,f) (r).cmicx_m0_idm_io_control_direct[0]=(((r).cmicx_m0_idm_io_control_direct[0] & ~((uint32)0xf << 7)) | ((((uint32)f) & 0xf) << 7))
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_AWPROTf_GET(r) ((((r).cmicx_m0_idm_io_control_direct[0]) >> 11) & 0x7)
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_AWPROTf_SET(r,f) (r).cmicx_m0_idm_io_control_direct[0]=(((r).cmicx_m0_idm_io_control_direct[0] & ~((uint32)0x7 << 11)) | ((((uint32)f) & 0x7) << 11))
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_ARCACHEf_GET(r) ((((r).cmicx_m0_idm_io_control_direct[0]) >> 16) & 0xf)
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_ARCACHEf_SET(r,f) (r).cmicx_m0_idm_io_control_direct[0]=(((r).cmicx_m0_idm_io_control_direct[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_AWUSERf_GET(r) ((((r).cmicx_m0_idm_io_control_direct[0]) >> 20) & 0x1f)
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_AWUSERf_SET(r,f) (r).cmicx_m0_idm_io_control_direct[0]=(((r).cmicx_m0_idm_io_control_direct[0] & ~((uint32)0x1f << 20)) | ((((uint32)f) & 0x1f) << 20))
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_ARUSERf_GET(r) ((((r).cmicx_m0_idm_io_control_direct[0]) >> 25) & 0x1f)
#define CMICX_M0_IDM_IO_CONTROL_DIRECTr_ARUSERf_SET(r,f) (r).cmicx_m0_idm_io_control_direct[0]=(((r).cmicx_m0_idm_io_control_direct[0] & ~((uint32)0x1f << 25)) | ((((uint32)f) & 0x1f) << 25))

/*
 * These macros can be used to access CMICX_M0_IDM_IO_CONTROL_DIRECT.
 */
#define READ_CMICX_M0_IDM_IO_CONTROL_DIRECTr(u,r) bcm5607x_read32(u, R_CMICX_M0_IDM_IO_CONTROL_DIRECT, &(r._cmicx_m0_idm_io_control_direct))
#define WRITE_CMICX_M0_IDM_IO_CONTROL_DIRECTr(u,r) bcm5607x_write32(u, R_CMICX_M0_IDM_IO_CONTROL_DIRECT, (r._cmicx_m0_idm_io_control_direct))

/*******************************************************************************
 * End of 'CMICX_M0_IDM_IO_CONTROL_DIRECTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0
 * BLOCKS:   CMIC
 * DESC:     When COS_RX_EN of CMIC_CONFIG is set, this register
indicates which cos are admitted by channel. This register
gives CoS 31 to 0.

 * SIZE:     32
 * FIELDS:
 *     COS_BMP          CH0 COS bitmap
 */
#define CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0.
 */
typedef union CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0r_s {
	uint32 v[1];
	uint32 cmic_cmc_pktdma_ch_cos_ctrl_rx_0[1];
	uint32 _cmic_cmc_pktdma_ch_cos_ctrl_rx_0;
} CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0r_t;

#define CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0r_CLR(r) (r).cmic_cmc_pktdma_ch_cos_ctrl_rx_0[0] = 0
#define CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0r_SET(r,d) (r).cmic_cmc_pktdma_ch_cos_ctrl_rx_0[0] = d
#define CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0r_GET(r) (r).cmic_cmc_pktdma_ch_cos_ctrl_rx_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0r_COS_BMPf_GET(r) ((r).cmic_cmc_pktdma_ch_cos_ctrl_rx_0[0])
#define CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0r_COS_BMPf_SET(r,f) (r).cmic_cmc_pktdma_ch_cos_ctrl_rx_0[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0.
 */
#define READ_CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0r(u,_cmc,_ch,r) bcm5607x_read32(u, CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0(_cmc,_ch), &(r._cmic_cmc_pktdma_ch_cos_ctrl_rx_0))
#define WRITE_CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0r(u,_cmc,_ch,r) bcm5607x_write32(u, CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0(_cmc,_ch), (r._cmic_cmc_pktdma_ch_cos_ctrl_rx_0))

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_CH_COS_CTRL_RX_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_CMC_PKTDMA_CH_CTRL
 * BLOCKS:   CMIC
 * DESC:     DMA Control Register
 * SIZE:     32
 * FIELDS:
 *     DIRECTION        DMA CH0 direction:1=Mem->SOC, 0=SOC->Mem
 *     DMA_EN           Set by CPU to start a DMA on CH0 
 *     ABORT_DMA        DMA CH0 abort
 *     PKTDMA_ENDIANESS (Bit 1) 0 = 1 = big word order for Packet DMA operations
 *     DESC_ENDIANESS   (Bit 1) 0 = 1 = big word order for Descriptor operations
 *     DROP_RX_PKT_ON_CHAIN_END DMA CH0 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     RLD_STS_UPD_DIS  When set, do not update status fields on reload operation.
 *     DESC_DONE_INTR_MODE 1'b0: Descriptor Done interrupt will be raised after completions of every descriptor.1'b1: Descriptor Done interrupt will be raised only when descriptor.INT bit is set in the descriptor. In both casses, interrupt should be cleared by SW.
 *     ENABLE_CONTINUOUS_DMA When set, continuous DMA is enabled. CH_IN_HALT status will be genrated only when this mode is enabled. 
 *     CONTIGUOUS_DESCRIPTORS 1'b0: Only one Descriptor is read at a time.1'b1: More than one Descriptor can be read at a time. During this mode, 'Remaining Descriptors' field in last read Descriptor is used to know the number of Descriptors present contiguously after the last Descriptor. Based on this information, DMA channel reads all those contiguous Descriptors (max upto 8) via a single read transaction. 
 *     EP_TO_CPU_ALIGNMENT_BYTES This field is applicable only when EP_TO_CPU_HEADER_SIZE is non-zero and trailing bytes of header andinitial bytes of data are to be copied within same Descriptor. In such a case, true packet data first byte is written after 0-3 bytes of address gap from last header byte.This is done in order to align the packet data as desired while allowing the header information to be aligned as desired.In case gap is created, then value of bytes in the gap region is don't care.Actual Bytes Transferred count in the Descriptor status word includes number of PAD bytes inserted.
 *     HEADER_ENDIANESS Endianess for (Rx PKTDMA) EP_TO_CPU Header and (Tx PKTDMA) IP MOD header. This endianess configuration value can be differentfrom Endianess configuration value for true packet data (bit PKTDMA_ENDIANESS)0 - Little Endian1 - Big Endian
 *     DISABLE_ABORT_ON_ERROR Packet DMA channel aborts when an error occurs during Descriptor read,Descriptor status write or Packet read/write.When this field is set, the Packet DMA channel does not abort and continues.
 */
#define CMIC_CMC_PKTDMA_CH_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_CH_CTRL.
 */
typedef union CMIC_CMC_PKTDMA_CH_CTRLr_s {
	uint32 v[1];
	uint32 cmic_cmc_pktdma_ch_ctrl[1];
	uint32 _cmic_cmc_pktdma_ch_ctrl;
} CMIC_CMC_PKTDMA_CH_CTRLr_t;

#define CMIC_CMC_PKTDMA_CH_CTRLr_CLR(r) (r).cmic_cmc_pktdma_ch_ctrl[0] = 0
#define CMIC_CMC_PKTDMA_CH_CTRLr_SET(r,d) (r).cmic_cmc_pktdma_ch_ctrl[0] = d
#define CMIC_CMC_PKTDMA_CH_CTRLr_GET(r) (r).cmic_cmc_pktdma_ch_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_CH_CTRLr_DIRECTIONf_GET(r) (((r).cmic_cmc_pktdma_ch_ctrl[0]) & 0x1)
#define CMIC_CMC_PKTDMA_CH_CTRLr_DIRECTIONf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC_PKTDMA_CH_CTRLr_DMA_ENf_GET(r) ((((r).cmic_cmc_pktdma_ch_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC_PKTDMA_CH_CTRLr_DMA_ENf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC_PKTDMA_CH_CTRLr_ABORT_DMAf_GET(r) ((((r).cmic_cmc_pktdma_ch_ctrl[0]) >> 2) & 0x1)
#define CMIC_CMC_PKTDMA_CH_CTRLr_ABORT_DMAf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC_PKTDMA_CH_CTRLr_PKTDMA_ENDIANESSf_GET(r) ((((r).cmic_cmc_pktdma_ch_ctrl[0]) >> 3) & 0x1)
#define CMIC_CMC_PKTDMA_CH_CTRLr_PKTDMA_ENDIANESSf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC_PKTDMA_CH_CTRLr_DESC_ENDIANESSf_GET(r) ((((r).cmic_cmc_pktdma_ch_ctrl[0]) >> 4) & 0x1)
#define CMIC_CMC_PKTDMA_CH_CTRLr_DESC_ENDIANESSf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC_PKTDMA_CH_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_cmc_pktdma_ch_ctrl[0]) >> 5) & 0x1)
#define CMIC_CMC_PKTDMA_CH_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC_PKTDMA_CH_CTRLr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_cmc_pktdma_ch_ctrl[0]) >> 6) & 0x1)
#define CMIC_CMC_PKTDMA_CH_CTRLr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC_PKTDMA_CH_CTRLr_DESC_DONE_INTR_MODEf_GET(r) ((((r).cmic_cmc_pktdma_ch_ctrl[0]) >> 7) & 0x1)
#define CMIC_CMC_PKTDMA_CH_CTRLr_DESC_DONE_INTR_MODEf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_CMC_PKTDMA_CH_CTRLr_ENABLE_CONTINUOUS_DMAf_GET(r) ((((r).cmic_cmc_pktdma_ch_ctrl[0]) >> 8) & 0x1)
#define CMIC_CMC_PKTDMA_CH_CTRLr_ENABLE_CONTINUOUS_DMAf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_CMC_PKTDMA_CH_CTRLr_CONTIGUOUS_DESCRIPTORSf_GET(r) ((((r).cmic_cmc_pktdma_ch_ctrl[0]) >> 9) & 0x1)
#define CMIC_CMC_PKTDMA_CH_CTRLr_CONTIGUOUS_DESCRIPTORSf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CMIC_CMC_PKTDMA_CH_CTRLr_EP_TO_CPU_ALIGNMENT_BYTESf_GET(r) ((((r).cmic_cmc_pktdma_ch_ctrl[0]) >> 10) & 0x3)
#define CMIC_CMC_PKTDMA_CH_CTRLr_EP_TO_CPU_ALIGNMENT_BYTESf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define CMIC_CMC_PKTDMA_CH_CTRLr_HEADER_ENDIANESSf_GET(r) ((((r).cmic_cmc_pktdma_ch_ctrl[0]) >> 12) & 0x1)
#define CMIC_CMC_PKTDMA_CH_CTRLr_HEADER_ENDIANESSf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define CMIC_CMC_PKTDMA_CH_CTRLr_DISABLE_ABORT_ON_ERRORf_GET(r) ((((r).cmic_cmc_pktdma_ch_ctrl[0]) >> 13) & 0x1)
#define CMIC_CMC_PKTDMA_CH_CTRLr_DISABLE_ABORT_ON_ERRORf_SET(r,f) (r).cmic_cmc_pktdma_ch_ctrl[0]=(((r).cmic_cmc_pktdma_ch_ctrl[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_CH_CTRL.
 */
#define READ_CMIC_CMC_PKTDMA_CH_CTRLr(u,_cmc,_ch,r) bcm5607x_read32(u, CMIC_CMC_PKTDMA_CH_CTRL(_cmc,_ch), &(r._cmic_cmc_pktdma_ch_ctrl))
#define WRITE_CMIC_CMC_PKTDMA_CH_CTRLr(u,_cmc,_ch,r) bcm5607x_write32(u, CMIC_CMC_PKTDMA_CH_CTRL(_cmc,_ch), (r._cmic_cmc_pktdma_ch_ctrl))

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_CH_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_CMC_PKTDMA_CH_DESC_ADDR_HI
 * BLOCKS:   CMIC
 * DESC:     Packet DMA CH0 Descriptor Address Higher 32 b
 * SIZE:     32
 * FIELDS:
 *     ADDR             MSB 32 bits of Descriptor Address for first descriptor in a chain. It should be programmed before setting ENABLE bit.
 */
#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_CH_DESC_ADDR_HI.
 */
typedef union CMIC_CMC_PKTDMA_CH_DESC_ADDR_HIr_s {
	uint32 v[1];
	uint32 cmic_cmc_pktdma_ch_desc_addr_hi[1];
	uint32 _cmic_cmc_pktdma_ch_desc_addr_hi;
} CMIC_CMC_PKTDMA_CH_DESC_ADDR_HIr_t;

#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_HIr_CLR(r) (r).cmic_cmc_pktdma_ch_desc_addr_hi[0] = 0
#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_HIr_SET(r,d) (r).cmic_cmc_pktdma_ch_desc_addr_hi[0] = d
#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_HIr_GET(r) (r).cmic_cmc_pktdma_ch_desc_addr_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_HIr_ADDRf_GET(r) ((r).cmic_cmc_pktdma_ch_desc_addr_hi[0])
#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_HIr_ADDRf_SET(r,f) (r).cmic_cmc_pktdma_ch_desc_addr_hi[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_CH_DESC_ADDR_HI.
 */
#define READ_CMIC_CMC_PKTDMA_CH_DESC_ADDR_HIr(u,_cmc,_ch,r) bcm5607x_read32(u, CMIC_CMC_PKTDMA_CH_DESC_ADDR_HI(_cmc,_ch), &(r._cmic_cmc_pktdma_ch_desc_addr_hi))
#define WRITE_CMIC_CMC_PKTDMA_CH_DESC_ADDR_HIr(u,_cmc,_ch,r) bcm5607x_write32(u, CMIC_CMC_PKTDMA_CH_DESC_ADDR_HI(_cmc,_ch), (r._cmic_cmc_pktdma_ch_desc_addr_hi))

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_CH_DESC_ADDR_HIr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_CMC_PKTDMA_CH_DESC_ADDR_LO
 * BLOCKS:   CMIC
 * DESC:     Packet DMA CH0 Descriptor Address Lower 32 b
 * SIZE:     32
 * FIELDS:
 *     ADDR             LSB 32 bits of Descriptor Address for first descriptor in a chain. It should be programmed before setting ENABLE bit.
 */
#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_CH_DESC_ADDR_LO.
 */
typedef union CMIC_CMC_PKTDMA_CH_DESC_ADDR_LOr_s {
	uint32 v[1];
	uint32 cmic_cmc_pktdma_ch_desc_addr_lo[1];
	uint32 _cmic_cmc_pktdma_ch_desc_addr_lo;
} CMIC_CMC_PKTDMA_CH_DESC_ADDR_LOr_t;

#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_LOr_CLR(r) (r).cmic_cmc_pktdma_ch_desc_addr_lo[0] = 0
#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_LOr_SET(r,d) (r).cmic_cmc_pktdma_ch_desc_addr_lo[0] = d
#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_LOr_GET(r) (r).cmic_cmc_pktdma_ch_desc_addr_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_LOr_ADDRf_GET(r) ((r).cmic_cmc_pktdma_ch_desc_addr_lo[0])
#define CMIC_CMC_PKTDMA_CH_DESC_ADDR_LOr_ADDRf_SET(r,f) (r).cmic_cmc_pktdma_ch_desc_addr_lo[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_CH_DESC_ADDR_LO.
 */
#define READ_CMIC_CMC_PKTDMA_CH_DESC_ADDR_LOr(u,_cmc,_ch,r) bcm5607x_read32(u, CMIC_CMC_PKTDMA_CH_DESC_ADDR_LO(_cmc,_ch), &(r._cmic_cmc_pktdma_ch_desc_addr_lo))
#define WRITE_CMIC_CMC_PKTDMA_CH_DESC_ADDR_LOr(u,_cmc,_ch,r) bcm5607x_write32(u, CMIC_CMC_PKTDMA_CH_DESC_ADDR_LO(_cmc,_ch), (r._cmic_cmc_pktdma_ch_desc_addr_lo))

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_CH_DESC_ADDR_LOr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_CMC_PKTDMA_CH_STAT
 * BLOCKS:   CMIC
 * DESC:     Packet DMA CH0 Status Register
 * SIZE:     32
 * FIELDS:
 *     CHAIN_DONE       Set by CMIC indicating DMA Chain Completion 
 *     DMA_ACTIVE       Set by CMIC to indicate DMA channel is Active
 *     STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to an address not defined in CMIC memory Map. Packet DMA chain aborts if DISABLE_ABORT_ON_ERROR is reset.This status bit can be cleared by resetting ENABLE bit. 
 *     PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to an address not defined in CMIC memory Map. Packet DMA chain aborts if DISABLE_ABORT_ON_ERROR is reset.This status bit can be cleared by resetting ENABLE bit. 
 *     DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to an address not defined in CMIC memory Map. Packet DMA chain aborts if DISABLE_ABORT_ON_ERROR is reset.This status bit can be cleared by resetting ENABLE bit. 
 *     PKTWR_ECC_ERR    Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 *     CH_IN_HALT       PacketDMA is halted because DESC_HALT_ADDR matches with CURR_DESC_ADDR to be fetched. Will be cleared once SW moves DESC_HALT_ADDR.
 *     RELOAD_UNALIGNED_ERR It is driven only in case CONTIGUOUS_DESCRIPTORS mode is set. Set by CMIC to indicate that a Reload Descriptor is wrongly received in other than last position in a burst of contiguous descriptors.In such case, Descriptor reading is stopped. Also, Packet DMA chain aborts if DISABLE_ABORT_ON_ERROR is reset.This status bit can be cleared by resetting ENABLE bit.
 */
#define CMIC_CMC_PKTDMA_CH_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PKTDMA_CH_STAT.
 */
typedef union CMIC_CMC_PKTDMA_CH_STATr_s {
	uint32 v[1];
	uint32 cmic_cmc_pktdma_ch_stat[1];
	uint32 _cmic_cmc_pktdma_ch_stat;
} CMIC_CMC_PKTDMA_CH_STATr_t;

#define CMIC_CMC_PKTDMA_CH_STATr_CLR(r) (r).cmic_cmc_pktdma_ch_stat[0] = 0
#define CMIC_CMC_PKTDMA_CH_STATr_SET(r,d) (r).cmic_cmc_pktdma_ch_stat[0] = d
#define CMIC_CMC_PKTDMA_CH_STATr_GET(r) (r).cmic_cmc_pktdma_ch_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_PKTDMA_CH_STATr_CHAIN_DONEf_GET(r) (((r).cmic_cmc_pktdma_ch_stat[0]) & 0x1)
#define CMIC_CMC_PKTDMA_CH_STATr_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_pktdma_ch_stat[0]=(((r).cmic_cmc_pktdma_ch_stat[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC_PKTDMA_CH_STATr_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc_pktdma_ch_stat[0]) >> 1) & 0x1)
#define CMIC_CMC_PKTDMA_CH_STATr_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc_pktdma_ch_stat[0]=(((r).cmic_cmc_pktdma_ch_stat[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC_PKTDMA_CH_STATr_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_pktdma_ch_stat[0]) >> 2) & 0x1)
#define CMIC_CMC_PKTDMA_CH_STATr_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_pktdma_ch_stat[0]=(((r).cmic_cmc_pktdma_ch_stat[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC_PKTDMA_CH_STATr_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_pktdma_ch_stat[0]) >> 3) & 0x1)
#define CMIC_CMC_PKTDMA_CH_STATr_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_pktdma_ch_stat[0]=(((r).cmic_cmc_pktdma_ch_stat[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC_PKTDMA_CH_STATr_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_pktdma_ch_stat[0]) >> 4) & 0x1)
#define CMIC_CMC_PKTDMA_CH_STATr_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_pktdma_ch_stat[0]=(((r).cmic_cmc_pktdma_ch_stat[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC_PKTDMA_CH_STATr_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_pktdma_ch_stat[0]) >> 5) & 0x1)
#define CMIC_CMC_PKTDMA_CH_STATr_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_pktdma_ch_stat[0]=(((r).cmic_cmc_pktdma_ch_stat[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC_PKTDMA_CH_STATr_CH_IN_HALTf_GET(r) ((((r).cmic_cmc_pktdma_ch_stat[0]) >> 6) & 0x1)
#define CMIC_CMC_PKTDMA_CH_STATr_CH_IN_HALTf_SET(r,f) (r).cmic_cmc_pktdma_ch_stat[0]=(((r).cmic_cmc_pktdma_ch_stat[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC_PKTDMA_CH_STATr_RELOAD_UNALIGNED_ERRf_GET(r) ((((r).cmic_cmc_pktdma_ch_stat[0]) >> 7) & 0x1)
#define CMIC_CMC_PKTDMA_CH_STATr_RELOAD_UNALIGNED_ERRf_SET(r,f) (r).cmic_cmc_pktdma_ch_stat[0]=(((r).cmic_cmc_pktdma_ch_stat[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access CMIC_CMC_PKTDMA_CH_STAT.
 */
#define READ_CMIC_CMC_PKTDMA_CH_STATr(u,_cmc,_ch,r) bcm5607x_read32(u, CMIC_CMC_PKTDMA_CH_STAT(_cmc,_ch), &(r._cmic_cmc_pktdma_ch_stat))
#define WRITE_CMIC_CMC_PKTDMA_CH_STATr(u,_cmc,_ch,r) bcm5607x_write32(u, CMIC_CMC_PKTDMA_CH_STAT(_cmc,_ch), (r._cmic_cmc_pktdma_ch_stat))

/*******************************************************************************
 * End of 'CMIC_CMC_PKTDMA_CH_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_CMC_SHARED_IRQ_STAT0
 * BLOCKS:   CMIC
 * DESC:     Capturs CMC specific funtions interrupt status.
 * SIZE:     32
 * FIELDS:
 *     CH0_DESC_DONE    Set after every descriptor completion, Cleared when respective bit is set in IRQ STAT0 CLR register
 *     CH0_CHAIN_DONE   Set after DMA Chain completion. Cleared when  respective bit is set in IRQ STAT0 CLR register. 
 *     CH0_INTR_COALESCING_INTR Set by CH0  interrupt coalescing logic and cleared when respective bit is set in IRQ STAT0 CLR register. 
 *     CH0_DESC_CONTROLLED_INTR HW raise this interrupt if the descriptor completed has desc.intr[1] bit is set. It is cleared when respective bit is set in IRQ STAT0 CLR register.
 *     CH1_DESC_DONE    Set after every descriptor completion, Cleared when respective bit is set in IRQ STAT0 CLR register
 *     CH1_CHAIN_DONE   Set after DMA Chain completion. Cleared when  respective bit is set in IRQ STAT0 CLR register. 
 *     CH1_INTR_COALESCING_INTR Set by CH1  interrupt coalescing logic and cleared when respective bit is set in IRQ STAT0 CLR register. 
 *     CH1_DESC_CONTROLLED_INTR HW raise this interrupt if the descriptor completed has desc.intr[1] bit is set. It is cleared when respective bit is set in IRQ STAT0 CLR register.
 *     CH2_DESC_DONE    Set after every descriptor completion, Cleared when respective bit is set in IRQ STAT0 CLR register
 *     CH2_CHAIN_DONE   Set after DMA Chain completion. Cleared when  respective bit is set in IRQ STAT0 CLR register. 
 *     CH2_INTR_COALESCING_INTR Set by CH2  interrupt coalescing logic and cleared when respective bit is set in IRQ STAT0 CLR register. 
 *     CH2_DESC_CONTROLLED_INTR HW raise this interrupt if the descriptor completed has desc.intr[1] bit is set. It is cleared when respective bit is set in IRQ STAT0 CLR register.
 *     CH3_DESC_DONE    Set after every descriptor completion, Cleared when respective bit is set in IRQ STAT0 CLR register
 *     CH3_CHAIN_DONE   Set after DMA Chain completion. Cleared when  respective bit is set in IRQ STAT0 CLR register. 
 *     CH3_INTR_COALESCING_INTR Set by CH3  interrupt coalescing logic and cleared when respective bit is set in IRQ STAT0 CLR register. 
 *     CH3_DESC_CONTROLLED_INTR HW raise this interrupt if the descriptor completed has desc.intr[1] bit is set. It is cleared when respective bit is set in IRQ STAT0 CLR register.
 *     CH4_DESC_DONE    Set after every descriptor completion, Cleared when respective bit is set in IRQ STAT0 CLR register
 *     CH4_CHAIN_DONE   Set after DMA Chain completion. Cleared when  respective bit is set in IRQ STAT0 CLR register. 
 *     CH4_INTR_COALESCING_INTR Set by CH4  interrupt coalescing logic and cleared when respective bit is set in IRQ STAT0 CLR register. 
 *     CH4_DESC_CONTROLLED_INTR HW raise this interrupt if the descriptor completed has desc.intr[1] bit is set. It is cleared when respective bit is set in IRQ STAT0 CLR register.
 *     CH5_DESC_DONE    Set after every descriptor completion, Cleared when respective bit is set in IRQ STAT0 CLR register
 *     CH5_CHAIN_DONE   Set after DMA Chain completion. Cleared when  respective bit is set in IRQ STAT0 CLR register. 
 *     CH5_INTR_COALESCING_INTR Set by CH5  interrupt coalescing logic and cleared when respective bit is set in IRQ STAT0 CLR register. 
 *     CH5_DESC_CONTROLLED_INTR HW raise this interrupt if the descriptor completed has desc.intr[1] bit is set. It is cleared when respective bit is set in IRQ STAT0 CLR register.
 *     CH6_DESC_DONE    Set after every descriptor completion, Cleared when respective bit is set in IRQ STAT0 CLR register
 *     CH6_CHAIN_DONE   Set after DMA Chain completion. Cleared when  respective bit is set in IRQ STAT0 CLR register. 
 *     CH6_INTR_COALESCING_INTR Set by CH6  interrupt coalescing logic and cleared when respective bit is set in IRQ STAT0 CLR register. 
 *     CH6_DESC_CONTROLLED_INTR HW raise this interrupt if the descriptor completed has desc.intr[1] bit is set. It is cleared when respective bit is set in IRQ STAT0 CLR register.
 *     CH7_DESC_DONE    Set after every descriptor completion, Cleared when respective bit is set in IRQ STAT0 CLR register
 *     CH7_CHAIN_DONE   Set after DMA Chain completion. Cleared when  respective bit is set in IRQ STAT0 CLR register. 
 *     CH7_INTR_COALESCING_INTR Set by CH7  interrupt coalescing logic and cleared when respective bit is set in IRQ STAT0 CLR register. 
 *     CH7_DESC_CONTROLLED_INTR HW raise this interrupt if the descriptor completed has desc.intr[1] bit is set. It is cleared when respective bit is set in IRQ STAT0 CLR register.
 */
#define CMIC_CMC_SHARED_IRQ_STAT0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SHARED_IRQ_STAT0.
 */
typedef union CMIC_CMC_SHARED_IRQ_STAT0r_s {
	uint32 v[1];
	uint32 cmic_cmc_shared_irq_stat0[1];
	uint32 _cmic_cmc_shared_irq_stat0;
} CMIC_CMC_SHARED_IRQ_STAT0r_t;

#define CMIC_CMC_SHARED_IRQ_STAT0r_CLR(r) (r).cmic_cmc_shared_irq_stat0[0] = 0
#define CMIC_CMC_SHARED_IRQ_STAT0r_SET(r,d) (r).cmic_cmc_shared_irq_stat0[0] = d
#define CMIC_CMC_SHARED_IRQ_STAT0r_GET(r) (r).cmic_cmc_shared_irq_stat0[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH0_DESC_DONEf_GET(r) (((r).cmic_cmc_shared_irq_stat0[0]) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH0_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 1) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH0_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 2) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH0_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH0_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 3) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH0_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH1_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 4) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH1_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 5) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH1_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 6) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH1_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH1_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 7) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH1_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH2_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 8) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH2_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 9) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH2_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 10) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH2_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH2_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 11) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH2_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH3_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 12) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH3_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 13) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH3_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 14) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH3_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH3_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 15) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH3_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH4_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 16) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH4_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH4_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 17) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH4_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH4_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 18) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH4_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH4_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 19) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH4_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH5_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 20) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH5_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH5_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 21) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH5_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH5_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 22) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH5_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH5_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 23) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH5_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH6_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 24) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH6_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH6_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 25) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH6_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH6_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 26) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH6_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH6_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 27) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH6_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH7_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 28) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH7_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH7_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 29) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH7_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH7_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 30) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH7_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH7_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat0[0]) >> 31) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT0r_CH7_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat0[0]=(((r).cmic_cmc_shared_irq_stat0[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_CMC_SHARED_IRQ_STAT0.
 */
#define READ_CMIC_CMC_SHARED_IRQ_STAT0r(u,i,r) bcm5607x_read32(u, CMIC_CMC_SHARED_IRQ_STAT0(i), &(r._cmic_cmc_shared_irq_stat0))
#define WRITE_CMIC_CMC_SHARED_IRQ_STAT0r(u,i,r) bcm5607x_write32(u, CMIC_CMC_SHARED_IRQ_STAT0(i), (r._cmic_cmc_shared_irq_stat0))

/*******************************************************************************
 * End of 'CMIC_CMC_SHARED_IRQ_STAT0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_CMC_SHARED_IRQ_STAT_CLR0
 * BLOCKS:   CMIC
 * DESC:     IRQ Status Clear register corresponding to CMIC_CMC_IRQ_STAT0.
 * SIZE:     32
 * FIELDS:
 *     CH0_DESC_DONE    Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH0_CHAIN_DONE   Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH0_INTR_COALESCING_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH0_DESC_CONTROLLED_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH1_DESC_DONE    Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH1_CHAIN_DONE   Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH1_INTR_COALESCING_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH1_DESC_CONTROLLED_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH2_DESC_DONE    Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH2_CHAIN_DONE   Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH2_INTR_COALESCING_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH2_DESC_CONTROLLED_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH3_DESC_DONE    Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH3_CHAIN_DONE   Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH3_INTR_COALESCING_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH3_DESC_CONTROLLED_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH4_DESC_DONE    Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH4_CHAIN_DONE   Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH4_INTR_COALESCING_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH4_DESC_CONTROLLED_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH5_DESC_DONE    Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH5_CHAIN_DONE   Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH5_INTR_COALESCING_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH5_DESC_CONTROLLED_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH6_DESC_DONE    Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH6_CHAIN_DONE   Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH6_INTR_COALESCING_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH6_DESC_CONTROLLED_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH7_DESC_DONE    Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH7_CHAIN_DONE   Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH7_INTR_COALESCING_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 *     CH7_DESC_CONTROLLED_INTR Writing 1 to this bit clears respective IRQ status bit in CMIC_CMC_IRQ_STAT0 register
 */
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SHARED_IRQ_STAT_CLR0.
 */
typedef union CMIC_CMC_SHARED_IRQ_STAT_CLR0r_s {
	uint32 v[1];
	uint32 cmic_cmc_shared_irq_stat_clr0[1];
	uint32 _cmic_cmc_shared_irq_stat_clr0;
} CMIC_CMC_SHARED_IRQ_STAT_CLR0r_t;

#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CLR(r) (r).cmic_cmc_shared_irq_stat_clr0[0] = 0
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_SET(r,d) (r).cmic_cmc_shared_irq_stat_clr0[0] = d
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_GET(r) (r).cmic_cmc_shared_irq_stat_clr0[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH0_DESC_DONEf_GET(r) (((r).cmic_cmc_shared_irq_stat_clr0[0]) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH0_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 1) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH0_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 2) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH0_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH0_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 3) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH0_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH1_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 4) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH1_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 5) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH1_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 6) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH1_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH1_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 7) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH1_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH2_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 8) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH2_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 9) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH2_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 10) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH2_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH2_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 11) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH2_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH3_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 12) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH3_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 13) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH3_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 14) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH3_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH3_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 15) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH3_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH4_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 16) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH4_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH4_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 17) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH4_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH4_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 18) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH4_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH4_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 19) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH4_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH5_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 20) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH5_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH5_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 21) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH5_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH5_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 22) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH5_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH5_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 23) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH5_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH6_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 24) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH6_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH6_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 25) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH6_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH6_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 26) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH6_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH6_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 27) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH6_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH7_DESC_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 28) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH7_DESC_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH7_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 29) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH7_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH7_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 30) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH7_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH7_DESC_CONTROLLED_INTRf_GET(r) ((((r).cmic_cmc_shared_irq_stat_clr0[0]) >> 31) & 0x1)
#define CMIC_CMC_SHARED_IRQ_STAT_CLR0r_CH7_DESC_CONTROLLED_INTRf_SET(r,f) (r).cmic_cmc_shared_irq_stat_clr0[0]=(((r).cmic_cmc_shared_irq_stat_clr0[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_CMC_SHARED_IRQ_STAT_CLR0.
 */
#define READ_CMIC_CMC_SHARED_IRQ_STAT_CLR0r(u,i,r) bcm5607x_read32(u, CMIC_CMC_SHARED_IRQ_STAT_CLR0(i), &(r._cmic_cmc_shared_irq_stat_clr0))
#define WRITE_CMIC_CMC_SHARED_IRQ_STAT_CLR0r(u,i,r) bcm5607x_write32(u, CMIC_CMC_SHARED_IRQ_STAT_CLR0(i), (r._cmic_cmc_shared_irq_stat_clr0))

/*******************************************************************************
 * End of 'CMIC_CMC_SHARED_IRQ_STAT_CLR0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_CMC_SHARED_PKT_COUNT_TXPKT
 * BLOCKS:   CMIC
 * DESC:     Packets Sent to IP from CMC0.
 * SIZE:     32
 * FIELDS:
 *     COUNT            Total number of TX Packets sent from CMC0. 
 */
#define CMIC_CMC_SHARED_PKT_COUNT_TXPKTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SHARED_PKT_COUNT_TXPKT.
 */
typedef union CMIC_CMC_SHARED_PKT_COUNT_TXPKTr_s {
	uint32 v[1];
	uint32 cmic_cmc_shared_pkt_count_txpkt[1];
	uint32 _cmic_cmc_shared_pkt_count_txpkt;
} CMIC_CMC_SHARED_PKT_COUNT_TXPKTr_t;

#define CMIC_CMC_SHARED_PKT_COUNT_TXPKTr_CLR(r) (r).cmic_cmc_shared_pkt_count_txpkt[0] = 0
#define CMIC_CMC_SHARED_PKT_COUNT_TXPKTr_SET(r,d) (r).cmic_cmc_shared_pkt_count_txpkt[0] = d
#define CMIC_CMC_SHARED_PKT_COUNT_TXPKTr_GET(r) (r).cmic_cmc_shared_pkt_count_txpkt[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SHARED_PKT_COUNT_TXPKTr_COUNTf_GET(r) ((r).cmic_cmc_shared_pkt_count_txpkt[0])
#define CMIC_CMC_SHARED_PKT_COUNT_TXPKTr_COUNTf_SET(r,f) (r).cmic_cmc_shared_pkt_count_txpkt[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_CMC_SHARED_PKT_COUNT_TXPKT.
 */
#define READ_CMIC_CMC_SHARED_PKT_COUNT_TXPKTr(u,i,r) bcm5607x_read32(u, CMIC_CMC_SHARED_PKT_COUNT_TXPKT(i), &(r._cmic_cmc_shared_pkt_count_txpkt))
#define WRITE_CMIC_CMC_SHARED_PKT_COUNT_TXPKTr(u,i,r) bcm5607x_write32(u, CMIC_CMC_SHARED_PKT_COUNT_TXPKT(i), (r._cmic_cmc_shared_pkt_count_txpkt))

/*******************************************************************************
 * End of 'CMIC_CMC_SHARED_PKT_COUNT_TXPKTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STAT
 * BLOCKS:   CMIC
 * DESC:     FIFO Read DMA CH0 Status
 * SIZE:     32
 * FIELDS:
 *     ERROR            An Error happened on FIFO Read DMA CH0
 *     ACTIVE           FIFO Read DMA CH0 Active
 *     HOSTMEM_OVERFLOW Hostmem Overflow condition
 *     HOSTMEM_TIMEOUT  Data was transferred to host memory after first interrupt and not been read (caused timeout).
 *     ABORTED          FIFO Read DMA Channel is stopped. S/W should clear ENABLE bit to conclude this operation and clear this bit.
 *     HOSTMEMWR_ERROR   Error while copying SBUSDMA data to Host Memory. Disable DMA to clear this bit. 
 *     SBUSACK_WRONG_BEATCOUNT  Received sbus ack data size is not same is in rep_words fields. Disable DMA to clear this bit. 
 *     SBUSACK_WRONG_OPCODE  Received sbus ack has wrong opcode. Disable DMA to clear this bit. 
 *     SBUSACK_NACK      Received sbus ack with error bit set. Disable DMA to clear this bit. 
 *     SBUSACK_ERROR     Received sbus ack with error bit set. Disable DMA to clear this bit.  
 *     SBUSACK_TIMEOUT   CMIC sets this bit if sbus ack does not come within the time mentioned in CMIC_SUS_TIMEOUT register. Disable DMA to clear this bit. 
 *     ECC_2BIT_CHECK_FAIL  Design will set this bit in case of any ECC error while reading from intermediate buffers residing in SBUSDMA engine. S/W can clear this bit using STAT_CLR register. 
 */
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_SIZE 4

/* CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr is element of CMIC_COMMON_POOL_FIFO_CH_RD_DMA_STAT */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STAT.
 */
typedef union CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_s {
	uint32 v[1];
	uint32 cmic_common_pool_fifo_ch0_rd_dma_stat[1];
	uint32 _cmic_common_pool_fifo_ch0_rd_dma_stat;
} CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_t;

#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_CLR(r) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] = 0
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_SET(r,d) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] = d
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_GET(r) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_ERRORf_GET(r) (((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]) & 0x1)
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_ERRORf_SET(r,f) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]=(((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_ACTIVEf_GET(r) ((((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]) >> 1) & 0x1)
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_ACTIVEf_SET(r,f) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]=(((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_HOSTMEM_OVERFLOWf_GET(r) ((((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]) >> 2) & 0x1)
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_HOSTMEM_OVERFLOWf_SET(r,f) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]=(((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_HOSTMEM_TIMEOUTf_GET(r) ((((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]) >> 3) & 0x1)
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_HOSTMEM_TIMEOUTf_SET(r,f) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]=(((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_ABORTEDf_GET(r) ((((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]) >> 4) & 0x1)
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_ABORTEDf_SET(r,f) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]=(((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_HOSTMEMWR_ERRORf_GET(r) ((((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]) >> 5) & 0x1)
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_HOSTMEMWR_ERRORf_SET(r,f) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]=(((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_SBUSACK_WRONG_BEATCOUNTf_GET(r) ((((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]) >> 6) & 0x1)
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_SBUSACK_WRONG_BEATCOUNTf_SET(r,f) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]=(((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_SBUSACK_WRONG_OPCODEf_GET(r) ((((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]) >> 7) & 0x1)
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_SBUSACK_WRONG_OPCODEf_SET(r,f) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]=(((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_SBUSACK_NACKf_GET(r) ((((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]) >> 8) & 0x1)
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_SBUSACK_NACKf_SET(r,f) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]=(((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_SBUSACK_ERRORf_GET(r) ((((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]) >> 9) & 0x1)
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_SBUSACK_ERRORf_SET(r,f) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]=(((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_SBUSACK_TIMEOUTf_GET(r) ((((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]) >> 10) & 0x1)
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_SBUSACK_TIMEOUTf_SET(r,f) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]=(((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_ECC_2BIT_CHECK_FAILf_GET(r) ((((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]) >> 11) & 0x1)
#define CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr_ECC_2BIT_CHECK_FAILf_SET(r,f) (r).cmic_common_pool_fifo_ch0_rd_dma_stat[0]=(((r).cmic_common_pool_fifo_ch0_rd_dma_stat[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))

/*
 * These macros can be used to access CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STAT.
 */
#define READ_CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STAT, &(r._cmic_common_pool_fifo_ch0_rd_dma_stat))
#define WRITE_CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STAT, (r._cmic_common_pool_fifo_ch0_rd_dma_stat))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_FIFO_CH0_RD_DMA_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNT
 * BLOCKS:   CMIC
 * DESC:     Debug register that provides the number of data
beats in the last SW PIO S-bus ACK

 * SIZE:     32
 * FIELDS:
 *     BEAT_COUNT       Beat count
 *     RESERVED_0       Reserved
 */
#define CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr is element of CMIC_COMMON_POOL_SCHAN_CH_ACK_DATA_BEAT_COUNT */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNT.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch0_ack_data_beat_count[1];
	uint32 _cmic_common_pool_schan_ch0_ack_data_beat_count;
} CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr_t;

#define CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr_CLR(r) (r).cmic_common_pool_schan_ch0_ack_data_beat_count[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr_SET(r,d) (r).cmic_common_pool_schan_ch0_ack_data_beat_count[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr_GET(r) (r).cmic_common_pool_schan_ch0_ack_data_beat_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET(r) (((r).cmic_common_pool_schan_ch0_ack_data_beat_count[0]) & 0x1f)
#define CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET(r,f) (r).cmic_common_pool_schan_ch0_ack_data_beat_count[0]=(((r).cmic_common_pool_schan_ch0_ack_data_beat_count[0] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))
#define CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET(r) ((((r).cmic_common_pool_schan_ch0_ack_data_beat_count[0]) >> 5) & 0x7ffffff)
#define CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET(r,f) (r).cmic_common_pool_schan_ch0_ack_data_beat_count[0]=(((r).cmic_common_pool_schan_ch0_ack_data_beat_count[0] & ~((uint32)0x7ffffff << 5)) | ((((uint32)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNT.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNT, &(r._cmic_common_pool_schan_ch0_ack_data_beat_count))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNT, (r._cmic_common_pool_schan_ch0_ack_data_beat_count))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH0_ACK_DATA_BEAT_COUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH0_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     MSG_START        Set by SW to start an SCH operation. Cleared by HW.
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion. When SW clears this bit, the status bits TIMEOUT, NACK and SER_CHECK_FAILED arecleared.
 *     ABORT            Set by SW to ABORT ongoing SCHAN Operation. SCHAN operation can be aborted only if SBus grant has not ben received. Once grant isreceived, the entire message should be sent and complete ack received. 
 *     SER_CHECK_FAIL   Set by CMIC to indicate last S-bus operation resulted in a SER Parity Check errorClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     SCHAN_ERROR      Set by CMIC to indicate last S-bus operation resulted in an errorThe following could be the cause of error:1) Transaction was aborted by software2) Transaction timed out3) A NACK was received4) SER error was received5) Message error was received6) Opcode was not properClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 */
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH0_CTRLr is element of CMIC_COMMON_POOL_SCHAN_CH_CTRL */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH0_CTRL.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch0_ctrl[1];
	uint32 _cmic_common_pool_schan_ch0_ctrl;
} CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_t;

#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_CLR(r) (r).cmic_common_pool_schan_ch0_ctrl[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_SET(r,d) (r).cmic_common_pool_schan_ch0_ctrl[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_GET(r) (r).cmic_common_pool_schan_ch0_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_MSG_STARTf_GET(r) (((r).cmic_common_pool_schan_ch0_ctrl[0]) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_common_pool_schan_ch0_ctrl[0]=(((r).cmic_common_pool_schan_ch0_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_common_pool_schan_ch0_ctrl[0]) >> 1) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_common_pool_schan_ch0_ctrl[0]=(((r).cmic_common_pool_schan_ch0_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_ABORTf_GET(r) ((((r).cmic_common_pool_schan_ch0_ctrl[0]) >> 2) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_ABORTf_SET(r,f) (r).cmic_common_pool_schan_ch0_ctrl[0]=(((r).cmic_common_pool_schan_ch0_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_SER_CHECK_FAILf_GET(r) ((((r).cmic_common_pool_schan_ch0_ctrl[0]) >> 20) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_SER_CHECK_FAILf_SET(r,f) (r).cmic_common_pool_schan_ch0_ctrl[0]=(((r).cmic_common_pool_schan_ch0_ctrl[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_NACKf_GET(r) ((((r).cmic_common_pool_schan_ch0_ctrl[0]) >> 21) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_NACKf_SET(r,f) (r).cmic_common_pool_schan_ch0_ctrl[0]=(((r).cmic_common_pool_schan_ch0_ctrl[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_common_pool_schan_ch0_ctrl[0]) >> 22) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_common_pool_schan_ch0_ctrl[0]=(((r).cmic_common_pool_schan_ch0_ctrl[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_SCHAN_ERRORf_GET(r) ((((r).cmic_common_pool_schan_ch0_ctrl[0]) >> 23) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH0_CTRLr_SCHAN_ERRORf_SET(r,f) (r).cmic_common_pool_schan_ch0_ctrl[0]=(((r).cmic_common_pool_schan_ch0_ctrl[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH0_CTRL.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH0_CTRLr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH0_CTRL, &(r._cmic_common_pool_schan_ch0_ctrl))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH0_CTRLr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH0_CTRL, (r._cmic_common_pool_schan_ch0_ctrl))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH0_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH0_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 */
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH0_ERRr is element of CMIC_COMMON_POOL_SCHAN_CH_ERR */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH0_ERR.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH0_ERRr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch0_err[1];
	uint32 _cmic_common_pool_schan_ch0_err;
} CMIC_COMMON_POOL_SCHAN_CH0_ERRr_t;

#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_CLR(r) (r).cmic_common_pool_schan_ch0_err[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_SET(r,d) (r).cmic_common_pool_schan_ch0_err[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_GET(r) (r).cmic_common_pool_schan_ch0_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_NACKf_GET(r) (((r).cmic_common_pool_schan_ch0_err[0]) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_NACKf_SET(r,f) (r).cmic_common_pool_schan_ch0_err[0]=(((r).cmic_common_pool_schan_ch0_err[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_ERR_CODEf_GET(r) ((((r).cmic_common_pool_schan_ch0_err[0]) >> 4) & 0x3)
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_ERR_CODEf_SET(r,f) (r).cmic_common_pool_schan_ch0_err[0]=(((r).cmic_common_pool_schan_ch0_err[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_ERRBITf_GET(r) ((((r).cmic_common_pool_schan_ch0_err[0]) >> 6) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_ERRBITf_SET(r,f) (r).cmic_common_pool_schan_ch0_err[0]=(((r).cmic_common_pool_schan_ch0_err[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_DATA_LENf_GET(r) ((((r).cmic_common_pool_schan_ch0_err[0]) >> 7) & 0x7f)
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_DATA_LENf_SET(r,f) (r).cmic_common_pool_schan_ch0_err[0]=(((r).cmic_common_pool_schan_ch0_err[0] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_SRC_PORTf_GET(r) ((((r).cmic_common_pool_schan_ch0_err[0]) >> 14) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_SRC_PORTf_SET(r,f) (r).cmic_common_pool_schan_ch0_err[0]=(((r).cmic_common_pool_schan_ch0_err[0] & ~((uint32)0x3f << 14)) | ((((uint32)f) & 0x3f) << 14))
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_DST_PORTf_GET(r) ((((r).cmic_common_pool_schan_ch0_err[0]) >> 20) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_DST_PORTf_SET(r,f) (r).cmic_common_pool_schan_ch0_err[0]=(((r).cmic_common_pool_schan_ch0_err[0] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_OP_CODEf_GET(r) ((((r).cmic_common_pool_schan_ch0_err[0]) >> 26) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH0_ERRr_OP_CODEf_SET(r,f) (r).cmic_common_pool_schan_ch0_err[0]=(((r).cmic_common_pool_schan_ch0_err[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH0_ERR.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH0_ERRr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH0_ERR, &(r._cmic_common_pool_schan_ch0_err))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH0_ERRr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH0_ERR, (r._cmic_common_pool_schan_ch0_err))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH0_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH0_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 */
#define CMIC_COMMON_POOL_SCHAN_CH0_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH0_MESSAGE.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH0_MESSAGEr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch0_message[1];
	uint32 _cmic_common_pool_schan_ch0_message;
} CMIC_COMMON_POOL_SCHAN_CH0_MESSAGEr_t;

#define CMIC_COMMON_POOL_SCHAN_CH0_MESSAGEr_CLR(r) (r).cmic_common_pool_schan_ch0_message[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH0_MESSAGEr_SET(r,d) (r).cmic_common_pool_schan_ch0_message[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH0_MESSAGEr_GET(r) (r).cmic_common_pool_schan_ch0_message[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH0_MESSAGEr_DATAf_GET(r) ((r).cmic_common_pool_schan_ch0_message[0])
#define CMIC_COMMON_POOL_SCHAN_CH0_MESSAGEr_DATAf_SET(r,f) (r).cmic_common_pool_schan_ch0_message[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH0_MESSAGE.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH0_MESSAGEr(u,i,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH0_MESSAGE(i), &(r._cmic_common_pool_schan_ch0_message))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH0_MESSAGEr(u,i,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH0_MESSAGE(i), (r._cmic_common_pool_schan_ch0_message))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH0_MESSAGEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNT
 * BLOCKS:   CMIC
 * DESC:     Debug register that provides the number of data
beats in the last SW PIO S-bus ACK

 * SIZE:     32
 * FIELDS:
 *     BEAT_COUNT       Beat count
 *     RESERVED_0       Reserved
 */
#define CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr is element of CMIC_COMMON_POOL_SCHAN_CH_ACK_DATA_BEAT_COUNT */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNT.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch1_ack_data_beat_count[1];
	uint32 _cmic_common_pool_schan_ch1_ack_data_beat_count;
} CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr_t;

#define CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr_CLR(r) (r).cmic_common_pool_schan_ch1_ack_data_beat_count[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr_SET(r,d) (r).cmic_common_pool_schan_ch1_ack_data_beat_count[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr_GET(r) (r).cmic_common_pool_schan_ch1_ack_data_beat_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET(r) (((r).cmic_common_pool_schan_ch1_ack_data_beat_count[0]) & 0x1f)
#define CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET(r,f) (r).cmic_common_pool_schan_ch1_ack_data_beat_count[0]=(((r).cmic_common_pool_schan_ch1_ack_data_beat_count[0] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))
#define CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET(r) ((((r).cmic_common_pool_schan_ch1_ack_data_beat_count[0]) >> 5) & 0x7ffffff)
#define CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET(r,f) (r).cmic_common_pool_schan_ch1_ack_data_beat_count[0]=(((r).cmic_common_pool_schan_ch1_ack_data_beat_count[0] & ~((uint32)0x7ffffff << 5)) | ((((uint32)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNT.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNT, &(r._cmic_common_pool_schan_ch1_ack_data_beat_count))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNT, (r._cmic_common_pool_schan_ch1_ack_data_beat_count))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH1_ACK_DATA_BEAT_COUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH1_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     MSG_START        Set by SW to start an SCH operation. Cleared by HW.
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion. When SW clears this bit, the status bits TIMEOUT, NACK and SER_CHECK_FAILED arecleared.
 *     ABORT            Set by SW to ABORT ongoing SCHAN Operation. SCHAN operation can be aborted only if SBus grant has not ben received. Once grant isreceived, the entire message should be sent and complete ack received. 
 *     SER_CHECK_FAIL   Set by CMIC to indicate last S-bus operation resulted in a SER Parity Check errorClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     SCHAN_ERROR      Set by CMIC to indicate last S-bus operation resulted in an errorThe following could be the cause of error:1) Transaction was aborted by software2) Transaction timed out3) A NACK was received4) SER error was received5) Message error was received6) Opcode was not properClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 */
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH1_CTRLr is element of CMIC_COMMON_POOL_SCHAN_CH_CTRL */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH1_CTRL.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch1_ctrl[1];
	uint32 _cmic_common_pool_schan_ch1_ctrl;
} CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_t;

#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_CLR(r) (r).cmic_common_pool_schan_ch1_ctrl[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_SET(r,d) (r).cmic_common_pool_schan_ch1_ctrl[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_GET(r) (r).cmic_common_pool_schan_ch1_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_MSG_STARTf_GET(r) (((r).cmic_common_pool_schan_ch1_ctrl[0]) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_common_pool_schan_ch1_ctrl[0]=(((r).cmic_common_pool_schan_ch1_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_common_pool_schan_ch1_ctrl[0]) >> 1) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_common_pool_schan_ch1_ctrl[0]=(((r).cmic_common_pool_schan_ch1_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_ABORTf_GET(r) ((((r).cmic_common_pool_schan_ch1_ctrl[0]) >> 2) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_ABORTf_SET(r,f) (r).cmic_common_pool_schan_ch1_ctrl[0]=(((r).cmic_common_pool_schan_ch1_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_SER_CHECK_FAILf_GET(r) ((((r).cmic_common_pool_schan_ch1_ctrl[0]) >> 20) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_SER_CHECK_FAILf_SET(r,f) (r).cmic_common_pool_schan_ch1_ctrl[0]=(((r).cmic_common_pool_schan_ch1_ctrl[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_NACKf_GET(r) ((((r).cmic_common_pool_schan_ch1_ctrl[0]) >> 21) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_NACKf_SET(r,f) (r).cmic_common_pool_schan_ch1_ctrl[0]=(((r).cmic_common_pool_schan_ch1_ctrl[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_common_pool_schan_ch1_ctrl[0]) >> 22) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_common_pool_schan_ch1_ctrl[0]=(((r).cmic_common_pool_schan_ch1_ctrl[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_SCHAN_ERRORf_GET(r) ((((r).cmic_common_pool_schan_ch1_ctrl[0]) >> 23) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH1_CTRLr_SCHAN_ERRORf_SET(r,f) (r).cmic_common_pool_schan_ch1_ctrl[0]=(((r).cmic_common_pool_schan_ch1_ctrl[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH1_CTRL.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH1_CTRLr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH1_CTRL, &(r._cmic_common_pool_schan_ch1_ctrl))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH1_CTRLr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH1_CTRL, (r._cmic_common_pool_schan_ch1_ctrl))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH1_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH1_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 */
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH1_ERRr is element of CMIC_COMMON_POOL_SCHAN_CH_ERR */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH1_ERR.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH1_ERRr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch1_err[1];
	uint32 _cmic_common_pool_schan_ch1_err;
} CMIC_COMMON_POOL_SCHAN_CH1_ERRr_t;

#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_CLR(r) (r).cmic_common_pool_schan_ch1_err[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_SET(r,d) (r).cmic_common_pool_schan_ch1_err[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_GET(r) (r).cmic_common_pool_schan_ch1_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_NACKf_GET(r) (((r).cmic_common_pool_schan_ch1_err[0]) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_NACKf_SET(r,f) (r).cmic_common_pool_schan_ch1_err[0]=(((r).cmic_common_pool_schan_ch1_err[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_ERR_CODEf_GET(r) ((((r).cmic_common_pool_schan_ch1_err[0]) >> 4) & 0x3)
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_ERR_CODEf_SET(r,f) (r).cmic_common_pool_schan_ch1_err[0]=(((r).cmic_common_pool_schan_ch1_err[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_ERRBITf_GET(r) ((((r).cmic_common_pool_schan_ch1_err[0]) >> 6) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_ERRBITf_SET(r,f) (r).cmic_common_pool_schan_ch1_err[0]=(((r).cmic_common_pool_schan_ch1_err[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_DATA_LENf_GET(r) ((((r).cmic_common_pool_schan_ch1_err[0]) >> 7) & 0x7f)
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_DATA_LENf_SET(r,f) (r).cmic_common_pool_schan_ch1_err[0]=(((r).cmic_common_pool_schan_ch1_err[0] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_SRC_PORTf_GET(r) ((((r).cmic_common_pool_schan_ch1_err[0]) >> 14) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_SRC_PORTf_SET(r,f) (r).cmic_common_pool_schan_ch1_err[0]=(((r).cmic_common_pool_schan_ch1_err[0] & ~((uint32)0x3f << 14)) | ((((uint32)f) & 0x3f) << 14))
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_DST_PORTf_GET(r) ((((r).cmic_common_pool_schan_ch1_err[0]) >> 20) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_DST_PORTf_SET(r,f) (r).cmic_common_pool_schan_ch1_err[0]=(((r).cmic_common_pool_schan_ch1_err[0] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_OP_CODEf_GET(r) ((((r).cmic_common_pool_schan_ch1_err[0]) >> 26) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH1_ERRr_OP_CODEf_SET(r,f) (r).cmic_common_pool_schan_ch1_err[0]=(((r).cmic_common_pool_schan_ch1_err[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH1_ERR.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH1_ERRr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH1_ERR, &(r._cmic_common_pool_schan_ch1_err))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH1_ERRr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH1_ERR, (r._cmic_common_pool_schan_ch1_err))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH1_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH1_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 */
#define CMIC_COMMON_POOL_SCHAN_CH1_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH1_MESSAGE.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH1_MESSAGEr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch1_message[1];
	uint32 _cmic_common_pool_schan_ch1_message;
} CMIC_COMMON_POOL_SCHAN_CH1_MESSAGEr_t;

#define CMIC_COMMON_POOL_SCHAN_CH1_MESSAGEr_CLR(r) (r).cmic_common_pool_schan_ch1_message[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH1_MESSAGEr_SET(r,d) (r).cmic_common_pool_schan_ch1_message[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH1_MESSAGEr_GET(r) (r).cmic_common_pool_schan_ch1_message[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH1_MESSAGEr_DATAf_GET(r) ((r).cmic_common_pool_schan_ch1_message[0])
#define CMIC_COMMON_POOL_SCHAN_CH1_MESSAGEr_DATAf_SET(r,f) (r).cmic_common_pool_schan_ch1_message[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH1_MESSAGE.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH1_MESSAGEr(u,i,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH1_MESSAGE(i), &(r._cmic_common_pool_schan_ch1_message))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH1_MESSAGEr(u,i,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH1_MESSAGE(i), (r._cmic_common_pool_schan_ch1_message))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH1_MESSAGEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNT
 * BLOCKS:   CMIC
 * DESC:     Debug register that provides the number of data
beats in the last SW PIO S-bus ACK

 * SIZE:     32
 * FIELDS:
 *     BEAT_COUNT       Beat count
 *     RESERVED_0       Reserved
 */
#define CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr is element of CMIC_COMMON_POOL_SCHAN_CH_ACK_DATA_BEAT_COUNT */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNT.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch2_ack_data_beat_count[1];
	uint32 _cmic_common_pool_schan_ch2_ack_data_beat_count;
} CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr_t;

#define CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr_CLR(r) (r).cmic_common_pool_schan_ch2_ack_data_beat_count[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr_SET(r,d) (r).cmic_common_pool_schan_ch2_ack_data_beat_count[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr_GET(r) (r).cmic_common_pool_schan_ch2_ack_data_beat_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET(r) (((r).cmic_common_pool_schan_ch2_ack_data_beat_count[0]) & 0x1f)
#define CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET(r,f) (r).cmic_common_pool_schan_ch2_ack_data_beat_count[0]=(((r).cmic_common_pool_schan_ch2_ack_data_beat_count[0] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))
#define CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET(r) ((((r).cmic_common_pool_schan_ch2_ack_data_beat_count[0]) >> 5) & 0x7ffffff)
#define CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET(r,f) (r).cmic_common_pool_schan_ch2_ack_data_beat_count[0]=(((r).cmic_common_pool_schan_ch2_ack_data_beat_count[0] & ~((uint32)0x7ffffff << 5)) | ((((uint32)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNT.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNT, &(r._cmic_common_pool_schan_ch2_ack_data_beat_count))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNT, (r._cmic_common_pool_schan_ch2_ack_data_beat_count))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH2_ACK_DATA_BEAT_COUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH2_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     MSG_START        Set by SW to start an SCH operation. Cleared by HW.
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion. When SW clears this bit, the status bits TIMEOUT, NACK and SER_CHECK_FAILED arecleared.
 *     ABORT            Set by SW to ABORT ongoing SCHAN Operation. SCHAN operation can be aborted only if SBus grant has not ben received. Once grant isreceived, the entire message should be sent and complete ack received. 
 *     SER_CHECK_FAIL   Set by CMIC to indicate last S-bus operation resulted in a SER Parity Check errorClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     SCHAN_ERROR      Set by CMIC to indicate last S-bus operation resulted in an errorThe following could be the cause of error:1) Transaction was aborted by software2) Transaction timed out3) A NACK was received4) SER error was received5) Message error was received6) Opcode was not properClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 */
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH2_CTRLr is element of CMIC_COMMON_POOL_SCHAN_CH_CTRL */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH2_CTRL.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch2_ctrl[1];
	uint32 _cmic_common_pool_schan_ch2_ctrl;
} CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_t;

#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_CLR(r) (r).cmic_common_pool_schan_ch2_ctrl[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_SET(r,d) (r).cmic_common_pool_schan_ch2_ctrl[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_GET(r) (r).cmic_common_pool_schan_ch2_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_MSG_STARTf_GET(r) (((r).cmic_common_pool_schan_ch2_ctrl[0]) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_common_pool_schan_ch2_ctrl[0]=(((r).cmic_common_pool_schan_ch2_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_common_pool_schan_ch2_ctrl[0]) >> 1) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_common_pool_schan_ch2_ctrl[0]=(((r).cmic_common_pool_schan_ch2_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_ABORTf_GET(r) ((((r).cmic_common_pool_schan_ch2_ctrl[0]) >> 2) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_ABORTf_SET(r,f) (r).cmic_common_pool_schan_ch2_ctrl[0]=(((r).cmic_common_pool_schan_ch2_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_SER_CHECK_FAILf_GET(r) ((((r).cmic_common_pool_schan_ch2_ctrl[0]) >> 20) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_SER_CHECK_FAILf_SET(r,f) (r).cmic_common_pool_schan_ch2_ctrl[0]=(((r).cmic_common_pool_schan_ch2_ctrl[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_NACKf_GET(r) ((((r).cmic_common_pool_schan_ch2_ctrl[0]) >> 21) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_NACKf_SET(r,f) (r).cmic_common_pool_schan_ch2_ctrl[0]=(((r).cmic_common_pool_schan_ch2_ctrl[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_common_pool_schan_ch2_ctrl[0]) >> 22) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_common_pool_schan_ch2_ctrl[0]=(((r).cmic_common_pool_schan_ch2_ctrl[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_SCHAN_ERRORf_GET(r) ((((r).cmic_common_pool_schan_ch2_ctrl[0]) >> 23) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH2_CTRLr_SCHAN_ERRORf_SET(r,f) (r).cmic_common_pool_schan_ch2_ctrl[0]=(((r).cmic_common_pool_schan_ch2_ctrl[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH2_CTRL.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH2_CTRLr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH2_CTRL, &(r._cmic_common_pool_schan_ch2_ctrl))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH2_CTRLr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH2_CTRL, (r._cmic_common_pool_schan_ch2_ctrl))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH2_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH2_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 */
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH2_ERRr is element of CMIC_COMMON_POOL_SCHAN_CH_ERR */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH2_ERR.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH2_ERRr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch2_err[1];
	uint32 _cmic_common_pool_schan_ch2_err;
} CMIC_COMMON_POOL_SCHAN_CH2_ERRr_t;

#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_CLR(r) (r).cmic_common_pool_schan_ch2_err[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_SET(r,d) (r).cmic_common_pool_schan_ch2_err[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_GET(r) (r).cmic_common_pool_schan_ch2_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_NACKf_GET(r) (((r).cmic_common_pool_schan_ch2_err[0]) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_NACKf_SET(r,f) (r).cmic_common_pool_schan_ch2_err[0]=(((r).cmic_common_pool_schan_ch2_err[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_ERR_CODEf_GET(r) ((((r).cmic_common_pool_schan_ch2_err[0]) >> 4) & 0x3)
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_ERR_CODEf_SET(r,f) (r).cmic_common_pool_schan_ch2_err[0]=(((r).cmic_common_pool_schan_ch2_err[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_ERRBITf_GET(r) ((((r).cmic_common_pool_schan_ch2_err[0]) >> 6) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_ERRBITf_SET(r,f) (r).cmic_common_pool_schan_ch2_err[0]=(((r).cmic_common_pool_schan_ch2_err[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_DATA_LENf_GET(r) ((((r).cmic_common_pool_schan_ch2_err[0]) >> 7) & 0x7f)
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_DATA_LENf_SET(r,f) (r).cmic_common_pool_schan_ch2_err[0]=(((r).cmic_common_pool_schan_ch2_err[0] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_SRC_PORTf_GET(r) ((((r).cmic_common_pool_schan_ch2_err[0]) >> 14) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_SRC_PORTf_SET(r,f) (r).cmic_common_pool_schan_ch2_err[0]=(((r).cmic_common_pool_schan_ch2_err[0] & ~((uint32)0x3f << 14)) | ((((uint32)f) & 0x3f) << 14))
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_DST_PORTf_GET(r) ((((r).cmic_common_pool_schan_ch2_err[0]) >> 20) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_DST_PORTf_SET(r,f) (r).cmic_common_pool_schan_ch2_err[0]=(((r).cmic_common_pool_schan_ch2_err[0] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_OP_CODEf_GET(r) ((((r).cmic_common_pool_schan_ch2_err[0]) >> 26) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH2_ERRr_OP_CODEf_SET(r,f) (r).cmic_common_pool_schan_ch2_err[0]=(((r).cmic_common_pool_schan_ch2_err[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH2_ERR.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH2_ERRr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH2_ERR, &(r._cmic_common_pool_schan_ch2_err))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH2_ERRr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH2_ERR, (r._cmic_common_pool_schan_ch2_err))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH2_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH2_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 */
#define CMIC_COMMON_POOL_SCHAN_CH2_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH2_MESSAGE.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH2_MESSAGEr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch2_message[1];
	uint32 _cmic_common_pool_schan_ch2_message;
} CMIC_COMMON_POOL_SCHAN_CH2_MESSAGEr_t;

#define CMIC_COMMON_POOL_SCHAN_CH2_MESSAGEr_CLR(r) (r).cmic_common_pool_schan_ch2_message[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH2_MESSAGEr_SET(r,d) (r).cmic_common_pool_schan_ch2_message[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH2_MESSAGEr_GET(r) (r).cmic_common_pool_schan_ch2_message[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH2_MESSAGEr_DATAf_GET(r) ((r).cmic_common_pool_schan_ch2_message[0])
#define CMIC_COMMON_POOL_SCHAN_CH2_MESSAGEr_DATAf_SET(r,f) (r).cmic_common_pool_schan_ch2_message[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH2_MESSAGE.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH2_MESSAGEr(u,i,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH2_MESSAGE(i), &(r._cmic_common_pool_schan_ch2_message))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH2_MESSAGEr(u,i,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH2_MESSAGE(i), (r._cmic_common_pool_schan_ch2_message))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH2_MESSAGEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNT
 * BLOCKS:   CMIC
 * DESC:     Debug register that provides the number of data
beats in the last SW PIO S-bus ACK

 * SIZE:     32
 * FIELDS:
 *     BEAT_COUNT       Beat count
 *     RESERVED_0       Reserved
 */
#define CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr is element of CMIC_COMMON_POOL_SCHAN_CH_ACK_DATA_BEAT_COUNT */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNT.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch3_ack_data_beat_count[1];
	uint32 _cmic_common_pool_schan_ch3_ack_data_beat_count;
} CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr_t;

#define CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr_CLR(r) (r).cmic_common_pool_schan_ch3_ack_data_beat_count[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr_SET(r,d) (r).cmic_common_pool_schan_ch3_ack_data_beat_count[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr_GET(r) (r).cmic_common_pool_schan_ch3_ack_data_beat_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET(r) (((r).cmic_common_pool_schan_ch3_ack_data_beat_count[0]) & 0x1f)
#define CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET(r,f) (r).cmic_common_pool_schan_ch3_ack_data_beat_count[0]=(((r).cmic_common_pool_schan_ch3_ack_data_beat_count[0] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))
#define CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET(r) ((((r).cmic_common_pool_schan_ch3_ack_data_beat_count[0]) >> 5) & 0x7ffffff)
#define CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET(r,f) (r).cmic_common_pool_schan_ch3_ack_data_beat_count[0]=(((r).cmic_common_pool_schan_ch3_ack_data_beat_count[0] & ~((uint32)0x7ffffff << 5)) | ((((uint32)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNT.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNT, &(r._cmic_common_pool_schan_ch3_ack_data_beat_count))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNT, (r._cmic_common_pool_schan_ch3_ack_data_beat_count))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH3_ACK_DATA_BEAT_COUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH3_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     MSG_START        Set by SW to start an SCH operation. Cleared by HW.
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion. When SW clears this bit, the status bits TIMEOUT, NACK and SER_CHECK_FAILED arecleared.
 *     ABORT            Set by SW to ABORT ongoing SCHAN Operation. SCHAN operation can be aborted only if SBus grant has not ben received. Once grant isreceived, the entire message should be sent and complete ack received. 
 *     SER_CHECK_FAIL   Set by CMIC to indicate last S-bus operation resulted in a SER Parity Check errorClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     SCHAN_ERROR      Set by CMIC to indicate last S-bus operation resulted in an errorThe following could be the cause of error:1) Transaction was aborted by software2) Transaction timed out3) A NACK was received4) SER error was received5) Message error was received6) Opcode was not properClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 */
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH3_CTRLr is element of CMIC_COMMON_POOL_SCHAN_CH_CTRL */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH3_CTRL.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch3_ctrl[1];
	uint32 _cmic_common_pool_schan_ch3_ctrl;
} CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_t;

#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_CLR(r) (r).cmic_common_pool_schan_ch3_ctrl[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_SET(r,d) (r).cmic_common_pool_schan_ch3_ctrl[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_GET(r) (r).cmic_common_pool_schan_ch3_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_MSG_STARTf_GET(r) (((r).cmic_common_pool_schan_ch3_ctrl[0]) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_common_pool_schan_ch3_ctrl[0]=(((r).cmic_common_pool_schan_ch3_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_common_pool_schan_ch3_ctrl[0]) >> 1) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_common_pool_schan_ch3_ctrl[0]=(((r).cmic_common_pool_schan_ch3_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_ABORTf_GET(r) ((((r).cmic_common_pool_schan_ch3_ctrl[0]) >> 2) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_ABORTf_SET(r,f) (r).cmic_common_pool_schan_ch3_ctrl[0]=(((r).cmic_common_pool_schan_ch3_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_SER_CHECK_FAILf_GET(r) ((((r).cmic_common_pool_schan_ch3_ctrl[0]) >> 20) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_SER_CHECK_FAILf_SET(r,f) (r).cmic_common_pool_schan_ch3_ctrl[0]=(((r).cmic_common_pool_schan_ch3_ctrl[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_NACKf_GET(r) ((((r).cmic_common_pool_schan_ch3_ctrl[0]) >> 21) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_NACKf_SET(r,f) (r).cmic_common_pool_schan_ch3_ctrl[0]=(((r).cmic_common_pool_schan_ch3_ctrl[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_common_pool_schan_ch3_ctrl[0]) >> 22) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_common_pool_schan_ch3_ctrl[0]=(((r).cmic_common_pool_schan_ch3_ctrl[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_SCHAN_ERRORf_GET(r) ((((r).cmic_common_pool_schan_ch3_ctrl[0]) >> 23) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH3_CTRLr_SCHAN_ERRORf_SET(r,f) (r).cmic_common_pool_schan_ch3_ctrl[0]=(((r).cmic_common_pool_schan_ch3_ctrl[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH3_CTRL.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH3_CTRLr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH3_CTRL, &(r._cmic_common_pool_schan_ch3_ctrl))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH3_CTRLr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH3_CTRL, (r._cmic_common_pool_schan_ch3_ctrl))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH3_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH3_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 */
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH3_ERRr is element of CMIC_COMMON_POOL_SCHAN_CH_ERR */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH3_ERR.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH3_ERRr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch3_err[1];
	uint32 _cmic_common_pool_schan_ch3_err;
} CMIC_COMMON_POOL_SCHAN_CH3_ERRr_t;

#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_CLR(r) (r).cmic_common_pool_schan_ch3_err[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_SET(r,d) (r).cmic_common_pool_schan_ch3_err[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_GET(r) (r).cmic_common_pool_schan_ch3_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_NACKf_GET(r) (((r).cmic_common_pool_schan_ch3_err[0]) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_NACKf_SET(r,f) (r).cmic_common_pool_schan_ch3_err[0]=(((r).cmic_common_pool_schan_ch3_err[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_ERR_CODEf_GET(r) ((((r).cmic_common_pool_schan_ch3_err[0]) >> 4) & 0x3)
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_ERR_CODEf_SET(r,f) (r).cmic_common_pool_schan_ch3_err[0]=(((r).cmic_common_pool_schan_ch3_err[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_ERRBITf_GET(r) ((((r).cmic_common_pool_schan_ch3_err[0]) >> 6) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_ERRBITf_SET(r,f) (r).cmic_common_pool_schan_ch3_err[0]=(((r).cmic_common_pool_schan_ch3_err[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_DATA_LENf_GET(r) ((((r).cmic_common_pool_schan_ch3_err[0]) >> 7) & 0x7f)
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_DATA_LENf_SET(r,f) (r).cmic_common_pool_schan_ch3_err[0]=(((r).cmic_common_pool_schan_ch3_err[0] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_SRC_PORTf_GET(r) ((((r).cmic_common_pool_schan_ch3_err[0]) >> 14) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_SRC_PORTf_SET(r,f) (r).cmic_common_pool_schan_ch3_err[0]=(((r).cmic_common_pool_schan_ch3_err[0] & ~((uint32)0x3f << 14)) | ((((uint32)f) & 0x3f) << 14))
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_DST_PORTf_GET(r) ((((r).cmic_common_pool_schan_ch3_err[0]) >> 20) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_DST_PORTf_SET(r,f) (r).cmic_common_pool_schan_ch3_err[0]=(((r).cmic_common_pool_schan_ch3_err[0] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_OP_CODEf_GET(r) ((((r).cmic_common_pool_schan_ch3_err[0]) >> 26) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH3_ERRr_OP_CODEf_SET(r,f) (r).cmic_common_pool_schan_ch3_err[0]=(((r).cmic_common_pool_schan_ch3_err[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH3_ERR.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH3_ERRr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH3_ERR, &(r._cmic_common_pool_schan_ch3_err))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH3_ERRr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH3_ERR, (r._cmic_common_pool_schan_ch3_err))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH3_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH3_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 */
#define CMIC_COMMON_POOL_SCHAN_CH3_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH3_MESSAGE.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH3_MESSAGEr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch3_message[1];
	uint32 _cmic_common_pool_schan_ch3_message;
} CMIC_COMMON_POOL_SCHAN_CH3_MESSAGEr_t;

#define CMIC_COMMON_POOL_SCHAN_CH3_MESSAGEr_CLR(r) (r).cmic_common_pool_schan_ch3_message[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH3_MESSAGEr_SET(r,d) (r).cmic_common_pool_schan_ch3_message[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH3_MESSAGEr_GET(r) (r).cmic_common_pool_schan_ch3_message[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH3_MESSAGEr_DATAf_GET(r) ((r).cmic_common_pool_schan_ch3_message[0])
#define CMIC_COMMON_POOL_SCHAN_CH3_MESSAGEr_DATAf_SET(r,f) (r).cmic_common_pool_schan_ch3_message[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH3_MESSAGE.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH3_MESSAGEr(u,i,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH3_MESSAGE(i), &(r._cmic_common_pool_schan_ch3_message))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH3_MESSAGEr(u,i,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH3_MESSAGE(i), (r._cmic_common_pool_schan_ch3_message))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH3_MESSAGEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNT
 * BLOCKS:   CMIC
 * DESC:     Debug register that provides the number of data
beats in the last SW PIO S-bus ACK

 * SIZE:     32
 * FIELDS:
 *     BEAT_COUNT       Beat count
 *     RESERVED_0       Reserved
 */
#define CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr is element of CMIC_COMMON_POOL_SCHAN_CH_ACK_DATA_BEAT_COUNT */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNT.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch4_ack_data_beat_count[1];
	uint32 _cmic_common_pool_schan_ch4_ack_data_beat_count;
} CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr_t;

#define CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr_CLR(r) (r).cmic_common_pool_schan_ch4_ack_data_beat_count[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr_SET(r,d) (r).cmic_common_pool_schan_ch4_ack_data_beat_count[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr_GET(r) (r).cmic_common_pool_schan_ch4_ack_data_beat_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET(r) (((r).cmic_common_pool_schan_ch4_ack_data_beat_count[0]) & 0x1f)
#define CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET(r,f) (r).cmic_common_pool_schan_ch4_ack_data_beat_count[0]=(((r).cmic_common_pool_schan_ch4_ack_data_beat_count[0] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))
#define CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET(r) ((((r).cmic_common_pool_schan_ch4_ack_data_beat_count[0]) >> 5) & 0x7ffffff)
#define CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET(r,f) (r).cmic_common_pool_schan_ch4_ack_data_beat_count[0]=(((r).cmic_common_pool_schan_ch4_ack_data_beat_count[0] & ~((uint32)0x7ffffff << 5)) | ((((uint32)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNT.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNT, &(r._cmic_common_pool_schan_ch4_ack_data_beat_count))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNT, (r._cmic_common_pool_schan_ch4_ack_data_beat_count))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH4_ACK_DATA_BEAT_COUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH4_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     MSG_START        Set by SW to start an SCH operation. Cleared by HW.
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion. When SW clears this bit, the status bits TIMEOUT, NACK and SER_CHECK_FAILED arecleared.
 *     ABORT            Set by SW to ABORT ongoing SCHAN Operation. SCHAN operation can be aborted only if SBus grant has not ben received. Once grant isreceived, the entire message should be sent and complete ack received. 
 *     SER_CHECK_FAIL   Set by CMIC to indicate last S-bus operation resulted in a SER Parity Check errorClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     SCHAN_ERROR      Set by CMIC to indicate last S-bus operation resulted in an errorThe following could be the cause of error:1) Transaction was aborted by software2) Transaction timed out3) A NACK was received4) SER error was received5) Message error was received6) Opcode was not properClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 */
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH4_CTRLr is element of CMIC_COMMON_POOL_SCHAN_CH_CTRL */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH4_CTRL.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch4_ctrl[1];
	uint32 _cmic_common_pool_schan_ch4_ctrl;
} CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_t;

#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_CLR(r) (r).cmic_common_pool_schan_ch4_ctrl[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_SET(r,d) (r).cmic_common_pool_schan_ch4_ctrl[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_GET(r) (r).cmic_common_pool_schan_ch4_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_MSG_STARTf_GET(r) (((r).cmic_common_pool_schan_ch4_ctrl[0]) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_common_pool_schan_ch4_ctrl[0]=(((r).cmic_common_pool_schan_ch4_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_common_pool_schan_ch4_ctrl[0]) >> 1) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_common_pool_schan_ch4_ctrl[0]=(((r).cmic_common_pool_schan_ch4_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_ABORTf_GET(r) ((((r).cmic_common_pool_schan_ch4_ctrl[0]) >> 2) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_ABORTf_SET(r,f) (r).cmic_common_pool_schan_ch4_ctrl[0]=(((r).cmic_common_pool_schan_ch4_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_SER_CHECK_FAILf_GET(r) ((((r).cmic_common_pool_schan_ch4_ctrl[0]) >> 20) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_SER_CHECK_FAILf_SET(r,f) (r).cmic_common_pool_schan_ch4_ctrl[0]=(((r).cmic_common_pool_schan_ch4_ctrl[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_NACKf_GET(r) ((((r).cmic_common_pool_schan_ch4_ctrl[0]) >> 21) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_NACKf_SET(r,f) (r).cmic_common_pool_schan_ch4_ctrl[0]=(((r).cmic_common_pool_schan_ch4_ctrl[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_common_pool_schan_ch4_ctrl[0]) >> 22) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_common_pool_schan_ch4_ctrl[0]=(((r).cmic_common_pool_schan_ch4_ctrl[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_SCHAN_ERRORf_GET(r) ((((r).cmic_common_pool_schan_ch4_ctrl[0]) >> 23) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH4_CTRLr_SCHAN_ERRORf_SET(r,f) (r).cmic_common_pool_schan_ch4_ctrl[0]=(((r).cmic_common_pool_schan_ch4_ctrl[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH4_CTRL.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH4_CTRLr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH4_CTRL, &(r._cmic_common_pool_schan_ch4_ctrl))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH4_CTRLr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH4_CTRL, (r._cmic_common_pool_schan_ch4_ctrl))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH4_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH4_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 */
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_SIZE 4

/* CMIC_COMMON_POOL_SCHAN_CH4_ERRr is element of CMIC_COMMON_POOL_SCHAN_CH_ERR */

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH4_ERR.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH4_ERRr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch4_err[1];
	uint32 _cmic_common_pool_schan_ch4_err;
} CMIC_COMMON_POOL_SCHAN_CH4_ERRr_t;

#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_CLR(r) (r).cmic_common_pool_schan_ch4_err[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_SET(r,d) (r).cmic_common_pool_schan_ch4_err[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_GET(r) (r).cmic_common_pool_schan_ch4_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_NACKf_GET(r) (((r).cmic_common_pool_schan_ch4_err[0]) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_NACKf_SET(r,f) (r).cmic_common_pool_schan_ch4_err[0]=(((r).cmic_common_pool_schan_ch4_err[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_ERR_CODEf_GET(r) ((((r).cmic_common_pool_schan_ch4_err[0]) >> 4) & 0x3)
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_ERR_CODEf_SET(r,f) (r).cmic_common_pool_schan_ch4_err[0]=(((r).cmic_common_pool_schan_ch4_err[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_ERRBITf_GET(r) ((((r).cmic_common_pool_schan_ch4_err[0]) >> 6) & 0x1)
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_ERRBITf_SET(r,f) (r).cmic_common_pool_schan_ch4_err[0]=(((r).cmic_common_pool_schan_ch4_err[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_DATA_LENf_GET(r) ((((r).cmic_common_pool_schan_ch4_err[0]) >> 7) & 0x7f)
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_DATA_LENf_SET(r,f) (r).cmic_common_pool_schan_ch4_err[0]=(((r).cmic_common_pool_schan_ch4_err[0] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_SRC_PORTf_GET(r) ((((r).cmic_common_pool_schan_ch4_err[0]) >> 14) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_SRC_PORTf_SET(r,f) (r).cmic_common_pool_schan_ch4_err[0]=(((r).cmic_common_pool_schan_ch4_err[0] & ~((uint32)0x3f << 14)) | ((((uint32)f) & 0x3f) << 14))
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_DST_PORTf_GET(r) ((((r).cmic_common_pool_schan_ch4_err[0]) >> 20) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_DST_PORTf_SET(r,f) (r).cmic_common_pool_schan_ch4_err[0]=(((r).cmic_common_pool_schan_ch4_err[0] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_OP_CODEf_GET(r) ((((r).cmic_common_pool_schan_ch4_err[0]) >> 26) & 0x3f)
#define CMIC_COMMON_POOL_SCHAN_CH4_ERRr_OP_CODEf_SET(r,f) (r).cmic_common_pool_schan_ch4_err[0]=(((r).cmic_common_pool_schan_ch4_err[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH4_ERR.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH4_ERRr(u,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH4_ERR, &(r._cmic_common_pool_schan_ch4_err))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH4_ERRr(u,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH4_ERR, (r._cmic_common_pool_schan_ch4_err))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH4_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_COMMON_POOL_SCHAN_CH4_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 */
#define CMIC_COMMON_POOL_SCHAN_CH4_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COMMON_POOL_SCHAN_CH4_MESSAGE.
 */
typedef union CMIC_COMMON_POOL_SCHAN_CH4_MESSAGEr_s {
	uint32 v[1];
	uint32 cmic_common_pool_schan_ch4_message[1];
	uint32 _cmic_common_pool_schan_ch4_message;
} CMIC_COMMON_POOL_SCHAN_CH4_MESSAGEr_t;

#define CMIC_COMMON_POOL_SCHAN_CH4_MESSAGEr_CLR(r) (r).cmic_common_pool_schan_ch4_message[0] = 0
#define CMIC_COMMON_POOL_SCHAN_CH4_MESSAGEr_SET(r,d) (r).cmic_common_pool_schan_ch4_message[0] = d
#define CMIC_COMMON_POOL_SCHAN_CH4_MESSAGEr_GET(r) (r).cmic_common_pool_schan_ch4_message[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_COMMON_POOL_SCHAN_CH4_MESSAGEr_DATAf_GET(r) ((r).cmic_common_pool_schan_ch4_message[0])
#define CMIC_COMMON_POOL_SCHAN_CH4_MESSAGEr_DATAf_SET(r,f) (r).cmic_common_pool_schan_ch4_message[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_COMMON_POOL_SCHAN_CH4_MESSAGE.
 */
#define READ_CMIC_COMMON_POOL_SCHAN_CH4_MESSAGEr(u,i,r) bcm5607x_read32(u, CMIC_COMMON_POOL_SCHAN_CH4_MESSAGE(i), &(r._cmic_common_pool_schan_ch4_message))
#define WRITE_CMIC_COMMON_POOL_SCHAN_CH4_MESSAGEr(u,i,r) bcm5607x_write32(u, CMIC_COMMON_POOL_SCHAN_CH4_MESSAGE(i), (r._cmic_common_pool_schan_ch4_message))

/*******************************************************************************
 * End of 'CMIC_COMMON_POOL_SCHAN_CH4_MESSAGEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_SEMAPHORE_1
 * BLOCKS:   IPROC
 * DESC:     Semaphore Test and Set Register
(Internal)0: Unlocked
(Internal)1: Locked
Read returns 0x0: Lock cannot be acquired
Read returns 0x1: Lock has been acquired
To clear the lock, master should write 0x0.
A write of 0x1 has no effect.


 * SIZE:     32
 * FIELDS:
 *     SEMAPHORE        Semaphore Test and Set Bit.
 */
#define CMIC_SEMAPHORE_1r_SIZE 4

/* CMIC_SEMAPHORE_1r is element of CMIC_SEMAPHORE */

/*
 * This structure should be used to declare and program CMIC_SEMAPHORE_1.
 */
typedef union CMIC_SEMAPHORE_1r_s {
	uint32 v[1];
	uint32 cmic_semaphore_1[1];
	uint32 _cmic_semaphore_1;
} CMIC_SEMAPHORE_1r_t;

#define CMIC_SEMAPHORE_1r_CLR(r) (r).cmic_semaphore_1[0] = 0
#define CMIC_SEMAPHORE_1r_SET(r,d) (r).cmic_semaphore_1[0] = d
#define CMIC_SEMAPHORE_1r_GET(r) (r).cmic_semaphore_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SEMAPHORE_1r_SEMAPHOREf_GET(r) (((r).cmic_semaphore_1[0]) & 0x1)
#define CMIC_SEMAPHORE_1r_SEMAPHOREf_SET(r,f) (r).cmic_semaphore_1[0]=(((r).cmic_semaphore_1[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_SEMAPHORE_1.
 */
#define READ_CMIC_SEMAPHORE_1r(u,r) bcm5607x_read32(u, R_CMIC_SEMAPHORE_1, &(r._cmic_semaphore_1))
#define WRITE_CMIC_SEMAPHORE_1r(u,r) bcm5607x_write32(u, R_CMIC_SEMAPHORE_1, (r._cmic_semaphore_1))

/*******************************************************************************
 * End of 'CMIC_SEMAPHORE_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_SEMAPHORE_1_SHADOW
 * BLOCKS:   IPROC
 * DESC:     Semaphore Test and Set Register (Shadow)
This returns the actual value of the lock
0: Unlocked
1: Locked


 * SIZE:     32
 * FIELDS:
 *     SEMAPHORE        Semaphore Test and Set Bit.
 */
#define CMIC_SEMAPHORE_1_SHADOWr_SIZE 4

/* CMIC_SEMAPHORE_1_SHADOWr is element of CMIC_SEMAPHORE_SHADOW */

/*
 * This structure should be used to declare and program CMIC_SEMAPHORE_1_SHADOW.
 */
typedef union CMIC_SEMAPHORE_1_SHADOWr_s {
	uint32 v[1];
	uint32 cmic_semaphore_1_shadow[1];
	uint32 _cmic_semaphore_1_shadow;
} CMIC_SEMAPHORE_1_SHADOWr_t;

#define CMIC_SEMAPHORE_1_SHADOWr_CLR(r) (r).cmic_semaphore_1_shadow[0] = 0
#define CMIC_SEMAPHORE_1_SHADOWr_SET(r,d) (r).cmic_semaphore_1_shadow[0] = d
#define CMIC_SEMAPHORE_1_SHADOWr_GET(r) (r).cmic_semaphore_1_shadow[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SEMAPHORE_1_SHADOWr_SEMAPHOREf_GET(r) (((r).cmic_semaphore_1_shadow[0]) & 0x1)
#define CMIC_SEMAPHORE_1_SHADOWr_SEMAPHOREf_SET(r,f) (r).cmic_semaphore_1_shadow[0]=(((r).cmic_semaphore_1_shadow[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_SEMAPHORE_1_SHADOW.
 */
#define READ_CMIC_SEMAPHORE_1_SHADOWr(u,r) bcm5607x_read32(u, R_CMIC_SEMAPHORE_1_SHADOW, &(r._cmic_semaphore_1_shadow))
#define WRITE_CMIC_SEMAPHORE_1_SHADOWr(u,r) bcm5607x_write32(u, R_CMIC_SEMAPHORE_1_SHADOW, (r._cmic_semaphore_1_shadow))

/*******************************************************************************
 * End of 'CMIC_SEMAPHORE_1_SHADOWr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_SEMAPHORE_2
 * BLOCKS:   IPROC
 * DESC:     Semaphore Test and Set Register
(Internal)0: Unlocked
(Internal)1: Locked
Read returns 0x0: Lock cannot be acquired
Read returns 0x1: Lock has been acquired
To clear the lock, master should write 0x0.
A write of 0x1 has no effect.


 * SIZE:     32
 * FIELDS:
 *     SEMAPHORE        Semaphore Test and Set Bit.
 */
#define CMIC_SEMAPHORE_2r_SIZE 4

/* CMIC_SEMAPHORE_2r is element of CMIC_SEMAPHORE */

/*
 * This structure should be used to declare and program CMIC_SEMAPHORE_2.
 */
typedef union CMIC_SEMAPHORE_2r_s {
	uint32 v[1];
	uint32 cmic_semaphore_2[1];
	uint32 _cmic_semaphore_2;
} CMIC_SEMAPHORE_2r_t;

#define CMIC_SEMAPHORE_2r_CLR(r) (r).cmic_semaphore_2[0] = 0
#define CMIC_SEMAPHORE_2r_SET(r,d) (r).cmic_semaphore_2[0] = d
#define CMIC_SEMAPHORE_2r_GET(r) (r).cmic_semaphore_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SEMAPHORE_2r_SEMAPHOREf_GET(r) (((r).cmic_semaphore_2[0]) & 0x1)
#define CMIC_SEMAPHORE_2r_SEMAPHOREf_SET(r,f) (r).cmic_semaphore_2[0]=(((r).cmic_semaphore_2[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_SEMAPHORE_2.
 */
#define READ_CMIC_SEMAPHORE_2r(u,r) bcm5607x_read32(u, R_CMIC_SEMAPHORE_2, &(r._cmic_semaphore_2))
#define WRITE_CMIC_SEMAPHORE_2r(u,r) bcm5607x_write32(u, R_CMIC_SEMAPHORE_2, (r._cmic_semaphore_2))

/*******************************************************************************
 * End of 'CMIC_SEMAPHORE_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_SEMAPHORE_2_SHADOW
 * BLOCKS:   IPROC
 * DESC:     Semaphore Test and Set Register (Shadow)
This returns the actual value of the lock
0: Unlocked
1: Locked


 * SIZE:     32
 * FIELDS:
 *     SEMAPHORE        Semaphore Test and Set Bit.
 */
#define CMIC_SEMAPHORE_2_SHADOWr_SIZE 4

/* CMIC_SEMAPHORE_2_SHADOWr is element of CMIC_SEMAPHORE_SHADOW */

/*
 * This structure should be used to declare and program CMIC_SEMAPHORE_2_SHADOW.
 */
typedef union CMIC_SEMAPHORE_2_SHADOWr_s {
	uint32 v[1];
	uint32 cmic_semaphore_2_shadow[1];
	uint32 _cmic_semaphore_2_shadow;
} CMIC_SEMAPHORE_2_SHADOWr_t;

#define CMIC_SEMAPHORE_2_SHADOWr_CLR(r) (r).cmic_semaphore_2_shadow[0] = 0
#define CMIC_SEMAPHORE_2_SHADOWr_SET(r,d) (r).cmic_semaphore_2_shadow[0] = d
#define CMIC_SEMAPHORE_2_SHADOWr_GET(r) (r).cmic_semaphore_2_shadow[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SEMAPHORE_2_SHADOWr_SEMAPHOREf_GET(r) (((r).cmic_semaphore_2_shadow[0]) & 0x1)
#define CMIC_SEMAPHORE_2_SHADOWr_SEMAPHOREf_SET(r,f) (r).cmic_semaphore_2_shadow[0]=(((r).cmic_semaphore_2_shadow[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_SEMAPHORE_2_SHADOW.
 */
#define READ_CMIC_SEMAPHORE_2_SHADOWr(u,r) bcm5607x_read32(u, R_CMIC_SEMAPHORE_2_SHADOW, &(r._cmic_semaphore_2_shadow))
#define WRITE_CMIC_SEMAPHORE_2_SHADOWr(u,r) bcm5607x_write32(u, R_CMIC_SEMAPHORE_2_SHADOW, (r._cmic_semaphore_2_shadow))

/*******************************************************************************
 * End of 'CMIC_SEMAPHORE_2_SHADOWr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_SEMAPHORE_3
 * BLOCKS:   IPROC
 * DESC:     Semaphore Test and Set Register
(Internal)0: Unlocked
(Internal)1: Locked
Read returns 0x0: Lock cannot be acquired
Read returns 0x1: Lock has been acquired
To clear the lock, master should write 0x0.
A write of 0x1 has no effect.


 * SIZE:     32
 * FIELDS:
 *     SEMAPHORE        Semaphore Test and Set Bit.
 */
#define CMIC_SEMAPHORE_3r_SIZE 4

/* CMIC_SEMAPHORE_3r is element of CMIC_SEMAPHORE */

/*
 * This structure should be used to declare and program CMIC_SEMAPHORE_3.
 */
typedef union CMIC_SEMAPHORE_3r_s {
	uint32 v[1];
	uint32 cmic_semaphore_3[1];
	uint32 _cmic_semaphore_3;
} CMIC_SEMAPHORE_3r_t;

#define CMIC_SEMAPHORE_3r_CLR(r) (r).cmic_semaphore_3[0] = 0
#define CMIC_SEMAPHORE_3r_SET(r,d) (r).cmic_semaphore_3[0] = d
#define CMIC_SEMAPHORE_3r_GET(r) (r).cmic_semaphore_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SEMAPHORE_3r_SEMAPHOREf_GET(r) (((r).cmic_semaphore_3[0]) & 0x1)
#define CMIC_SEMAPHORE_3r_SEMAPHOREf_SET(r,f) (r).cmic_semaphore_3[0]=(((r).cmic_semaphore_3[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_SEMAPHORE_3.
 */
#define READ_CMIC_SEMAPHORE_3r(u,r) bcm5607x_read32(u, R_CMIC_SEMAPHORE_3, &(r._cmic_semaphore_3))
#define WRITE_CMIC_SEMAPHORE_3r(u,r) bcm5607x_write32(u, R_CMIC_SEMAPHORE_3, (r._cmic_semaphore_3))

/*******************************************************************************
 * End of 'CMIC_SEMAPHORE_3r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_SEMAPHORE_3_SHADOW
 * BLOCKS:   IPROC
 * DESC:     Semaphore Test and Set Register (Shadow)
This returns the actual value of the lock
0: Unlocked
1: Locked


 * SIZE:     32
 * FIELDS:
 *     SEMAPHORE        Semaphore Test and Set Bit.
 */
#define CMIC_SEMAPHORE_3_SHADOWr_SIZE 4

/* CMIC_SEMAPHORE_3_SHADOWr is element of CMIC_SEMAPHORE_SHADOW */

/*
 * This structure should be used to declare and program CMIC_SEMAPHORE_3_SHADOW.
 */
typedef union CMIC_SEMAPHORE_3_SHADOWr_s {
	uint32 v[1];
	uint32 cmic_semaphore_3_shadow[1];
	uint32 _cmic_semaphore_3_shadow;
} CMIC_SEMAPHORE_3_SHADOWr_t;

#define CMIC_SEMAPHORE_3_SHADOWr_CLR(r) (r).cmic_semaphore_3_shadow[0] = 0
#define CMIC_SEMAPHORE_3_SHADOWr_SET(r,d) (r).cmic_semaphore_3_shadow[0] = d
#define CMIC_SEMAPHORE_3_SHADOWr_GET(r) (r).cmic_semaphore_3_shadow[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SEMAPHORE_3_SHADOWr_SEMAPHOREf_GET(r) (((r).cmic_semaphore_3_shadow[0]) & 0x1)
#define CMIC_SEMAPHORE_3_SHADOWr_SEMAPHOREf_SET(r,f) (r).cmic_semaphore_3_shadow[0]=(((r).cmic_semaphore_3_shadow[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_SEMAPHORE_3_SHADOW.
 */
#define READ_CMIC_SEMAPHORE_3_SHADOWr(u,r) bcm5607x_read32(u, R_CMIC_SEMAPHORE_3_SHADOW, &(r._cmic_semaphore_3_shadow))
#define WRITE_CMIC_SEMAPHORE_3_SHADOWr(u,r) bcm5607x_write32(u, R_CMIC_SEMAPHORE_3_SHADOW, (r._cmic_semaphore_3_shadow))

/*******************************************************************************
 * End of 'CMIC_SEMAPHORE_3_SHADOWr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_TOP_CONFIG
 * BLOCKS:   CMIC
 * DESC:     CMIC TOP CONFIG Register. It should be updated during initialization
 * SIZE:     32
 * FIELDS:
 *     ENABLE_PIO_WRITE_NON_POSTED When 0, PIO writes falling in CMIC PIO address range always return success to interconnect. When 1, PIO writes falling in CMIC PIO address range will return address decode error to interconnect when address points to a null space within the address range.
 *     IP_2_EP_LOOPBACK_ENABLE When 1, entire IP bound traffic (IP pipe) is loopback into EP pipe internally. Original IP/EP interface will be dead. i.e. no packet will go out towards switch on IP interface and EP interface from switch will be ignored.Loopback packet format is different. When 0, loopback is disabled.
 *     CMC0_CLK_EN      When 1, CMC0 clock is enabledWhen 0, CMC0 clock is disabld
 *     CMC1_CLK_EN      When 1, CMC1 clock is enabledWhen 0, CMC1 clock is disabld
 *     COMMON_POOL_CLK_EN When 1, Common Pool clock is enabledWhen 0, Common Pool clock is disabld
 *     RPE_CLK_EN       When 1, RPE clock is enabledWhen 0, RPE clock is disabld
 *     IP_INTERFACE_PAYLOAD_ENDIANESS When 1, IP Packet Payload portion is driven in Big Endian format by CMICWhen 0, IP Packet Payload portion is driven in Little Endian format by CMIC
 *     IP_INTERFACE_HEADER_ENDIANESS When 1, IP Packet Header portion is driven in Big Endian format by CMICWhen 0, IP Packet Header portion is driven in Little Endian format by CMIC
 *     EP_INTERFACE_PAYLOAD_ENDIANESS When 1, EP Packet Payload portion arrives into CMIC in Big Endian formatWhen 0, EP Packet Payload portion arrives into CMIC in Little Endian format
 *     EP_INTERFACE_HEADER_ENDIANESS When 1, EP Packet Header portion arrives into CMIC in Big Endian formatWhen 0, EP Packet Header portion arrives into CMIC in Little Endian format
 *     CLEAR_ON_READ_ENABLE When 1, a status counter is cleared upon read
 *     SATURATE_ENABLE  When 1, a status counter does not roll over when incremented after reaching max all 1's valueWhen 1, a status counter rolls over to zero when incremented after reaching max all 1's value
 *     CLEAR_CMC0_COUNTERS For Debug purpose.When 1, all CMC0 counters are reset to zero. SW should write 0 for resumingnormal operation of the counters.
 *     CLEAR_CMC1_COUNTERS For Debug purpose.When 1, all CMC1 counters are reset to zero. SW should write 0 for resumingnormal operation of the counters.
 *     CLEAR_RPE_COUNTERS For Debug purpose.When 1, all RPE counters are reset to zero. SW should write 0 for resumingnormal operation of the counters.
 *     CLEAR_TOP_COUNTERS For Debug purpose.When 1, all CMIC TOP level counters are reset to zero. SW should write 0 for resumingnormal operation of the counters.
 *     DISABLE_CMIC_RESET_UPON_IPROC_PIO_RESET When 0, complete CMIC resets due to input PIO reset (cmic_pio_reset_n) fromIPROC.When 1, CMIC core logic does not reset due to the input PIO reset. Only PIO bus logic within CMIC resets. Hence, CMIC core logic can remain out of reset even when IPROC goes to reset,thus avoiding any reset of switch logic.
 */
#define CMIC_TOP_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TOP_CONFIG.
 */
typedef union CMIC_TOP_CONFIGr_s {
	uint32 v[1];
	uint32 cmic_top_config[1];
	uint32 _cmic_top_config;
} CMIC_TOP_CONFIGr_t;

#define CMIC_TOP_CONFIGr_CLR(r) (r).cmic_top_config[0] = 0
#define CMIC_TOP_CONFIGr_SET(r,d) (r).cmic_top_config[0] = d
#define CMIC_TOP_CONFIGr_GET(r) (r).cmic_top_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_CONFIGr_ENABLE_PIO_WRITE_NON_POSTEDf_GET(r) (((r).cmic_top_config[0]) & 0x1)
#define CMIC_TOP_CONFIGr_ENABLE_PIO_WRITE_NON_POSTEDf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_TOP_CONFIGr_IP_2_EP_LOOPBACK_ENABLEf_GET(r) ((((r).cmic_top_config[0]) >> 1) & 0x1)
#define CMIC_TOP_CONFIGr_IP_2_EP_LOOPBACK_ENABLEf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_TOP_CONFIGr_CMC0_CLK_ENf_GET(r) ((((r).cmic_top_config[0]) >> 2) & 0x1)
#define CMIC_TOP_CONFIGr_CMC0_CLK_ENf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_TOP_CONFIGr_CMC1_CLK_ENf_GET(r) ((((r).cmic_top_config[0]) >> 3) & 0x1)
#define CMIC_TOP_CONFIGr_CMC1_CLK_ENf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_TOP_CONFIGr_COMMON_POOL_CLK_ENf_GET(r) ((((r).cmic_top_config[0]) >> 4) & 0x1)
#define CMIC_TOP_CONFIGr_COMMON_POOL_CLK_ENf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_TOP_CONFIGr_RPE_CLK_ENf_GET(r) ((((r).cmic_top_config[0]) >> 5) & 0x1)
#define CMIC_TOP_CONFIGr_RPE_CLK_ENf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_TOP_CONFIGr_IP_INTERFACE_PAYLOAD_ENDIANESSf_GET(r) ((((r).cmic_top_config[0]) >> 6) & 0x1)
#define CMIC_TOP_CONFIGr_IP_INTERFACE_PAYLOAD_ENDIANESSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_TOP_CONFIGr_IP_INTERFACE_HEADER_ENDIANESSf_GET(r) ((((r).cmic_top_config[0]) >> 7) & 0x1)
#define CMIC_TOP_CONFIGr_IP_INTERFACE_HEADER_ENDIANESSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_TOP_CONFIGr_EP_INTERFACE_PAYLOAD_ENDIANESSf_GET(r) ((((r).cmic_top_config[0]) >> 8) & 0x1)
#define CMIC_TOP_CONFIGr_EP_INTERFACE_PAYLOAD_ENDIANESSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_TOP_CONFIGr_EP_INTERFACE_HEADER_ENDIANESSf_GET(r) ((((r).cmic_top_config[0]) >> 9) & 0x1)
#define CMIC_TOP_CONFIGr_EP_INTERFACE_HEADER_ENDIANESSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CMIC_TOP_CONFIGr_CLEAR_ON_READ_ENABLEf_GET(r) ((((r).cmic_top_config[0]) >> 10) & 0x1)
#define CMIC_TOP_CONFIGr_CLEAR_ON_READ_ENABLEf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define CMIC_TOP_CONFIGr_SATURATE_ENABLEf_GET(r) ((((r).cmic_top_config[0]) >> 11) & 0x1)
#define CMIC_TOP_CONFIGr_SATURATE_ENABLEf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define CMIC_TOP_CONFIGr_CLEAR_CMC0_COUNTERSf_GET(r) ((((r).cmic_top_config[0]) >> 12) & 0x1)
#define CMIC_TOP_CONFIGr_CLEAR_CMC0_COUNTERSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define CMIC_TOP_CONFIGr_CLEAR_CMC1_COUNTERSf_GET(r) ((((r).cmic_top_config[0]) >> 13) & 0x1)
#define CMIC_TOP_CONFIGr_CLEAR_CMC1_COUNTERSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define CMIC_TOP_CONFIGr_CLEAR_RPE_COUNTERSf_GET(r) ((((r).cmic_top_config[0]) >> 14) & 0x1)
#define CMIC_TOP_CONFIGr_CLEAR_RPE_COUNTERSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define CMIC_TOP_CONFIGr_CLEAR_TOP_COUNTERSf_GET(r) ((((r).cmic_top_config[0]) >> 15) & 0x1)
#define CMIC_TOP_CONFIGr_CLEAR_TOP_COUNTERSf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define CMIC_TOP_CONFIGr_DISABLE_CMIC_RESET_UPON_IPROC_PIO_RESETf_GET(r) ((((r).cmic_top_config[0]) >> 16) & 0x1)
#define CMIC_TOP_CONFIGr_DISABLE_CMIC_RESET_UPON_IPROC_PIO_RESETf_SET(r,f) (r).cmic_top_config[0]=(((r).cmic_top_config[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))

/*
 * These macros can be used to access CMIC_TOP_CONFIG.
 */
#define READ_CMIC_TOP_CONFIGr(u,r) bcm5607x_read32(u, CMIC_TOP_CONFIG, &(r._cmic_top_config))
#define WRITE_CMIC_TOP_CONFIGr(u,r) bcm5607x_write32(u, CMIC_TOP_CONFIG, (r._cmic_top_config))

/*******************************************************************************
 * End of 'CMIC_TOP_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITS
 * BLOCKS:   CMIC
 * DESC:     This register has the config bit which when written to 1 will release the max number of credits to the EP block so EP block can send data worth number of credits times 8B. This has to be done only once after both CMIC and EP blocks are out of reset. If EP block is not out of reset, it will not be able to sample the number of credits released to it resulting in hang scenario. Once ininitial credits are released, CMIC block will continue to release the credits as it reads the interface buffer.

 * SIZE:     32
 * FIELDS:
 *     MAX_CREDITS      Indicates the number of credits that will be released to EP. Max value is 64. This has to be configured first before credits are released
 *     FLUSH_EPINTFBUF  Set this bit to flush EP interface buffer. CLear this bit to get into normal operation. (DEBUG Purpose only)
 *     WR_EP_INTF_CREDITS Set this bit to write credits number mentioned in MAX_CREDITS field. It is self clearing bit
 */
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITS.
 */
typedef union CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_s {
	uint32 v[1];
	uint32 cmic_top_epintf_max_interface_credits[1];
	uint32 _cmic_top_epintf_max_interface_credits;
} CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_t;

#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_CLR(r) (r).cmic_top_epintf_max_interface_credits[0] = 0
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_SET(r,d) (r).cmic_top_epintf_max_interface_credits[0] = d
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_GET(r) (r).cmic_top_epintf_max_interface_credits[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_MAX_CREDITSf_GET(r) (((r).cmic_top_epintf_max_interface_credits[0]) & 0x7f)
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_MAX_CREDITSf_SET(r,f) (r).cmic_top_epintf_max_interface_credits[0]=(((r).cmic_top_epintf_max_interface_credits[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_FLUSH_EPINTFBUFf_GET(r) ((((r).cmic_top_epintf_max_interface_credits[0]) >> 7) & 0x1)
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_FLUSH_EPINTFBUFf_SET(r,f) (r).cmic_top_epintf_max_interface_credits[0]=(((r).cmic_top_epintf_max_interface_credits[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_WR_EP_INTF_CREDITSf_GET(r) ((((r).cmic_top_epintf_max_interface_credits[0]) >> 8) & 0x1)
#define CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr_WR_EP_INTF_CREDITSf_SET(r,f) (r).cmic_top_epintf_max_interface_credits[0]=(((r).cmic_top_epintf_max_interface_credits[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))

/*
 * These macros can be used to access CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITS.
 */
#define READ_CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr(u,r) bcm5607x_read32(u, CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITS, &(r._cmic_top_epintf_max_interface_credits))
#define WRITE_CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr(u,r) bcm5607x_write32(u, CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITS, (r._cmic_top_epintf_max_interface_credits))

/*******************************************************************************
 * End of 'CMIC_TOP_EPINTF_MAX_INTERFACE_CREDITSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_TOP_EPINTF_RELEASE_ALL_CREDITS
 * BLOCKS:   CMIC
 * DESC:     This register has the config bit which when written to 1 will release the max number of credits to the EP block so EP block can send data worth number of credits times 8B. This has to be done only once after both CMIC and EP blocks are out of reset. If EP block is not out of reset, it will not be able to sample the number of credits released to it resulting in hang scenario. Once ininitial credits are released, CMIC block will continue to release the credits as it reads the interface buffer.

 * SIZE:     32
 * FIELDS:
 *     RELEASE_ALL_CREDITS Changing this from 0 to 1, will cause the credits to be released
 */
#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TOP_EPINTF_RELEASE_ALL_CREDITS.
 */
typedef union CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_s {
	uint32 v[1];
	uint32 cmic_top_epintf_release_all_credits[1];
	uint32 _cmic_top_epintf_release_all_credits;
} CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_t;

#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_CLR(r) (r).cmic_top_epintf_release_all_credits[0] = 0
#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_SET(r,d) (r).cmic_top_epintf_release_all_credits[0] = d
#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_GET(r) (r).cmic_top_epintf_release_all_credits[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_RELEASE_ALL_CREDITSf_GET(r) (((r).cmic_top_epintf_release_all_credits[0]) & 0x1)
#define CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr_RELEASE_ALL_CREDITSf_SET(r,f) (r).cmic_top_epintf_release_all_credits[0]=(((r).cmic_top_epintf_release_all_credits[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_TOP_EPINTF_RELEASE_ALL_CREDITS.
 */
#define READ_CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr(u,r) bcm5607x_read32(u, CMIC_TOP_EPINTF_RELEASE_ALL_CREDITS, &(r._cmic_top_epintf_release_all_credits))
#define WRITE_CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr(u,r) bcm5607x_write32(u, CMIC_TOP_EPINTF_RELEASE_ALL_CREDITS, (r._cmic_top_epintf_release_all_credits))

/*******************************************************************************
 * End of 'CMIC_TOP_EPINTF_RELEASE_ALL_CREDITSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_TOP_EP_TO_CPU_HEADER_SIZE
 * BLOCKS:   CMIC
 * DESC:     This status register indicates value of EP_TO_CPU Header size in multiple of 8
Bytes.

 * SIZE:     32
 * FIELDS:
 *     EP_TO_CPU_HEADER_SIZE EP TO CPU Header Size in multiple of 8 bytes. Valid range is 0 to 12 i.e. EP_TO_CPU Header of 0 to 96 bytes.
 */
#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TOP_EP_TO_CPU_HEADER_SIZE.
 */
typedef union CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_s {
	uint32 v[1];
	uint32 cmic_top_ep_to_cpu_header_size[1];
	uint32 _cmic_top_ep_to_cpu_header_size;
} CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_t;

#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_CLR(r) (r).cmic_top_ep_to_cpu_header_size[0] = 0
#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_SET(r,d) (r).cmic_top_ep_to_cpu_header_size[0] = d
#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_GET(r) (r).cmic_top_ep_to_cpu_header_size[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_EP_TO_CPU_HEADER_SIZEf_GET(r) (((r).cmic_top_ep_to_cpu_header_size[0]) & 0xf)
#define CMIC_TOP_EP_TO_CPU_HEADER_SIZEr_EP_TO_CPU_HEADER_SIZEf_SET(r,f) (r).cmic_top_ep_to_cpu_header_size[0]=(((r).cmic_top_ep_to_cpu_header_size[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))

/*
 * These macros can be used to access CMIC_TOP_EP_TO_CPU_HEADER_SIZE.
 */
#define READ_CMIC_TOP_EP_TO_CPU_HEADER_SIZEr(u,r) bcm5607x_read32(u, CMIC_TOP_EP_TO_CPU_HEADER_SIZE, &(r._cmic_top_ep_to_cpu_header_size))
#define WRITE_CMIC_TOP_EP_TO_CPU_HEADER_SIZEr(u,r) bcm5607x_write32(u, CMIC_TOP_EP_TO_CPU_HEADER_SIZE, (r._cmic_top_ep_to_cpu_header_size))

/*******************************************************************************
 * End of 'CMIC_TOP_EP_TO_CPU_HEADER_SIZEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_TOP_SBUS_RING_MAP_0_7
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (0 to 7) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_0 S-bus ring number for agent with S-bus ID  0
 *     RING_NUM_SBUS_ID_1 S-bus ring number for agent with S-bus ID  1
 *     RING_NUM_SBUS_ID_2 S-bus ring number for agent with S-bus ID  2
 *     RING_NUM_SBUS_ID_3 S-bus ring number for agent with S-bus ID  3
 *     RING_NUM_SBUS_ID_4 S-bus ring number for agent with S-bus ID  4
 *     RING_NUM_SBUS_ID_5 S-bus ring number for agent with S-bus ID  5
 *     RING_NUM_SBUS_ID_6 S-bus ring number for agent with S-bus ID  6
 *     RING_NUM_SBUS_ID_7 S-bus ring number for agent with S-bus ID  7
 */
#define CMIC_TOP_SBUS_RING_MAP_0_7r_SIZE 4

/* CMIC_TOP_SBUS_RING_MAP_0_7r is element of CMIC_TOP_SBUS_RING_MAP */

/*
 * This structure should be used to declare and program CMIC_TOP_SBUS_RING_MAP_0_7.
 */
typedef union CMIC_TOP_SBUS_RING_MAP_0_7r_s {
	uint32 v[1];
	uint32 cmic_top_sbus_ring_map_0_7[1];
	uint32 _cmic_top_sbus_ring_map_0_7;
} CMIC_TOP_SBUS_RING_MAP_0_7r_t;

#define CMIC_TOP_SBUS_RING_MAP_0_7r_CLR(r) (r).cmic_top_sbus_ring_map_0_7[0] = 0
#define CMIC_TOP_SBUS_RING_MAP_0_7r_SET(r,d) (r).cmic_top_sbus_ring_map_0_7[0] = d
#define CMIC_TOP_SBUS_RING_MAP_0_7r_GET(r) (r).cmic_top_sbus_ring_map_0_7[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_0f_GET(r) (((r).cmic_top_sbus_ring_map_0_7[0]) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_0f_SET(r,f) (r).cmic_top_sbus_ring_map_0_7[0]=(((r).cmic_top_sbus_ring_map_0_7[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_1f_GET(r) ((((r).cmic_top_sbus_ring_map_0_7[0]) >> 4) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_1f_SET(r,f) (r).cmic_top_sbus_ring_map_0_7[0]=(((r).cmic_top_sbus_ring_map_0_7[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_2f_GET(r) ((((r).cmic_top_sbus_ring_map_0_7[0]) >> 8) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_2f_SET(r,f) (r).cmic_top_sbus_ring_map_0_7[0]=(((r).cmic_top_sbus_ring_map_0_7[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_3f_GET(r) ((((r).cmic_top_sbus_ring_map_0_7[0]) >> 12) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_3f_SET(r,f) (r).cmic_top_sbus_ring_map_0_7[0]=(((r).cmic_top_sbus_ring_map_0_7[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_4f_GET(r) ((((r).cmic_top_sbus_ring_map_0_7[0]) >> 16) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_4f_SET(r,f) (r).cmic_top_sbus_ring_map_0_7[0]=(((r).cmic_top_sbus_ring_map_0_7[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_5f_GET(r) ((((r).cmic_top_sbus_ring_map_0_7[0]) >> 20) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_5f_SET(r,f) (r).cmic_top_sbus_ring_map_0_7[0]=(((r).cmic_top_sbus_ring_map_0_7[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_6f_GET(r) ((((r).cmic_top_sbus_ring_map_0_7[0]) >> 24) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_6f_SET(r,f) (r).cmic_top_sbus_ring_map_0_7[0]=(((r).cmic_top_sbus_ring_map_0_7[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_7f_GET(r) ((((r).cmic_top_sbus_ring_map_0_7[0]) >> 28) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_7f_SET(r,f) (r).cmic_top_sbus_ring_map_0_7[0]=(((r).cmic_top_sbus_ring_map_0_7[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_TOP_SBUS_RING_MAP_0_7.
 */
#define READ_CMIC_TOP_SBUS_RING_MAP_0_7r(u,r) bcm5607x_read32(u, CMIC_TOP_SBUS_RING_MAP_0_7, &(r._cmic_top_sbus_ring_map_0_7))
#define WRITE_CMIC_TOP_SBUS_RING_MAP_0_7r(u,r) bcm5607x_write32(u, CMIC_TOP_SBUS_RING_MAP_0_7, (r._cmic_top_sbus_ring_map_0_7))

/*******************************************************************************
 * End of 'CMIC_TOP_SBUS_RING_MAP_0_7r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_TOP_SBUS_RING_MAP_16_23
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (16 to 23) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_16 S-bus ring number for agent with S-bus ID  16
 *     RING_NUM_SBUS_ID_17 S-bus ring number for agent with S-bus ID  17
 *     RING_NUM_SBUS_ID_18 S-bus ring number for agent with S-bus ID  18
 *     RING_NUM_SBUS_ID_19 S-bus ring number for agent with S-bus ID  19
 *     RING_NUM_SBUS_ID_20 S-bus ring number for agent with S-bus ID  20
 *     RING_NUM_SBUS_ID_21 S-bus ring number for agent with S-bus ID  21
 *     RING_NUM_SBUS_ID_22 S-bus ring number for agent with S-bus ID  22
 *     RING_NUM_SBUS_ID_23 S-bus ring number for agent with S-bus ID  23
 */
#define CMIC_TOP_SBUS_RING_MAP_16_23r_SIZE 4

/* CMIC_TOP_SBUS_RING_MAP_16_23r is element of CMIC_TOP_SBUS_RING_MAP */

/*
 * This structure should be used to declare and program CMIC_TOP_SBUS_RING_MAP_16_23.
 */
typedef union CMIC_TOP_SBUS_RING_MAP_16_23r_s {
	uint32 v[1];
	uint32 cmic_top_sbus_ring_map_16_23[1];
	uint32 _cmic_top_sbus_ring_map_16_23;
} CMIC_TOP_SBUS_RING_MAP_16_23r_t;

#define CMIC_TOP_SBUS_RING_MAP_16_23r_CLR(r) (r).cmic_top_sbus_ring_map_16_23[0] = 0
#define CMIC_TOP_SBUS_RING_MAP_16_23r_SET(r,d) (r).cmic_top_sbus_ring_map_16_23[0] = d
#define CMIC_TOP_SBUS_RING_MAP_16_23r_GET(r) (r).cmic_top_sbus_ring_map_16_23[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_16f_GET(r) (((r).cmic_top_sbus_ring_map_16_23[0]) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_16f_SET(r,f) (r).cmic_top_sbus_ring_map_16_23[0]=(((r).cmic_top_sbus_ring_map_16_23[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_17f_GET(r) ((((r).cmic_top_sbus_ring_map_16_23[0]) >> 4) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_17f_SET(r,f) (r).cmic_top_sbus_ring_map_16_23[0]=(((r).cmic_top_sbus_ring_map_16_23[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_18f_GET(r) ((((r).cmic_top_sbus_ring_map_16_23[0]) >> 8) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_18f_SET(r,f) (r).cmic_top_sbus_ring_map_16_23[0]=(((r).cmic_top_sbus_ring_map_16_23[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_19f_GET(r) ((((r).cmic_top_sbus_ring_map_16_23[0]) >> 12) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_19f_SET(r,f) (r).cmic_top_sbus_ring_map_16_23[0]=(((r).cmic_top_sbus_ring_map_16_23[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_20f_GET(r) ((((r).cmic_top_sbus_ring_map_16_23[0]) >> 16) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_20f_SET(r,f) (r).cmic_top_sbus_ring_map_16_23[0]=(((r).cmic_top_sbus_ring_map_16_23[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_21f_GET(r) ((((r).cmic_top_sbus_ring_map_16_23[0]) >> 20) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_21f_SET(r,f) (r).cmic_top_sbus_ring_map_16_23[0]=(((r).cmic_top_sbus_ring_map_16_23[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_22f_GET(r) ((((r).cmic_top_sbus_ring_map_16_23[0]) >> 24) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_22f_SET(r,f) (r).cmic_top_sbus_ring_map_16_23[0]=(((r).cmic_top_sbus_ring_map_16_23[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_23f_GET(r) ((((r).cmic_top_sbus_ring_map_16_23[0]) >> 28) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_23f_SET(r,f) (r).cmic_top_sbus_ring_map_16_23[0]=(((r).cmic_top_sbus_ring_map_16_23[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_TOP_SBUS_RING_MAP_16_23.
 */
#define READ_CMIC_TOP_SBUS_RING_MAP_16_23r(u,r) bcm5607x_read32(u, CMIC_TOP_SBUS_RING_MAP_16_23, &(r._cmic_top_sbus_ring_map_16_23))
#define WRITE_CMIC_TOP_SBUS_RING_MAP_16_23r(u,r) bcm5607x_write32(u, CMIC_TOP_SBUS_RING_MAP_16_23, (r._cmic_top_sbus_ring_map_16_23))

/*******************************************************************************
 * End of 'CMIC_TOP_SBUS_RING_MAP_16_23r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_TOP_SBUS_RING_MAP_24_31
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (24 to 31) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_24 S-bus ring number for agent with S-bus ID  24
 *     RING_NUM_SBUS_ID_25 S-bus ring number for agent with S-bus ID  25
 *     RING_NUM_SBUS_ID_26 S-bus ring number for agent with S-bus ID  26
 *     RING_NUM_SBUS_ID_27 S-bus ring number for agent with S-bus ID  27
 *     RING_NUM_SBUS_ID_28 S-bus ring number for agent with S-bus ID  28
 *     RING_NUM_SBUS_ID_29 S-bus ring number for agent with S-bus ID  29
 *     RING_NUM_SBUS_ID_30 S-bus ring number for agent with S-bus ID  30
 *     RING_NUM_SBUS_ID_31 S-bus ring number for agent with S-bus ID  31
 */
#define CMIC_TOP_SBUS_RING_MAP_24_31r_SIZE 4

/* CMIC_TOP_SBUS_RING_MAP_24_31r is element of CMIC_TOP_SBUS_RING_MAP */

/*
 * This structure should be used to declare and program CMIC_TOP_SBUS_RING_MAP_24_31.
 */
typedef union CMIC_TOP_SBUS_RING_MAP_24_31r_s {
	uint32 v[1];
	uint32 cmic_top_sbus_ring_map_24_31[1];
	uint32 _cmic_top_sbus_ring_map_24_31;
} CMIC_TOP_SBUS_RING_MAP_24_31r_t;

#define CMIC_TOP_SBUS_RING_MAP_24_31r_CLR(r) (r).cmic_top_sbus_ring_map_24_31[0] = 0
#define CMIC_TOP_SBUS_RING_MAP_24_31r_SET(r,d) (r).cmic_top_sbus_ring_map_24_31[0] = d
#define CMIC_TOP_SBUS_RING_MAP_24_31r_GET(r) (r).cmic_top_sbus_ring_map_24_31[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_24f_GET(r) (((r).cmic_top_sbus_ring_map_24_31[0]) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_24f_SET(r,f) (r).cmic_top_sbus_ring_map_24_31[0]=(((r).cmic_top_sbus_ring_map_24_31[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_25f_GET(r) ((((r).cmic_top_sbus_ring_map_24_31[0]) >> 4) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_25f_SET(r,f) (r).cmic_top_sbus_ring_map_24_31[0]=(((r).cmic_top_sbus_ring_map_24_31[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_26f_GET(r) ((((r).cmic_top_sbus_ring_map_24_31[0]) >> 8) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_26f_SET(r,f) (r).cmic_top_sbus_ring_map_24_31[0]=(((r).cmic_top_sbus_ring_map_24_31[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_27f_GET(r) ((((r).cmic_top_sbus_ring_map_24_31[0]) >> 12) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_27f_SET(r,f) (r).cmic_top_sbus_ring_map_24_31[0]=(((r).cmic_top_sbus_ring_map_24_31[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_28f_GET(r) ((((r).cmic_top_sbus_ring_map_24_31[0]) >> 16) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_28f_SET(r,f) (r).cmic_top_sbus_ring_map_24_31[0]=(((r).cmic_top_sbus_ring_map_24_31[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_29f_GET(r) ((((r).cmic_top_sbus_ring_map_24_31[0]) >> 20) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_29f_SET(r,f) (r).cmic_top_sbus_ring_map_24_31[0]=(((r).cmic_top_sbus_ring_map_24_31[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_30f_GET(r) ((((r).cmic_top_sbus_ring_map_24_31[0]) >> 24) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_30f_SET(r,f) (r).cmic_top_sbus_ring_map_24_31[0]=(((r).cmic_top_sbus_ring_map_24_31[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_31f_GET(r) ((((r).cmic_top_sbus_ring_map_24_31[0]) >> 28) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_31f_SET(r,f) (r).cmic_top_sbus_ring_map_24_31[0]=(((r).cmic_top_sbus_ring_map_24_31[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_TOP_SBUS_RING_MAP_24_31.
 */
#define READ_CMIC_TOP_SBUS_RING_MAP_24_31r(u,r) bcm5607x_read32(u, CMIC_TOP_SBUS_RING_MAP_24_31, &(r._cmic_top_sbus_ring_map_24_31))
#define WRITE_CMIC_TOP_SBUS_RING_MAP_24_31r(u,r) bcm5607x_write32(u, CMIC_TOP_SBUS_RING_MAP_24_31, (r._cmic_top_sbus_ring_map_24_31))

/*******************************************************************************
 * End of 'CMIC_TOP_SBUS_RING_MAP_24_31r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_TOP_SBUS_RING_MAP_32_39
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (32 to 39) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_32 S-bus ring number for agent with S-bus ID  32
 *     RING_NUM_SBUS_ID_33 S-bus ring number for agent with S-bus ID  33
 *     RING_NUM_SBUS_ID_34 S-bus ring number for agent with S-bus ID  34
 *     RING_NUM_SBUS_ID_35 S-bus ring number for agent with S-bus ID  35
 *     RING_NUM_SBUS_ID_36 S-bus ring number for agent with S-bus ID  36
 *     RING_NUM_SBUS_ID_37 S-bus ring number for agent with S-bus ID  37
 *     RING_NUM_SBUS_ID_38 S-bus ring number for agent with S-bus ID  38
 *     RING_NUM_SBUS_ID_39 S-bus ring number for agent with S-bus ID  39
 */
#define CMIC_TOP_SBUS_RING_MAP_32_39r_SIZE 4

/* CMIC_TOP_SBUS_RING_MAP_32_39r is element of CMIC_TOP_SBUS_RING_MAP */

/*
 * This structure should be used to declare and program CMIC_TOP_SBUS_RING_MAP_32_39.
 */
typedef union CMIC_TOP_SBUS_RING_MAP_32_39r_s {
	uint32 v[1];
	uint32 cmic_top_sbus_ring_map_32_39[1];
	uint32 _cmic_top_sbus_ring_map_32_39;
} CMIC_TOP_SBUS_RING_MAP_32_39r_t;

#define CMIC_TOP_SBUS_RING_MAP_32_39r_CLR(r) (r).cmic_top_sbus_ring_map_32_39[0] = 0
#define CMIC_TOP_SBUS_RING_MAP_32_39r_SET(r,d) (r).cmic_top_sbus_ring_map_32_39[0] = d
#define CMIC_TOP_SBUS_RING_MAP_32_39r_GET(r) (r).cmic_top_sbus_ring_map_32_39[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_32f_GET(r) (((r).cmic_top_sbus_ring_map_32_39[0]) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_32f_SET(r,f) (r).cmic_top_sbus_ring_map_32_39[0]=(((r).cmic_top_sbus_ring_map_32_39[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_33f_GET(r) ((((r).cmic_top_sbus_ring_map_32_39[0]) >> 4) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_33f_SET(r,f) (r).cmic_top_sbus_ring_map_32_39[0]=(((r).cmic_top_sbus_ring_map_32_39[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_34f_GET(r) ((((r).cmic_top_sbus_ring_map_32_39[0]) >> 8) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_34f_SET(r,f) (r).cmic_top_sbus_ring_map_32_39[0]=(((r).cmic_top_sbus_ring_map_32_39[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_35f_GET(r) ((((r).cmic_top_sbus_ring_map_32_39[0]) >> 12) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_35f_SET(r,f) (r).cmic_top_sbus_ring_map_32_39[0]=(((r).cmic_top_sbus_ring_map_32_39[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_36f_GET(r) ((((r).cmic_top_sbus_ring_map_32_39[0]) >> 16) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_36f_SET(r,f) (r).cmic_top_sbus_ring_map_32_39[0]=(((r).cmic_top_sbus_ring_map_32_39[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_37f_GET(r) ((((r).cmic_top_sbus_ring_map_32_39[0]) >> 20) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_37f_SET(r,f) (r).cmic_top_sbus_ring_map_32_39[0]=(((r).cmic_top_sbus_ring_map_32_39[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_38f_GET(r) ((((r).cmic_top_sbus_ring_map_32_39[0]) >> 24) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_38f_SET(r,f) (r).cmic_top_sbus_ring_map_32_39[0]=(((r).cmic_top_sbus_ring_map_32_39[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_39f_GET(r) ((((r).cmic_top_sbus_ring_map_32_39[0]) >> 28) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_39f_SET(r,f) (r).cmic_top_sbus_ring_map_32_39[0]=(((r).cmic_top_sbus_ring_map_32_39[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_TOP_SBUS_RING_MAP_32_39.
 */
#define READ_CMIC_TOP_SBUS_RING_MAP_32_39r(u,r) bcm5607x_read32(u, CMIC_TOP_SBUS_RING_MAP_32_39, &(r._cmic_top_sbus_ring_map_32_39))
#define WRITE_CMIC_TOP_SBUS_RING_MAP_32_39r(u,r) bcm5607x_write32(u, CMIC_TOP_SBUS_RING_MAP_32_39, (r._cmic_top_sbus_ring_map_32_39))

/*******************************************************************************
 * End of 'CMIC_TOP_SBUS_RING_MAP_32_39r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_TOP_SBUS_RING_MAP_40_47
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (40 to 47) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_40 S-bus ring number for agent with S-bus ID  40
 *     RING_NUM_SBUS_ID_41 S-bus ring number for agent with S-bus ID  41
 *     RING_NUM_SBUS_ID_42 S-bus ring number for agent with S-bus ID  42
 *     RING_NUM_SBUS_ID_43 S-bus ring number for agent with S-bus ID  43
 *     RING_NUM_SBUS_ID_44 S-bus ring number for agent with S-bus ID  44
 *     RING_NUM_SBUS_ID_45 S-bus ring number for agent with S-bus ID  45
 *     RING_NUM_SBUS_ID_46 S-bus ring number for agent with S-bus ID  46
 *     RING_NUM_SBUS_ID_47 S-bus ring number for agent with S-bus ID  47
 */
#define CMIC_TOP_SBUS_RING_MAP_40_47r_SIZE 4

/* CMIC_TOP_SBUS_RING_MAP_40_47r is element of CMIC_TOP_SBUS_RING_MAP */

/*
 * This structure should be used to declare and program CMIC_TOP_SBUS_RING_MAP_40_47.
 */
typedef union CMIC_TOP_SBUS_RING_MAP_40_47r_s {
	uint32 v[1];
	uint32 cmic_top_sbus_ring_map_40_47[1];
	uint32 _cmic_top_sbus_ring_map_40_47;
} CMIC_TOP_SBUS_RING_MAP_40_47r_t;

#define CMIC_TOP_SBUS_RING_MAP_40_47r_CLR(r) (r).cmic_top_sbus_ring_map_40_47[0] = 0
#define CMIC_TOP_SBUS_RING_MAP_40_47r_SET(r,d) (r).cmic_top_sbus_ring_map_40_47[0] = d
#define CMIC_TOP_SBUS_RING_MAP_40_47r_GET(r) (r).cmic_top_sbus_ring_map_40_47[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_40f_GET(r) (((r).cmic_top_sbus_ring_map_40_47[0]) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_40f_SET(r,f) (r).cmic_top_sbus_ring_map_40_47[0]=(((r).cmic_top_sbus_ring_map_40_47[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_41f_GET(r) ((((r).cmic_top_sbus_ring_map_40_47[0]) >> 4) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_41f_SET(r,f) (r).cmic_top_sbus_ring_map_40_47[0]=(((r).cmic_top_sbus_ring_map_40_47[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_42f_GET(r) ((((r).cmic_top_sbus_ring_map_40_47[0]) >> 8) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_42f_SET(r,f) (r).cmic_top_sbus_ring_map_40_47[0]=(((r).cmic_top_sbus_ring_map_40_47[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_43f_GET(r) ((((r).cmic_top_sbus_ring_map_40_47[0]) >> 12) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_43f_SET(r,f) (r).cmic_top_sbus_ring_map_40_47[0]=(((r).cmic_top_sbus_ring_map_40_47[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_44f_GET(r) ((((r).cmic_top_sbus_ring_map_40_47[0]) >> 16) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_44f_SET(r,f) (r).cmic_top_sbus_ring_map_40_47[0]=(((r).cmic_top_sbus_ring_map_40_47[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_45f_GET(r) ((((r).cmic_top_sbus_ring_map_40_47[0]) >> 20) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_45f_SET(r,f) (r).cmic_top_sbus_ring_map_40_47[0]=(((r).cmic_top_sbus_ring_map_40_47[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_46f_GET(r) ((((r).cmic_top_sbus_ring_map_40_47[0]) >> 24) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_46f_SET(r,f) (r).cmic_top_sbus_ring_map_40_47[0]=(((r).cmic_top_sbus_ring_map_40_47[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_47f_GET(r) ((((r).cmic_top_sbus_ring_map_40_47[0]) >> 28) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_47f_SET(r,f) (r).cmic_top_sbus_ring_map_40_47[0]=(((r).cmic_top_sbus_ring_map_40_47[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_TOP_SBUS_RING_MAP_40_47.
 */
#define READ_CMIC_TOP_SBUS_RING_MAP_40_47r(u,r) bcm5607x_read32(u, CMIC_TOP_SBUS_RING_MAP_40_47, &(r._cmic_top_sbus_ring_map_40_47))
#define WRITE_CMIC_TOP_SBUS_RING_MAP_40_47r(u,r) bcm5607x_write32(u, CMIC_TOP_SBUS_RING_MAP_40_47, (r._cmic_top_sbus_ring_map_40_47))

/*******************************************************************************
 * End of 'CMIC_TOP_SBUS_RING_MAP_40_47r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_TOP_SBUS_RING_MAP_8_15
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (8 to 15) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_8 S-bus ring number for agent with S-bus ID  8
 *     RING_NUM_SBUS_ID_9 S-bus ring number for agent with S-bus ID  9
 *     RING_NUM_SBUS_ID_10 S-bus ring number for agent with S-bus ID  10
 *     RING_NUM_SBUS_ID_11 S-bus ring number for agent with S-bus ID  11
 *     RING_NUM_SBUS_ID_12 S-bus ring number for agent with S-bus ID  12
 *     RING_NUM_SBUS_ID_13 S-bus ring number for agent with S-bus ID  13
 *     RING_NUM_SBUS_ID_14 S-bus ring number for agent with S-bus ID  14
 *     RING_NUM_SBUS_ID_15 S-bus ring number for agent with S-bus ID  15
 */
#define CMIC_TOP_SBUS_RING_MAP_8_15r_SIZE 4

/* CMIC_TOP_SBUS_RING_MAP_8_15r is element of CMIC_TOP_SBUS_RING_MAP */

/*
 * This structure should be used to declare and program CMIC_TOP_SBUS_RING_MAP_8_15.
 */
typedef union CMIC_TOP_SBUS_RING_MAP_8_15r_s {
	uint32 v[1];
	uint32 cmic_top_sbus_ring_map_8_15[1];
	uint32 _cmic_top_sbus_ring_map_8_15;
} CMIC_TOP_SBUS_RING_MAP_8_15r_t;

#define CMIC_TOP_SBUS_RING_MAP_8_15r_CLR(r) (r).cmic_top_sbus_ring_map_8_15[0] = 0
#define CMIC_TOP_SBUS_RING_MAP_8_15r_SET(r,d) (r).cmic_top_sbus_ring_map_8_15[0] = d
#define CMIC_TOP_SBUS_RING_MAP_8_15r_GET(r) (r).cmic_top_sbus_ring_map_8_15[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_8f_GET(r) (((r).cmic_top_sbus_ring_map_8_15[0]) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_8f_SET(r,f) (r).cmic_top_sbus_ring_map_8_15[0]=(((r).cmic_top_sbus_ring_map_8_15[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_9f_GET(r) ((((r).cmic_top_sbus_ring_map_8_15[0]) >> 4) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_9f_SET(r,f) (r).cmic_top_sbus_ring_map_8_15[0]=(((r).cmic_top_sbus_ring_map_8_15[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_10f_GET(r) ((((r).cmic_top_sbus_ring_map_8_15[0]) >> 8) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_10f_SET(r,f) (r).cmic_top_sbus_ring_map_8_15[0]=(((r).cmic_top_sbus_ring_map_8_15[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_11f_GET(r) ((((r).cmic_top_sbus_ring_map_8_15[0]) >> 12) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_11f_SET(r,f) (r).cmic_top_sbus_ring_map_8_15[0]=(((r).cmic_top_sbus_ring_map_8_15[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_12f_GET(r) ((((r).cmic_top_sbus_ring_map_8_15[0]) >> 16) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_12f_SET(r,f) (r).cmic_top_sbus_ring_map_8_15[0]=(((r).cmic_top_sbus_ring_map_8_15[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_13f_GET(r) ((((r).cmic_top_sbus_ring_map_8_15[0]) >> 20) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_13f_SET(r,f) (r).cmic_top_sbus_ring_map_8_15[0]=(((r).cmic_top_sbus_ring_map_8_15[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_14f_GET(r) ((((r).cmic_top_sbus_ring_map_8_15[0]) >> 24) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_14f_SET(r,f) (r).cmic_top_sbus_ring_map_8_15[0]=(((r).cmic_top_sbus_ring_map_8_15[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_15f_GET(r) ((((r).cmic_top_sbus_ring_map_8_15[0]) >> 28) & 0xf)
#define CMIC_TOP_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_15f_SET(r,f) (r).cmic_top_sbus_ring_map_8_15[0]=(((r).cmic_top_sbus_ring_map_8_15[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_TOP_SBUS_RING_MAP_8_15.
 */
#define READ_CMIC_TOP_SBUS_RING_MAP_8_15r(u,r) bcm5607x_read32(u, CMIC_TOP_SBUS_RING_MAP_8_15, &(r._cmic_top_sbus_ring_map_8_15))
#define WRITE_CMIC_TOP_SBUS_RING_MAP_8_15r(u,r) bcm5607x_write32(u, CMIC_TOP_SBUS_RING_MAP_8_15, (r._cmic_top_sbus_ring_map_8_15))

/*******************************************************************************
 * End of 'CMIC_TOP_SBUS_RING_MAP_8_15r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CMIC_TOP_SBUS_TIMEOUT
 * BLOCKS:   CMIC
 * DESC:     S-bus operation completion time limit (in terms of 
number of core clocks).
If this limit is exceeded, the CMIC will set the SW PIO
"DONE" bit and the "ERROR" bit to indicate the timeout.

 * SIZE:     32
 * FIELDS:
 *     TIMEOUT_VAL      Timeout value in core clocks
 */
#define CMIC_TOP_SBUS_TIMEOUTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TOP_SBUS_TIMEOUT.
 */
typedef union CMIC_TOP_SBUS_TIMEOUTr_s {
	uint32 v[1];
	uint32 cmic_top_sbus_timeout[1];
	uint32 _cmic_top_sbus_timeout;
} CMIC_TOP_SBUS_TIMEOUTr_t;

#define CMIC_TOP_SBUS_TIMEOUTr_CLR(r) (r).cmic_top_sbus_timeout[0] = 0
#define CMIC_TOP_SBUS_TIMEOUTr_SET(r,d) (r).cmic_top_sbus_timeout[0] = d
#define CMIC_TOP_SBUS_TIMEOUTr_GET(r) (r).cmic_top_sbus_timeout[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_TOP_SBUS_TIMEOUTr_TIMEOUT_VALf_GET(r) ((r).cmic_top_sbus_timeout[0])
#define CMIC_TOP_SBUS_TIMEOUTr_TIMEOUT_VALf_SET(r,f) (r).cmic_top_sbus_timeout[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_TOP_SBUS_TIMEOUT.
 */
#define READ_CMIC_TOP_SBUS_TIMEOUTr(u,r) bcm5607x_read32(u, CMIC_TOP_SBUS_TIMEOUT, &(r._cmic_top_sbus_timeout))
#define WRITE_CMIC_TOP_SBUS_TIMEOUTr(u,r) bcm5607x_write32(u, CMIC_TOP_SBUS_TIMEOUT, (r._cmic_top_sbus_timeout))

/*******************************************************************************
 * End of 'CMIC_TOP_SBUS_TIMEOUTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CNGCOSPKTLIMIT0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT0  PKT THD.CNG0 Set Limit for COS n for an egress port.This sets the packet threshold numbers that are allowed for CNG0 packets per egress port of CoS n.When MISCCONIG.CNG_DROP_EN=1, all incoming packets with packet counts above (>=) this threshold and with the following congestion value (CNG[1:0] == 2'b01 => RED) will be dropped. 
 */
#define CNGCOSPKTLIMIT0r_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT0.
 */
typedef union CNGCOSPKTLIMIT0r_s {
	uint32 v[1];
	uint32 cngcospktlimit0[1];
	uint32 _cngcospktlimit0;
} CNGCOSPKTLIMIT0r_t;

#define CNGCOSPKTLIMIT0r_CLR(r) (r).cngcospktlimit0[0] = 0
#define CNGCOSPKTLIMIT0r_SET(r,d) (r).cngcospktlimit0[0] = d
#define CNGCOSPKTLIMIT0r_GET(r) (r).cngcospktlimit0[0]

/*
 * These macros can be used to access individual fields.
 */
#define CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_GET(r) (((r).cngcospktlimit0[0]) & 0x1fff)
#define CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_SET(r,f) (r).cngcospktlimit0[0]=(((r).cngcospktlimit0[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT0.
 */
#define WRITE_CNGCOSPKTLIMIT0r(u,p, cos,r) bcm5607x_reg_set(u, R_CNGCOSPKTLIMIT0(cos,p), (r._cngcospktlimit0))
#define READ_CNGCOSPKTLIMIT0r(u,p, cos,r) bcm5607x_reg_get(u,R_CNGCOSPKTLIMIT0(cos,p),&(r._cngcospktlimit0))

/*******************************************************************************
 * End of 'CNGCOSPKTLIMIT0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CNGCOSPKTLIMIT0_QGROUP
 * BLOCKS:   MMU
 * DESC:     per-QG HOL packet RED color threshold
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT0  CNG0 Set Limit for COS n for an egress port.This sets the packet threshold numbers that are allowed for CNG0 packets per egress port of CoS n.When MISCCONIG.CNG_DROP_EN=1, all incoming packets with packet counts above (>=) this threshold and with the following congestion value (CNG[1:0] == 2'b01 => RED) will be dropped. 
 */
#define CNGCOSPKTLIMIT0_QGROUPr_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT0_QGROUP.
 */
typedef union CNGCOSPKTLIMIT0_QGROUPr_s {
	uint32 v[1];
	uint32 cngcospktlimit0_qgroup[1];
	uint32 _cngcospktlimit0_qgroup;
} CNGCOSPKTLIMIT0_QGROUPr_t;

#define CNGCOSPKTLIMIT0_QGROUPr_CLR(r) (r).cngcospktlimit0_qgroup[0] = 0
#define CNGCOSPKTLIMIT0_QGROUPr_SET(r,d) (r).cngcospktlimit0_qgroup[0] = d
#define CNGCOSPKTLIMIT0_QGROUPr_GET(r) (r).cngcospktlimit0_qgroup[0]

/*
 * These macros can be used to access individual fields.
 */
#define CNGCOSPKTLIMIT0_QGROUPr_CNGPKTSETLIMIT0f_GET(r) (((r).cngcospktlimit0_qgroup[0]) & 0x1fff)
#define CNGCOSPKTLIMIT0_QGROUPr_CNGPKTSETLIMIT0f_SET(r,f) (r).cngcospktlimit0_qgroup[0]=(((r).cngcospktlimit0_qgroup[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT0_QGROUP.
 */
#define WRITE_CNGCOSPKTLIMIT0_QGROUPr(u,p, i,r) bcm5607x_reg_set(u, R_CNGCOSPKTLIMIT0_QGROUP(i,p), (r._cngcospktlimit0_qgroup))
#define READ_CNGCOSPKTLIMIT0_QGROUPr(u,p, i,r) bcm5607x_reg_get(u,R_CNGCOSPKTLIMIT0_QGROUP(i,p),&(r._cngcospktlimit0_qgroup))

/*******************************************************************************
 * End of 'CNGCOSPKTLIMIT0_QGROUPr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CNGCOSPKTLIMIT0_QLAYER
 * BLOCKS:   MMU
 * DESC:     per-Q HOL packet RED color threshold
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT0  CNG0 Set Limit for COS n for an egress port.This sets the packet threshold numbers that are allowed for CNG0 packets per egress port of CoS n.When MISCCONIG.CNG_DROP_EN=1, all incoming packets with packet counts above (>=) this threshold and with the following congestion value (CNG[1:0] == 2'b01 => RED) will be dropped. 
 */
#define CNGCOSPKTLIMIT0_QLAYERr_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT0_QLAYER.
 */
typedef union CNGCOSPKTLIMIT0_QLAYERr_s {
	uint32 v[1];
	uint32 cngcospktlimit0_qlayer[1];
	uint32 _cngcospktlimit0_qlayer;
} CNGCOSPKTLIMIT0_QLAYERr_t;

#define CNGCOSPKTLIMIT0_QLAYERr_CLR(r) (r).cngcospktlimit0_qlayer[0] = 0
#define CNGCOSPKTLIMIT0_QLAYERr_SET(r,d) (r).cngcospktlimit0_qlayer[0] = d
#define CNGCOSPKTLIMIT0_QLAYERr_GET(r) (r).cngcospktlimit0_qlayer[0]

/*
 * These macros can be used to access individual fields.
 */
#define CNGCOSPKTLIMIT0_QLAYERr_CNGPKTSETLIMIT0f_GET(r) (((r).cngcospktlimit0_qlayer[0]) & 0x1fff)
#define CNGCOSPKTLIMIT0_QLAYERr_CNGPKTSETLIMIT0f_SET(r,f) (r).cngcospktlimit0_qlayer[0]=(((r).cngcospktlimit0_qlayer[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT0_QLAYER.
 */
#define WRITE_CNGCOSPKTLIMIT0_QLAYERr(u,p, cos,r) bcm5607x_reg_set(u, R_CNGCOSPKTLIMIT0_QLAYER(cos,p), (r._cngcospktlimit0_qlayer))
#define READ_CNGCOSPKTLIMIT0_QLAYERr(u,p, cos,r) bcm5607x_reg_get(u,R_CNGCOSPKTLIMIT0_QLAYER(cos,p),&(r._cngcospktlimit0_qlayer))

/*******************************************************************************
 * End of 'CNGCOSPKTLIMIT0_QLAYERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CNGCOSPKTLIMIT1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT1  PKT THD.CNG1 Set Limit for COS n for an egress port.This sets the packet threshold numbers that are allowed for CNG1 packets per egress port of COS n.When MISCCONIG.CNG_DROP_EN=1, all incoming packets with packet counts above (>=) this threshold and with the following congestion value (CNG[1:0] == 2'b01 => RED) and (CNG[1:0] == 2'b11 => YELLOW)will be dropped. 
 */
#define CNGCOSPKTLIMIT1r_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT1.
 */
typedef union CNGCOSPKTLIMIT1r_s {
	uint32 v[1];
	uint32 cngcospktlimit1[1];
	uint32 _cngcospktlimit1;
} CNGCOSPKTLIMIT1r_t;

#define CNGCOSPKTLIMIT1r_CLR(r) (r).cngcospktlimit1[0] = 0
#define CNGCOSPKTLIMIT1r_SET(r,d) (r).cngcospktlimit1[0] = d
#define CNGCOSPKTLIMIT1r_GET(r) (r).cngcospktlimit1[0]

/*
 * These macros can be used to access individual fields.
 */
#define CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_GET(r) (((r).cngcospktlimit1[0]) & 0x1fff)
#define CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_SET(r,f) (r).cngcospktlimit1[0]=(((r).cngcospktlimit1[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT1.
 */
#define WRITE_CNGCOSPKTLIMIT1r(u,p, cos,r) bcm5607x_reg_set(u, R_CNGCOSPKTLIMIT1(cos,p), (r._cngcospktlimit1))
#define READ_CNGCOSPKTLIMIT1r(u,p, cos,r) bcm5607x_reg_get(u,R_CNGCOSPKTLIMIT1(cos,p),&(r._cngcospktlimit1))

/*******************************************************************************
 * End of 'CNGCOSPKTLIMIT1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CNGCOSPKTLIMIT1_QGROUP
 * BLOCKS:   MMU
 * DESC:     per-QG HOL packet Yellow color threshold
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT1  CNG1 Set Limit for COS n for an egress port.This sets the packet threshold numbers that are allowed for CNG1 packets per egress port of COS n.When MISCCONIG.CNG_DROP_EN=1, all incoming packets with packet counts above (>=) this threshold and with the following congestion value (CNG[1:0] == 2'b01 => RED) and (CNG[1:0] == 2'b11 => YELLOW)will be dropped. 
 */
#define CNGCOSPKTLIMIT1_QGROUPr_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT1_QGROUP.
 */
typedef union CNGCOSPKTLIMIT1_QGROUPr_s {
	uint32 v[1];
	uint32 cngcospktlimit1_qgroup[1];
	uint32 _cngcospktlimit1_qgroup;
} CNGCOSPKTLIMIT1_QGROUPr_t;

#define CNGCOSPKTLIMIT1_QGROUPr_CLR(r) (r).cngcospktlimit1_qgroup[0] = 0
#define CNGCOSPKTLIMIT1_QGROUPr_SET(r,d) (r).cngcospktlimit1_qgroup[0] = d
#define CNGCOSPKTLIMIT1_QGROUPr_GET(r) (r).cngcospktlimit1_qgroup[0]

/*
 * These macros can be used to access individual fields.
 */
#define CNGCOSPKTLIMIT1_QGROUPr_CNGPKTSETLIMIT1f_GET(r) (((r).cngcospktlimit1_qgroup[0]) & 0x1fff)
#define CNGCOSPKTLIMIT1_QGROUPr_CNGPKTSETLIMIT1f_SET(r,f) (r).cngcospktlimit1_qgroup[0]=(((r).cngcospktlimit1_qgroup[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT1_QGROUP.
 */
#define WRITE_CNGCOSPKTLIMIT1_QGROUPr(u,p, i,r) bcm5607x_reg_set(u, R_CNGCOSPKTLIMIT1_QGROUP(i,p), (r._cngcospktlimit1_qgroup))
#define READ_CNGCOSPKTLIMIT1_QGROUPr(u,p, i,r) bcm5607x_reg_get(u,R_CNGCOSPKTLIMIT1_QGROUP(i,p),&(r._cngcospktlimit1_qgroup))

/*******************************************************************************
 * End of 'CNGCOSPKTLIMIT1_QGROUPr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CNGCOSPKTLIMIT1_QLAYER
 * BLOCKS:   MMU
 * DESC:     per-Q HOL packet Yellow color threshold
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT1  CNG1 Set Limit for COS n for an egress port.This sets the packet threshold numbers that are allowed for CNG1 packets per egress port of COS n.When MISCCONIG.CNG_DROP_EN=1, all incoming packets with packet counts above (>=) this threshold and with the following congestion value (CNG[1:0] == 2'b01 => RED) and (CNG[1:0] == 2'b11 => YELLOW)will be dropped. 
 */
#define CNGCOSPKTLIMIT1_QLAYERr_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT1_QLAYER.
 */
typedef union CNGCOSPKTLIMIT1_QLAYERr_s {
	uint32 v[1];
	uint32 cngcospktlimit1_qlayer[1];
	uint32 _cngcospktlimit1_qlayer;
} CNGCOSPKTLIMIT1_QLAYERr_t;

#define CNGCOSPKTLIMIT1_QLAYERr_CLR(r) (r).cngcospktlimit1_qlayer[0] = 0
#define CNGCOSPKTLIMIT1_QLAYERr_SET(r,d) (r).cngcospktlimit1_qlayer[0] = d
#define CNGCOSPKTLIMIT1_QLAYERr_GET(r) (r).cngcospktlimit1_qlayer[0]

/*
 * These macros can be used to access individual fields.
 */
#define CNGCOSPKTLIMIT1_QLAYERr_CNGPKTSETLIMIT1f_GET(r) (((r).cngcospktlimit1_qlayer[0]) & 0x1fff)
#define CNGCOSPKTLIMIT1_QLAYERr_CNGPKTSETLIMIT1f_SET(r,f) (r).cngcospktlimit1_qlayer[0]=(((r).cngcospktlimit1_qlayer[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT1_QLAYER.
 */
#define WRITE_CNGCOSPKTLIMIT1_QLAYERr(u,p, cos,r) bcm5607x_reg_set(u, R_CNGCOSPKTLIMIT1_QLAYER(cos,p), (r._cngcospktlimit1_qlayer))
#define READ_CNGCOSPKTLIMIT1_QLAYERr(u,p, cos,r) bcm5607x_reg_get(u,R_CNGCOSPKTLIMIT1_QLAYER(cos,p),&(r._cngcospktlimit1_qlayer))

/*******************************************************************************
 * End of 'CNGCOSPKTLIMIT1_QLAYERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CNGPORTPKTLIMIT0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPORTPKTLIMIT0 PKT THD.CNG0 Set Limit for an egress port.This sets the packet threshold numbers that are allowed for CNG0 packets per egress port. When packet count for an egress port is above this limit, incoming packet carried congestion color red (CNG[1:0]==2'b01) will be dropped for that port, if that cos is consuming XQ dynamic space. This limit is needed to be set lower than Total XQ size of the same port to ensure dropping CNG0 packet mechanism will take effect early than HOL. 
 */
#define CNGPORTPKTLIMIT0r_SIZE 4

/* CNGPORTPKTLIMIT0r is element of CNGPORTPKTLIMIT */

/*
 * This structure should be used to declare and program CNGPORTPKTLIMIT0.
 */
typedef union CNGPORTPKTLIMIT0r_s {
	uint32 v[1];
	uint32 cngportpktlimit0[1];
	uint32 _cngportpktlimit0;
} CNGPORTPKTLIMIT0r_t;

#define CNGPORTPKTLIMIT0r_CLR(r) (r).cngportpktlimit0[0] = 0
#define CNGPORTPKTLIMIT0r_SET(r,d) (r).cngportpktlimit0[0] = d
#define CNGPORTPKTLIMIT0r_GET(r) (r).cngportpktlimit0[0]

/*
 * These macros can be used to access individual fields.
 */
#define CNGPORTPKTLIMIT0r_CNGPORTPKTLIMIT0f_GET(r) (((r).cngportpktlimit0[0]) & 0x1fff)
#define CNGPORTPKTLIMIT0r_CNGPORTPKTLIMIT0f_SET(r,f) (r).cngportpktlimit0[0]=(((r).cngportpktlimit0[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access CNGPORTPKTLIMIT0.
 */
#define WRITE_CNGPORTPKTLIMIT0r(u,p,r) bcm5607x_reg_set(u,R_CNGPORTPKTLIMIT0(p),(r._cngportpktlimit0))
#define READ_CNGPORTPKTLIMIT0r(u,p,r) bcm5607x_reg_get(u,R_CNGPORTPKTLIMIT0(p),&(r._cngportpktlimit0))

/*******************************************************************************
 * End of 'CNGPORTPKTLIMIT0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  CNGPORTPKTLIMIT1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPORTPKTLIMIT1 PKT THD.CNG1 Set Limit for an egress port.This sets the packet threshold numbers that are allowed for CNG1 packets per egress port. When packet count for an egress port is above this limit, incoming packet carried congestion color yellow (CNG[1:0]==2'b11) will be dropped for that port, if that cos is consuming XQ dynamic space. This limit is needed to be set lower than Total XQ size of the same port to ensure dropping CNG1 packet mechanism will take effect early than HOL. 
 */
#define CNGPORTPKTLIMIT1r_SIZE 4

/* CNGPORTPKTLIMIT1r is element of CNGPORTPKTLIMIT */

/*
 * This structure should be used to declare and program CNGPORTPKTLIMIT1.
 */
typedef union CNGPORTPKTLIMIT1r_s {
	uint32 v[1];
	uint32 cngportpktlimit1[1];
	uint32 _cngportpktlimit1;
} CNGPORTPKTLIMIT1r_t;

#define CNGPORTPKTLIMIT1r_CLR(r) (r).cngportpktlimit1[0] = 0
#define CNGPORTPKTLIMIT1r_SET(r,d) (r).cngportpktlimit1[0] = d
#define CNGPORTPKTLIMIT1r_GET(r) (r).cngportpktlimit1[0]

/*
 * These macros can be used to access individual fields.
 */
#define CNGPORTPKTLIMIT1r_CNGPORTPKTLIMIT1f_GET(r) (((r).cngportpktlimit1[0]) & 0x1fff)
#define CNGPORTPKTLIMIT1r_CNGPORTPKTLIMIT1f_SET(r,f) (r).cngportpktlimit1[0]=(((r).cngportpktlimit1[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access CNGPORTPKTLIMIT1.
 */
#define WRITE_CNGPORTPKTLIMIT1r(u,p,r) bcm5607x_reg_set(u,R_CNGPORTPKTLIMIT1(p),(r._cngportpktlimit1))
#define READ_CNGPORTPKTLIMIT1r(u,p,r) bcm5607x_reg_get(u,R_CNGPORTPKTLIMIT1(p),&(r._cngportpktlimit1))

/*******************************************************************************
 * End of 'CNGPORTPKTLIMIT1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  COLOR_DROP_EN
 * BLOCKS:   MMU
 * DESC:     Enable register for queue color discard for color congestion management
 * SIZE:     32
 * FIELDS:
 *     COLOR_DROP_EN    Enable register for queue's color discard for color congestion management0: Disable1: Enable 
 */
#define COLOR_DROP_ENr_SIZE 4

/*
 * This structure should be used to declare and program COLOR_DROP_EN.
 */
typedef union COLOR_DROP_ENr_s {
	uint32 v[1];
	uint32 color_drop_en[1];
	uint32 _color_drop_en;
} COLOR_DROP_ENr_t;

#define COLOR_DROP_ENr_CLR(r) (r).color_drop_en[0] = 0
#define COLOR_DROP_ENr_SET(r,d) (r).color_drop_en[0] = d
#define COLOR_DROP_ENr_GET(r) (r).color_drop_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define COLOR_DROP_ENr_COLOR_DROP_ENf_GET(r) (((r).color_drop_en[0]) & 0xff)
#define COLOR_DROP_ENr_COLOR_DROP_ENf_SET(r,f) (r).color_drop_en[0]=(((r).color_drop_en[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))

/*
 * These macros can be used to access COLOR_DROP_EN.
 */
#define WRITE_COLOR_DROP_ENr(u,p,r) bcm5607x_reg_set(u,R_COLOR_DROP_EN(p),(r._color_drop_en))
#define READ_COLOR_DROP_ENr(u,p,r) bcm5607x_reg_get(u,R_COLOR_DROP_EN(p),&(r._color_drop_en))

/*******************************************************************************
 * End of 'COLOR_DROP_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  COLOR_DROP_EN_QGROUP
 * BLOCKS:   MMU
 * DESC:     Enable register for queue groups color discard for color congestion managements
 * SIZE:     32
 * FIELDS:
 *     COLOR_DROP_EN    Enable register for queue group's color discard for color congestion managementx0: Disable1: Enable 
 */
#define COLOR_DROP_EN_QGROUPr_SIZE 4

/*
 * This structure should be used to declare and program COLOR_DROP_EN_QGROUP.
 */
typedef union COLOR_DROP_EN_QGROUPr_s {
	uint32 v[1];
	uint32 color_drop_en_qgroup[1];
	uint32 _color_drop_en_qgroup;
} COLOR_DROP_EN_QGROUPr_t;

#define COLOR_DROP_EN_QGROUPr_CLR(r) (r).color_drop_en_qgroup[0] = 0
#define COLOR_DROP_EN_QGROUPr_SET(r,d) (r).color_drop_en_qgroup[0] = d
#define COLOR_DROP_EN_QGROUPr_GET(r) (r).color_drop_en_qgroup[0]

/*
 * These macros can be used to access individual fields.
 */
#define COLOR_DROP_EN_QGROUPr_COLOR_DROP_ENf_GET(r) (((r).color_drop_en_qgroup[0]) & 0xff)
#define COLOR_DROP_EN_QGROUPr_COLOR_DROP_ENf_SET(r,f) (r).color_drop_en_qgroup[0]=(((r).color_drop_en_qgroup[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))

/*
 * These macros can be used to access COLOR_DROP_EN_QGROUP.
 */
#define WRITE_COLOR_DROP_EN_QGROUPr(u,p,r) bcm5607x_reg_set(u,R_COLOR_DROP_EN_QGROUP(p),(r._color_drop_en_qgroup))
#define READ_COLOR_DROP_EN_QGROUPr(u,p,r) bcm5607x_reg_get(u,R_COLOR_DROP_EN_QGROUP(p),&(r._color_drop_en_qgroup))

/*******************************************************************************
 * End of 'COLOR_DROP_EN_QGROUPr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  COLOR_DROP_EN_QLAYER
 * BLOCKS:   MMU
 * DESC:     Enable register for queue color discard for color congestion management
 * SIZE:     32
 * FIELDS:
 *     COLOR_DROP_EN    The first register is for Q0~31, the 2nd one is for Q32~63Enable register for queue's color discard for color congestion management0: Disable1: Enable 
 */
#define COLOR_DROP_EN_QLAYERr_SIZE 4

/*
 * This structure should be used to declare and program COLOR_DROP_EN_QLAYER.
 */
typedef union COLOR_DROP_EN_QLAYERr_s {
	uint32 v[1];
	uint32 color_drop_en_qlayer[1];
	uint32 _color_drop_en_qlayer;
} COLOR_DROP_EN_QLAYERr_t;

#define COLOR_DROP_EN_QLAYERr_CLR(r) (r).color_drop_en_qlayer[0] = 0
#define COLOR_DROP_EN_QLAYERr_SET(r,d) (r).color_drop_en_qlayer[0] = d
#define COLOR_DROP_EN_QLAYERr_GET(r) (r).color_drop_en_qlayer[0]

/*
 * These macros can be used to access individual fields.
 */
#define COLOR_DROP_EN_QLAYERr_COLOR_DROP_ENf_GET(r) ((r).color_drop_en_qlayer[0])
#define COLOR_DROP_EN_QLAYERr_COLOR_DROP_ENf_SET(r,f) (r).color_drop_en_qlayer[0]=((uint32)f)

/*
 * These macros can be used to access COLOR_DROP_EN_QLAYER.
 */
#define WRITE_COLOR_DROP_EN_QLAYERr(u,p, i,r) bcm5607x_reg_set(u, R_COLOR_DROP_EN_QLAYER(i,p), (r._color_drop_en_qlayer))
#define READ_COLOR_DROP_EN_QLAYERr(u,p, i,r) bcm5607x_reg_get(u,R_COLOR_DROP_EN_QLAYER(i,p),&(r._color_drop_en_qlayer))

/*******************************************************************************
 * End of 'COLOR_DROP_EN_QLAYERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  COMMAND_CONFIG
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Command register. Used by the host processor to control and configure the core
 * SIZE:     32
 * FIELDS:
 *     TX_ENA           Enable/Disable MAC transmit path for data packets & pause/pfc packets sent in the normal data path.Pause/pfc packets generated internally are allowed if ignore_tx_pause is not set. When set to '0' (Reset value), the MAC transmit function is disable.  When set to '1', the MAC transmit function is enabled.
 *     RX_ENA           Enable/Disable MAC receive path. When set to '0' (Reset value), the MAC receive function is disable.  When set to '1', the MAC receive function is enabled.
 *     ETH_SPEED        Set MAC speed. Ignored when the register bit ENA_EXT_CONFIG is set to '1'.  When the Register bit ENA_EXT_CONFIG is set to '0', used to set the core mode of operation: 00: Enable 10Mbps Ethernet mode 01: Enable 100Mbps Ethernet mode 10: Enable Gigabit Ethernet mode 11: Enable 2.5Gigabit Ethernet mode
 *     PROMIS_EN        Enable/Disable MAC promiscuous operation. When asserted (Set to '1'), all frames are received without Unicast address filtering.
 *     PAD_EN           Enable/Disable Frame Padding. If enabled (Set to '1'), then padding is removed from the received frame before it is transmitted to the userapplication. If disabled (set to reset value '0'), then no padding is removed on receive by the MAC. This bit has no effect on Tx padding and hence Transmit always pad runts to guarantee a minimum frame size of 64 octets.
 *     CRC_FWD          Terminate/Forward Received CRC. If enabled (1) the CRC field of received frames are transmitted to the user application.If disabled (0) the CRC field is stripped from the frame.Note: If padding function (Bit PAD_EN set to '1') is enabled. CRC_FWD is ignored and the CRC field is checked and always terminated and removed.
 *     PAUSE_FWD        Terminate/Forward Pause Frames. If enabled (Set to '1') pause frames are forwarded to the user application.  If disabled (Set to reset value '0'), pause frames are terminated and discarded in the MAC.
 *     PAUSE_IGNORE     Ignore Pause Frame Quanta. If enabled (Set to '1') received pause frames are ignored by the MAC. When disabled (Set to reset value '0') the transmit process is stopped for the amount of time specified in the pause quanta received within the pause frame.
 *     TX_ADDR_INS      Set MAC address on transmit. If enabled (Set to '1') the MAC overwrites the source MAC address with the programmed MAC address in registers MAC_0 and MAC_1. If disabled (Set to reset value '0'), the source MAC address received from the transmit application transmitted is not modified by the MAC.
 *     HD_ENA           Half duplex enable. When set to '1', enables half duplex mode, when set to '0', the MAC operates in full duplex mode.Ignored at ethernet speeds 1G/2.5G or when the register ENA_EXT_CONFIG is set to '1'.
 *     RX_LOW_LATENCY_EN This works only when runt filter is disabled. It reduces the receive latency by 48 MAC clock time.
 *     OVERFLOW_EN      If set, enables Rx FIFO overflow logic. In this case, the RXFIFO_STAT[1] register bit is not operational (always set to 0).If cleared, disables RX FIFO overflow logic. In this case, the RXFIFO_STAT[1] register bit is operational (Sticky set when overrun occurs, clearable only by SW_Reset).
 *     SW_RESET         Software Reset Command. When asserted, the TX and RX are disabled. Config registers are not affected by sw reset. Write a 0 to de-assert the sw reset. 
 *     FCS_CORRUPT_URUN_EN Corrupt Tx FCS, on underrun, when set to '1', No FCS corruption when set to '0' (Reset value).
 *     LOOP_ENA         Enable GMII/MII loopback when set to '1', normal operation when set to '0' (Reset value).
 *     MAC_LOOP_CON     Transmit packets to PHY while in MAC local loopback, when set to '1', otherwise transmit to PHY is disabled (normal operation),when set to '0' (Reset value).
 *     SW_OVERRIDE_TX   If set, enables the SW programmed Tx pause capability config bits to overwrite the auto negotiated Tx pause capabilities when ena_ext_config (autoconfig) is set.If cleared, and when ena_ext_config (autoconfig) is set, then SW programmed Tx pause capability config bits has no effect over auto negotiated capabilities.
 *     SW_OVERRIDE_RX   If set, enables the SW programmed Rx pause capability config bits to overwrite the auto negotiated Rx pause capabilities when ena_ext_config (autoconfig) is set.If cleared, and when ena_ext_config (autoconfig) is set, then SW programmed Rx pause capability config bits has no effect over auto negotiated capabilities.
 *     EN_INTERNAL_TX_CRS If enabled, then CRS input to Unimac is ORed with tds[8] (tx data valid output). This is helpful when TX CRS is disabled inside PHY.
 *     ENA_EXT_CONFIG   Enable Configuration with External Pins. When set to '0' (Reset value) the Core speed and Mode is programmed with the register bits ETH_SPEED(1:0) and HD_ENA. When set to '1', the Core is configured with the pins set_speed(1:0) and set_duplex.
 *     CNTL_FRM_ENA     MAC Control Frame Enable. When set to '1', MAC Control frames with any Opcode other than 0x0001 are accepted and forward to the Client interface. When set to '0' (Reset value), MAC Control frames with any Opcode other than 0x0001 are silently discarded.
 *     NO_LGTH_CHECK    Payload Length Check Disable. When set to '0', the Core checks the frame's payload length with the FrameLength/Type field, when set to '1'(Reset value), the payload length check is disabled.
 *     LINE_LOOPBACK    Enable Line Loopback i.e. MAC FIFO side loopback, when set to '1', normal operation when set to '0' (Reset value).
 *     RX_ERR_DISC      Receive Errored Frame Discard Enable. When set to '1', any frame received with an error is discarded in the Core and not forwarded to the Client interface. When set to '0', errored Frames are forwarded to the Client interface with ff_rx_err asserted.It is recommended to set RX_ERR_DISC to '1' only when Store and Forward operation is enabled on the Core Receive FIFO Receive FIFO Section full threshold set to 0).
 *     FD_TX_URUN_FIX_EN Tx Underflow detection can be improved by accounting for residue bytes in 128b to 8b convertor. The fix is valid only for full duplex mode and can be enabled by setting this bit. 
 *     IGNORE_TX_PAUSE  Ignores the back pressure signaling from the system and hence no Tx pause generation, when set.
 *     OOB_EFC_EN       If set then out-of-band egress flow control is enabled. When this bit is set and input pin ext_tx_flow_control is enabled then data frame trasmission is stopped, whereas Pause & PFC frames are transmitted normally. This operation is similar to halting the transmit datapath due to the reception of a Pause Frame with non-zero timer value, and is used in applications where the flow control information is exchanged out of band. Enabling or disabling this bit has no effect on regular Rx_pause pkt based egress flow control.
 *     RUNT_FILTER_DIS  When set, disable runt filtering.
 */
#define COMMAND_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program COMMAND_CONFIG.
 */
typedef union COMMAND_CONFIGr_s {
	uint32 v[1];
	uint32 command_config[1];
	uint32 _command_config;
} COMMAND_CONFIGr_t;

#define COMMAND_CONFIGr_CLR(r) (r).command_config[0] = 0
#define COMMAND_CONFIGr_SET(r,d) (r).command_config[0] = d
#define COMMAND_CONFIGr_GET(r) (r).command_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define COMMAND_CONFIGr_TX_ENAf_GET(r) (((r).command_config[0]) & 0x1)
#define COMMAND_CONFIGr_TX_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define COMMAND_CONFIGr_RX_ENAf_GET(r) ((((r).command_config[0]) >> 1) & 0x1)
#define COMMAND_CONFIGr_RX_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define COMMAND_CONFIGr_ETH_SPEEDf_GET(r) ((((r).command_config[0]) >> 2) & 0x3)
#define COMMAND_CONFIGr_ETH_SPEEDf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define COMMAND_CONFIGr_PROMIS_ENf_GET(r) ((((r).command_config[0]) >> 4) & 0x1)
#define COMMAND_CONFIGr_PROMIS_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define COMMAND_CONFIGr_PAD_ENf_GET(r) ((((r).command_config[0]) >> 5) & 0x1)
#define COMMAND_CONFIGr_PAD_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define COMMAND_CONFIGr_CRC_FWDf_GET(r) ((((r).command_config[0]) >> 6) & 0x1)
#define COMMAND_CONFIGr_CRC_FWDf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define COMMAND_CONFIGr_PAUSE_FWDf_GET(r) ((((r).command_config[0]) >> 7) & 0x1)
#define COMMAND_CONFIGr_PAUSE_FWDf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define COMMAND_CONFIGr_PAUSE_IGNOREf_GET(r) ((((r).command_config[0]) >> 8) & 0x1)
#define COMMAND_CONFIGr_PAUSE_IGNOREf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define COMMAND_CONFIGr_TX_ADDR_INSf_GET(r) ((((r).command_config[0]) >> 9) & 0x1)
#define COMMAND_CONFIGr_TX_ADDR_INSf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define COMMAND_CONFIGr_HD_ENAf_GET(r) ((((r).command_config[0]) >> 10) & 0x1)
#define COMMAND_CONFIGr_HD_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define COMMAND_CONFIGr_RX_LOW_LATENCY_ENf_GET(r) ((((r).command_config[0]) >> 11) & 0x1)
#define COMMAND_CONFIGr_RX_LOW_LATENCY_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define COMMAND_CONFIGr_OVERFLOW_ENf_GET(r) ((((r).command_config[0]) >> 12) & 0x1)
#define COMMAND_CONFIGr_OVERFLOW_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define COMMAND_CONFIGr_SW_RESETf_GET(r) ((((r).command_config[0]) >> 13) & 0x1)
#define COMMAND_CONFIGr_SW_RESETf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define COMMAND_CONFIGr_FCS_CORRUPT_URUN_ENf_GET(r) ((((r).command_config[0]) >> 14) & 0x1)
#define COMMAND_CONFIGr_FCS_CORRUPT_URUN_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define COMMAND_CONFIGr_LOOP_ENAf_GET(r) ((((r).command_config[0]) >> 15) & 0x1)
#define COMMAND_CONFIGr_LOOP_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define COMMAND_CONFIGr_MAC_LOOP_CONf_GET(r) ((((r).command_config[0]) >> 16) & 0x1)
#define COMMAND_CONFIGr_MAC_LOOP_CONf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define COMMAND_CONFIGr_SW_OVERRIDE_TXf_GET(r) ((((r).command_config[0]) >> 17) & 0x1)
#define COMMAND_CONFIGr_SW_OVERRIDE_TXf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define COMMAND_CONFIGr_SW_OVERRIDE_RXf_GET(r) ((((r).command_config[0]) >> 18) & 0x1)
#define COMMAND_CONFIGr_SW_OVERRIDE_RXf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define COMMAND_CONFIGr_EN_INTERNAL_TX_CRSf_GET(r) ((((r).command_config[0]) >> 21) & 0x1)
#define COMMAND_CONFIGr_EN_INTERNAL_TX_CRSf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define COMMAND_CONFIGr_ENA_EXT_CONFIGf_GET(r) ((((r).command_config[0]) >> 22) & 0x1)
#define COMMAND_CONFIGr_ENA_EXT_CONFIGf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define COMMAND_CONFIGr_CNTL_FRM_ENAf_GET(r) ((((r).command_config[0]) >> 23) & 0x1)
#define COMMAND_CONFIGr_CNTL_FRM_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define COMMAND_CONFIGr_NO_LGTH_CHECKf_GET(r) ((((r).command_config[0]) >> 24) & 0x1)
#define COMMAND_CONFIGr_NO_LGTH_CHECKf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define COMMAND_CONFIGr_LINE_LOOPBACKf_GET(r) ((((r).command_config[0]) >> 25) & 0x1)
#define COMMAND_CONFIGr_LINE_LOOPBACKf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define COMMAND_CONFIGr_RX_ERR_DISCf_GET(r) ((((r).command_config[0]) >> 26) & 0x1)
#define COMMAND_CONFIGr_RX_ERR_DISCf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define COMMAND_CONFIGr_FD_TX_URUN_FIX_ENf_GET(r) ((((r).command_config[0]) >> 27) & 0x1)
#define COMMAND_CONFIGr_FD_TX_URUN_FIX_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define COMMAND_CONFIGr_IGNORE_TX_PAUSEf_GET(r) ((((r).command_config[0]) >> 28) & 0x1)
#define COMMAND_CONFIGr_IGNORE_TX_PAUSEf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define COMMAND_CONFIGr_OOB_EFC_ENf_GET(r) ((((r).command_config[0]) >> 29) & 0x1)
#define COMMAND_CONFIGr_OOB_EFC_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define COMMAND_CONFIGr_RUNT_FILTER_DISf_GET(r) ((((r).command_config[0]) >> 30) & 0x1)
#define COMMAND_CONFIGr_RUNT_FILTER_DISf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))

/*
 * These macros can be used to access COMMAND_CONFIG.
 */
#define WRITE_COMMAND_CONFIGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_COMMAND_CONFIG(bcm5607x_gport_lport_to_index_in_block[p]), (r._command_config))
#define READ_COMMAND_CONFIGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_COMMAND_CONFIG(bcm5607x_gport_lport_to_index_in_block[p]), &(r._command_config))

/*******************************************************************************
 * End of 'COMMAND_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  COSLCCOUNT
 * BLOCKS:   MMU
 * DESC:     The COSx cell count
 * SIZE:     32
 * FIELDS:
 *     LCCOUNT          This indicates the number of cells enqueued for an egress port of COS n. 
 */
#define COSLCCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program COSLCCOUNT.
 */
typedef union COSLCCOUNTr_s {
	uint32 v[1];
	uint32 coslccount[1];
	uint32 _coslccount;
} COSLCCOUNTr_t;

#define COSLCCOUNTr_CLR(r) (r).coslccount[0] = 0
#define COSLCCOUNTr_SET(r,d) (r).coslccount[0] = d
#define COSLCCOUNTr_GET(r) (r).coslccount[0]

/*
 * These macros can be used to access individual fields.
 */
#define COSLCCOUNTr_LCCOUNTf_GET(r) (((r).coslccount[0]) & 0x3fff)
#define COSLCCOUNTr_LCCOUNTf_SET(r,f) (r).coslccount[0]=(((r).coslccount[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))

/*
 * These macros can be used to access COSLCCOUNT.
 */
#define WRITE_COSLCCOUNTr(u,p, cos,r) bcm5607x_reg_set(u, R_COSLCCOUNT(cos,p), (r._coslccount))
#define READ_COSLCCOUNTr(u,p, cos,r) bcm5607x_reg_get(u,R_COSLCCOUNT(cos,p),&(r._coslccount))

/*******************************************************************************
 * End of 'COSLCCOUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  COSLCCOUNT_QGROUP
 * BLOCKS:   MMU
 * DESC:     The QGx cell count, only dynamic part
 * SIZE:     32
 * FIELDS:
 *     LCCOUNT          This indicates the number of cells enqueued for an egress port of queue group n. only dynamic part is calculated into it.
 */
#define COSLCCOUNT_QGROUPr_SIZE 4

/*
 * This structure should be used to declare and program COSLCCOUNT_QGROUP.
 */
typedef union COSLCCOUNT_QGROUPr_s {
	uint32 v[1];
	uint32 coslccount_qgroup[1];
	uint32 _coslccount_qgroup;
} COSLCCOUNT_QGROUPr_t;

#define COSLCCOUNT_QGROUPr_CLR(r) (r).coslccount_qgroup[0] = 0
#define COSLCCOUNT_QGROUPr_SET(r,d) (r).coslccount_qgroup[0] = d
#define COSLCCOUNT_QGROUPr_GET(r) (r).coslccount_qgroup[0]

/*
 * These macros can be used to access individual fields.
 */
#define COSLCCOUNT_QGROUPr_LCCOUNTf_GET(r) (((r).coslccount_qgroup[0]) & 0x3fff)
#define COSLCCOUNT_QGROUPr_LCCOUNTf_SET(r,f) (r).coslccount_qgroup[0]=(((r).coslccount_qgroup[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))

/*
 * These macros can be used to access COSLCCOUNT_QGROUP.
 */
#define WRITE_COSLCCOUNT_QGROUPr(u,p, i,r) bcm5607x_reg_set(u, R_COSLCCOUNT_QGROUP(i,p), (r._coslccount_qgroup))
#define READ_COSLCCOUNT_QGROUPr(u,p, i,r) bcm5607x_reg_get(u,R_COSLCCOUNT_QGROUP(i,p),&(r._coslccount_qgroup))

/*******************************************************************************
 * End of 'COSLCCOUNT_QGROUPr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  COS_MAP
 * BLOCKS:   IPIPE
 * DESC:     This table allows per ingress port priorities to be mapped to egress queues. This table is indexed by {TAF_COS_PROFILE[3:0], COS_MAP_SEL.SELECT[1:0], ingress port internal priority[3:0]}
 * SIZE:     8
 * FIELDS:
 *     COS              8 CoS for Front Panel ports 
 */
#define COS_MAPm_MIN 0
#define COS_MAPm_MAX 1023
#define COS_MAPm_CMAX(u) 1023
#define COS_MAPm_SIZE 1

/*
 * This structure should be used to declare and program COS_MAP.
 */
typedef union COS_MAPm_s {
	uint32 v[1];
	uint32 cos_map[1];
	uint32 _cos_map;
} COS_MAPm_t;

#define COS_MAPm_CLR(r) (r).cos_map[0] = 0
#define COS_MAPm_SET(r,d) (r).cos_map[0] = d
#define COS_MAPm_GET(r) (r).cos_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define COS_MAPm_COSf_GET(r) (((r).cos_map[0]) & 0x7)
#define COS_MAPm_COSf_SET(r,f) (r).cos_map[0]=(((r).cos_map[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))

/*
 * These macros can be used to access COS_MAP.
 */
#define WRITE_COS_MAPm(u,i,r) bcm5607x_mem_set(u, M_COS_MAP(i), &(r._cos_map), 1)
#define READ_COS_MAPm(u,i,r) bcm5607x_mem_get(u, M_COS_MAP(i), &(r._cos_map), 1)

/*******************************************************************************
 * End of 'COS_MAPm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_CRU_RESET
 * BLOCKS:   IPROC
 * DESC:     DMU CRU reset control register
 * SIZE:     32
 * FIELDS:
 *     SW_RESET_N       Switch/CMICd reset. This includes top registers. (self-clear)
 *     IPROC_RESET_N    iProc only reset. (self-clear)
 */
#define DMU_CRU_RESETr_SIZE 4

/*
 * This structure should be used to declare and program DMU_CRU_RESET.
 */
typedef union DMU_CRU_RESETr_s {
	uint32 v[1];
	uint32 dmu_cru_reset[1];
	uint32 _dmu_cru_reset;
} DMU_CRU_RESETr_t;

#define DMU_CRU_RESETr_CLR(r) (r).dmu_cru_reset[0] = 0
#define DMU_CRU_RESETr_SET(r,d) (r).dmu_cru_reset[0] = d
#define DMU_CRU_RESETr_GET(r) (r).dmu_cru_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_CRU_RESETr_SW_RESET_Nf_GET(r) (((r).dmu_cru_reset[0]) & 0x1)
#define DMU_CRU_RESETr_SW_RESET_Nf_SET(r,f) (r).dmu_cru_reset[0]=(((r).dmu_cru_reset[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define DMU_CRU_RESETr_IPROC_RESET_Nf_GET(r) ((((r).dmu_cru_reset[0]) >> 1) & 0x1)
#define DMU_CRU_RESETr_IPROC_RESET_Nf_SET(r,f) (r).dmu_cru_reset[0]=(((r).dmu_cru_reset[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access DMU_CRU_RESET.
 */
#define READ_DMU_CRU_RESETr(u,r) bcm5607x_read32(u, R_DMU_CRU_RESET, &(r._dmu_cru_reset))
#define WRITE_DMU_CRU_RESETr(u,r) bcm5607x_write32(u, R_DMU_CRU_RESET, (r._dmu_cru_reset))

/*******************************************************************************
 * End of 'DMU_CRU_RESETr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_0
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_0r_SIZE 4

/* DMU_PCU_OTP_CONFIG_0r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_0.
 */
typedef union DMU_PCU_OTP_CONFIG_0r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_0[1];
	uint32 _dmu_pcu_otp_config_0;
} DMU_PCU_OTP_CONFIG_0r_t;

#define DMU_PCU_OTP_CONFIG_0r_CLR(r) (r).dmu_pcu_otp_config_0[0] = 0
#define DMU_PCU_OTP_CONFIG_0r_SET(r,d) (r).dmu_pcu_otp_config_0[0] = d
#define DMU_PCU_OTP_CONFIG_0r_GET(r) (r).dmu_pcu_otp_config_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_0r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_0[0])
#define DMU_PCU_OTP_CONFIG_0r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_0[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_0.
 */
#define READ_DMU_PCU_OTP_CONFIG_0r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_0, &(r._dmu_pcu_otp_config_0))
#define WRITE_DMU_PCU_OTP_CONFIG_0r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_0, (r._dmu_pcu_otp_config_0))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_1
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_1r_SIZE 4

/* DMU_PCU_OTP_CONFIG_1r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_1.
 */
typedef union DMU_PCU_OTP_CONFIG_1r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_1[1];
	uint32 _dmu_pcu_otp_config_1;
} DMU_PCU_OTP_CONFIG_1r_t;

#define DMU_PCU_OTP_CONFIG_1r_CLR(r) (r).dmu_pcu_otp_config_1[0] = 0
#define DMU_PCU_OTP_CONFIG_1r_SET(r,d) (r).dmu_pcu_otp_config_1[0] = d
#define DMU_PCU_OTP_CONFIG_1r_GET(r) (r).dmu_pcu_otp_config_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_1r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_1[0])
#define DMU_PCU_OTP_CONFIG_1r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_1[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_1.
 */
#define READ_DMU_PCU_OTP_CONFIG_1r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_1, &(r._dmu_pcu_otp_config_1))
#define WRITE_DMU_PCU_OTP_CONFIG_1r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_1, (r._dmu_pcu_otp_config_1))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_10
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_10r_SIZE 4

/* DMU_PCU_OTP_CONFIG_10r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_10.
 */
typedef union DMU_PCU_OTP_CONFIG_10r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_10[1];
	uint32 _dmu_pcu_otp_config_10;
} DMU_PCU_OTP_CONFIG_10r_t;

#define DMU_PCU_OTP_CONFIG_10r_CLR(r) (r).dmu_pcu_otp_config_10[0] = 0
#define DMU_PCU_OTP_CONFIG_10r_SET(r,d) (r).dmu_pcu_otp_config_10[0] = d
#define DMU_PCU_OTP_CONFIG_10r_GET(r) (r).dmu_pcu_otp_config_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_10r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_10[0])
#define DMU_PCU_OTP_CONFIG_10r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_10[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_10.
 */
#define READ_DMU_PCU_OTP_CONFIG_10r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_10, &(r._dmu_pcu_otp_config_10))
#define WRITE_DMU_PCU_OTP_CONFIG_10r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_10, (r._dmu_pcu_otp_config_10))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_10r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_11
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_11r_SIZE 4

/* DMU_PCU_OTP_CONFIG_11r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_11.
 */
typedef union DMU_PCU_OTP_CONFIG_11r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_11[1];
	uint32 _dmu_pcu_otp_config_11;
} DMU_PCU_OTP_CONFIG_11r_t;

#define DMU_PCU_OTP_CONFIG_11r_CLR(r) (r).dmu_pcu_otp_config_11[0] = 0
#define DMU_PCU_OTP_CONFIG_11r_SET(r,d) (r).dmu_pcu_otp_config_11[0] = d
#define DMU_PCU_OTP_CONFIG_11r_GET(r) (r).dmu_pcu_otp_config_11[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_11r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_11[0])
#define DMU_PCU_OTP_CONFIG_11r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_11[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_11.
 */
#define READ_DMU_PCU_OTP_CONFIG_11r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_11, &(r._dmu_pcu_otp_config_11))
#define WRITE_DMU_PCU_OTP_CONFIG_11r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_11, (r._dmu_pcu_otp_config_11))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_11r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_12
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_12r_SIZE 4

/* DMU_PCU_OTP_CONFIG_12r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_12.
 */
typedef union DMU_PCU_OTP_CONFIG_12r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_12[1];
	uint32 _dmu_pcu_otp_config_12;
} DMU_PCU_OTP_CONFIG_12r_t;

#define DMU_PCU_OTP_CONFIG_12r_CLR(r) (r).dmu_pcu_otp_config_12[0] = 0
#define DMU_PCU_OTP_CONFIG_12r_SET(r,d) (r).dmu_pcu_otp_config_12[0] = d
#define DMU_PCU_OTP_CONFIG_12r_GET(r) (r).dmu_pcu_otp_config_12[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_12r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_12[0])
#define DMU_PCU_OTP_CONFIG_12r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_12[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_12.
 */
#define READ_DMU_PCU_OTP_CONFIG_12r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_12, &(r._dmu_pcu_otp_config_12))
#define WRITE_DMU_PCU_OTP_CONFIG_12r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_12, (r._dmu_pcu_otp_config_12))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_12r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_13
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_13r_SIZE 4

/* DMU_PCU_OTP_CONFIG_13r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_13.
 */
typedef union DMU_PCU_OTP_CONFIG_13r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_13[1];
	uint32 _dmu_pcu_otp_config_13;
} DMU_PCU_OTP_CONFIG_13r_t;

#define DMU_PCU_OTP_CONFIG_13r_CLR(r) (r).dmu_pcu_otp_config_13[0] = 0
#define DMU_PCU_OTP_CONFIG_13r_SET(r,d) (r).dmu_pcu_otp_config_13[0] = d
#define DMU_PCU_OTP_CONFIG_13r_GET(r) (r).dmu_pcu_otp_config_13[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_13r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_13[0])
#define DMU_PCU_OTP_CONFIG_13r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_13[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_13.
 */
#define READ_DMU_PCU_OTP_CONFIG_13r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_13, &(r._dmu_pcu_otp_config_13))
#define WRITE_DMU_PCU_OTP_CONFIG_13r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_13, (r._dmu_pcu_otp_config_13))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_13r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_14
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_14r_SIZE 4

/* DMU_PCU_OTP_CONFIG_14r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_14.
 */
typedef union DMU_PCU_OTP_CONFIG_14r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_14[1];
	uint32 _dmu_pcu_otp_config_14;
} DMU_PCU_OTP_CONFIG_14r_t;

#define DMU_PCU_OTP_CONFIG_14r_CLR(r) (r).dmu_pcu_otp_config_14[0] = 0
#define DMU_PCU_OTP_CONFIG_14r_SET(r,d) (r).dmu_pcu_otp_config_14[0] = d
#define DMU_PCU_OTP_CONFIG_14r_GET(r) (r).dmu_pcu_otp_config_14[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_14r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_14[0])
#define DMU_PCU_OTP_CONFIG_14r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_14[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_14.
 */
#define READ_DMU_PCU_OTP_CONFIG_14r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_14, &(r._dmu_pcu_otp_config_14))
#define WRITE_DMU_PCU_OTP_CONFIG_14r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_14, (r._dmu_pcu_otp_config_14))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_14r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_15
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_15r_SIZE 4

/* DMU_PCU_OTP_CONFIG_15r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_15.
 */
typedef union DMU_PCU_OTP_CONFIG_15r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_15[1];
	uint32 _dmu_pcu_otp_config_15;
} DMU_PCU_OTP_CONFIG_15r_t;

#define DMU_PCU_OTP_CONFIG_15r_CLR(r) (r).dmu_pcu_otp_config_15[0] = 0
#define DMU_PCU_OTP_CONFIG_15r_SET(r,d) (r).dmu_pcu_otp_config_15[0] = d
#define DMU_PCU_OTP_CONFIG_15r_GET(r) (r).dmu_pcu_otp_config_15[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_15r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_15[0])
#define DMU_PCU_OTP_CONFIG_15r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_15[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_15.
 */
#define READ_DMU_PCU_OTP_CONFIG_15r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_15, &(r._dmu_pcu_otp_config_15))
#define WRITE_DMU_PCU_OTP_CONFIG_15r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_15, (r._dmu_pcu_otp_config_15))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_15r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_16
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_16r_SIZE 4

/* DMU_PCU_OTP_CONFIG_16r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_16.
 */
typedef union DMU_PCU_OTP_CONFIG_16r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_16[1];
	uint32 _dmu_pcu_otp_config_16;
} DMU_PCU_OTP_CONFIG_16r_t;

#define DMU_PCU_OTP_CONFIG_16r_CLR(r) (r).dmu_pcu_otp_config_16[0] = 0
#define DMU_PCU_OTP_CONFIG_16r_SET(r,d) (r).dmu_pcu_otp_config_16[0] = d
#define DMU_PCU_OTP_CONFIG_16r_GET(r) (r).dmu_pcu_otp_config_16[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_16r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_16[0])
#define DMU_PCU_OTP_CONFIG_16r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_16[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_16.
 */
#define READ_DMU_PCU_OTP_CONFIG_16r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_16, &(r._dmu_pcu_otp_config_16))
#define WRITE_DMU_PCU_OTP_CONFIG_16r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_16, (r._dmu_pcu_otp_config_16))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_16r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_17
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_17r_SIZE 4

/* DMU_PCU_OTP_CONFIG_17r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_17.
 */
typedef union DMU_PCU_OTP_CONFIG_17r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_17[1];
	uint32 _dmu_pcu_otp_config_17;
} DMU_PCU_OTP_CONFIG_17r_t;

#define DMU_PCU_OTP_CONFIG_17r_CLR(r) (r).dmu_pcu_otp_config_17[0] = 0
#define DMU_PCU_OTP_CONFIG_17r_SET(r,d) (r).dmu_pcu_otp_config_17[0] = d
#define DMU_PCU_OTP_CONFIG_17r_GET(r) (r).dmu_pcu_otp_config_17[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_17r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_17[0])
#define DMU_PCU_OTP_CONFIG_17r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_17[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_17.
 */
#define READ_DMU_PCU_OTP_CONFIG_17r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_17, &(r._dmu_pcu_otp_config_17))
#define WRITE_DMU_PCU_OTP_CONFIG_17r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_17, (r._dmu_pcu_otp_config_17))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_17r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_18
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_18r_SIZE 4

/* DMU_PCU_OTP_CONFIG_18r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_18.
 */
typedef union DMU_PCU_OTP_CONFIG_18r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_18[1];
	uint32 _dmu_pcu_otp_config_18;
} DMU_PCU_OTP_CONFIG_18r_t;

#define DMU_PCU_OTP_CONFIG_18r_CLR(r) (r).dmu_pcu_otp_config_18[0] = 0
#define DMU_PCU_OTP_CONFIG_18r_SET(r,d) (r).dmu_pcu_otp_config_18[0] = d
#define DMU_PCU_OTP_CONFIG_18r_GET(r) (r).dmu_pcu_otp_config_18[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_18r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_18[0])
#define DMU_PCU_OTP_CONFIG_18r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_18[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_18.
 */
#define READ_DMU_PCU_OTP_CONFIG_18r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_18, &(r._dmu_pcu_otp_config_18))
#define WRITE_DMU_PCU_OTP_CONFIG_18r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_18, (r._dmu_pcu_otp_config_18))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_18r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_19
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_19r_SIZE 4

/* DMU_PCU_OTP_CONFIG_19r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_19.
 */
typedef union DMU_PCU_OTP_CONFIG_19r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_19[1];
	uint32 _dmu_pcu_otp_config_19;
} DMU_PCU_OTP_CONFIG_19r_t;

#define DMU_PCU_OTP_CONFIG_19r_CLR(r) (r).dmu_pcu_otp_config_19[0] = 0
#define DMU_PCU_OTP_CONFIG_19r_SET(r,d) (r).dmu_pcu_otp_config_19[0] = d
#define DMU_PCU_OTP_CONFIG_19r_GET(r) (r).dmu_pcu_otp_config_19[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_19r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_19[0])
#define DMU_PCU_OTP_CONFIG_19r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_19[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_19.
 */
#define READ_DMU_PCU_OTP_CONFIG_19r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_19, &(r._dmu_pcu_otp_config_19))
#define WRITE_DMU_PCU_OTP_CONFIG_19r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_19, (r._dmu_pcu_otp_config_19))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_19r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_2
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_2r_SIZE 4

/* DMU_PCU_OTP_CONFIG_2r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_2.
 */
typedef union DMU_PCU_OTP_CONFIG_2r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_2[1];
	uint32 _dmu_pcu_otp_config_2;
} DMU_PCU_OTP_CONFIG_2r_t;

#define DMU_PCU_OTP_CONFIG_2r_CLR(r) (r).dmu_pcu_otp_config_2[0] = 0
#define DMU_PCU_OTP_CONFIG_2r_SET(r,d) (r).dmu_pcu_otp_config_2[0] = d
#define DMU_PCU_OTP_CONFIG_2r_GET(r) (r).dmu_pcu_otp_config_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_2r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_2[0])
#define DMU_PCU_OTP_CONFIG_2r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_2[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_2.
 */
#define READ_DMU_PCU_OTP_CONFIG_2r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_2, &(r._dmu_pcu_otp_config_2))
#define WRITE_DMU_PCU_OTP_CONFIG_2r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_2, (r._dmu_pcu_otp_config_2))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_20
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_20r_SIZE 4

/* DMU_PCU_OTP_CONFIG_20r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_20.
 */
typedef union DMU_PCU_OTP_CONFIG_20r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_20[1];
	uint32 _dmu_pcu_otp_config_20;
} DMU_PCU_OTP_CONFIG_20r_t;

#define DMU_PCU_OTP_CONFIG_20r_CLR(r) (r).dmu_pcu_otp_config_20[0] = 0
#define DMU_PCU_OTP_CONFIG_20r_SET(r,d) (r).dmu_pcu_otp_config_20[0] = d
#define DMU_PCU_OTP_CONFIG_20r_GET(r) (r).dmu_pcu_otp_config_20[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_20r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_20[0])
#define DMU_PCU_OTP_CONFIG_20r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_20[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_20.
 */
#define READ_DMU_PCU_OTP_CONFIG_20r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_20, &(r._dmu_pcu_otp_config_20))
#define WRITE_DMU_PCU_OTP_CONFIG_20r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_20, (r._dmu_pcu_otp_config_20))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_20r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_21
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_21r_SIZE 4

/* DMU_PCU_OTP_CONFIG_21r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_21.
 */
typedef union DMU_PCU_OTP_CONFIG_21r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_21[1];
	uint32 _dmu_pcu_otp_config_21;
} DMU_PCU_OTP_CONFIG_21r_t;

#define DMU_PCU_OTP_CONFIG_21r_CLR(r) (r).dmu_pcu_otp_config_21[0] = 0
#define DMU_PCU_OTP_CONFIG_21r_SET(r,d) (r).dmu_pcu_otp_config_21[0] = d
#define DMU_PCU_OTP_CONFIG_21r_GET(r) (r).dmu_pcu_otp_config_21[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_21r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_21[0])
#define DMU_PCU_OTP_CONFIG_21r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_21[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_21.
 */
#define READ_DMU_PCU_OTP_CONFIG_21r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_21, &(r._dmu_pcu_otp_config_21))
#define WRITE_DMU_PCU_OTP_CONFIG_21r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_21, (r._dmu_pcu_otp_config_21))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_21r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_22
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_22r_SIZE 4

/* DMU_PCU_OTP_CONFIG_22r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_22.
 */
typedef union DMU_PCU_OTP_CONFIG_22r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_22[1];
	uint32 _dmu_pcu_otp_config_22;
} DMU_PCU_OTP_CONFIG_22r_t;

#define DMU_PCU_OTP_CONFIG_22r_CLR(r) (r).dmu_pcu_otp_config_22[0] = 0
#define DMU_PCU_OTP_CONFIG_22r_SET(r,d) (r).dmu_pcu_otp_config_22[0] = d
#define DMU_PCU_OTP_CONFIG_22r_GET(r) (r).dmu_pcu_otp_config_22[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_22r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_22[0])
#define DMU_PCU_OTP_CONFIG_22r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_22[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_22.
 */
#define READ_DMU_PCU_OTP_CONFIG_22r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_22, &(r._dmu_pcu_otp_config_22))
#define WRITE_DMU_PCU_OTP_CONFIG_22r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_22, (r._dmu_pcu_otp_config_22))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_22r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_23
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_23r_SIZE 4

/* DMU_PCU_OTP_CONFIG_23r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_23.
 */
typedef union DMU_PCU_OTP_CONFIG_23r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_23[1];
	uint32 _dmu_pcu_otp_config_23;
} DMU_PCU_OTP_CONFIG_23r_t;

#define DMU_PCU_OTP_CONFIG_23r_CLR(r) (r).dmu_pcu_otp_config_23[0] = 0
#define DMU_PCU_OTP_CONFIG_23r_SET(r,d) (r).dmu_pcu_otp_config_23[0] = d
#define DMU_PCU_OTP_CONFIG_23r_GET(r) (r).dmu_pcu_otp_config_23[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_23r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_23[0])
#define DMU_PCU_OTP_CONFIG_23r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_23[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_23.
 */
#define READ_DMU_PCU_OTP_CONFIG_23r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_23, &(r._dmu_pcu_otp_config_23))
#define WRITE_DMU_PCU_OTP_CONFIG_23r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_23, (r._dmu_pcu_otp_config_23))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_23r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_24
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_24r_SIZE 4

/* DMU_PCU_OTP_CONFIG_24r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_24.
 */
typedef union DMU_PCU_OTP_CONFIG_24r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_24[1];
	uint32 _dmu_pcu_otp_config_24;
} DMU_PCU_OTP_CONFIG_24r_t;

#define DMU_PCU_OTP_CONFIG_24r_CLR(r) (r).dmu_pcu_otp_config_24[0] = 0
#define DMU_PCU_OTP_CONFIG_24r_SET(r,d) (r).dmu_pcu_otp_config_24[0] = d
#define DMU_PCU_OTP_CONFIG_24r_GET(r) (r).dmu_pcu_otp_config_24[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_24r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_24[0])
#define DMU_PCU_OTP_CONFIG_24r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_24[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_24.
 */
#define READ_DMU_PCU_OTP_CONFIG_24r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_24, &(r._dmu_pcu_otp_config_24))
#define WRITE_DMU_PCU_OTP_CONFIG_24r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_24, (r._dmu_pcu_otp_config_24))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_24r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_25
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_25r_SIZE 4

/* DMU_PCU_OTP_CONFIG_25r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_25.
 */
typedef union DMU_PCU_OTP_CONFIG_25r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_25[1];
	uint32 _dmu_pcu_otp_config_25;
} DMU_PCU_OTP_CONFIG_25r_t;

#define DMU_PCU_OTP_CONFIG_25r_CLR(r) (r).dmu_pcu_otp_config_25[0] = 0
#define DMU_PCU_OTP_CONFIG_25r_SET(r,d) (r).dmu_pcu_otp_config_25[0] = d
#define DMU_PCU_OTP_CONFIG_25r_GET(r) (r).dmu_pcu_otp_config_25[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_25r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_25[0])
#define DMU_PCU_OTP_CONFIG_25r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_25[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_25.
 */
#define READ_DMU_PCU_OTP_CONFIG_25r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_25, &(r._dmu_pcu_otp_config_25))
#define WRITE_DMU_PCU_OTP_CONFIG_25r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_25, (r._dmu_pcu_otp_config_25))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_25r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_26
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_26r_SIZE 4

/* DMU_PCU_OTP_CONFIG_26r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_26.
 */
typedef union DMU_PCU_OTP_CONFIG_26r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_26[1];
	uint32 _dmu_pcu_otp_config_26;
} DMU_PCU_OTP_CONFIG_26r_t;

#define DMU_PCU_OTP_CONFIG_26r_CLR(r) (r).dmu_pcu_otp_config_26[0] = 0
#define DMU_PCU_OTP_CONFIG_26r_SET(r,d) (r).dmu_pcu_otp_config_26[0] = d
#define DMU_PCU_OTP_CONFIG_26r_GET(r) (r).dmu_pcu_otp_config_26[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_26r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_26[0])
#define DMU_PCU_OTP_CONFIG_26r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_26[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_26.
 */
#define READ_DMU_PCU_OTP_CONFIG_26r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_26, &(r._dmu_pcu_otp_config_26))
#define WRITE_DMU_PCU_OTP_CONFIG_26r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_26, (r._dmu_pcu_otp_config_26))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_26r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_27
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_27r_SIZE 4

/* DMU_PCU_OTP_CONFIG_27r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_27.
 */
typedef union DMU_PCU_OTP_CONFIG_27r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_27[1];
	uint32 _dmu_pcu_otp_config_27;
} DMU_PCU_OTP_CONFIG_27r_t;

#define DMU_PCU_OTP_CONFIG_27r_CLR(r) (r).dmu_pcu_otp_config_27[0] = 0
#define DMU_PCU_OTP_CONFIG_27r_SET(r,d) (r).dmu_pcu_otp_config_27[0] = d
#define DMU_PCU_OTP_CONFIG_27r_GET(r) (r).dmu_pcu_otp_config_27[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_27r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_27[0])
#define DMU_PCU_OTP_CONFIG_27r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_27[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_27.
 */
#define READ_DMU_PCU_OTP_CONFIG_27r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_27, &(r._dmu_pcu_otp_config_27))
#define WRITE_DMU_PCU_OTP_CONFIG_27r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_27, (r._dmu_pcu_otp_config_27))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_27r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_28
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_28r_SIZE 4

/* DMU_PCU_OTP_CONFIG_28r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_28.
 */
typedef union DMU_PCU_OTP_CONFIG_28r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_28[1];
	uint32 _dmu_pcu_otp_config_28;
} DMU_PCU_OTP_CONFIG_28r_t;

#define DMU_PCU_OTP_CONFIG_28r_CLR(r) (r).dmu_pcu_otp_config_28[0] = 0
#define DMU_PCU_OTP_CONFIG_28r_SET(r,d) (r).dmu_pcu_otp_config_28[0] = d
#define DMU_PCU_OTP_CONFIG_28r_GET(r) (r).dmu_pcu_otp_config_28[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_28r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_28[0])
#define DMU_PCU_OTP_CONFIG_28r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_28[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_28.
 */
#define READ_DMU_PCU_OTP_CONFIG_28r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_28, &(r._dmu_pcu_otp_config_28))
#define WRITE_DMU_PCU_OTP_CONFIG_28r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_28, (r._dmu_pcu_otp_config_28))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_28r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_29
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_29r_SIZE 4

/* DMU_PCU_OTP_CONFIG_29r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_29.
 */
typedef union DMU_PCU_OTP_CONFIG_29r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_29[1];
	uint32 _dmu_pcu_otp_config_29;
} DMU_PCU_OTP_CONFIG_29r_t;

#define DMU_PCU_OTP_CONFIG_29r_CLR(r) (r).dmu_pcu_otp_config_29[0] = 0
#define DMU_PCU_OTP_CONFIG_29r_SET(r,d) (r).dmu_pcu_otp_config_29[0] = d
#define DMU_PCU_OTP_CONFIG_29r_GET(r) (r).dmu_pcu_otp_config_29[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_29r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_29[0])
#define DMU_PCU_OTP_CONFIG_29r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_29[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_29.
 */
#define READ_DMU_PCU_OTP_CONFIG_29r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_29, &(r._dmu_pcu_otp_config_29))
#define WRITE_DMU_PCU_OTP_CONFIG_29r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_29, (r._dmu_pcu_otp_config_29))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_29r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_3
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_3r_SIZE 4

/* DMU_PCU_OTP_CONFIG_3r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_3.
 */
typedef union DMU_PCU_OTP_CONFIG_3r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_3[1];
	uint32 _dmu_pcu_otp_config_3;
} DMU_PCU_OTP_CONFIG_3r_t;

#define DMU_PCU_OTP_CONFIG_3r_CLR(r) (r).dmu_pcu_otp_config_3[0] = 0
#define DMU_PCU_OTP_CONFIG_3r_SET(r,d) (r).dmu_pcu_otp_config_3[0] = d
#define DMU_PCU_OTP_CONFIG_3r_GET(r) (r).dmu_pcu_otp_config_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_3r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_3[0])
#define DMU_PCU_OTP_CONFIG_3r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_3[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_3.
 */
#define READ_DMU_PCU_OTP_CONFIG_3r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_3, &(r._dmu_pcu_otp_config_3))
#define WRITE_DMU_PCU_OTP_CONFIG_3r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_3, (r._dmu_pcu_otp_config_3))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_3r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_30
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_30r_SIZE 4

/* DMU_PCU_OTP_CONFIG_30r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_30.
 */
typedef union DMU_PCU_OTP_CONFIG_30r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_30[1];
	uint32 _dmu_pcu_otp_config_30;
} DMU_PCU_OTP_CONFIG_30r_t;

#define DMU_PCU_OTP_CONFIG_30r_CLR(r) (r).dmu_pcu_otp_config_30[0] = 0
#define DMU_PCU_OTP_CONFIG_30r_SET(r,d) (r).dmu_pcu_otp_config_30[0] = d
#define DMU_PCU_OTP_CONFIG_30r_GET(r) (r).dmu_pcu_otp_config_30[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_30r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_30[0])
#define DMU_PCU_OTP_CONFIG_30r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_30[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_30.
 */
#define READ_DMU_PCU_OTP_CONFIG_30r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_30, &(r._dmu_pcu_otp_config_30))
#define WRITE_DMU_PCU_OTP_CONFIG_30r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_30, (r._dmu_pcu_otp_config_30))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_30r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_31
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_31r_SIZE 4

/* DMU_PCU_OTP_CONFIG_31r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_31.
 */
typedef union DMU_PCU_OTP_CONFIG_31r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_31[1];
	uint32 _dmu_pcu_otp_config_31;
} DMU_PCU_OTP_CONFIG_31r_t;

#define DMU_PCU_OTP_CONFIG_31r_CLR(r) (r).dmu_pcu_otp_config_31[0] = 0
#define DMU_PCU_OTP_CONFIG_31r_SET(r,d) (r).dmu_pcu_otp_config_31[0] = d
#define DMU_PCU_OTP_CONFIG_31r_GET(r) (r).dmu_pcu_otp_config_31[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_31r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_31[0])
#define DMU_PCU_OTP_CONFIG_31r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_31[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_31.
 */
#define READ_DMU_PCU_OTP_CONFIG_31r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_31, &(r._dmu_pcu_otp_config_31))
#define WRITE_DMU_PCU_OTP_CONFIG_31r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_31, (r._dmu_pcu_otp_config_31))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_31r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_4
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_4r_SIZE 4

/* DMU_PCU_OTP_CONFIG_4r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_4.
 */
typedef union DMU_PCU_OTP_CONFIG_4r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_4[1];
	uint32 _dmu_pcu_otp_config_4;
} DMU_PCU_OTP_CONFIG_4r_t;

#define DMU_PCU_OTP_CONFIG_4r_CLR(r) (r).dmu_pcu_otp_config_4[0] = 0
#define DMU_PCU_OTP_CONFIG_4r_SET(r,d) (r).dmu_pcu_otp_config_4[0] = d
#define DMU_PCU_OTP_CONFIG_4r_GET(r) (r).dmu_pcu_otp_config_4[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_4r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_4[0])
#define DMU_PCU_OTP_CONFIG_4r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_4[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_4.
 */
#define READ_DMU_PCU_OTP_CONFIG_4r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_4, &(r._dmu_pcu_otp_config_4))
#define WRITE_DMU_PCU_OTP_CONFIG_4r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_4, (r._dmu_pcu_otp_config_4))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_4r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_5
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_5r_SIZE 4

/* DMU_PCU_OTP_CONFIG_5r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_5.
 */
typedef union DMU_PCU_OTP_CONFIG_5r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_5[1];
	uint32 _dmu_pcu_otp_config_5;
} DMU_PCU_OTP_CONFIG_5r_t;

#define DMU_PCU_OTP_CONFIG_5r_CLR(r) (r).dmu_pcu_otp_config_5[0] = 0
#define DMU_PCU_OTP_CONFIG_5r_SET(r,d) (r).dmu_pcu_otp_config_5[0] = d
#define DMU_PCU_OTP_CONFIG_5r_GET(r) (r).dmu_pcu_otp_config_5[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_5r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_5[0])
#define DMU_PCU_OTP_CONFIG_5r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_5[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_5.
 */
#define READ_DMU_PCU_OTP_CONFIG_5r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_5, &(r._dmu_pcu_otp_config_5))
#define WRITE_DMU_PCU_OTP_CONFIG_5r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_5, (r._dmu_pcu_otp_config_5))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_5r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_6
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_6r_SIZE 4

/* DMU_PCU_OTP_CONFIG_6r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_6.
 */
typedef union DMU_PCU_OTP_CONFIG_6r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_6[1];
	uint32 _dmu_pcu_otp_config_6;
} DMU_PCU_OTP_CONFIG_6r_t;

#define DMU_PCU_OTP_CONFIG_6r_CLR(r) (r).dmu_pcu_otp_config_6[0] = 0
#define DMU_PCU_OTP_CONFIG_6r_SET(r,d) (r).dmu_pcu_otp_config_6[0] = d
#define DMU_PCU_OTP_CONFIG_6r_GET(r) (r).dmu_pcu_otp_config_6[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_6r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_6[0])
#define DMU_PCU_OTP_CONFIG_6r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_6[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_6.
 */
#define READ_DMU_PCU_OTP_CONFIG_6r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_6, &(r._dmu_pcu_otp_config_6))
#define WRITE_DMU_PCU_OTP_CONFIG_6r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_6, (r._dmu_pcu_otp_config_6))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_6r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_7
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_7r_SIZE 4

/* DMU_PCU_OTP_CONFIG_7r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_7.
 */
typedef union DMU_PCU_OTP_CONFIG_7r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_7[1];
	uint32 _dmu_pcu_otp_config_7;
} DMU_PCU_OTP_CONFIG_7r_t;

#define DMU_PCU_OTP_CONFIG_7r_CLR(r) (r).dmu_pcu_otp_config_7[0] = 0
#define DMU_PCU_OTP_CONFIG_7r_SET(r,d) (r).dmu_pcu_otp_config_7[0] = d
#define DMU_PCU_OTP_CONFIG_7r_GET(r) (r).dmu_pcu_otp_config_7[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_7r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_7[0])
#define DMU_PCU_OTP_CONFIG_7r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_7[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_7.
 */
#define READ_DMU_PCU_OTP_CONFIG_7r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_7, &(r._dmu_pcu_otp_config_7))
#define WRITE_DMU_PCU_OTP_CONFIG_7r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_7, (r._dmu_pcu_otp_config_7))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_7r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_8
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_8r_SIZE 4

/* DMU_PCU_OTP_CONFIG_8r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_8.
 */
typedef union DMU_PCU_OTP_CONFIG_8r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_8[1];
	uint32 _dmu_pcu_otp_config_8;
} DMU_PCU_OTP_CONFIG_8r_t;

#define DMU_PCU_OTP_CONFIG_8r_CLR(r) (r).dmu_pcu_otp_config_8[0] = 0
#define DMU_PCU_OTP_CONFIG_8r_SET(r,d) (r).dmu_pcu_otp_config_8[0] = d
#define DMU_PCU_OTP_CONFIG_8r_GET(r) (r).dmu_pcu_otp_config_8[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_8r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_8[0])
#define DMU_PCU_OTP_CONFIG_8r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_8[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_8.
 */
#define READ_DMU_PCU_OTP_CONFIG_8r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_8, &(r._dmu_pcu_otp_config_8))
#define WRITE_DMU_PCU_OTP_CONFIG_8r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_8, (r._dmu_pcu_otp_config_8))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_8r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DMU_PCU_OTP_CONFIG_9
 * BLOCKS:   IPROC
 * DESC:     Captures chip OTP configuration
 * SIZE:     32
 * FIELDS:
 *     OTP_CONFIG       Config bits driven by OTP
 */
#define DMU_PCU_OTP_CONFIG_9r_SIZE 4

/* DMU_PCU_OTP_CONFIG_9r is element of DMU_PCU_OTP_CONFIG */

/*
 * This structure should be used to declare and program DMU_PCU_OTP_CONFIG_9.
 */
typedef union DMU_PCU_OTP_CONFIG_9r_s {
	uint32 v[1];
	uint32 dmu_pcu_otp_config_9[1];
	uint32 _dmu_pcu_otp_config_9;
} DMU_PCU_OTP_CONFIG_9r_t;

#define DMU_PCU_OTP_CONFIG_9r_CLR(r) (r).dmu_pcu_otp_config_9[0] = 0
#define DMU_PCU_OTP_CONFIG_9r_SET(r,d) (r).dmu_pcu_otp_config_9[0] = d
#define DMU_PCU_OTP_CONFIG_9r_GET(r) (r).dmu_pcu_otp_config_9[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_PCU_OTP_CONFIG_9r_OTP_CONFIGf_GET(r) ((r).dmu_pcu_otp_config_9[0])
#define DMU_PCU_OTP_CONFIG_9r_OTP_CONFIGf_SET(r,f) (r).dmu_pcu_otp_config_9[0]=((uint32)f)

/*
 * These macros can be used to access DMU_PCU_OTP_CONFIG_9.
 */
#define READ_DMU_PCU_OTP_CONFIG_9r(u,r) bcm5607x_read32(u, R_DMU_PCU_OTP_CONFIG_9, &(r._dmu_pcu_otp_config_9))
#define WRITE_DMU_PCU_OTP_CONFIG_9r(u,r) bcm5607x_write32(u, R_DMU_PCU_OTP_CONFIG_9, (r._dmu_pcu_otp_config_9))

/*******************************************************************************
 * End of 'DMU_PCU_OTP_CONFIG_9r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DOS_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     DOS (Denial of Service) Attack Control Register
 * SIZE:     32
 * FIELDS:
 *     IPV4_FIRST_FRAG_CHECK_ENABLE If set to 1, enable checking DOS attacks on IP first fragments for both IPv4 and IPv6 packets.
 *     IP_FIRST_FRAG_CHECK_ENABLE If set to 1, enable checking DOS attacks on IP first fragments for both IPv4 and IPv6.
 *     BIG_ICMP_PKT_SIZE Maximum length ICMP packet allowed before dropping (maximum 16k bytes)
 *     MIN_TCPHDR_SIZE  Minimum TCP header length allowed (minimum 0 bytes, maximum 255 bytes)
 *     DROP_IF_SIP_EQUALS_DIP If set to 1, drop IPv4/IPv6 packets if the SIP == DIP
 *     MACSA_EQUALS_MACDA_DROP If set to 1, drop packets with MACSA == MACDA
 *     TCP_FLAGS_SYN_FRAG_ENABLE If set to 1, enable dropping of TCP SYN Packets with Source Port 0-1023. It applies to unfragmented packets and IPv4 first fragments (if DOS_CONTROL.IPV4_FIRST_FRAG_CHECK_ENABLE = 1) 
 *     TCP_FLAGS_CTRL0_SEQ0_ENABLE If set to 1, TCP Packets with control flags == 0 AND sequence number == 0 will be dropped
 */
#define DOS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program DOS_CONTROL.
 */
typedef union DOS_CONTROLr_s {
	uint32 v[1];
	uint32 dos_control[1];
	uint32 _dos_control;
} DOS_CONTROLr_t;

#define DOS_CONTROLr_CLR(r) (r).dos_control[0] = 0
#define DOS_CONTROLr_SET(r,d) (r).dos_control[0] = d
#define DOS_CONTROLr_GET(r) (r).dos_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET(r) (((r).dos_control[0]) & 0x1)
#define DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define DOS_CONTROLr_IP_FIRST_FRAG_CHECK_ENABLEf_GET(r) (((r).dos_control[0]) & 0x1)
#define DOS_CONTROLr_IP_FIRST_FRAG_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_GET(r) ((((r).dos_control[0]) >> 1) & 0xffff)
#define DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0xffff << 1)) | ((((uint32)f) & 0xffff) << 1))
#define DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET(r) ((((r).dos_control[0]) >> 17) & 0xff)
#define DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0xff << 17)) | ((((uint32)f) & 0xff) << 17))
#define DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET(r) ((((r).dos_control[0]) >> 25) & 0x1)
#define DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_GET(r) ((((r).dos_control[0]) >> 26) & 0x1)
#define DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_GET(r) ((((r).dos_control[0]) >> 27) & 0x1)
#define DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_GET(r) ((((r).dos_control[0]) >> 28) & 0x1)
#define DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))

/*
 * These macros can be used to access DOS_CONTROL.
 */
#define WRITE_DOS_CONTROLr(u,r) bcm5607x_reg_set(u,R_DOS_CONTROL,(r._dos_control))
#define READ_DOS_CONTROLr(u,r) bcm5607x_reg_get(u,R_DOS_CONTROL,&(r._dos_control))

/*******************************************************************************
 * End of 'DOS_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DOS_CONTROL2
 * BLOCKS:   IPIPE
 * DESC:     DOS (Denial of Service) Attack Control Register 2
 * SIZE:     32
 * FIELDS:
 *     BIG_ICMPV6_PKT_SIZE Maximum length ICMPv6 ping packet allowed before dropping (maximum 16k bytes)
 *     TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLE If set to 1, TCP packets with FIN, URG and PSH bits set AND seq. number == 0 are dropped
 *     TCP_FLAGS_SYN_FIN_ENABLE If set to 1, TCP packets with SYN & FIN bits set are dropped
 *     TCP_SPORT_EQ_DPORT_ENABLE If set to 1, BLAT - TCP packets with SPORT = DPORT are dropped
 *     UDP_SPORT_EQ_DPORT_ENABLE If set to 1, BLAT - UDP packets with SPORT = DPORT are dropped
 *     TCP_HDR_PARTIAL_ENABLE If set to 1, FIRST TCP fragments that have a TCP header smaller than DOS_CONTROL.MIN_TCPHDR_SIZE are dropped.
 *     TCP_HDR_OFFSET_EQ1_ENABLE If set to 1, TCP fragments with offset value of 1 are dropped. Fragment offset values are programmed in 8byte increments. The value of 1 means 8bytes
 *     ICMP_V6_PING_SIZE_ENABLE If set to 1, ICMPv6 ping packets with payload size greater than the programmable value in DOS_CONTROL.BIG_ICMP_PKT_SIZE.
 *     ICMP_V4_PING_SIZE_ENABLE If set to 1, ICMPv4 ping packets with payload size greater than the programmable value in DOS_CONTROL.BIG_ICMP_PKT_SIZE
 *     ICMP_FRAG_PKTS_ENABLE If set to 1, fragmented ICMP packets will be dropped
 *     IPV6_MIN_FRAG_SIZE_ENABLE Check for minimum size of IPV6 fragments. See also register IPV6_MIN_FRAG_SIZE.
 */
#define DOS_CONTROL2r_SIZE 4

/*
 * This structure should be used to declare and program DOS_CONTROL2.
 */
typedef union DOS_CONTROL2r_s {
	uint32 v[1];
	uint32 dos_control2[1];
	uint32 _dos_control2;
} DOS_CONTROL2r_t;

#define DOS_CONTROL2r_CLR(r) (r).dos_control2[0] = 0
#define DOS_CONTROL2r_SET(r,d) (r).dos_control2[0] = d
#define DOS_CONTROL2r_GET(r) (r).dos_control2[0]

/*
 * These macros can be used to access individual fields.
 */
#define DOS_CONTROL2r_BIG_ICMPV6_PKT_SIZEf_GET(r) (((r).dos_control2[0]) & 0xffff)
#define DOS_CONTROL2r_BIG_ICMPV6_PKT_SIZEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define DOS_CONTROL2r_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 16) & 0x1)
#define DOS_CONTROL2r_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define DOS_CONTROL2r_TCP_FLAGS_SYN_FIN_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 17) & 0x1)
#define DOS_CONTROL2r_TCP_FLAGS_SYN_FIN_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define DOS_CONTROL2r_TCP_SPORT_EQ_DPORT_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 18) & 0x1)
#define DOS_CONTROL2r_TCP_SPORT_EQ_DPORT_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define DOS_CONTROL2r_UDP_SPORT_EQ_DPORT_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 19) & 0x1)
#define DOS_CONTROL2r_UDP_SPORT_EQ_DPORT_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define DOS_CONTROL2r_TCP_HDR_PARTIAL_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 20) & 0x1)
#define DOS_CONTROL2r_TCP_HDR_PARTIAL_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define DOS_CONTROL2r_TCP_HDR_OFFSET_EQ1_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 21) & 0x1)
#define DOS_CONTROL2r_TCP_HDR_OFFSET_EQ1_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define DOS_CONTROL2r_ICMP_V6_PING_SIZE_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 22) & 0x1)
#define DOS_CONTROL2r_ICMP_V6_PING_SIZE_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define DOS_CONTROL2r_ICMP_V4_PING_SIZE_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 23) & 0x1)
#define DOS_CONTROL2r_ICMP_V4_PING_SIZE_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define DOS_CONTROL2r_ICMP_FRAG_PKTS_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 24) & 0x1)
#define DOS_CONTROL2r_ICMP_FRAG_PKTS_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define DOS_CONTROL2r_IPV6_MIN_FRAG_SIZE_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 25) & 0x1)
#define DOS_CONTROL2r_IPV6_MIN_FRAG_SIZE_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))

/*
 * These macros can be used to access DOS_CONTROL2.
 */
#define WRITE_DOS_CONTROL2r(u,r) bcm5607x_reg_set(u,R_DOS_CONTROL2,(r._dos_control2))
#define READ_DOS_CONTROL2r(u,r) bcm5607x_reg_get(u,R_DOS_CONTROL2,&(r._dos_control2))

/*******************************************************************************
 * End of 'DOS_CONTROL2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  DSCP_TB
 * BLOCKS:   IPIPE
 * DESC:     Diff Serv Code Point Table
This table provides the ability to reassign the DSCP value of the incoming packet to the new DSCP/PRI/CNG values. This table is enabled when ingress port has TRUST_DSCP_V4 or V6 value set to 1 in the PORT table. When this table is used, its values will override the ING_PRI_CNG_MAP and CNG_MAP tables. This table is indexed by the ingress port and packet DSCP.
 * SIZE:     11
 * FIELDS:
 *     DSCP             New Diff Serv Code Point
 *     PRI              Priority
 *     CNG              Congestion bits
 */
#define DSCP_TBm_MIN 0
#define DSCP_TBm_MAX 4223
#define DSCP_TBm_CMAX(u) 4223
#define DSCP_TBm_SIZE 2

/*
 * This structure should be used to declare and program DSCP_TB.
 */
typedef union DSCP_TBm_s {
	uint32 v[1];
	uint32 dscp_tb[1];
	uint32 _dscp_tb;
} DSCP_TBm_t;

#define DSCP_TBm_CLR(r) (r).dscp_tb[0] = 0
#define DSCP_TBm_SET(r,d) (r).dscp_tb[0] = d
#define DSCP_TBm_GET(r) (r).dscp_tb[0]

/*
 * These macros can be used to access individual fields.
 */
#define DSCP_TBm_DSCPf_GET(r) (((r).dscp_tb[0]) & 0x3f)
#define DSCP_TBm_DSCPf_SET(r,f) (r).dscp_tb[0]=(((r).dscp_tb[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define DSCP_TBm_PRIf_GET(r) ((((r).dscp_tb[0]) >> 6) & 0x7)
#define DSCP_TBm_PRIf_SET(r,f) (r).dscp_tb[0]=(((r).dscp_tb[0] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define DSCP_TBm_CNGf_GET(r) ((((r).dscp_tb[0]) >> 9) & 0x3)
#define DSCP_TBm_CNGf_SET(r,f) (r).dscp_tb[0]=(((r).dscp_tb[0] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))

/*
 * These macros can be used to access DSCP_TB.
 */
#define WRITE_DSCP_TBm(u,i,r) bcm5607x_mem_set(u, M_DSCP_TB(i), &(r._dscp_tb), 1)
#define READ_DSCP_TBm(u,i,r) bcm5607x_mem_get(u, M_DSCP_TB(i), &(r._dscp_tb), 1)

/*******************************************************************************
 * End of 'DSCP_TBm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DYNCELLLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNCELLSETLIMIT  This field specifies the number of cells a port may utilize from the dynamic memory pool.When the following conditions are met, it will set this queue's HOL status and stop admitting any new coming cells. ( ( DYNCELLCOUNT(port) >= DYNCELLLIMIT.DYNCELLLIMIT(port) ) OR ( TOTALDYNCELLUSED >= TOTALDYNCELLLIMIT.SETLIMIT ) ) AND ( COSLCCOUNT(port, cos) >=LWMCOSCELLSETLIMIT.CELLSETLIMIT(port, cos) ) 
 *     DYNCELLRESETLIMIT This field indicates the level at which buffer utilization in terms of cells must drop below before traffic is allowed to resume from HOL blocking state.To reset a cos queue's HOL status, it needs to meet following conditions ( ( DYNCELLCOUNT(port) < DYNCELLLIMIT.RESETLIMIT (port) ) AND ( TOTALDYNCELLUSED < TOTALDYNCELLRESETLIMIT.RESETLIMIT ) ) OR ( COSLCCOUNT(port, cos) <LWMCOSCELLSETLIMIT.RESETLIMIT(port, cos) ) 
 */
#define DYNCELLLIMITr_SIZE 4

/*
 * This structure should be used to declare and program DYNCELLLIMIT.
 */
typedef union DYNCELLLIMITr_s {
	uint32 v[1];
	uint32 dyncelllimit[1];
	uint32 _dyncelllimit;
} DYNCELLLIMITr_t;

#define DYNCELLLIMITr_CLR(r) (r).dyncelllimit[0] = 0
#define DYNCELLLIMITr_SET(r,d) (r).dyncelllimit[0] = d
#define DYNCELLLIMITr_GET(r) (r).dyncelllimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define DYNCELLLIMITr_DYNCELLSETLIMITf_GET(r) (((r).dyncelllimit[0]) & 0x3fff)
#define DYNCELLLIMITr_DYNCELLSETLIMITf_SET(r,f) (r).dyncelllimit[0]=(((r).dyncelllimit[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define DYNCELLLIMITr_DYNCELLRESETLIMITf_GET(r) ((((r).dyncelllimit[0]) >> 14) & 0x3fff)
#define DYNCELLLIMITr_DYNCELLRESETLIMITf_SET(r,f) (r).dyncelllimit[0]=(((r).dyncelllimit[0] & ~((uint32)0x3fff << 14)) | ((((uint32)f) & 0x3fff) << 14))

/*
 * These macros can be used to access DYNCELLLIMIT.
 */
#define WRITE_DYNCELLLIMITr(u,p,r) bcm5607x_reg_set(u,R_DYNCELLLIMIT(p),(r._dyncelllimit))
#define READ_DYNCELLLIMITr(u,p,r) bcm5607x_reg_get(u,R_DYNCELLLIMIT(p),&(r._dyncelllimit))

/*******************************************************************************
 * End of 'DYNCELLLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DYNRESETLIMPORT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNRESETLIMPORT  PKT THD.Dynamic reset limit for HOLWhen (DYNPKTCNTPORT >= DYNXQCNTPORT) the COS queues which are using pointers from the dynamic XQ pool and (COSPKTCOUNT>HOLCOSMINXQCNT) will be put into HOL blocking state.The HOL blocking state will be cleared once DYNPKTCNTPORT has fallen below the DYNRESETLIMPORT value. 
 */
#define DYNRESETLIMPORTr_SIZE 4

/*
 * This structure should be used to declare and program DYNRESETLIMPORT.
 */
typedef union DYNRESETLIMPORTr_s {
	uint32 v[1];
	uint32 dynresetlimport[1];
	uint32 _dynresetlimport;
} DYNRESETLIMPORTr_t;

#define DYNRESETLIMPORTr_CLR(r) (r).dynresetlimport[0] = 0
#define DYNRESETLIMPORTr_SET(r,d) (r).dynresetlimport[0] = d
#define DYNRESETLIMPORTr_GET(r) (r).dynresetlimport[0]

/*
 * These macros can be used to access individual fields.
 */
#define DYNRESETLIMPORTr_DYNRESETLIMPORTf_GET(r) (((r).dynresetlimport[0]) & 0x1fff)
#define DYNRESETLIMPORTr_DYNRESETLIMPORTf_SET(r,f) (r).dynresetlimport[0]=(((r).dynresetlimport[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access DYNRESETLIMPORT.
 */
#define WRITE_DYNRESETLIMPORTr(u,p,r) bcm5607x_reg_set(u,R_DYNRESETLIMPORT(p),(r._dynresetlimport))
#define READ_DYNRESETLIMPORTr(u,p,r) bcm5607x_reg_get(u,R_DYNRESETLIMPORT(p),&(r._dynresetlimport))

/*******************************************************************************
 * End of 'DYNRESETLIMPORTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  DYNXQCNTPORT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNXQCNTPORT     PKT THD.Number of dynamic XQ pointers per egress port.When dynamic XQ mode is enabled program this field to: Size of XQ(port) - MISCCONFIG.SKIDMARKER - sum of prefetch pointer - (Sum of all HOLCOSMINXQCNT)  When dynamic XQ mode is not used program this field to 0. In order to make use of the dynamic XQ pointers the HOLCOSPKTSETLIMIT.PKTSETLIMIT must be greater than the HOLCOSMINXQCNT setting. When (DYNPKTCNTPORT >= DYNXQCNTPORT) the COS queues which are using pointers from the dynamic XQ pool and (COSPKTCOUNT>HOLCOSMINXQCNT) will be put into HOL blocking state. The HOL blocking state will be cleared once DYNPKTCNTPORT has fallen below the DYNRESETLIMPORT value. "MISCCONFIG.SKIDMARKER" is the hardware response time from CTR drop signal generation to IDM start to drop. "sum of prefetch pointer" is for each Q's link list control logic to prefetch. When XQ is almost used, at least keep one for each Q's prefetch.In GH/HR3, sum of prefetch pointer = 9    :  8 COS + central prefetchIn GH2   , sum of prefetch pointer = 64+4 : max 64 COS + scratch pad prefetch 
 */
#define DYNXQCNTPORTr_SIZE 4

/*
 * This structure should be used to declare and program DYNXQCNTPORT.
 */
typedef union DYNXQCNTPORTr_s {
	uint32 v[1];
	uint32 dynxqcntport[1];
	uint32 _dynxqcntport;
} DYNXQCNTPORTr_t;

#define DYNXQCNTPORTr_CLR(r) (r).dynxqcntport[0] = 0
#define DYNXQCNTPORTr_SET(r,d) (r).dynxqcntport[0] = d
#define DYNXQCNTPORTr_GET(r) (r).dynxqcntport[0]

/*
 * These macros can be used to access individual fields.
 */
#define DYNXQCNTPORTr_DYNXQCNTPORTf_GET(r) (((r).dynxqcntport[0]) & 0x1fff)
#define DYNXQCNTPORTr_DYNXQCNTPORTf_SET(r,f) (r).dynxqcntport[0]=(((r).dynxqcntport[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access DYNXQCNTPORT.
 */
#define WRITE_DYNXQCNTPORTr(u,p,r) bcm5607x_reg_set(u,R_DYNXQCNTPORT(p),(r._dynxqcntport))
#define READ_DYNXQCNTPORTr(u,p,r) bcm5607x_reg_get(u,R_DYNXQCNTPORT(p),&(r._dynxqcntport))

/*******************************************************************************
 * End of 'DYNXQCNTPORTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  E2ECC_HOL_EN
 * BLOCKS:   MMU
 * DESC:     E2ECC HOL report enable,operation mode
 * SIZE:     32
 * FIELDS:
 *     EN               report enable
 */
#define E2ECC_HOL_ENr_SIZE 4

/*
 * This structure should be used to declare and program E2ECC_HOL_EN.
 */
typedef union E2ECC_HOL_ENr_s {
	uint32 v[1];
	uint32 e2ecc_hol_en[1];
	uint32 _e2ecc_hol_en;
} E2ECC_HOL_ENr_t;

#define E2ECC_HOL_ENr_CLR(r) (r).e2ecc_hol_en[0] = 0
#define E2ECC_HOL_ENr_SET(r,d) (r).e2ecc_hol_en[0] = d
#define E2ECC_HOL_ENr_GET(r) (r).e2ecc_hol_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define E2ECC_HOL_ENr_ENf_GET(r) (((r).e2ecc_hol_en[0]) & 0x1)
#define E2ECC_HOL_ENr_ENf_SET(r,f) (r).e2ecc_hol_en[0]=(((r).e2ecc_hol_en[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access E2ECC_HOL_EN.
 */
#define WRITE_E2ECC_HOL_ENr(u,r) bcm5607x_reg_set(u,R_E2ECC_HOL_EN,(r._e2ecc_hol_en))
#define READ_E2ECC_HOL_ENr(u,r) bcm5607x_reg_get(u,R_E2ECC_HOL_EN,&(r._e2ecc_hol_en))

/*******************************************************************************
 * End of 'E2ECC_HOL_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  E2ECC_MAX_TX_TIMER
 * BLOCKS:   MMU
 * DESC:     E2ECC TX HG Maximum Repeat Timer Register
 * SIZE:     32
 * FIELDS:
 *     TIMER            Indicates maximum number of time unit allowed between back-to-back E2ECC messages.An E2ECC message shall be generated to refresh the current IBP status when timer expires.Typically should have minimum value of 1.If set to 0, E2ECC message refresh is disabled and only generated for change of IBP status.
 *     LG               Indicates time unit is 25us if set to 1, default time unit is 250ns.
 */
#define E2ECC_MAX_TX_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program E2ECC_MAX_TX_TIMER.
 */
typedef union E2ECC_MAX_TX_TIMERr_s {
	uint32 v[1];
	uint32 e2ecc_max_tx_timer[1];
	uint32 _e2ecc_max_tx_timer;
} E2ECC_MAX_TX_TIMERr_t;

#define E2ECC_MAX_TX_TIMERr_CLR(r) (r).e2ecc_max_tx_timer[0] = 0
#define E2ECC_MAX_TX_TIMERr_SET(r,d) (r).e2ecc_max_tx_timer[0] = d
#define E2ECC_MAX_TX_TIMERr_GET(r) (r).e2ecc_max_tx_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define E2ECC_MAX_TX_TIMERr_TIMERf_GET(r) (((r).e2ecc_max_tx_timer[0]) & 0x3ff)
#define E2ECC_MAX_TX_TIMERr_TIMERf_SET(r,f) (r).e2ecc_max_tx_timer[0]=(((r).e2ecc_max_tx_timer[0] & ~((uint32)0x3ff)) | (((uint32)f) & 0x3ff))
#define E2ECC_MAX_TX_TIMERr_LGf_GET(r) ((((r).e2ecc_max_tx_timer[0]) >> 10) & 0x1)
#define E2ECC_MAX_TX_TIMERr_LGf_SET(r,f) (r).e2ecc_max_tx_timer[0]=(((r).e2ecc_max_tx_timer[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))

/*
 * These macros can be used to access E2ECC_MAX_TX_TIMER.
 */
#define WRITE_E2ECC_MAX_TX_TIMERr(u,r) bcm5607x_reg_set(u,R_E2ECC_MAX_TX_TIMER,(r._e2ecc_max_tx_timer))
#define READ_E2ECC_MAX_TX_TIMERr(u,r) bcm5607x_reg_get(u,R_E2ECC_MAX_TX_TIMER,&(r._e2ecc_max_tx_timer))

/*******************************************************************************
 * End of 'E2ECC_MAX_TX_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  E2ECC_MIN_TX_TIMER
 * BLOCKS:   MMU
 * DESC:     E2ECC TX HG Minimum Repeat Timer Register
 * SIZE:     32
 * FIELDS:
 *     TIMER            Indicates minimum number of time unit allowed between back-to-back E2ECC messages.No back-to-back E2ECC message shall be generated until timer expires.Typically should have minimum value of 1.If set to 0, back-to-back E2ECC messages can be generated as fast as supported by hardware.
 *     LG               Indicates time unit is 25us if set to 1, default time unit is 250ns.
 */
#define E2ECC_MIN_TX_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program E2ECC_MIN_TX_TIMER.
 */
typedef union E2ECC_MIN_TX_TIMERr_s {
	uint32 v[1];
	uint32 e2ecc_min_tx_timer[1];
	uint32 _e2ecc_min_tx_timer;
} E2ECC_MIN_TX_TIMERr_t;

#define E2ECC_MIN_TX_TIMERr_CLR(r) (r).e2ecc_min_tx_timer[0] = 0
#define E2ECC_MIN_TX_TIMERr_SET(r,d) (r).e2ecc_min_tx_timer[0] = d
#define E2ECC_MIN_TX_TIMERr_GET(r) (r).e2ecc_min_tx_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define E2ECC_MIN_TX_TIMERr_TIMERf_GET(r) (((r).e2ecc_min_tx_timer[0]) & 0x3ff)
#define E2ECC_MIN_TX_TIMERr_TIMERf_SET(r,f) (r).e2ecc_min_tx_timer[0]=(((r).e2ecc_min_tx_timer[0] & ~((uint32)0x3ff)) | (((uint32)f) & 0x3ff))
#define E2ECC_MIN_TX_TIMERr_LGf_GET(r) ((((r).e2ecc_min_tx_timer[0]) >> 10) & 0x1)
#define E2ECC_MIN_TX_TIMERr_LGf_SET(r,f) (r).e2ecc_min_tx_timer[0]=(((r).e2ecc_min_tx_timer[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))

/*
 * These macros can be used to access E2ECC_MIN_TX_TIMER.
 */
#define WRITE_E2ECC_MIN_TX_TIMERr(u,r) bcm5607x_reg_set(u,R_E2ECC_MIN_TX_TIMER,(r._e2ecc_min_tx_timer))
#define READ_E2ECC_MIN_TX_TIMERr(u,r) bcm5607x_reg_get(u,R_E2ECC_MIN_TX_TIMER,&(r._e2ecc_min_tx_timer))

/*******************************************************************************
 * End of 'E2ECC_MIN_TX_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  E2ECC_MODE
 * BLOCKS:   MMU
 * DESC:     Determine the type of E2E-CC
 * SIZE:     32
 * FIELDS:
 *     EN               Determine the type of E2E-CC 0: Regular E2E-CC (default)1: Early E2E-CC
 */
#define E2ECC_MODEr_SIZE 4

/*
 * This structure should be used to declare and program E2ECC_MODE.
 */
typedef union E2ECC_MODEr_s {
	uint32 v[1];
	uint32 e2ecc_mode[1];
	uint32 _e2ecc_mode;
} E2ECC_MODEr_t;

#define E2ECC_MODEr_CLR(r) (r).e2ecc_mode[0] = 0
#define E2ECC_MODEr_SET(r,d) (r).e2ecc_mode[0] = d
#define E2ECC_MODEr_GET(r) (r).e2ecc_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define E2ECC_MODEr_ENf_GET(r) (((r).e2ecc_mode[0]) & 0x1)
#define E2ECC_MODEr_ENf_SET(r,f) (r).e2ecc_mode[0]=(((r).e2ecc_mode[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access E2ECC_MODE.
 */
#define WRITE_E2ECC_MODEr(u,r) bcm5607x_reg_set(u,R_E2ECC_MODE,(r._e2ecc_mode))
#define READ_E2ECC_MODEr(u,r) bcm5607x_reg_get(u,R_E2ECC_MODE,&(r._e2ecc_mode))

/*******************************************************************************
 * End of 'E2ECC_MODEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  E2ECC_PORT_CONFIG
 * BLOCKS:   MMU
 * DESC:     Enable reporting of egress queue cell and packet  congestion states in the E2ECC frames.
 * SIZE:     32
 * FIELDS:
 *     COS_PKT_EN       Enable reporting of egress COS's packets congestion states in the E2ECC frames.0: Disable1: Enable 
 *     COS_CELL_EN      Enable reporting of egress COS's cells congestion states in the E2ECC frames.0: Disable1: Enable 
 */
#define E2ECC_PORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program E2ECC_PORT_CONFIG.
 */
typedef union E2ECC_PORT_CONFIGr_s {
	uint32 v[1];
	uint32 e2ecc_port_config[1];
	uint32 _e2ecc_port_config;
} E2ECC_PORT_CONFIGr_t;

#define E2ECC_PORT_CONFIGr_CLR(r) (r).e2ecc_port_config[0] = 0
#define E2ECC_PORT_CONFIGr_SET(r,d) (r).e2ecc_port_config[0] = d
#define E2ECC_PORT_CONFIGr_GET(r) (r).e2ecc_port_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define E2ECC_PORT_CONFIGr_COS_PKT_ENf_GET(r) (((r).e2ecc_port_config[0]) & 0xff)
#define E2ECC_PORT_CONFIGr_COS_PKT_ENf_SET(r,f) (r).e2ecc_port_config[0]=(((r).e2ecc_port_config[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define E2ECC_PORT_CONFIGr_COS_CELL_ENf_GET(r) ((((r).e2ecc_port_config[0]) >> 8) & 0xff)
#define E2ECC_PORT_CONFIGr_COS_CELL_ENf_SET(r,f) (r).e2ecc_port_config[0]=(((r).e2ecc_port_config[0] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))

/*
 * These macros can be used to access E2ECC_PORT_CONFIG.
 */
#define WRITE_E2ECC_PORT_CONFIGr(u,p,r) bcm5607x_reg_set(u,R_E2ECC_PORT_CONFIG(p),(r._e2ecc_port_config))
#define READ_E2ECC_PORT_CONFIGr(u,p,r) bcm5607x_reg_get(u,R_E2ECC_PORT_CONFIG(p),&(r._e2ecc_port_config))

/*******************************************************************************
 * End of 'E2ECC_PORT_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  E2ECC_TX_ENABLE_BMP
 * BLOCKS:   MMU
 * DESC:     e2ecc tx enable for each port of each XLPORT
 * SIZE:     32
 * FIELDS:
 *     TX_ENABLE_BMP    E2ECC TX enable for each port in a XLPORT
 */
#define E2ECC_TX_ENABLE_BMPr_SIZE 4

/*
 * This structure should be used to declare and program E2ECC_TX_ENABLE_BMP.
 */
typedef union E2ECC_TX_ENABLE_BMPr_s {
	uint32 v[1];
	uint32 e2ecc_tx_enable_bmp[1];
	uint32 _e2ecc_tx_enable_bmp;
} E2ECC_TX_ENABLE_BMPr_t;

#define E2ECC_TX_ENABLE_BMPr_CLR(r) (r).e2ecc_tx_enable_bmp[0] = 0
#define E2ECC_TX_ENABLE_BMPr_SET(r,d) (r).e2ecc_tx_enable_bmp[0] = d
#define E2ECC_TX_ENABLE_BMPr_GET(r) (r).e2ecc_tx_enable_bmp[0]

/*
 * These macros can be used to access individual fields.
 */
#define E2ECC_TX_ENABLE_BMPr_TX_ENABLE_BMPf_GET(r) (((r).e2ecc_tx_enable_bmp[0]) & 0xf)
#define E2ECC_TX_ENABLE_BMPr_TX_ENABLE_BMPf_SET(r,f) (r).e2ecc_tx_enable_bmp[0]=(((r).e2ecc_tx_enable_bmp[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))

/*
 * These macros can be used to access E2ECC_TX_ENABLE_BMP.
 */
#define WRITE_E2ECC_TX_ENABLE_BMPr(u,i,r) bcm5607x_reg_set(u,R_E2ECC_TX_ENABLE_BMP(i),(r._e2ecc_tx_enable_bmp))
#define READ_E2ECC_TX_ENABLE_BMPr(u,i,r) bcm5607x_reg_get(u,R_E2ECC_TX_ENABLE_BMP(i),&(r._e2ecc_tx_enable_bmp))

/*******************************************************************************
 * End of 'E2ECC_TX_ENABLE_BMPr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  E2ECC_TX_PORTS_NUM
 * BLOCKS:   MMU
 * DESC:     number of ports state carried in E2ECC message 
 * SIZE:     32
 * FIELDS:
 *     TX_PORTS_NUM     number of ports state carried in E2ECC message. Must Be even number between 2 - 64. The max port number support is 64 for E2ECC. 
 */
#define E2ECC_TX_PORTS_NUMr_SIZE 4

/*
 * This structure should be used to declare and program E2ECC_TX_PORTS_NUM.
 */
typedef union E2ECC_TX_PORTS_NUMr_s {
	uint32 v[1];
	uint32 e2ecc_tx_ports_num[1];
	uint32 _e2ecc_tx_ports_num;
} E2ECC_TX_PORTS_NUMr_t;

#define E2ECC_TX_PORTS_NUMr_CLR(r) (r).e2ecc_tx_ports_num[0] = 0
#define E2ECC_TX_PORTS_NUMr_SET(r,d) (r).e2ecc_tx_ports_num[0] = d
#define E2ECC_TX_PORTS_NUMr_GET(r) (r).e2ecc_tx_ports_num[0]

/*
 * These macros can be used to access individual fields.
 */
#define E2ECC_TX_PORTS_NUMr_TX_PORTS_NUMf_GET(r) (((r).e2ecc_tx_ports_num[0]) & 0xff)
#define E2ECC_TX_PORTS_NUMr_TX_PORTS_NUMf_SET(r,f) (r).e2ecc_tx_ports_num[0]=(((r).e2ecc_tx_ports_num[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))

/*
 * These macros can be used to access E2ECC_TX_PORTS_NUM.
 */
#define WRITE_E2ECC_TX_PORTS_NUMr(u,r) bcm5607x_reg_set(u,R_E2ECC_TX_PORTS_NUM,(r._e2ecc_tx_ports_num))
#define READ_E2ECC_TX_PORTS_NUMr(u,r) bcm5607x_reg_get(u,R_E2ECC_TX_PORTS_NUM,&(r._e2ecc_tx_ports_num))

/*******************************************************************************
 * End of 'E2ECC_TX_PORTS_NUMr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  E2EFC_IBP_EN
 * BLOCKS:   MMU
 * DESC:     E2EFC IBP report enable
 * SIZE:     32
 * FIELDS:
 *     EN               IBP TX report enable
 *     SEND_RX_E2E_BKP_EN BKP RX Enable0: Does not take into account the E2EFC congestion state while performing PAUSE.1: Takes into account the E2EFC congestion state while performing PAUSE.
 */
#define E2EFC_IBP_ENr_SIZE 4

/*
 * This structure should be used to declare and program E2EFC_IBP_EN.
 */
typedef union E2EFC_IBP_ENr_s {
	uint32 v[1];
	uint32 e2efc_ibp_en[1];
	uint32 _e2efc_ibp_en;
} E2EFC_IBP_ENr_t;

#define E2EFC_IBP_ENr_CLR(r) (r).e2efc_ibp_en[0] = 0
#define E2EFC_IBP_ENr_SET(r,d) (r).e2efc_ibp_en[0] = d
#define E2EFC_IBP_ENr_GET(r) (r).e2efc_ibp_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define E2EFC_IBP_ENr_ENf_GET(r) (((r).e2efc_ibp_en[0]) & 0x1)
#define E2EFC_IBP_ENr_ENf_SET(r,f) (r).e2efc_ibp_en[0]=(((r).e2efc_ibp_en[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define E2EFC_IBP_ENr_SEND_RX_E2E_BKP_ENf_GET(r) ((((r).e2efc_ibp_en[0]) >> 1) & 0x1)
#define E2EFC_IBP_ENr_SEND_RX_E2E_BKP_ENf_SET(r,f) (r).e2efc_ibp_en[0]=(((r).e2efc_ibp_en[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access E2EFC_IBP_EN.
 */
#define WRITE_E2EFC_IBP_ENr(u,r) bcm5607x_reg_set(u,R_E2EFC_IBP_EN,(r._e2efc_ibp_en))
#define READ_E2EFC_IBP_ENr(u,r) bcm5607x_reg_get(u,R_E2EFC_IBP_EN,&(r._e2efc_ibp_en))

/*******************************************************************************
 * End of 'E2EFC_IBP_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EARLY_DYNCELLLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     EARLY_DYNCELLSETLIMIT This field specifies early E2ECC set limit for the number of cells a port may utilize from the dynamic memory pool. (criterion:DYNCELLCOUNT>=EARLY_DYNCELLSETLIMIT)
 */
#define EARLY_DYNCELLLIMITr_SIZE 4

/*
 * This structure should be used to declare and program EARLY_DYNCELLLIMIT.
 */
typedef union EARLY_DYNCELLLIMITr_s {
	uint32 v[1];
	uint32 early_dyncelllimit[1];
	uint32 _early_dyncelllimit;
} EARLY_DYNCELLLIMITr_t;

#define EARLY_DYNCELLLIMITr_CLR(r) (r).early_dyncelllimit[0] = 0
#define EARLY_DYNCELLLIMITr_SET(r,d) (r).early_dyncelllimit[0] = d
#define EARLY_DYNCELLLIMITr_GET(r) (r).early_dyncelllimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define EARLY_DYNCELLLIMITr_EARLY_DYNCELLSETLIMITf_GET(r) (((r).early_dyncelllimit[0]) & 0x3fff)
#define EARLY_DYNCELLLIMITr_EARLY_DYNCELLSETLIMITf_SET(r,f) (r).early_dyncelllimit[0]=(((r).early_dyncelllimit[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))

/*
 * These macros can be used to access EARLY_DYNCELLLIMIT.
 */
#define WRITE_EARLY_DYNCELLLIMITr(u,p,r) bcm5607x_reg_set(u,R_EARLY_DYNCELLLIMIT(p),(r._early_dyncelllimit))
#define READ_EARLY_DYNCELLLIMITr(u,p,r) bcm5607x_reg_get(u,R_EARLY_DYNCELLLIMIT(p),&(r._early_dyncelllimit))

/*******************************************************************************
 * End of 'EARLY_DYNCELLLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EARLY_HOLCOSCELLMAXLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     EARLY_CELLMAXLIMIT A queue can be put into early E2ECC congestion state when the HOL cell count reaches (>=) the value set in this register.(criterion:COSLCCOUNT >= EARLY_CELLMAXLIMIT)
 */
#define EARLY_HOLCOSCELLMAXLIMITr_SIZE 4

/*
 * This structure should be used to declare and program EARLY_HOLCOSCELLMAXLIMIT.
 */
typedef union EARLY_HOLCOSCELLMAXLIMITr_s {
	uint32 v[1];
	uint32 early_holcoscellmaxlimit[1];
	uint32 _early_holcoscellmaxlimit;
} EARLY_HOLCOSCELLMAXLIMITr_t;

#define EARLY_HOLCOSCELLMAXLIMITr_CLR(r) (r).early_holcoscellmaxlimit[0] = 0
#define EARLY_HOLCOSCELLMAXLIMITr_SET(r,d) (r).early_holcoscellmaxlimit[0] = d
#define EARLY_HOLCOSCELLMAXLIMITr_GET(r) (r).early_holcoscellmaxlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define EARLY_HOLCOSCELLMAXLIMITr_EARLY_CELLMAXLIMITf_GET(r) (((r).early_holcoscellmaxlimit[0]) & 0x3fff)
#define EARLY_HOLCOSCELLMAXLIMITr_EARLY_CELLMAXLIMITf_SET(r,f) (r).early_holcoscellmaxlimit[0]=(((r).early_holcoscellmaxlimit[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))

/*
 * These macros can be used to access EARLY_HOLCOSCELLMAXLIMIT.
 */
#define WRITE_EARLY_HOLCOSCELLMAXLIMITr(u,p, cos,r) bcm5607x_reg_set(u, R_EARLY_HOLCOSCELLMAXLIMIT(cos,p), (r._early_holcoscellmaxlimit))
#define READ_EARLY_HOLCOSCELLMAXLIMITr(u,p, cos,r) bcm5607x_reg_get(u,R_EARLY_HOLCOSCELLMAXLIMIT(cos,p),&(r._early_holcoscellmaxlimit))

/*******************************************************************************
 * End of 'EARLY_HOLCOSCELLMAXLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EGRMETERINGBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     BUCKET           Level of maximum rate bucket with unit of 0.5 or 1 bit depends on METER_EGR_PORT_GRAN setting.
 *     IN_PROFILE_FLAG  IN_PROFILE_FLAG inidcates the current state of metering bucket1: Out profile (port egress rate has been reached) 0: In profile (port egress rate has been not reached)(default) 
 */
#define EGRMETERINGBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program EGRMETERINGBUCKET.
 */
typedef union EGRMETERINGBUCKETr_s {
	uint32 v[1];
	uint32 egrmeteringbucket[1];
	uint32 _egrmeteringbucket;
} EGRMETERINGBUCKETr_t;

#define EGRMETERINGBUCKETr_CLR(r) (r).egrmeteringbucket[0] = 0
#define EGRMETERINGBUCKETr_SET(r,d) (r).egrmeteringbucket[0] = d
#define EGRMETERINGBUCKETr_GET(r) (r).egrmeteringbucket[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGRMETERINGBUCKETr_BUCKETf_GET(r) (((r).egrmeteringbucket[0]) & 0x1fffffff)
#define EGRMETERINGBUCKETr_BUCKETf_SET(r,f) (r).egrmeteringbucket[0]=(((r).egrmeteringbucket[0] & ~((uint32)0x1fffffff)) | (((uint32)f) & 0x1fffffff))
#define EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_GET(r) ((((r).egrmeteringbucket[0]) >> 29) & 0x1)
#define EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_SET(r,f) (r).egrmeteringbucket[0]=(((r).egrmeteringbucket[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))

/*
 * These macros can be used to access EGRMETERINGBUCKET.
 */
#define WRITE_EGRMETERINGBUCKETr(u,p,r) bcm5607x_reg_set(u,R_EGRMETERINGBUCKET(p),(r._egrmeteringbucket))
#define READ_EGRMETERINGBUCKETr(u,p,r) bcm5607x_reg_get(u,R_EGRMETERINGBUCKET(p),&(r._egrmeteringbucket))

/*******************************************************************************
 * End of 'EGRMETERINGBUCKETr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EGRMETERINGCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     THD_SEL          Egress Metering Bucket function is disabled when bucket size is 0.Threshold for metering bucket.The setting of Threshold determines the size of bucket and not related to actual bandwidth rate number. It also determines how burstiness of traffic is.When METER_EGR_PORT_GRAN corresponding setting is 0:  The Bucket Size is range from 4k Bytes to 16M Bytes with 4k Bytes increment. The Bucket size is determined by the formula,  Bucket Size = PAUSE_THD * 4KBytesWhen METER_EGR_PORT_GRAN corresponding setting is 1:  The Bucket Size is range from 8k Bytes to 32M Bytes with 8k Bytes increment. The Bucket size is determined by the formula,  Bucket Size = PAUSE_THD * 8KBytes
 *     REFRESH          Refresh count for metering bucket. hen METER_EGR_PORT_GRAN corresponding setting is 0:  Every unit of REFRESH represents 64,000 bps, (bits per second).  Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),                set MIN_REFRESH = 7812,  Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),                set MIN_REFRESH = 15624.When METER_ING_PORT_GRAN corresponding setting is 1:  Every unit of REFRESH represents 256,000 bps, (bits per second).
 */
#define EGRMETERINGCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGRMETERINGCONFIG.
 */
typedef union EGRMETERINGCONFIGr_s {
	uint32 v[1];
	uint32 egrmeteringconfig[1];
	uint32 _egrmeteringconfig;
} EGRMETERINGCONFIGr_t;

#define EGRMETERINGCONFIGr_CLR(r) (r).egrmeteringconfig[0] = 0
#define EGRMETERINGCONFIGr_SET(r,d) (r).egrmeteringconfig[0] = d
#define EGRMETERINGCONFIGr_GET(r) (r).egrmeteringconfig[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGRMETERINGCONFIGr_THD_SELf_GET(r) (((r).egrmeteringconfig[0]) & 0xfff)
#define EGRMETERINGCONFIGr_THD_SELf_SET(r,f) (r).egrmeteringconfig[0]=(((r).egrmeteringconfig[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define EGRMETERINGCONFIGr_REFRESHf_GET(r) ((((r).egrmeteringconfig[0]) >> 12) & 0x3ffff)
#define EGRMETERINGCONFIGr_REFRESHf_SET(r,f) (r).egrmeteringconfig[0]=(((r).egrmeteringconfig[0] & ~((uint32)0x3ffff << 12)) | ((((uint32)f) & 0x3ffff) << 12))

/*
 * These macros can be used to access EGRMETERINGCONFIG.
 */
#define WRITE_EGRMETERINGCONFIGr(u,p,r) bcm5607x_reg_set(u,R_EGRMETERINGCONFIG(p),(r._egrmeteringconfig))
#define READ_EGRMETERINGCONFIGr(u,p,r) bcm5607x_reg_get(u,R_EGRMETERINGCONFIG(p),&(r._egrmeteringconfig))

/*******************************************************************************
 * End of 'EGRMETERINGCONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EGR_CONFIG
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for the entire chip.
 * SIZE:     32
 * FIELDS:
 *     SNAP_OTHER_DECODE_ENABLE Decode SNAP packets with non-zero OUI for protocol-based VLAN
 *     USE_LEARN_VID    Use the learn_vid for vid membership and STG state check.
 *     LEARN_VID        Vid to be used for vid membership and STG state check when USE_LEARN_VID is set.
 *     INNER_TPID       TPID to identify inner vlan tag of the packet when switch is operating in DT mode, i.e. DT_MODE bit is set.
 */
#define EGR_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_CONFIG.
 */
typedef union EGR_CONFIGr_s {
	uint32 v[1];
	uint32 egr_config[1];
	uint32 _egr_config;
} EGR_CONFIGr_t;

#define EGR_CONFIGr_CLR(r) (r).egr_config[0] = 0
#define EGR_CONFIGr_SET(r,d) (r).egr_config[0] = d
#define EGR_CONFIGr_GET(r) (r).egr_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET(r) ((((r).egr_config[0]) >> 2) & 0x1)
#define EGR_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define EGR_CONFIGr_USE_LEARN_VIDf_GET(r) ((((r).egr_config[0]) >> 3) & 0x1)
#define EGR_CONFIGr_USE_LEARN_VIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define EGR_CONFIGr_LEARN_VIDf_GET(r) ((((r).egr_config[0]) >> 4) & 0xfff)
#define EGR_CONFIGr_LEARN_VIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32)0xfff << 4)) | ((((uint32)f) & 0xfff) << 4))
#define EGR_CONFIGr_INNER_TPIDf_GET(r) ((((r).egr_config[0]) >> 16) & 0xffff)
#define EGR_CONFIGr_INNER_TPIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access EGR_CONFIG.
 */
#define WRITE_EGR_CONFIGr(u,r) bcm5607x_reg_set(u,R_EGR_CONFIG,(r._egr_config))
#define READ_EGR_CONFIGr(u,r) bcm5607x_reg_get(u,R_EGR_CONFIG,&(r._egr_config))

/*******************************************************************************
 * End of 'EGR_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  EGR_EM_MTP_INDEX
 * BLOCKS:   EPIPE
 * DESC:     Mirror to Port Table. 
Index is constructed using pbe.mtp_index[6:0] field.
We use {pbe.mtp_index[5:4],pbe.mtp_index[2:0]} as index into this table.

 * SIZE:     19
 * FIELDS:
 *     MTP_DST_MODID    DST_MODID field to be used in the module header in case of mirroring.
 *     MTP_DST_PORT     DST_PORT field to be used in module header in case of mirroring.
 *     MIRROR_ENCAP_ENABLE If set, causes a mirroring encapsulation on mirror packets using the EGR_MIRROR_ENCAP_DATA_1/_2/CONTROL tables.
 *     MIRROR_ENCAP_INDEX Index into the EGR_MIRROR_ENCAP_DATA_1/_2/CONTROL tables.
 */
#define EGR_EM_MTP_INDEXm_MIN 0
#define EGR_EM_MTP_INDEXm_MAX 31
#define EGR_EM_MTP_INDEXm_CMAX(u) 31
#define EGR_EM_MTP_INDEXm_SIZE 3

/*
 * This structure should be used to declare and program EGR_EM_MTP_INDEX.
 */
typedef union EGR_EM_MTP_INDEXm_s {
	uint32 v[1];
	uint32 egr_em_mtp_index[1];
	uint32 _egr_em_mtp_index;
} EGR_EM_MTP_INDEXm_t;

#define EGR_EM_MTP_INDEXm_CLR(r) (r).egr_em_mtp_index[0] = 0
#define EGR_EM_MTP_INDEXm_SET(r,d) (r).egr_em_mtp_index[0] = d
#define EGR_EM_MTP_INDEXm_GET(r) (r).egr_em_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_GET(r) (((r).egr_em_mtp_index[0]) & 0xff)
#define EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define EGR_EM_MTP_INDEXm_MTP_DST_PORTf_GET(r) ((((r).egr_em_mtp_index[0]) >> 8) & 0x7f)
#define EGR_EM_MTP_INDEXm_MTP_DST_PORTf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32)0x7f << 8)) | ((((uint32)f) & 0x7f) << 8))
#define EGR_EM_MTP_INDEXm_MIRROR_ENCAP_ENABLEf_GET(r) ((((r).egr_em_mtp_index[0]) >> 15) & 0x1)
#define EGR_EM_MTP_INDEXm_MIRROR_ENCAP_ENABLEf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define EGR_EM_MTP_INDEXm_MIRROR_ENCAP_INDEXf_GET(r) ((((r).egr_em_mtp_index[0]) >> 16) & 0x7)
#define EGR_EM_MTP_INDEXm_MIRROR_ENCAP_INDEXf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32)0x7 << 16)) | ((((uint32)f) & 0x7) << 16))

/*
 * These macros can be used to access EGR_EM_MTP_INDEX.
 */
#define WRITE_EGR_EM_MTP_INDEXm(u,i,r) bcm5607x_mem_set(u, M_EGR_EM_MTP_INDEX(i), &(r._egr_em_mtp_index), 1)
#define READ_EGR_EM_MTP_INDEXm(u,i,r) bcm5607x_mem_get(u, M_EGR_EM_MTP_INDEX(i), &(r._egr_em_mtp_index), 1)

/*******************************************************************************
 * End of 'EGR_EM_MTP_INDEXm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  EGR_ENABLE
 * BLOCKS:   EPIPE
 * DESC:     Egress Enable (per physical port)
 * SIZE:     1
 * FIELDS:
 *     PRT_ENABLE       Port is enabled. If this bit is set, this port will generate requests to the MMU.
 */
#define EGR_ENABLEm_MIN 0
#define EGR_ENABLEm_MAX 77
#define EGR_ENABLEm_CMAX(u) 77
#define EGR_ENABLEm_SIZE 1

/*
 * This structure should be used to declare and program EGR_ENABLE.
 */
typedef union EGR_ENABLEm_s {
	uint32 v[1];
	uint32 egr_enable[1];
	uint32 _egr_enable;
} EGR_ENABLEm_t;

#define EGR_ENABLEm_CLR(r) (r).egr_enable[0] = 0
#define EGR_ENABLEm_SET(r,d) (r).egr_enable[0] = d
#define EGR_ENABLEm_GET(r) (r).egr_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_ENABLEm_PRT_ENABLEf_GET(r) (((r).egr_enable[0]) & 0x1)
#define EGR_ENABLEm_PRT_ENABLEf_SET(r,f) (r).egr_enable[0]=(((r).egr_enable[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access EGR_ENABLE.
 */
#define WRITE_EGR_ENABLEm(u,i,r) bcm5607x_mem_set(u, M_EGR_ENABLE(i), &(r._egr_enable), 1)
#define READ_EGR_ENABLEm(u,i,r) bcm5607x_mem_get(u, M_EGR_ENABLE(i), &(r._egr_enable), 1)

/*******************************************************************************
 * End of 'EGR_ENABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EGR_HW_RESET_CONTROL_0
 * BLOCKS:   EPIPE
 * DESC:     This register is for controlling the HW Table Initialization Feature of the Egress Pipeline.
This register should be programmed before programming EGR_HW_RESET_CONTROL_1 register.

 * SIZE:     32
 * FIELDS:
 *     START_ADDRESS    HW starts incrementing from this address until EGR_HW_RESET_CONTROL_1.COUNT is completed.  START_ADDRESS is relevant even when EGR_HW_RESET_CONTROL_1.RESET_ALL bit is set.
 *     STAGE_NUMBER     Stage Number where table to be reset is located. This is NOT used when EGR_HW_RESET_CONTROL_1.RESET_ALL bit is set.
 */
#define EGR_HW_RESET_CONTROL_0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_HW_RESET_CONTROL_0.
 */
typedef union EGR_HW_RESET_CONTROL_0r_s {
	uint32 v[1];
	uint32 egr_hw_reset_control_0[1];
	uint32 _egr_hw_reset_control_0;
} EGR_HW_RESET_CONTROL_0r_t;

#define EGR_HW_RESET_CONTROL_0r_CLR(r) (r).egr_hw_reset_control_0[0] = 0
#define EGR_HW_RESET_CONTROL_0r_SET(r,d) (r).egr_hw_reset_control_0[0] = d
#define EGR_HW_RESET_CONTROL_0r_GET(r) (r).egr_hw_reset_control_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET(r) (((r).egr_hw_reset_control_0[0]) & 0x3ffffff)
#define EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET(r,f) (r).egr_hw_reset_control_0[0]=(((r).egr_hw_reset_control_0[0] & ~((uint32)0x3ffffff)) | (((uint32)f) & 0x3ffffff))
#define EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET(r) ((((r).egr_hw_reset_control_0[0]) >> 26) & 0x3f)
#define EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET(r,f) (r).egr_hw_reset_control_0[0]=(((r).egr_hw_reset_control_0[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access EGR_HW_RESET_CONTROL_0.
 */
#define WRITE_EGR_HW_RESET_CONTROL_0r(u,r) bcm5607x_reg_set(u,R_EGR_HW_RESET_CONTROL_0,(r._egr_hw_reset_control_0))
#define READ_EGR_HW_RESET_CONTROL_0r(u,r) bcm5607x_reg_get(u,R_EGR_HW_RESET_CONTROL_0,&(r._egr_hw_reset_control_0))

/*******************************************************************************
 * End of 'EGR_HW_RESET_CONTROL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EGR_HW_RESET_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     This register is for controlling the HW Table Initialization Feature of the Egress Pipeline.

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count of entries which need to be resetted starting from EGR_HW_RESET_CONTROL_0.START_ADDRESS.
 *     RESET_ALL        If set, then ALL Tables in the Egress Pipeline will be resetted for COUNT entries. STAGE_NUMBER is ignored when this bit is set. 
 *     VALID            The HW table initialization will start after Logic sees this bit as set.
 *     DONE             After HW has issued memory reset commands equal to COUNT times, it will set DONE bit,SW can poll this bit from time to time and whenever it is set, SW should reset DONE and VALIDbits to 0. This will end the HW Reset Sequence of memories in the HW.
 */
#define EGR_HW_RESET_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_HW_RESET_CONTROL_1.
 */
typedef union EGR_HW_RESET_CONTROL_1r_s {
	uint32 v[1];
	uint32 egr_hw_reset_control_1[1];
	uint32 _egr_hw_reset_control_1;
} EGR_HW_RESET_CONTROL_1r_t;

#define EGR_HW_RESET_CONTROL_1r_CLR(r) (r).egr_hw_reset_control_1[0] = 0
#define EGR_HW_RESET_CONTROL_1r_SET(r,d) (r).egr_hw_reset_control_1[0] = d
#define EGR_HW_RESET_CONTROL_1r_GET(r) (r).egr_hw_reset_control_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_HW_RESET_CONTROL_1r_COUNTf_GET(r) (((r).egr_hw_reset_control_1[0]) & 0xffff)
#define EGR_HW_RESET_CONTROL_1r_COUNTf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 16) & 0x1)
#define EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define EGR_HW_RESET_CONTROL_1r_VALIDf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 17) & 0x1)
#define EGR_HW_RESET_CONTROL_1r_VALIDf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define EGR_HW_RESET_CONTROL_1r_DONEf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 18) & 0x1)
#define EGR_HW_RESET_CONTROL_1r_DONEf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))

/*
 * These macros can be used to access EGR_HW_RESET_CONTROL_1.
 */
#define WRITE_EGR_HW_RESET_CONTROL_1r(u,r) bcm5607x_reg_set(u,R_EGR_HW_RESET_CONTROL_1,(r._egr_hw_reset_control_1))
#define READ_EGR_HW_RESET_CONTROL_1r(u,r) bcm5607x_reg_get(u,R_EGR_HW_RESET_CONTROL_1,&(r._egr_hw_reset_control_1))

/*******************************************************************************
 * End of 'EGR_HW_RESET_CONTROL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  EGR_IM_MTP_INDEX
 * BLOCKS:   EPIPE
 * DESC:     Mirror to Port Table to be used for IM tagged packets. 
Index is constructed using pbe.mtp_index[6:0] field.
We use {pbe.mtp_index[4:3],pbe.mtp_index[2:0]} as index into this table.

 * SIZE:     19
 * FIELDS:
 *     MTP_DST_MODID    DST_MODID field to be used in the module header in case of mirroring.
 *     MTP_DST_PORT     DST_PORT field to be used in module header in case of mirroring.
 *     MIRROR_ENCAP_ENABLE If set, causes a mirroring encapsulation on mirror packets using the EGR_MIRROR_ENCAP_DATA_1/_2/CONTROL tables.
 *     MIRROR_ENCAP_INDEX Index into the EGR_MIRROR_ENCAP_DATA_1/_2/CONTROL tables.
 */
#define EGR_IM_MTP_INDEXm_MIN 0
#define EGR_IM_MTP_INDEXm_MAX 31
#define EGR_IM_MTP_INDEXm_CMAX(u) 31
#define EGR_IM_MTP_INDEXm_SIZE 3

/*
 * This structure should be used to declare and program EGR_IM_MTP_INDEX.
 */
typedef union EGR_IM_MTP_INDEXm_s {
	uint32 v[1];
	uint32 egr_im_mtp_index[1];
	uint32 _egr_im_mtp_index;
} EGR_IM_MTP_INDEXm_t;

#define EGR_IM_MTP_INDEXm_CLR(r) (r).egr_im_mtp_index[0] = 0
#define EGR_IM_MTP_INDEXm_SET(r,d) (r).egr_im_mtp_index[0] = d
#define EGR_IM_MTP_INDEXm_GET(r) (r).egr_im_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_GET(r) (((r).egr_im_mtp_index[0]) & 0xff)
#define EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define EGR_IM_MTP_INDEXm_MTP_DST_PORTf_GET(r) ((((r).egr_im_mtp_index[0]) >> 8) & 0x7f)
#define EGR_IM_MTP_INDEXm_MTP_DST_PORTf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32)0x7f << 8)) | ((((uint32)f) & 0x7f) << 8))
#define EGR_IM_MTP_INDEXm_MIRROR_ENCAP_ENABLEf_GET(r) ((((r).egr_im_mtp_index[0]) >> 15) & 0x1)
#define EGR_IM_MTP_INDEXm_MIRROR_ENCAP_ENABLEf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define EGR_IM_MTP_INDEXm_MIRROR_ENCAP_INDEXf_GET(r) ((((r).egr_im_mtp_index[0]) >> 16) & 0x7)
#define EGR_IM_MTP_INDEXm_MIRROR_ENCAP_INDEXf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32)0x7 << 16)) | ((((uint32)f) & 0x7) << 16))

/*
 * These macros can be used to access EGR_IM_MTP_INDEX.
 */
#define WRITE_EGR_IM_MTP_INDEXm(u,i,r) bcm5607x_mem_set(u, M_EGR_IM_MTP_INDEX(i), &(r._egr_im_mtp_index), 1)
#define READ_EGR_IM_MTP_INDEXm(u,i,r) bcm5607x_mem_get(u, M_EGR_IM_MTP_INDEX(i), &(r._egr_im_mtp_index), 1)

/*******************************************************************************
 * End of 'EGR_IM_MTP_INDEXm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPING
 * BLOCKS:   EPIPE
 * DESC:     Egress Logical to Physical Port Number Mapping Register. Indexed by the Logical port number, and provides the corresponding physical port number.
 * SIZE:     32
 * FIELDS:
 *     PHYSICAL_PORT_NUMBER Physical port number value
 */
#define EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPING.
 */
typedef union EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_s {
	uint32 v[1];
	uint32 egr_logical_to_physical_port_number_mapping[1];
	uint32 _egr_logical_to_physical_port_number_mapping;
} EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_t;

#define EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_CLR(r) (r).egr_logical_to_physical_port_number_mapping[0] = 0
#define EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_SET(r,d) (r).egr_logical_to_physical_port_number_mapping[0] = d
#define EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_GET(r) (r).egr_logical_to_physical_port_number_mapping[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_PHYSICAL_PORT_NUMBERf_GET(r) (((r).egr_logical_to_physical_port_number_mapping[0]) & 0x7f)
#define EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_PHYSICAL_PORT_NUMBERf_SET(r,f) (r).egr_logical_to_physical_port_number_mapping[0]=(((r).egr_logical_to_physical_port_number_mapping[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))

/*
 * These macros can be used to access EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPING.
 */
#define WRITE_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr(u,p,r) bcm5607x_reg_set(u,R_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPING(p),(r._egr_logical_to_physical_port_number_mapping))
#define READ_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr(u,p,r) bcm5607x_reg_get(u,R_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPING(p),&(r._egr_logical_to_physical_port_number_mapping))

/*******************************************************************************
 * End of 'EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  EGR_MASK
 * BLOCKS:   IPIPE
 * DESC:     Egress Mask Table
 * SIZE:     67
 * FIELDS:
 *     EGRESS_MASK      Egress mask block mask for source port
 *     EGRESS_MASK_LO   Egress mask block mask for source port
 *     EVEN_PARITY       Even parity
 */
#define EGR_MASKm_MIN 0
#define EGR_MASKm_MAX 8191
#define EGR_MASKm_CMAX(u) 8191
#define EGR_MASKm_SIZE 9

/*
 * This structure should be used to declare and program EGR_MASK.
 */
typedef union EGR_MASKm_s {
	uint32 v[3];
	uint32 egr_mask[3];
	uint32 _egr_mask;
} EGR_MASKm_t;

#define EGR_MASKm_CLR(r) sal_memset(&((r)._egr_mask), 0, sizeof(EGR_MASKm_t))
#define EGR_MASKm_SET(r,i,d) (r).egr_mask[i] = d
#define EGR_MASKm_GET(r,i) (r).egr_mask[i]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_MASKm_EGRESS_MASKf_GET(r,a) field_get((r).egr_mask,0,65,a)
#define EGR_MASKm_EGRESS_MASKf_SET(r,a) field_set((r).egr_mask,0,65,a)
#define EGR_MASKm_EGRESS_MASK_LOf_GET(r,a) field_get((r).egr_mask,0,65,a)
#define EGR_MASKm_EGRESS_MASK_LOf_SET(r,a) field_set((r).egr_mask,0,65,a)
#define EGR_MASKm_EVEN_PARITYf_GET(r) ((((r).egr_mask[2]) >> 2) & 0x1)
#define EGR_MASKm_EVEN_PARITYf_SET(r,f) (r).egr_mask[2]=(((r).egr_mask[2] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))

/*
 * These macros can be used to access EGR_MASK.
 */
#define WRITE_EGR_MASKm(u,i,r) bcm5607x_mem_set(u, M_EGR_MASK(i), &(r._egr_mask), 3)
#define READ_EGR_MASKm(u,i,r) bcm5607x_mem_get(u, M_EGR_MASK(i), &(r._egr_mask), 3)

/*******************************************************************************
 * End of 'EGR_MASKm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EGR_PORT_64
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for a Port. This is different for each GE, 10GE port. FeatureSpecific-Ethernet
 * SIZE:     64
 * FIELDS:
 *     PORT_TYPE        
 *     HIGIG2           If PORT_TYPE bit is set to HiGig, then this bit indicates HIGIG2 or HIGIG+.
 *     EN_EFILTER       If this bit is set, the VLAN Membership check is done for the outgoing port.
 *     PRESERVE_CPU_TAG Preserve the tag of the packet destines to CPU.
 *     EM_SRCMOD_CHANGE Set to change the src_modid for the egress mirrored pkts going out of the higig port.
 *     MY_MODID         Module ID of this chip.
 *     EGR_PORT_GROUP_ID FP port group ID (used in the EFP for grouping ports)
 *     VT_PORT_GROUP_ID Port group ID of the egress port for egress VLAN translation
 *     DUAL_MODID_ENABLE Enable dual modid mode where this chip looks like two MODIDs to rest of system. Outgoing higig packets using (MY_MODID) with a (Port_ID>31) should be adjusted to (MY_MODID+1) with a (Port_ID-32) for transmission. Note that when set, MY_MODID must be even (ends in 0). When not set, all ports belong to single MY_MODID and no adjustment is necessary.
 *     EFP_FILTER_ENABLE RESERVED.
 *     VNTAG_ACTIONS_IF_PRESENT Values are: 00: No OP (do nothing), 01: Reserved, 10: Modify VNTAG - Set outgoing VNTAG's L-bit to 0 and src_vif to this egress port's NIV_VIF_ID/ETAG.VID, Reserved for ETAG. 11: Remove VNTAG/ETAG from the outgoing packet if present. Do not add a new VNTAG. Outgoing packet should be sent without VNTAG/ETAG.
 *     NIV_PRUNE_ENABLE This egress port is connecting to a VM and hence is a leaf port of the network. The outgoing packet needs to undergo a NIV/PE based pruning check. Compare the src_vif/VID field of the packet's VNTAG/ETAG with this egrss port's NIV_VIF_ID/ETAG.VID. If there is a match, do not forward the packet.
 *     NIV_VIF_ID       This port's NIV/PE Virtual Interface (VIF) identifier. If this port is a downlink port, then this value shall be used for setting the SRC_VIF of the outgoing VTAG if VTAG is added by the egress port and the packet originated from a different Namespace. If this port is an IV downlink port then this value shall be use to compare against VTAG src_vif field in the packet for NIV-based pruning (if NIV_PRUNE_ENABLE is set).
 *     NIV_UPLINK_PORT  If set to 1, this port is an NIV/PE uplink port. So, if VTAG's are inserted by the outgoing port, the d-field of the VNTAG/ETAG should be set to 1.
 *     MIRROR_ENCAP_ENABLE If set, causes a mirroring encapsulation on mirror packets using the EGR_MIRROR_ENCAP_DATA_1/_2/CONTROL tables.
 *     MIRROR_ENCAP_INDEX Index into the EGR_MIRROR_ENCAP_DATA_1/_2/CONTROL tables.
 *     CUSTOM_HEADER_ENABLE The CUSTOM_HEADER_ENABLE will decide if a packet will be modified to add the custom header even if the IFP action is to add a custom header.
 *     PTP_DOMAIN_ID    Represents a bitmap that indicates which  of the 4 Domain_IDs are supported on this port.
 */
#define EGR_PORT_64r_SIZE 8

/*
 * This structure should be used to declare and program EGR_PORT_64.
 */
typedef union EGR_PORT_64r_s {
	uint32 v[2];
	uint32 egr_port_64[2];
	uint32 _egr_port_64;
} EGR_PORT_64r_t;

#define EGR_PORT_64r_CLR(r) sal_memset(&((r)._egr_port_64), 0, sizeof(EGR_PORT_64r_t))
#define EGR_PORT_64r_SET(r,i,d) (r).egr_port_64[i] = d
#define EGR_PORT_64r_GET(r,i) (r).egr_port_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_PORT_64r_PORT_TYPEf_GET(r) (((r).egr_port_64[0]) & 0x3)
#define EGR_PORT_64r_PORT_TYPEf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EGR_PORT_64r_HIGIG2f_GET(r) ((((r).egr_port_64[0]) >> 2) & 0x1)
#define EGR_PORT_64r_HIGIG2f_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define EGR_PORT_64r_EN_EFILTERf_GET(r) ((((r).egr_port_64[0]) >> 3) & 0x1)
#define EGR_PORT_64r_EN_EFILTERf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define EGR_PORT_64r_PRESERVE_CPU_TAGf_GET(r) ((((r).egr_port_64[0]) >> 4) & 0x1)
#define EGR_PORT_64r_PRESERVE_CPU_TAGf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define EGR_PORT_64r_EM_SRCMOD_CHANGEf_GET(r) ((((r).egr_port_64[0]) >> 6) & 0x1)
#define EGR_PORT_64r_EM_SRCMOD_CHANGEf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define EGR_PORT_64r_MY_MODIDf_GET(r) ((((r).egr_port_64[0]) >> 7) & 0xff)
#define EGR_PORT_64r_MY_MODIDf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define EGR_PORT_64r_EGR_PORT_GROUP_IDf_GET(r) ((((r).egr_port_64[0]) >> 15) & 0xff)
#define EGR_PORT_64r_EGR_PORT_GROUP_IDf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0xff << 15)) | ((((uint32)f) & 0xff) << 15))
#define EGR_PORT_64r_VT_PORT_GROUP_IDf_GET(r) ((((r).egr_port_64[0]) >> 23) & 0x7f)
#define EGR_PORT_64r_VT_PORT_GROUP_IDf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x7f << 23)) | ((((uint32)f) & 0x7f) << 23))
#define EGR_PORT_64r_DUAL_MODID_ENABLEf_GET(r) ((((r).egr_port_64[0]) >> 30) & 0x1)
#define EGR_PORT_64r_DUAL_MODID_ENABLEf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define EGR_PORT_64r_EFP_FILTER_ENABLEf_GET(r) ((((r).egr_port_64[0]) >> 31) & 0x1)
#define EGR_PORT_64r_EFP_FILTER_ENABLEf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define EGR_PORT_64r_VNTAG_ACTIONS_IF_PRESENTf_GET(r) (((r).egr_port_64[1]) & 0x3)
#define EGR_PORT_64r_VNTAG_ACTIONS_IF_PRESENTf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EGR_PORT_64r_NIV_PRUNE_ENABLEf_GET(r) ((((r).egr_port_64[1]) >> 2) & 0x1)
#define EGR_PORT_64r_NIV_PRUNE_ENABLEf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define EGR_PORT_64r_NIV_VIF_IDf_GET(r) ((((r).egr_port_64[1]) >> 3) & 0xfff)
#define EGR_PORT_64r_NIV_VIF_IDf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define EGR_PORT_64r_NIV_UPLINK_PORTf_GET(r) ((((r).egr_port_64[1]) >> 15) & 0x1)
#define EGR_PORT_64r_NIV_UPLINK_PORTf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define EGR_PORT_64r_MIRROR_ENCAP_ENABLEf_GET(r) ((((r).egr_port_64[1]) >> 16) & 0x1)
#define EGR_PORT_64r_MIRROR_ENCAP_ENABLEf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define EGR_PORT_64r_MIRROR_ENCAP_INDEXf_GET(r) ((((r).egr_port_64[1]) >> 17) & 0x7)
#define EGR_PORT_64r_MIRROR_ENCAP_INDEXf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0x7 << 17)) | ((((uint32)f) & 0x7) << 17))
#define EGR_PORT_64r_CUSTOM_HEADER_ENABLEf_GET(r) ((((r).egr_port_64[1]) >> 20) & 0x1)
#define EGR_PORT_64r_CUSTOM_HEADER_ENABLEf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define EGR_PORT_64r_PTP_DOMAIN_IDf_GET(r) ((((r).egr_port_64[1]) >> 21) & 0xf)
#define EGR_PORT_64r_PTP_DOMAIN_IDf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0xf << 21)) | ((((uint32)f) & 0xf) << 21))

/*
 * These macros can be used to access EGR_PORT_64.
 */
#define WRITE_EGR_PORT_64r(u,p,r) bcm5607x_reg64_set(u,R_EGR_PORT_64(p),&(r._egr_port_64),2)
#define READ_EGR_PORT_64r(u,p,r) bcm5607x_reg64_get(u,R_EGR_PORT_64(p),&(r._egr_port_64),2)

/*******************************************************************************
 * End of 'EGR_PORT_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EGR_PORT_BUFFER_CLK_SHUTDOWN
 * BLOCKS:   EPIPE
 * DESC:     Soft shutdown the clocking of interface buffer
 * SIZE:     32
 * FIELDS:
 *     EGR_CM           Soft shutdown the clocking of the EGR_CM buffer
 *     EGR_GE0          Soft shutdown the clocking of the EGR_GE0 buffer
 *     EGR_GE1          Soft shutdown the clocking of the EGR_GE1 buffer
 *     EGR_GE2          Soft shutdown the clocking of the EGR_GE2 buffer
 *     EGR_GE3          Soft shutdown the clocking of the EGR_GE3 buffer
 *     EGR_GE4          Soft shutdown the clocking of the EGR_GE4 buffer
 *     EGR_GE5          Soft shutdown the clocking of the EGR_GE5 buffer
 *     EGR_XL0          Soft shutdown the clocking of the EGR_XL0 buffer
 *     EGR_XL1          Soft shutdown the clocking of the EGR_XL1 buffer
 *     EGR_XL2          Soft shutdown the clocking of the EGR_XL2 buffer
 *     EGR_XL3          Soft shutdown the clocking of the EGR_XL3 buffer
 *     EGR_XL4          Soft shutdown the clocking of the EGR_XL4 buffer
 *     EGR_XL5          Soft shutdown the clocking of the EGR_XL5 buffer
 *     EGR_CL0          Soft shutdown the clocking of the EGR_CL0 buffer
 *     EGR_CL1          Soft shutdown the clocking of the EGR_CL1 buffer
 *     EGR_CL2          Soft shutdown the clocking of the EGR_CL2 buffer
 *     EGR_CL3          Soft shutdown the clocking of the EGR_CL3 buffer
 */
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT_BUFFER_CLK_SHUTDOWN.
 */
typedef union EGR_PORT_BUFFER_CLK_SHUTDOWNr_s {
	uint32 v[1];
	uint32 egr_port_buffer_clk_shutdown[1];
	uint32 _egr_port_buffer_clk_shutdown;
} EGR_PORT_BUFFER_CLK_SHUTDOWNr_t;

#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_CLR(r) (r).egr_port_buffer_clk_shutdown[0] = 0
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_SET(r,d) (r).egr_port_buffer_clk_shutdown[0] = d
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_GET(r) (r).egr_port_buffer_clk_shutdown[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_CMf_GET(r) (((r).egr_port_buffer_clk_shutdown[0]) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_CMf_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_GE0f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 1) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_GE0f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_GE1f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 2) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_GE1f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_GE2f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 3) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_GE2f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_GE3f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 4) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_GE3f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_GE4f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 5) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_GE4f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_GE5f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 6) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_GE5f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_XL0f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 7) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_XL0f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_XL1f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 8) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_XL1f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_XL2f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 9) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_XL2f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_XL3f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 10) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_XL3f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_XL4f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 11) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_XL4f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_XL5f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 12) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_XL5f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_CL0f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 13) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_CL0f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_CL1f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 14) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_CL1f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_CL2f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 15) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_CL2f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_CL3f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 16) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_EGR_CL3f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))

/*
 * These macros can be used to access EGR_PORT_BUFFER_CLK_SHUTDOWN.
 */
#define WRITE_EGR_PORT_BUFFER_CLK_SHUTDOWNr(u,r) bcm5607x_reg_set(u,R_EGR_PORT_BUFFER_CLK_SHUTDOWN,(r._egr_port_buffer_clk_shutdown))
#define READ_EGR_PORT_BUFFER_CLK_SHUTDOWNr(u,r) bcm5607x_reg_get(u,R_EGR_PORT_BUFFER_CLK_SHUTDOWN,&(r._egr_port_buffer_clk_shutdown))

/*******************************************************************************
 * End of 'EGR_PORT_BUFFER_CLK_SHUTDOWNr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  EGR_PORT_CREDIT_RESET
 * BLOCKS:   EPIPE
 * DESC:     To clear the port credit(per physical port)
 * SIZE:     1
 * FIELDS:
 *     VALUE            The flag to clear the port credit. If this bit is set, the requests from the port will be credit. Explicitly write to zero to clear the bit
 */
#define EGR_PORT_CREDIT_RESETm_MIN 0
#define EGR_PORT_CREDIT_RESETm_MAX 77
#define EGR_PORT_CREDIT_RESETm_CMAX(u) 77
#define EGR_PORT_CREDIT_RESETm_SIZE 1

/*
 * This structure should be used to declare and program EGR_PORT_CREDIT_RESET.
 */
typedef union EGR_PORT_CREDIT_RESETm_s {
	uint32 v[1];
	uint32 egr_port_credit_reset[1];
	uint32 _egr_port_credit_reset;
} EGR_PORT_CREDIT_RESETm_t;

#define EGR_PORT_CREDIT_RESETm_CLR(r) (r).egr_port_credit_reset[0] = 0
#define EGR_PORT_CREDIT_RESETm_SET(r,d) (r).egr_port_credit_reset[0] = d
#define EGR_PORT_CREDIT_RESETm_GET(r) (r).egr_port_credit_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_PORT_CREDIT_RESETm_VALUEf_GET(r) (((r).egr_port_credit_reset[0]) & 0x1)
#define EGR_PORT_CREDIT_RESETm_VALUEf_SET(r,f) (r).egr_port_credit_reset[0]=(((r).egr_port_credit_reset[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access EGR_PORT_CREDIT_RESET.
 */
#define WRITE_EGR_PORT_CREDIT_RESETm(u,i,r) bcm5607x_mem_set(u, M_EGR_PORT_CREDIT_RESET(i), &(r._egr_port_credit_reset), 1)
#define READ_EGR_PORT_CREDIT_RESETm(u,i,r) bcm5607x_mem_get(u, M_EGR_PORT_CREDIT_RESET(i), &(r._egr_port_credit_reset), 1)

/*******************************************************************************
 * End of 'EGR_PORT_CREDIT_RESETm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  EGR_PORT_REQUESTS
 * BLOCKS:   EPIPE
 * DESC:     This table contains the cell requests asserted by individual port blocks (XLPORT's and CMIC).
Meaning of cell request is different for different ports, but this register has no
understanding of those meanings. All it shows is the number of times cell_request signal
was asserted by each port to TP.

 * SIZE:     9
 * FIELDS:
 *     OUTSTANDING_PORT_REQUESTS Number of cell requests.
 */
#define EGR_PORT_REQUESTSm_MIN 0
#define EGR_PORT_REQUESTSm_MAX 77
#define EGR_PORT_REQUESTSm_CMAX(u) 77
#define EGR_PORT_REQUESTSm_SIZE 2

/*
 * This structure should be used to declare and program EGR_PORT_REQUESTS.
 */
typedef union EGR_PORT_REQUESTSm_s {
	uint32 v[1];
	uint32 egr_port_requests[1];
	uint32 _egr_port_requests;
} EGR_PORT_REQUESTSm_t;

#define EGR_PORT_REQUESTSm_CLR(r) (r).egr_port_requests[0] = 0
#define EGR_PORT_REQUESTSm_SET(r,d) (r).egr_port_requests[0] = d
#define EGR_PORT_REQUESTSm_GET(r) (r).egr_port_requests[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_PORT_REQUESTSm_OUTSTANDING_PORT_REQUESTSf_GET(r) (((r).egr_port_requests[0]) & 0x1ff)
#define EGR_PORT_REQUESTSm_OUTSTANDING_PORT_REQUESTSf_SET(r,f) (r).egr_port_requests[0]=(((r).egr_port_requests[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))

/*
 * These macros can be used to access EGR_PORT_REQUESTS.
 */
#define WRITE_EGR_PORT_REQUESTSm(u,i,r) bcm5607x_mem_set(u, M_EGR_PORT_REQUESTS(i), &(r._egr_port_requests), 1)
#define READ_EGR_PORT_REQUESTSm(u,i,r) bcm5607x_mem_get(u, M_EGR_PORT_REQUESTS(i), &(r._egr_port_requests), 1)

/*******************************************************************************
 * End of 'EGR_PORT_REQUESTSm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  EGR_TDM_PORT_MAP
 * BLOCKS:   EPIPE
 * DESC:     To enable the physical port map
 * SIZE:     78
 * FIELDS:
 *     BITMAP           The TDM physical port bit map
 */
#define EGR_TDM_PORT_MAPm_MIN 0
#define EGR_TDM_PORT_MAPm_MAX 0
#define EGR_TDM_PORT_MAPm_CMAX(u) 0
#define EGR_TDM_PORT_MAPm_SIZE 10

/*
 * This structure should be used to declare and program EGR_TDM_PORT_MAP.
 */
typedef union EGR_TDM_PORT_MAPm_s {
	uint32 v[3];
	uint32 egr_tdm_port_map[3];
	uint32 _egr_tdm_port_map;
} EGR_TDM_PORT_MAPm_t;

#define EGR_TDM_PORT_MAPm_CLR(r) sal_memset(&((r)._egr_tdm_port_map), 0, sizeof(EGR_TDM_PORT_MAPm_t))
#define EGR_TDM_PORT_MAPm_SET(r,i,d) (r).egr_tdm_port_map[i] = d
#define EGR_TDM_PORT_MAPm_GET(r,i) (r).egr_tdm_port_map[i]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_TDM_PORT_MAPm_BITMAPf_GET(r,a) field_get((r).egr_tdm_port_map,0,77,a)
#define EGR_TDM_PORT_MAPm_BITMAPf_SET(r,a) field_set((r).egr_tdm_port_map,0,77,a)

/*
 * These macros can be used to access EGR_TDM_PORT_MAP.
 */
#define WRITE_EGR_TDM_PORT_MAPm(u,r) bcm5607x_mem_set(u, M_EGR_TDM_PORT_MAP, &(r._egr_tdm_port_map), 3)
#define READ_EGR_TDM_PORT_MAPm(u,r) bcm5607x_mem_get(u, M_EGR_TDM_PORT_MAP, &(r._egr_tdm_port_map), 3)

/*******************************************************************************
 * End of 'EGR_TDM_PORT_MAPm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  EGR_VLAN
 * BLOCKS:   EPIPE
 * DESC:     Vlan Membership Table for Egress
 * SIZE:     152
 * FIELDS:
 *     UT_BITMAP        Alias for UT_PORT_BITMAP
 *     UT_BITMAP_HI     Alias for UT_PORT_BITMAP
 *     UT_BITMAP_LO     Alias for UT_PORT_BITMAP
 *     UT_PORT_BITMAP   Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed. For Q-in-Q, indicates on which port, the outer tag needs to be removed.
 *     UT_PORT_BITMAP_HI Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed. For Q-in-Q, indicates on which port, the outer tag needs to be removed.
 *     UT_PORT_BITMAP_LO Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed. For Q-in-Q, indicates on which port, the outer tag needs to be removed.
 *     PORT_BITMAP      Bitmap to indicate the port members that belong to this VLAN.
 *     PORT_BITMAP_HI   the port bitmap
 *     PORT_BITMAP_LO   the port bitmap
 *     STG              Spanning Tree Group Number. To be used for indexing VLAN_STG table.
 *     RESERVED_0       Reserved.
 *     VALID            Indicates if the entry is valid.
 *     OUTER_TPID_INDEX Used when EGR_VLAN_CONTROL_1.OUTER_TPID_SEL is set and indicates which ofthe EGR_OUTER_TPID[xx] registers is to be used as the TPID for this VLAN
 *     REMARK_DOT1P     If this bit is set, (int_pri, CNG) are mapped to outer (CFI, 802.1p) bits in the EGR_MPLS_PRI_MAPPING table.
 *     DOT1P_MAPPING_PTR Selects one of 8 PRI(CNG) to EXP mapping profiles.
 *     SR_LAN_ID_VALID  Indicates whether the SR_LAN_ID is valid or not. 0: InValid, 1: Valid.
 *     SR_LAN_ID        Used for Seamless Redundancy (802.1CB) and Indicates whether this VLAN is LAN_A or LAN_B. 0: LAN_A, 1: LAN_B.
 *     SR_ENABLE        When set Indicates that Seamless Redundancy is enabled on this VLAN.  
 *     EVEN_PARITY      PARITY BIT to make the entry parity even
 */
#define EGR_VLANm_MIN 0
#define EGR_VLANm_MAX 4095
#define EGR_VLANm_CMAX(u) 4095
#define EGR_VLANm_SIZE 19

/*
 * This structure should be used to declare and program EGR_VLAN.
 */
typedef union EGR_VLANm_s {
	uint32 v[5];
	uint32 egr_vlan[5];
	uint32 _egr_vlan;
} EGR_VLANm_t;

#define EGR_VLANm_CLR(r) sal_memset(&((r)._egr_vlan), 0, sizeof(EGR_VLANm_t))
#define EGR_VLANm_SET(r,i,d) (r).egr_vlan[i] = d
#define EGR_VLANm_GET(r,i) (r).egr_vlan[i]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_VLANm_UT_BITMAPf_GET(r,a) field_get((r).egr_vlan,0,65,a)
#define EGR_VLANm_UT_BITMAPf_SET(r,a) field_set((r).egr_vlan,0,65,a)
#define EGR_VLANm_UT_BITMAP_HIf_GET(r,a) field_get((r).egr_vlan,0,65,a)
#define EGR_VLANm_UT_BITMAP_HIf_SET(r,a) field_set((r).egr_vlan,0,65,a)
#define EGR_VLANm_UT_BITMAP_LOf_GET(r,a) field_get((r).egr_vlan,0,65,a)
#define EGR_VLANm_UT_BITMAP_LOf_SET(r,a) field_set((r).egr_vlan,0,65,a)
#define EGR_VLANm_UT_PORT_BITMAPf_GET(r,a) field_get((r).egr_vlan,0,65,a)
#define EGR_VLANm_UT_PORT_BITMAPf_SET(r,a) field_set((r).egr_vlan,0,65,a)
#define EGR_VLANm_UT_PORT_BITMAP_HIf_GET(r,a) field_get((r).egr_vlan,0,65,a)
#define EGR_VLANm_UT_PORT_BITMAP_HIf_SET(r,a) field_set((r).egr_vlan,0,65,a)
#define EGR_VLANm_UT_PORT_BITMAP_LOf_GET(r,a) field_get((r).egr_vlan,0,65,a)
#define EGR_VLANm_UT_PORT_BITMAP_LOf_SET(r,a) field_set((r).egr_vlan,0,65,a)
#define EGR_VLANm_PORT_BITMAPf_GET(r,a) field_get((r).egr_vlan,66,131,a)
#define EGR_VLANm_PORT_BITMAPf_SET(r,a) field_set((r).egr_vlan,66,131,a)
#define EGR_VLANm_PORT_BITMAP_HIf_GET(r,a) field_get((r).egr_vlan,66,131,a)
#define EGR_VLANm_PORT_BITMAP_HIf_SET(r,a) field_set((r).egr_vlan,66,131,a)
#define EGR_VLANm_PORT_BITMAP_LOf_GET(r,a) field_get((r).egr_vlan,66,131,a)
#define EGR_VLANm_PORT_BITMAP_LOf_SET(r,a) field_set((r).egr_vlan,66,131,a)
#define EGR_VLANm_STGf_GET(r) ((((r).egr_vlan[4]) >> 4) & 0x7f)
#define EGR_VLANm_STGf_SET(r,f) (r).egr_vlan[4]=(((r).egr_vlan[4] & ~((uint32)0x7f << 4)) | ((((uint32)f) & 0x7f) << 4))
#define EGR_VLANm_RESERVED_0f_GET(r) ((((r).egr_vlan[4]) >> 11) & 0x1)
#define EGR_VLANm_RESERVED_0f_SET(r,f) (r).egr_vlan[4]=(((r).egr_vlan[4] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define EGR_VLANm_VALIDf_GET(r) ((((r).egr_vlan[4]) >> 12) & 0x1)
#define EGR_VLANm_VALIDf_SET(r,f) (r).egr_vlan[4]=(((r).egr_vlan[4] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define EGR_VLANm_OUTER_TPID_INDEXf_GET(r) ((((r).egr_vlan[4]) >> 13) & 0x3)
#define EGR_VLANm_OUTER_TPID_INDEXf_SET(r,f) (r).egr_vlan[4]=(((r).egr_vlan[4] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define EGR_VLANm_REMARK_DOT1Pf_GET(r) ((((r).egr_vlan[4]) >> 15) & 0x1)
#define EGR_VLANm_REMARK_DOT1Pf_SET(r,f) (r).egr_vlan[4]=(((r).egr_vlan[4] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define EGR_VLANm_DOT1P_MAPPING_PTRf_GET(r) ((((r).egr_vlan[4]) >> 16) & 0xf)
#define EGR_VLANm_DOT1P_MAPPING_PTRf_SET(r,f) (r).egr_vlan[4]=(((r).egr_vlan[4] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define EGR_VLANm_SR_LAN_ID_VALIDf_GET(r) ((((r).egr_vlan[4]) >> 20) & 0x1)
#define EGR_VLANm_SR_LAN_ID_VALIDf_SET(r,f) (r).egr_vlan[4]=(((r).egr_vlan[4] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define EGR_VLANm_SR_LAN_IDf_GET(r) ((((r).egr_vlan[4]) >> 21) & 0x1)
#define EGR_VLANm_SR_LAN_IDf_SET(r,f) (r).egr_vlan[4]=(((r).egr_vlan[4] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define EGR_VLANm_SR_ENABLEf_GET(r) ((((r).egr_vlan[4]) >> 22) & 0x1)
#define EGR_VLANm_SR_ENABLEf_SET(r,f) (r).egr_vlan[4]=(((r).egr_vlan[4] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define EGR_VLANm_EVEN_PARITYf_GET(r) ((((r).egr_vlan[4]) >> 23) & 0x1)
#define EGR_VLANm_EVEN_PARITYf_SET(r,f) (r).egr_vlan[4]=(((r).egr_vlan[4] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))

/*
 * These macros can be used to access EGR_VLAN.
 */
#define WRITE_EGR_VLANm(u,i,r) bcm5607x_mem_set(u, M_EGR_VLAN(i), &(r._egr_vlan), 5)
#define READ_EGR_VLANm(u,i,r) bcm5607x_mem_get(u, M_EGR_VLAN(i), &(r._egr_vlan), 5)

/*******************************************************************************
 * End of 'EGR_VLANm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EGR_VLAN_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     Controls Vlan Translate and VLAN membership related functions.

 * SIZE:     32
 * FIELDS:
 *     VT_ENABLE        VLAN Translate is enabled on this port. If this bit is set, then the vid, pri obtained from the VLAN translation Lookup is used.
 *     VT_MISS_DROP     If this bit is set, and a lookup in the VLAN translation table results in a miss, then pkt is dropped.This bit is meaningful only when VT_ENABLE is set.
 *     VT_MISS_UT_DROP  If this bit is set, and a lookup in the VLAN translation table results in a miss, and pkt is untagged by vlan_table, then pkt is dropped.This bit is meaningful only when VT_ENABLE is set.
 *     VT_MISS_UNTAG    If this bit is set, it will force vlan translation misses to be untagged
 *     OUTER_TPID_SEL   If this bit is set, use the EGR_VLAN table OUTER_TPID_INDEX to index into the EGR_OUTER_TPID registers and obtain the outer TPID.Else, use the EGR_VLAN_CONTROL_1 register OUTER_TPID_INDEXfield to index into the EGR_OUTER_TPID registers and obtain the outer TPID.
 *     OUTER_TPID_INDEX Index into the EGR_OUTER_TPID[xx] register array.
 *     CFI_AS_CNG       The 4 bits are associated with the 4 EGR_OUTER_TPID registers. If one of these bits is set, the CFI bit in packets with the corresponding EGR_OUTER_TPID register indicates CNG.
 *     REMARK_OUTER_DOT1P If this bit is set, (int_pri, CNG) are mapped to outer (CFI, 802.1p) bits in the EGR_PRI_CNG_MAP table. Whether the CFI is used depends on the TPID's CFI_AS_CNG setting.
 *     REMARK_OUTER_DSCP If this bit is set, (int_pri, CNG) are mapped to outgoing IP header's DSCP in the EGR_DSCP table.
 *     INNER_TPID_ENABLE 
 */
#define EGR_VLAN_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_VLAN_CONTROL_1.
 */
typedef union EGR_VLAN_CONTROL_1r_s {
	uint32 v[1];
	uint32 egr_vlan_control_1[1];
	uint32 _egr_vlan_control_1;
} EGR_VLAN_CONTROL_1r_t;

#define EGR_VLAN_CONTROL_1r_CLR(r) (r).egr_vlan_control_1[0] = 0
#define EGR_VLAN_CONTROL_1r_SET(r,d) (r).egr_vlan_control_1[0] = d
#define EGR_VLAN_CONTROL_1r_GET(r) (r).egr_vlan_control_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_VLAN_CONTROL_1r_VT_ENABLEf_GET(r) (((r).egr_vlan_control_1[0]) & 0x1)
#define EGR_VLAN_CONTROL_1r_VT_ENABLEf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_GET(r) ((((r).egr_vlan_control_1[0]) >> 1) & 0x1)
#define EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_GET(r) ((((r).egr_vlan_control_1[0]) >> 2) & 0x1)
#define EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define EGR_VLAN_CONTROL_1r_VT_MISS_UNTAGf_GET(r) ((((r).egr_vlan_control_1[0]) >> 3) & 0x1)
#define EGR_VLAN_CONTROL_1r_VT_MISS_UNTAGf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define EGR_VLAN_CONTROL_1r_OUTER_TPID_SELf_GET(r) ((((r).egr_vlan_control_1[0]) >> 4) & 0x1)
#define EGR_VLAN_CONTROL_1r_OUTER_TPID_SELf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define EGR_VLAN_CONTROL_1r_OUTER_TPID_INDEXf_GET(r) ((((r).egr_vlan_control_1[0]) >> 5) & 0x3)
#define EGR_VLAN_CONTROL_1r_OUTER_TPID_INDEXf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x3 << 5)) | ((((uint32)f) & 0x3) << 5))
#define EGR_VLAN_CONTROL_1r_CFI_AS_CNGf_GET(r) ((((r).egr_vlan_control_1[0]) >> 7) & 0xf)
#define EGR_VLAN_CONTROL_1r_CFI_AS_CNGf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0xf << 7)) | ((((uint32)f) & 0xf) << 7))
#define EGR_VLAN_CONTROL_1r_REMARK_OUTER_DOT1Pf_GET(r) ((((r).egr_vlan_control_1[0]) >> 12) & 0x1)
#define EGR_VLAN_CONTROL_1r_REMARK_OUTER_DOT1Pf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define EGR_VLAN_CONTROL_1r_REMARK_OUTER_DSCPf_GET(r) ((((r).egr_vlan_control_1[0]) >> 13) & 0x1)
#define EGR_VLAN_CONTROL_1r_REMARK_OUTER_DSCPf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define EGR_VLAN_CONTROL_1r_INNER_TPID_ENABLEf_GET(r) ((((r).egr_vlan_control_1[0]) >> 14) & 0x1)
#define EGR_VLAN_CONTROL_1r_INNER_TPID_ENABLEf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))

/*
 * These macros can be used to access EGR_VLAN_CONTROL_1.
 */
#define WRITE_EGR_VLAN_CONTROL_1r(u,p,r) bcm5607x_reg_set(u,R_EGR_VLAN_CONTROL_1(p),(r._egr_vlan_control_1))
#define READ_EGR_VLAN_CONTROL_1r(u,p,r) bcm5607x_reg_get(u,R_EGR_VLAN_CONTROL_1(p),&(r._egr_vlan_control_1))

/*******************************************************************************
 * End of 'EGR_VLAN_CONTROL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  EGR_VLAN_STG
 * BLOCKS:   EPIPE
 * DESC:     Egress Spanning Tree Stage Table, FeatureSpecific-Ethernet
 * SIZE:     133
 * FIELDS:
 *     SP_TREE_PORT0    Spanning Tree State for Port 0.
 *     SP_TREE_PORT1    Spanning Tree State for Port 1.
 *     SP_TREE_PORT2    Spanning Tree State for Port 2.
 *     SP_TREE_PORT3    Spanning Tree State for Port 3.
 *     SP_TREE_PORT4    Spanning Tree State for Port 4.
 *     SP_TREE_PORT5    Spanning Tree State for Port 5.
 *     SP_TREE_PORT6    Spanning Tree State for Port 6.
 *     SP_TREE_PORT7    Spanning Tree State for Port 7.
 *     SP_TREE_PORT8    Spanning Tree State for Port 8.
 *     SP_TREE_PORT9    Spanning Tree State for Port 9.
 *     SP_TREE_PORT10   Spanning Tree State for Port 10.
 *     SP_TREE_PORT11   Spanning Tree State for Port 11.
 *     SP_TREE_PORT12   Spanning Tree State for Port 12.
 *     SP_TREE_PORT13   Spanning Tree State for Port 13.
 *     SP_TREE_PORT14   Spanning Tree State for Port 14.
 *     SP_TREE_PORT15   Spanning Tree State for Port 15.
 *     SP_TREE_PORT16   Spanning Tree State for Port 16.
 *     SP_TREE_PORT17   Spanning Tree State for Port 17.
 *     SP_TREE_PORT18   Spanning Tree State for Port 18.
 *     SP_TREE_PORT19   Spanning Tree State for Port 19.
 *     SP_TREE_PORT20   Spanning Tree State for Port 20.
 *     SP_TREE_PORT21   Spanning Tree State for Port 21.
 *     SP_TREE_PORT22   Spanning Tree State for Port 22.
 *     SP_TREE_PORT23   Spanning Tree State for Port 23.
 *     SP_TREE_PORT24   Spanning Tree State for Port 24.
 *     SP_TREE_PORT25   Spanning Tree State for Port 25.
 *     SP_TREE_PORT26   Spanning Tree State for Port 26.
 *     SP_TREE_PORT27   Spanning Tree State for Port 27.
 *     SP_TREE_PORT28   Spanning Tree State for Port 28.
 *     SP_TREE_PORT29   Spanning Tree State for Port 29.
 *     SP_TREE_PORT30   Spanning Tree State for Port 30.
 *     SP_TREE_PORT31   Spanning Tree State for Port 31.
 *     SP_TREE_PORT32   Spanning Tree State for Port 32.
 *     SP_TREE_PORT33   Spanning Tree State for Port 33.
 *     SP_TREE_PORT34   Spanning Tree State for Port 34.
 *     SP_TREE_PORT35   Spanning Tree State for Port 35.
 *     SP_TREE_PORT36   Spanning Tree State for Port 36.
 *     SP_TREE_PORT37   Spanning Tree State for Port 37.
 *     SP_TREE_PORT38   Spanning Tree State for Port 38.
 *     SP_TREE_PORT39   Spanning Tree State for Port 39.
 *     SP_TREE_PORT40   Spanning Tree State for Port 40.
 *     SP_TREE_PORT41   Spanning Tree State for Port 41.
 *     SP_TREE_PORT42   Spanning Tree State for Port 42.
 *     SP_TREE_PORT43   Spanning Tree State for Port 43.
 *     SP_TREE_PORT44   Spanning Tree State for Port 44.
 *     SP_TREE_PORT45   Spanning Tree State for Port 45.
 *     SP_TREE_PORT46   Spanning Tree State for Port 46.
 *     SP_TREE_PORT47   Spanning Tree State for Port 47.
 *     SP_TREE_PORT48   Spanning Tree State for Port 48.
 *     SP_TREE_PORT49   Spanning Tree State for Port 49.
 *     SP_TREE_PORT50   Spanning Tree State for Port 50.
 *     SP_TREE_PORT51   Spanning Tree State for Port 51.
 *     SP_TREE_PORT52   Spanning Tree State for Port 52.
 *     SP_TREE_PORT53   Spanning Tree State for Port 53.
 *     SP_TREE_PORT54   Spanning Tree State for Port 54.
 *     SP_TREE_PORT55   Spanning Tree State for Port 55.
 *     SP_TREE_PORT56   Spanning Tree State for Port 56.
 *     SP_TREE_PORT57   Spanning Tree State for Port 57.
 *     SP_TREE_PORT58   Spanning Tree State for Port 58.
 *     SP_TREE_PORT59   Spanning Tree State for Port 59.
 *     SP_TREE_PORT60   Spanning Tree State for Port 60.
 *     SP_TREE_PORT61   Spanning Tree State for Port 61.
 *     SP_TREE_PORT62   Spanning Tree State for Port 62.
 *     SP_TREE_PORT63   Spanning Tree State for Port 63.
 *     SP_TREE_PORT64   Spanning Tree State for Port 64.
 *     SP_TREE_PORT65   Spanning Tree State for Port 65.
 *     EVEN_PARITY      PARITY BIT to make the entry parity even.
 */
#define EGR_VLAN_STGm_MIN 0
#define EGR_VLAN_STGm_MAX 127
#define EGR_VLAN_STGm_CMAX(u) 127
#define EGR_VLAN_STGm_SIZE 17

/*
 * This structure should be used to declare and program EGR_VLAN_STG.
 */
typedef union EGR_VLAN_STGm_s {
	uint32 v[5];
	uint32 egr_vlan_stg[5];
	uint32 _egr_vlan_stg;
} EGR_VLAN_STGm_t;

#define EGR_VLAN_STGm_CLR(r) sal_memset(&((r)._egr_vlan_stg), 0, sizeof(EGR_VLAN_STGm_t))
#define EGR_VLAN_STGm_SET(r,i,d) (r).egr_vlan_stg[i] = d
#define EGR_VLAN_STGm_GET(r,i) (r).egr_vlan_stg[i]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_VLAN_STGm_SP_TREE_PORT0f_GET(r) (((r).egr_vlan_stg[0]) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT0f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EGR_VLAN_STGm_SP_TREE_PORT1f_GET(r) ((((r).egr_vlan_stg[0]) >> 2) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT1f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define EGR_VLAN_STGm_SP_TREE_PORT2f_GET(r) ((((r).egr_vlan_stg[0]) >> 4) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT2f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define EGR_VLAN_STGm_SP_TREE_PORT3f_GET(r) ((((r).egr_vlan_stg[0]) >> 6) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT3f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define EGR_VLAN_STGm_SP_TREE_PORT4f_GET(r) ((((r).egr_vlan_stg[0]) >> 8) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT4f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define EGR_VLAN_STGm_SP_TREE_PORT5f_GET(r) ((((r).egr_vlan_stg[0]) >> 10) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT5f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define EGR_VLAN_STGm_SP_TREE_PORT6f_GET(r) ((((r).egr_vlan_stg[0]) >> 12) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT6f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define EGR_VLAN_STGm_SP_TREE_PORT7f_GET(r) ((((r).egr_vlan_stg[0]) >> 14) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT7f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define EGR_VLAN_STGm_SP_TREE_PORT8f_GET(r) ((((r).egr_vlan_stg[0]) >> 16) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT8f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define EGR_VLAN_STGm_SP_TREE_PORT9f_GET(r) ((((r).egr_vlan_stg[0]) >> 18) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT9f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define EGR_VLAN_STGm_SP_TREE_PORT10f_GET(r) ((((r).egr_vlan_stg[0]) >> 20) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT10f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define EGR_VLAN_STGm_SP_TREE_PORT11f_GET(r) ((((r).egr_vlan_stg[0]) >> 22) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT11f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define EGR_VLAN_STGm_SP_TREE_PORT12f_GET(r) ((((r).egr_vlan_stg[0]) >> 24) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT12f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define EGR_VLAN_STGm_SP_TREE_PORT13f_GET(r) ((((r).egr_vlan_stg[0]) >> 26) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT13f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define EGR_VLAN_STGm_SP_TREE_PORT14f_GET(r) ((((r).egr_vlan_stg[0]) >> 28) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT14f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define EGR_VLAN_STGm_SP_TREE_PORT15f_GET(r) ((((r).egr_vlan_stg[0]) >> 30) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT15f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define EGR_VLAN_STGm_SP_TREE_PORT16f_GET(r) (((r).egr_vlan_stg[1]) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT16f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EGR_VLAN_STGm_SP_TREE_PORT17f_GET(r) ((((r).egr_vlan_stg[1]) >> 2) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT17f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define EGR_VLAN_STGm_SP_TREE_PORT18f_GET(r) ((((r).egr_vlan_stg[1]) >> 4) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT18f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define EGR_VLAN_STGm_SP_TREE_PORT19f_GET(r) ((((r).egr_vlan_stg[1]) >> 6) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT19f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define EGR_VLAN_STGm_SP_TREE_PORT20f_GET(r) ((((r).egr_vlan_stg[1]) >> 8) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT20f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define EGR_VLAN_STGm_SP_TREE_PORT21f_GET(r) ((((r).egr_vlan_stg[1]) >> 10) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT21f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define EGR_VLAN_STGm_SP_TREE_PORT22f_GET(r) ((((r).egr_vlan_stg[1]) >> 12) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT22f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define EGR_VLAN_STGm_SP_TREE_PORT23f_GET(r) ((((r).egr_vlan_stg[1]) >> 14) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT23f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define EGR_VLAN_STGm_SP_TREE_PORT24f_GET(r) ((((r).egr_vlan_stg[1]) >> 16) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT24f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define EGR_VLAN_STGm_SP_TREE_PORT25f_GET(r) ((((r).egr_vlan_stg[1]) >> 18) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT25f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define EGR_VLAN_STGm_SP_TREE_PORT26f_GET(r) ((((r).egr_vlan_stg[1]) >> 20) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT26f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define EGR_VLAN_STGm_SP_TREE_PORT27f_GET(r) ((((r).egr_vlan_stg[1]) >> 22) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT27f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define EGR_VLAN_STGm_SP_TREE_PORT28f_GET(r) ((((r).egr_vlan_stg[1]) >> 24) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT28f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define EGR_VLAN_STGm_SP_TREE_PORT29f_GET(r) ((((r).egr_vlan_stg[1]) >> 26) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT29f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define EGR_VLAN_STGm_SP_TREE_PORT30f_GET(r) ((((r).egr_vlan_stg[1]) >> 28) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT30f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define EGR_VLAN_STGm_SP_TREE_PORT31f_GET(r) ((((r).egr_vlan_stg[1]) >> 30) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT31f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define EGR_VLAN_STGm_SP_TREE_PORT32f_GET(r) (((r).egr_vlan_stg[2]) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT32f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EGR_VLAN_STGm_SP_TREE_PORT33f_GET(r) ((((r).egr_vlan_stg[2]) >> 2) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT33f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define EGR_VLAN_STGm_SP_TREE_PORT34f_GET(r) ((((r).egr_vlan_stg[2]) >> 4) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT34f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define EGR_VLAN_STGm_SP_TREE_PORT35f_GET(r) ((((r).egr_vlan_stg[2]) >> 6) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT35f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define EGR_VLAN_STGm_SP_TREE_PORT36f_GET(r) ((((r).egr_vlan_stg[2]) >> 8) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT36f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define EGR_VLAN_STGm_SP_TREE_PORT37f_GET(r) ((((r).egr_vlan_stg[2]) >> 10) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT37f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define EGR_VLAN_STGm_SP_TREE_PORT38f_GET(r) ((((r).egr_vlan_stg[2]) >> 12) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT38f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define EGR_VLAN_STGm_SP_TREE_PORT39f_GET(r) ((((r).egr_vlan_stg[2]) >> 14) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT39f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define EGR_VLAN_STGm_SP_TREE_PORT40f_GET(r) ((((r).egr_vlan_stg[2]) >> 16) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT40f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define EGR_VLAN_STGm_SP_TREE_PORT41f_GET(r) ((((r).egr_vlan_stg[2]) >> 18) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT41f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define EGR_VLAN_STGm_SP_TREE_PORT42f_GET(r) ((((r).egr_vlan_stg[2]) >> 20) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT42f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define EGR_VLAN_STGm_SP_TREE_PORT43f_GET(r) ((((r).egr_vlan_stg[2]) >> 22) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT43f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define EGR_VLAN_STGm_SP_TREE_PORT44f_GET(r) ((((r).egr_vlan_stg[2]) >> 24) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT44f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define EGR_VLAN_STGm_SP_TREE_PORT45f_GET(r) ((((r).egr_vlan_stg[2]) >> 26) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT45f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define EGR_VLAN_STGm_SP_TREE_PORT46f_GET(r) ((((r).egr_vlan_stg[2]) >> 28) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT46f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define EGR_VLAN_STGm_SP_TREE_PORT47f_GET(r) ((((r).egr_vlan_stg[2]) >> 30) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT47f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define EGR_VLAN_STGm_SP_TREE_PORT48f_GET(r) (((r).egr_vlan_stg[3]) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT48f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EGR_VLAN_STGm_SP_TREE_PORT49f_GET(r) ((((r).egr_vlan_stg[3]) >> 2) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT49f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define EGR_VLAN_STGm_SP_TREE_PORT50f_GET(r) ((((r).egr_vlan_stg[3]) >> 4) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT50f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define EGR_VLAN_STGm_SP_TREE_PORT51f_GET(r) ((((r).egr_vlan_stg[3]) >> 6) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT51f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define EGR_VLAN_STGm_SP_TREE_PORT52f_GET(r) ((((r).egr_vlan_stg[3]) >> 8) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT52f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define EGR_VLAN_STGm_SP_TREE_PORT53f_GET(r) ((((r).egr_vlan_stg[3]) >> 10) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT53f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define EGR_VLAN_STGm_SP_TREE_PORT54f_GET(r) ((((r).egr_vlan_stg[3]) >> 12) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT54f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define EGR_VLAN_STGm_SP_TREE_PORT55f_GET(r) ((((r).egr_vlan_stg[3]) >> 14) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT55f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define EGR_VLAN_STGm_SP_TREE_PORT56f_GET(r) ((((r).egr_vlan_stg[3]) >> 16) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT56f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define EGR_VLAN_STGm_SP_TREE_PORT57f_GET(r) ((((r).egr_vlan_stg[3]) >> 18) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT57f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define EGR_VLAN_STGm_SP_TREE_PORT58f_GET(r) ((((r).egr_vlan_stg[3]) >> 20) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT58f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define EGR_VLAN_STGm_SP_TREE_PORT59f_GET(r) ((((r).egr_vlan_stg[3]) >> 22) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT59f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define EGR_VLAN_STGm_SP_TREE_PORT60f_GET(r) ((((r).egr_vlan_stg[3]) >> 24) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT60f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define EGR_VLAN_STGm_SP_TREE_PORT61f_GET(r) ((((r).egr_vlan_stg[3]) >> 26) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT61f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define EGR_VLAN_STGm_SP_TREE_PORT62f_GET(r) ((((r).egr_vlan_stg[3]) >> 28) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT62f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define EGR_VLAN_STGm_SP_TREE_PORT63f_GET(r) ((((r).egr_vlan_stg[3]) >> 30) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT63f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define EGR_VLAN_STGm_SP_TREE_PORT64f_GET(r) (((r).egr_vlan_stg[4]) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT64f_SET(r,f) (r).egr_vlan_stg[4]=(((r).egr_vlan_stg[4] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EGR_VLAN_STGm_SP_TREE_PORT65f_GET(r) ((((r).egr_vlan_stg[4]) >> 2) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT65f_SET(r,f) (r).egr_vlan_stg[4]=(((r).egr_vlan_stg[4] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define EGR_VLAN_STGm_EVEN_PARITYf_GET(r) ((((r).egr_vlan_stg[4]) >> 4) & 0x1)
#define EGR_VLAN_STGm_EVEN_PARITYf_SET(r,f) (r).egr_vlan_stg[4]=(((r).egr_vlan_stg[4] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))

/*
 * These macros can be used to access EGR_VLAN_STG.
 */
#define WRITE_EGR_VLAN_STGm(u,i,r) bcm5607x_mem_set(u, M_EGR_VLAN_STG(i), &(r._egr_vlan_stg), 5)
#define READ_EGR_VLAN_STGm(u,i,r) bcm5607x_mem_get(u, M_EGR_VLAN_STG(i), &(r._egr_vlan_stg), 5)

/*******************************************************************************
 * End of 'EGR_VLAN_STGm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EMIRROR_CONTROL_HI_64
 * BLOCKS:   IPIPE
 * DESC:     Egress mirror bitmap register: HIGH BITs
 * SIZE:     64
 * FIELDS:
 *     OVER_LO          Used for whole regsiter default value
 *     BITMAP           Egress mirror bitmap
 *     BITMAP_LO        Overlay bitmap
 *     RESERVED         Reserved.
 *     OVER_HI          Used for whole regsiter default value
 */
#define EMIRROR_CONTROL_HI_64r_SIZE 8

/*
 * This structure should be used to declare and program EMIRROR_CONTROL_HI_64.
 */
typedef union EMIRROR_CONTROL_HI_64r_s {
	uint32 v[2];
	uint32 emirror_control_hi_64[2];
	uint32 _emirror_control_hi_64;
} EMIRROR_CONTROL_HI_64r_t;

#define EMIRROR_CONTROL_HI_64r_CLR(r) sal_memset(&((r)._emirror_control_hi_64), 0, sizeof(EMIRROR_CONTROL_HI_64r_t))
#define EMIRROR_CONTROL_HI_64r_SET(r,i,d) (r).emirror_control_hi_64[i] = d
#define EMIRROR_CONTROL_HI_64r_GET(r,i) (r).emirror_control_hi_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define EMIRROR_CONTROL_HI_64r_OVER_LOf_GET(r) ((r).emirror_control_hi_64[0])
#define EMIRROR_CONTROL_HI_64r_OVER_LOf_SET(r,f) (r).emirror_control_hi_64[0]=((uint32)f)
#define EMIRROR_CONTROL_HI_64r_BITMAPf_GET(r) (((r).emirror_control_hi_64[0]) & 0x3)
#define EMIRROR_CONTROL_HI_64r_BITMAPf_SET(r,f) (r).emirror_control_hi_64[0]=(((r).emirror_control_hi_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EMIRROR_CONTROL_HI_64r_BITMAP_LOf_GET(r) (((r).emirror_control_hi_64[0]) & 0x3)
#define EMIRROR_CONTROL_HI_64r_BITMAP_LOf_SET(r,f) (r).emirror_control_hi_64[0]=(((r).emirror_control_hi_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EMIRROR_CONTROL_HI_64r_RESERVEDf_GET(r,a) field_get((r).emirror_control_hi_64,2,63,a)
#define EMIRROR_CONTROL_HI_64r_RESERVEDf_SET(r,a) field_set((r).emirror_control_hi_64,2,63,a)
#define EMIRROR_CONTROL_HI_64r_OVER_HIf_GET(r) ((r).emirror_control_hi_64[1])
#define EMIRROR_CONTROL_HI_64r_OVER_HIf_SET(r,f) (r).emirror_control_hi_64[1]=((uint32)f)

/*
 * These macros can be used to access EMIRROR_CONTROL_HI_64.
 */
#define WRITE_EMIRROR_CONTROL_HI_64r(u,p,r) bcm5607x_reg64_set(u,R_EMIRROR_CONTROL_HI_64(p),&(r._emirror_control_hi_64),2)
#define READ_EMIRROR_CONTROL_HI_64r(u,p,r) bcm5607x_reg64_get(u,R_EMIRROR_CONTROL_HI_64(p),&(r._emirror_control_hi_64),2)

/*******************************************************************************
 * End of 'EMIRROR_CONTROL_HI_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EMIRROR_CONTROL_LO_64
 * BLOCKS:   IPIPE
 * DESC:     Egress mirror bitmap register: LOW BITs
 * SIZE:     64
 * FIELDS:
 *     BITMAP           Egress mirror bitmap
 *     BITMAP_LO        Overlay bitmap
 *     OVER_LO          Used for whole regsiter default value
 *     OVER_HI          Used for whole regsiter default value
 */
#define EMIRROR_CONTROL_LO_64r_SIZE 8

/*
 * This structure should be used to declare and program EMIRROR_CONTROL_LO_64.
 */
typedef union EMIRROR_CONTROL_LO_64r_s {
	uint32 v[2];
	uint32 emirror_control_lo_64[2];
	uint32 _emirror_control_lo_64;
} EMIRROR_CONTROL_LO_64r_t;

#define EMIRROR_CONTROL_LO_64r_CLR(r) sal_memset(&((r)._emirror_control_lo_64), 0, sizeof(EMIRROR_CONTROL_LO_64r_t))
#define EMIRROR_CONTROL_LO_64r_SET(r,i,d) (r).emirror_control_lo_64[i] = d
#define EMIRROR_CONTROL_LO_64r_GET(r,i) (r).emirror_control_lo_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define EMIRROR_CONTROL_LO_64r_BITMAPf_GET(r,a) field_get((r).emirror_control_lo_64,0,63,a)
#define EMIRROR_CONTROL_LO_64r_BITMAPf_SET(r,a) field_set((r).emirror_control_lo_64,0,63,a)
#define EMIRROR_CONTROL_LO_64r_BITMAP_LOf_GET(r,a) field_get((r).emirror_control_lo_64,0,63,a)
#define EMIRROR_CONTROL_LO_64r_BITMAP_LOf_SET(r,a) field_set((r).emirror_control_lo_64,0,63,a)
#define EMIRROR_CONTROL_LO_64r_OVER_LOf_GET(r) ((r).emirror_control_lo_64[0])
#define EMIRROR_CONTROL_LO_64r_OVER_LOf_SET(r,f) (r).emirror_control_lo_64[0]=((uint32)f)
#define EMIRROR_CONTROL_LO_64r_OVER_HIf_GET(r) ((r).emirror_control_lo_64[1])
#define EMIRROR_CONTROL_LO_64r_OVER_HIf_SET(r,f) (r).emirror_control_lo_64[1]=((uint32)f)

/*
 * These macros can be used to access EMIRROR_CONTROL_LO_64.
 */
#define WRITE_EMIRROR_CONTROL_LO_64r(u,p,r) bcm5607x_reg64_set(u,R_EMIRROR_CONTROL_LO_64(p),&(r._emirror_control_lo_64),2)
#define READ_EMIRROR_CONTROL_LO_64r(u,p,r) bcm5607x_reg64_get(u,R_EMIRROR_CONTROL_LO_64(p),&(r._emirror_control_lo_64),2)

/*******************************************************************************
 * End of 'EMIRROR_CONTROL_LO_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  EM_MTP_INDEX
 * BLOCKS:   IPIPE
 * DESC:     Egress Mirror to Port Table
This index into this table is taken from MIRROR_CONTROL.EM_MTP_INDEX
 * SIZE:     16
 * FIELDS:
 *     PORT_NUM         Port if T==0
 *     TGID             Trunk ID value if T==1
 *     MODULE_ID        Module ID if T==0
 *     T                Trunked port (LAG) indication
 */
#define EM_MTP_INDEXm_MIN 0
#define EM_MTP_INDEXm_MAX 3
#define EM_MTP_INDEXm_CMAX(u) 3
#define EM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program EM_MTP_INDEX.
 */
typedef union EM_MTP_INDEXm_s {
	uint32 v[1];
	uint32 em_mtp_index[1];
	uint32 _em_mtp_index;
} EM_MTP_INDEXm_t;

#define EM_MTP_INDEXm_CLR(r) (r).em_mtp_index[0] = 0
#define EM_MTP_INDEXm_SET(r,d) (r).em_mtp_index[0] = d
#define EM_MTP_INDEXm_GET(r) (r).em_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 */
#define EM_MTP_INDEXm_PORT_NUMf_GET(r) (((r).em_mtp_index[0]) & 0x7f)
#define EM_MTP_INDEXm_PORT_NUMf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define EM_MTP_INDEXm_TGIDf_GET(r) (((r).em_mtp_index[0]) & 0x7f)
#define EM_MTP_INDEXm_TGIDf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define EM_MTP_INDEXm_MODULE_IDf_GET(r) ((((r).em_mtp_index[0]) >> 7) & 0xff)
#define EM_MTP_INDEXm_MODULE_IDf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define EM_MTP_INDEXm_Tf_GET(r) ((((r).em_mtp_index[0]) >> 15) & 0x1)
#define EM_MTP_INDEXm_Tf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))

/*
 * These macros can be used to access EM_MTP_INDEX.
 */
#define WRITE_EM_MTP_INDEXm(u,i,r) bcm5607x_mem_set(u, M_EM_MTP_INDEX(i), &(r._em_mtp_index), 1)
#define READ_EM_MTP_INDEXm(u,i,r) bcm5607x_mem_get(u, M_EM_MTP_INDEX(i), &(r._em_mtp_index), 1)

/*******************************************************************************
 * End of 'EM_MTP_INDEXm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EPC_LINK_BMAP_HI_64
 * BLOCKS:   IPIPE
 * DESC:     Link status register under software control HIGH BITs
 * SIZE:     64
 * FIELDS:
 *     PORT_BITMAP      Link status bitmap 
 *     PORT_BITMAP_LO   Overlay bitmap for ports
 *     RESERVED         Reserved.
 */
#define EPC_LINK_BMAP_HI_64r_SIZE 8

/*
 * This structure should be used to declare and program EPC_LINK_BMAP_HI_64.
 */
typedef union EPC_LINK_BMAP_HI_64r_s {
	uint32 v[2];
	uint32 epc_link_bmap_hi_64[2];
	uint32 _epc_link_bmap_hi_64;
} EPC_LINK_BMAP_HI_64r_t;

#define EPC_LINK_BMAP_HI_64r_CLR(r) sal_memset(&((r)._epc_link_bmap_hi_64), 0, sizeof(EPC_LINK_BMAP_HI_64r_t))
#define EPC_LINK_BMAP_HI_64r_SET(r,i,d) (r).epc_link_bmap_hi_64[i] = d
#define EPC_LINK_BMAP_HI_64r_GET(r,i) (r).epc_link_bmap_hi_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define EPC_LINK_BMAP_HI_64r_PORT_BITMAPf_GET(r) (((r).epc_link_bmap_hi_64[0]) & 0x3)
#define EPC_LINK_BMAP_HI_64r_PORT_BITMAPf_SET(r,f) (r).epc_link_bmap_hi_64[0]=(((r).epc_link_bmap_hi_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EPC_LINK_BMAP_HI_64r_PORT_BITMAP_LOf_GET(r) (((r).epc_link_bmap_hi_64[0]) & 0x3)
#define EPC_LINK_BMAP_HI_64r_PORT_BITMAP_LOf_SET(r,f) (r).epc_link_bmap_hi_64[0]=(((r).epc_link_bmap_hi_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EPC_LINK_BMAP_HI_64r_RESERVEDf_GET(r,a) field_get((r).epc_link_bmap_hi_64,2,63,a)
#define EPC_LINK_BMAP_HI_64r_RESERVEDf_SET(r,a) field_set((r).epc_link_bmap_hi_64,2,63,a)

/*
 * These macros can be used to access EPC_LINK_BMAP_HI_64.
 */
#define WRITE_EPC_LINK_BMAP_HI_64r(u,r) bcm5607x_reg64_set(u,R_EPC_LINK_BMAP_HI_64,&(r._epc_link_bmap_hi_64),2)
#define READ_EPC_LINK_BMAP_HI_64r(u,r) bcm5607x_reg64_get(u,R_EPC_LINK_BMAP_HI_64,&(r._epc_link_bmap_hi_64),2)

/*******************************************************************************
 * End of 'EPC_LINK_BMAP_HI_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  EPC_LINK_BMAP_LO_64
 * BLOCKS:   IPIPE
 * DESC:     Link status register under software control LOW BITs
 * SIZE:     64
 * FIELDS:
 *     PORT_BITMAP      Link status bitmap 
 *     PORT_BITMAP_LO   Overlay bitmap for ports
 */
#define EPC_LINK_BMAP_LO_64r_SIZE 8

/*
 * This structure should be used to declare and program EPC_LINK_BMAP_LO_64.
 */
typedef union EPC_LINK_BMAP_LO_64r_s {
	uint32 v[2];
	uint32 epc_link_bmap_lo_64[2];
	uint32 _epc_link_bmap_lo_64;
} EPC_LINK_BMAP_LO_64r_t;

#define EPC_LINK_BMAP_LO_64r_CLR(r) sal_memset(&((r)._epc_link_bmap_lo_64), 0, sizeof(EPC_LINK_BMAP_LO_64r_t))
#define EPC_LINK_BMAP_LO_64r_SET(r,i,d) (r).epc_link_bmap_lo_64[i] = d
#define EPC_LINK_BMAP_LO_64r_GET(r,i) (r).epc_link_bmap_lo_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define EPC_LINK_BMAP_LO_64r_PORT_BITMAPf_GET(r,a) field_get((r).epc_link_bmap_lo_64,0,63,a)
#define EPC_LINK_BMAP_LO_64r_PORT_BITMAPf_SET(r,a) field_set((r).epc_link_bmap_lo_64,0,63,a)
#define EPC_LINK_BMAP_LO_64r_PORT_BITMAP_LOf_GET(r,a) field_get((r).epc_link_bmap_lo_64,0,63,a)
#define EPC_LINK_BMAP_LO_64r_PORT_BITMAP_LOf_SET(r,a) field_set((r).epc_link_bmap_lo_64,0,63,a)

/*
 * These macros can be used to access EPC_LINK_BMAP_LO_64.
 */
#define WRITE_EPC_LINK_BMAP_LO_64r(u,r) bcm5607x_reg64_set(u,R_EPC_LINK_BMAP_LO_64,&(r._epc_link_bmap_lo_64),2)
#define READ_EPC_LINK_BMAP_LO_64r(u,r) bcm5607x_reg64_get(u,R_EPC_LINK_BMAP_LO_64,&(r._epc_link_bmap_lo_64),2)

/*******************************************************************************
 * End of 'EPC_LINK_BMAP_LO_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * SWFORMAT:  EP_TO_CPU_HEADER
 * BLOCKS:  
 * DESC:     Egress Pipeline to CMIC/CPU HDR format.
 * SIZE:     448
 * FIELDS:
 *     PADDED           4 byte padding to make it 56 bytes
 *     TIMESTAMP_UPPER  Carries the MSB 32bits of the DM-TIMESTAMP for an OAM-DM packet  
 *     INCOMING_TAG_STATUS Indicates the incoming tag status, PBE field: 0 = untagged, 1 = single inner-tag, 2 = single outer-tag, 3 = double tagged.
 *     ING_OTAG_ACTION  Indicates ingress outer VLAN tag action, PBE field: 0 = do not modify, 1 = add O-VID, 2 = replace O-VID, <3 = reserved>
 *     ING_ITAG_ACTION  Indicates ingress inner VLAN tag action, PBE field: 0 = do not modify, 1 = add I-VID, 2 = replace I-VID, 3 = remove I-VID
 *     SD_TAG_PRESENT   Indicates there is an SD tag in the packet
 *     SWITCH           flag to indicate this is a switched packet as opposed to a mirrored packet, PBE field
 *     PKT_HIGIG_LOOKUP 
 *     SRC_HIGIG_TYPE   If set  then source port is Higig2, else Higig+. Valid only if SRC_HG is set, PBE field
 *     SRC_HIGIG        Source is Higig, PBE field
 *     IP_ROUTED        Indicates packet was routed - UC OR MC
 *     L3ONLY           L3 IP Multicast Packet Flag, PBE field
 *     VNTAG_ACTION     New field for VNTAG/ETAGs:                         00: Do not Modify                        01: Add/Replace incoming VNTAG with Ingress Port Based VNTAG                        10: Add/Replace incoming ETAG with Ingress Port Based ETAG.                        11: Delete Packets VNTAG/ETAG
 *     SPECIAL_PACKET_INDICATOR OAM or BFD PACKET INDICATOR.Is called SPECIAL_PACKET_INDICATOR in TR3
 *     DO_NOT_CHANGE_TTL This should be the final control in the EP indicating to not change the TTL, from any source.
 *     BPDU             BPDU Packet, PBE field
 *     TIMESTAMP_TYPE   "0"=> Invalid."3" => 802.1AS timestamp in the TIMESTAMP field. "1" => TIMESTAMP field carries the LM packet-count for an OAM LMM packet. "2" => {TIMESTAMP_UPPER,TIMESTAMP} fields carry the 64-bit DM Time-stamp for an OAM DMM packet.
 *     COS              Port queue number for regular ethernet ports.
 *     IM_MTP_INDEX     IM Mirror-to-Port Index, PBE field
 *     ECN              New ECN value provided by the IFP.
 *     CHANGE_ECN       Change the ECN as indicated by the IFP.
 *     TIMESTAMP        If TIMESTAMP_TYPE=3, then this field carries the 32-bit 802.1AS timestamp. If TIMESTAMP_TPYE=1, then this field carried the 32-bit LM packet-count for an OAM-LMM packet.
 *     DSCP             New DSCP value computed by the chip (EP) for the packet
 *     CHANGE_DSCP      Set to 1 if the DSCP value has been changed by the EP
 *     IMIRROR          Ingress Mirroring, PBE field
 *     EMIRROR          Egress Mirroring, PBE field
 *     OUTER_CFI        CFI which was constructed in EP based on CNG mapping, after the hcpm stage of EP.
 *     OUTER_PRI        Outer Priority after the hcpm stage of the EP.
 *     HG_COS           Reserved.Port queue number for ports in higig stacking mode.Doesnt exist for Hurricane
 *     VFI_4_0          bit 4 to bit 0 of 12 bits VFI value.
 *     INNER_VID        THE FINAL VERSION
 *     INNER_CFI        THE FINAL VERSION
 *     REPLICATION      Indicates the packet is generated as a result of packet replication
 *     INNER_PRI        THE FINAL VERSION
 *     REPLICATION_OR_NHOP_INDEX 2 bits of reserved and 14 bits of REPLICATION_OR_NHOP_INDEX
 *     RESERVED_147     Reserved.
 *     VFI_VALID        Validates VFI field
 *     EM_MTP_INDEX     EM Mirror-to-Port Index, PBE field
 *     SPECIAL_PACKET_TYPE NEW OAM PACKET INDICATOR
 *     SRC_PORT_NUM     Source Port Number, PBE field
 *     PKT_LENGTH       Packet length after all modification
 *     MATCHED_RULE     Matched Rule, PBE field.For EP-COPY-TO-CPU pkt, this will be EFP_MATCHED_RULE.
 *     HGI              Valid only for packets which came in on Higig+ source port. Higig+ module header field, PBE field
 *     CPU_COS          Queue number used in MMU for cpu port, PBE field.For EP-COPY-TO-CPU pkt, this value will come from EP-REDIR-BUS.
 *     REGEN_CRC        If set, then packet has been modified by the EP and CRC needs to be regenerated
 *     VFI_9_5          bit 9 to bit 5 of 12 bits VFI value.
 *     VLAN_COS         Reserved.Port queue number for ports in VLAN shaping mode.Doesnt exist for Hurricane
 *     SHAPING_COS_SEL  Indicates which COS value should be used for MMU bandwidth shaping - specifies the queue number that was used on this port for this packet.  0=COS, 1=CPU_COS, 2=HG_COS, 3=VLAN_COS.HG_COS,VLAN_COS donot exist for Hurricane.
 *     VFI_11_10        bit 11 to bit 10 of 12 bits VFI value.
 *     CPU_OPCODE_TYPE  Always set to 0 for HR2
 *     OUTER_VID        VID value after the hcpm stage of EP.
 *     MODULE_HDR_3     Module Header information to the CPU port.
 *     MODULE_HDR_2     Module Header information to the CPU port.
 *     MODULE_HDR_1     Module Header information to the CPU port.
 *     MODULE_HDR_0     Module Header information to the CPU port.
 */
#define EP_TO_CPU_HEADER_SIZE 56

/*
 * This structure should be used to declare and program EP_TO_CPU_HEADER.
 */
typedef union EP_TO_CPU_HEADER_s {
	uint32 v[14];
	uint32 ep_to_cpu_header[14];
	uint32 _ep_to_cpu_header;
} EP_TO_CPU_HEADER_t;

#define EP_TO_CPU_HEADER_CLR(r) sal_memset(&((r)._ep_to_cpu_header), 0, sizeof(EP_TO_CPU_HEADER_t))
#define EP_TO_CPU_HEADER_SET(r,i,d) (r).ep_to_cpu_header[i] = d
#define EP_TO_CPU_HEADER_GET(r,i) (r).ep_to_cpu_header[i]

/*
 * These macros can be used to access individual fields.
 */
#define EP_TO_CPU_HEADER_PADDEDf_GET(r) ((r).ep_to_cpu_header[13])
#define EP_TO_CPU_HEADER_PADDEDf_SET(r,f) (r).ep_to_cpu_header[13]=((uint32)f)
#define EP_TO_CPU_HEADER_TIMESTAMP_UPPERf_GET(r) ((r).ep_to_cpu_header[12])
#define EP_TO_CPU_HEADER_TIMESTAMP_UPPERf_SET(r,f) (r).ep_to_cpu_header[12]=((uint32)f)
#define EP_TO_CPU_HEADER_INCOMING_TAG_STATUSf_GET(r) (((r).ep_to_cpu_header[11]) & 0x3)
#define EP_TO_CPU_HEADER_INCOMING_TAG_STATUSf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EP_TO_CPU_HEADER_ING_OTAG_ACTIONf_GET(r) ((((r).ep_to_cpu_header[11]) >> 2) & 0x3)
#define EP_TO_CPU_HEADER_ING_OTAG_ACTIONf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define EP_TO_CPU_HEADER_ING_ITAG_ACTIONf_GET(r) ((((r).ep_to_cpu_header[11]) >> 4) & 0x3)
#define EP_TO_CPU_HEADER_ING_ITAG_ACTIONf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define EP_TO_CPU_HEADER_SD_TAG_PRESENTf_GET(r) ((((r).ep_to_cpu_header[11]) >> 6) & 0x1)
#define EP_TO_CPU_HEADER_SD_TAG_PRESENTf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define EP_TO_CPU_HEADER_SWITCHf_GET(r) ((((r).ep_to_cpu_header[11]) >> 7) & 0x1)
#define EP_TO_CPU_HEADER_SWITCHf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define EP_TO_CPU_HEADER_PKT_HIGIG_LOOKUPf_GET(r) ((((r).ep_to_cpu_header[11]) >> 8) & 0x1)
#define EP_TO_CPU_HEADER_PKT_HIGIG_LOOKUPf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define EP_TO_CPU_HEADER_SRC_HIGIG_TYPEf_GET(r) ((((r).ep_to_cpu_header[11]) >> 9) & 0x1)
#define EP_TO_CPU_HEADER_SRC_HIGIG_TYPEf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define EP_TO_CPU_HEADER_SRC_HIGIGf_GET(r) ((((r).ep_to_cpu_header[11]) >> 10) & 0x1)
#define EP_TO_CPU_HEADER_SRC_HIGIGf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define EP_TO_CPU_HEADER_IP_ROUTEDf_GET(r) ((((r).ep_to_cpu_header[11]) >> 11) & 0x1)
#define EP_TO_CPU_HEADER_IP_ROUTEDf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define EP_TO_CPU_HEADER_L3ONLYf_GET(r) ((((r).ep_to_cpu_header[11]) >> 12) & 0x1)
#define EP_TO_CPU_HEADER_L3ONLYf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define EP_TO_CPU_HEADER_VNTAG_ACTIONf_GET(r) ((((r).ep_to_cpu_header[11]) >> 13) & 0x3)
#define EP_TO_CPU_HEADER_VNTAG_ACTIONf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define EP_TO_CPU_HEADER_SPECIAL_PACKET_INDICATORf_GET(r) ((((r).ep_to_cpu_header[11]) >> 15) & 0x1)
#define EP_TO_CPU_HEADER_SPECIAL_PACKET_INDICATORf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define EP_TO_CPU_HEADER_DO_NOT_CHANGE_TTLf_GET(r) ((((r).ep_to_cpu_header[11]) >> 16) & 0x1)
#define EP_TO_CPU_HEADER_DO_NOT_CHANGE_TTLf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define EP_TO_CPU_HEADER_BPDUf_GET(r) ((((r).ep_to_cpu_header[11]) >> 17) & 0x1)
#define EP_TO_CPU_HEADER_BPDUf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define EP_TO_CPU_HEADER_TIMESTAMP_TYPEf_GET(r) ((((r).ep_to_cpu_header[11]) >> 18) & 0x3)
#define EP_TO_CPU_HEADER_TIMESTAMP_TYPEf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define EP_TO_CPU_HEADER_COSf_GET(r) ((((r).ep_to_cpu_header[11]) >> 20) & 0xf)
#define EP_TO_CPU_HEADER_COSf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define EP_TO_CPU_HEADER_IM_MTP_INDEXf_GET(r) ((((r).ep_to_cpu_header[11]) >> 24) & 0x1f)
#define EP_TO_CPU_HEADER_IM_MTP_INDEXf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x1f << 24)) | ((((uint32)f) & 0x1f) << 24))
#define EP_TO_CPU_HEADER_ECNf_GET(r) ((((r).ep_to_cpu_header[11]) >> 29) & 0x3)
#define EP_TO_CPU_HEADER_ECNf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x3 << 29)) | ((((uint32)f) & 0x3) << 29))
#define EP_TO_CPU_HEADER_CHANGE_ECNf_GET(r) ((((r).ep_to_cpu_header[11]) >> 31) & 0x1)
#define EP_TO_CPU_HEADER_CHANGE_ECNf_SET(r,f) (r).ep_to_cpu_header[11]=(((r).ep_to_cpu_header[11] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define EP_TO_CPU_HEADER_TIMESTAMPf_GET(r) ((r).ep_to_cpu_header[10])
#define EP_TO_CPU_HEADER_TIMESTAMPf_SET(r,f) (r).ep_to_cpu_header[10]=((uint32)f)
#define EP_TO_CPU_HEADER_DSCPf_GET(r) (((r).ep_to_cpu_header[9]) & 0x3f)
#define EP_TO_CPU_HEADER_DSCPf_SET(r,f) (r).ep_to_cpu_header[9]=(((r).ep_to_cpu_header[9] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define EP_TO_CPU_HEADER_CHANGE_DSCPf_GET(r) ((((r).ep_to_cpu_header[9]) >> 6) & 0x1)
#define EP_TO_CPU_HEADER_CHANGE_DSCPf_SET(r,f) (r).ep_to_cpu_header[9]=(((r).ep_to_cpu_header[9] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define EP_TO_CPU_HEADER_IMIRRORf_GET(r) ((((r).ep_to_cpu_header[9]) >> 7) & 0x1)
#define EP_TO_CPU_HEADER_IMIRRORf_SET(r,f) (r).ep_to_cpu_header[9]=(((r).ep_to_cpu_header[9] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define EP_TO_CPU_HEADER_EMIRRORf_GET(r) ((((r).ep_to_cpu_header[9]) >> 8) & 0x1)
#define EP_TO_CPU_HEADER_EMIRRORf_SET(r,f) (r).ep_to_cpu_header[9]=(((r).ep_to_cpu_header[9] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define EP_TO_CPU_HEADER_OUTER_CFIf_GET(r) ((((r).ep_to_cpu_header[9]) >> 9) & 0x1)
#define EP_TO_CPU_HEADER_OUTER_CFIf_SET(r,f) (r).ep_to_cpu_header[9]=(((r).ep_to_cpu_header[9] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define EP_TO_CPU_HEADER_OUTER_PRIf_GET(r) ((((r).ep_to_cpu_header[9]) >> 10) & 0x7)
#define EP_TO_CPU_HEADER_OUTER_PRIf_SET(r,f) (r).ep_to_cpu_header[9]=(((r).ep_to_cpu_header[9] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define EP_TO_CPU_HEADER_HG_COSf_GET(r) ((((r).ep_to_cpu_header[9]) >> 13) & 0x1f)
#define EP_TO_CPU_HEADER_HG_COSf_SET(r,f) (r).ep_to_cpu_header[9]=(((r).ep_to_cpu_header[9] & ~((uint32)0x1f << 13)) | ((((uint32)f) & 0x1f) << 13))
#define EP_TO_CPU_HEADER_VFI_4_0f_GET(r) ((((r).ep_to_cpu_header[9]) >> 13) & 0x1f)
#define EP_TO_CPU_HEADER_VFI_4_0f_SET(r,f) (r).ep_to_cpu_header[9]=(((r).ep_to_cpu_header[9] & ~((uint32)0x1f << 13)) | ((((uint32)f) & 0x1f) << 13))
#define EP_TO_CPU_HEADER_INNER_VIDf_GET(r) ((((r).ep_to_cpu_header[9]) >> 18) & 0xfff)
#define EP_TO_CPU_HEADER_INNER_VIDf_SET(r,f) (r).ep_to_cpu_header[9]=(((r).ep_to_cpu_header[9] & ~((uint32)0xfff << 18)) | ((((uint32)f) & 0xfff) << 18))
#define EP_TO_CPU_HEADER_INNER_CFIf_GET(r) ((((r).ep_to_cpu_header[9]) >> 30) & 0x1)
#define EP_TO_CPU_HEADER_INNER_CFIf_SET(r,f) (r).ep_to_cpu_header[9]=(((r).ep_to_cpu_header[9] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define EP_TO_CPU_HEADER_REPLICATIONf_GET(r) ((((r).ep_to_cpu_header[9]) >> 31) & 0x1)
#define EP_TO_CPU_HEADER_REPLICATIONf_SET(r,f) (r).ep_to_cpu_header[9]=(((r).ep_to_cpu_header[9] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define EP_TO_CPU_HEADER_INNER_PRIf_GET(r) (((r).ep_to_cpu_header[8]) & 0x7)
#define EP_TO_CPU_HEADER_INNER_PRIf_SET(r,f) (r).ep_to_cpu_header[8]=(((r).ep_to_cpu_header[8] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define EP_TO_CPU_HEADER_REPLICATION_OR_NHOP_INDEXf_GET(r) ((((r).ep_to_cpu_header[8]) >> 3) & 0xffff)
#define EP_TO_CPU_HEADER_REPLICATION_OR_NHOP_INDEXf_SET(r,f) (r).ep_to_cpu_header[8]=(((r).ep_to_cpu_header[8] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define EP_TO_CPU_HEADER_RESERVED_147f_GET(r) ((((r).ep_to_cpu_header[8]) >> 19) & 0xf)
#define EP_TO_CPU_HEADER_RESERVED_147f_SET(r,f) (r).ep_to_cpu_header[8]=(((r).ep_to_cpu_header[8] & ~((uint32)0xf << 19)) | ((((uint32)f) & 0xf) << 19))
#define EP_TO_CPU_HEADER_VFI_VALIDf_GET(r) ((((r).ep_to_cpu_header[8]) >> 23) & 0x1)
#define EP_TO_CPU_HEADER_VFI_VALIDf_SET(r,f) (r).ep_to_cpu_header[8]=(((r).ep_to_cpu_header[8] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define EP_TO_CPU_HEADER_EM_MTP_INDEXf_GET(r) ((((r).ep_to_cpu_header[8]) >> 24) & 0x1f)
#define EP_TO_CPU_HEADER_EM_MTP_INDEXf_SET(r,f) (r).ep_to_cpu_header[8]=(((r).ep_to_cpu_header[8] & ~((uint32)0x1f << 24)) | ((((uint32)f) & 0x1f) << 24))
#define EP_TO_CPU_HEADER_SPECIAL_PACKET_TYPEf_GET(r) ((((r).ep_to_cpu_header[8]) >> 29) & 0x7)
#define EP_TO_CPU_HEADER_SPECIAL_PACKET_TYPEf_SET(r,f) (r).ep_to_cpu_header[8]=(((r).ep_to_cpu_header[8] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))
#define EP_TO_CPU_HEADER_SRC_PORT_NUMf_GET(r) (((r).ep_to_cpu_header[7]) & 0xff)
#define EP_TO_CPU_HEADER_SRC_PORT_NUMf_SET(r,f) (r).ep_to_cpu_header[7]=(((r).ep_to_cpu_header[7] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define EP_TO_CPU_HEADER_PKT_LENGTHf_GET(r) ((((r).ep_to_cpu_header[7]) >> 8) & 0x3fff)
#define EP_TO_CPU_HEADER_PKT_LENGTHf_SET(r,f) (r).ep_to_cpu_header[7]=(((r).ep_to_cpu_header[7] & ~((uint32)0x3fff << 8)) | ((((uint32)f) & 0x3fff) << 8))
#define EP_TO_CPU_HEADER_MATCHED_RULEf_GET(r) ((((r).ep_to_cpu_header[7]) >> 22) & 0xff)
#define EP_TO_CPU_HEADER_MATCHED_RULEf_SET(r,f) (r).ep_to_cpu_header[7]=(((r).ep_to_cpu_header[7] & ~((uint32)0xff << 22)) | ((((uint32)f) & 0xff) << 22))
#define EP_TO_CPU_HEADER_HGIf_GET(r) ((((r).ep_to_cpu_header[7]) >> 30) & 0x3)
#define EP_TO_CPU_HEADER_HGIf_SET(r,f) (r).ep_to_cpu_header[7]=(((r).ep_to_cpu_header[7] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define EP_TO_CPU_HEADER_CPU_COSf_GET(r) (((r).ep_to_cpu_header[6]) & 0x3f)
#define EP_TO_CPU_HEADER_CPU_COSf_SET(r,f) (r).ep_to_cpu_header[6]=(((r).ep_to_cpu_header[6] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define EP_TO_CPU_HEADER_REGEN_CRCf_GET(r) ((((r).ep_to_cpu_header[6]) >> 6) & 0x1)
#define EP_TO_CPU_HEADER_REGEN_CRCf_SET(r,f) (r).ep_to_cpu_header[6]=(((r).ep_to_cpu_header[6] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define EP_TO_CPU_HEADER_VFI_9_5f_GET(r) ((((r).ep_to_cpu_header[6]) >> 7) & 0x1f)
#define EP_TO_CPU_HEADER_VFI_9_5f_SET(r,f) (r).ep_to_cpu_header[6]=(((r).ep_to_cpu_header[6] & ~((uint32)0x1f << 7)) | ((((uint32)f) & 0x1f) << 7))
#define EP_TO_CPU_HEADER_VLAN_COSf_GET(r) ((((r).ep_to_cpu_header[6]) >> 7) & 0x1f)
#define EP_TO_CPU_HEADER_VLAN_COSf_SET(r,f) (r).ep_to_cpu_header[6]=(((r).ep_to_cpu_header[6] & ~((uint32)0x1f << 7)) | ((((uint32)f) & 0x1f) << 7))
#define EP_TO_CPU_HEADER_SHAPING_COS_SELf_GET(r) ((((r).ep_to_cpu_header[6]) >> 12) & 0x3)
#define EP_TO_CPU_HEADER_SHAPING_COS_SELf_SET(r,f) (r).ep_to_cpu_header[6]=(((r).ep_to_cpu_header[6] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define EP_TO_CPU_HEADER_VFI_11_10f_GET(r) ((((r).ep_to_cpu_header[6]) >> 14) & 0x3)
#define EP_TO_CPU_HEADER_VFI_11_10f_SET(r,f) (r).ep_to_cpu_header[6]=(((r).ep_to_cpu_header[6] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define EP_TO_CPU_HEADER_CPU_OPCODE_TYPEf_GET(r) ((((r).ep_to_cpu_header[6]) >> 16) & 0xf)
#define EP_TO_CPU_HEADER_CPU_OPCODE_TYPEf_SET(r,f) (r).ep_to_cpu_header[6]=(((r).ep_to_cpu_header[6] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define EP_TO_CPU_HEADER_OUTER_VIDf_GET(r) ((((r).ep_to_cpu_header[6]) >> 20) & 0xfff)
#define EP_TO_CPU_HEADER_OUTER_VIDf_SET(r,f) (r).ep_to_cpu_header[6]=(((r).ep_to_cpu_header[6] & ~((uint32)0xfff << 20)) | ((((uint32)f) & 0xfff) << 20))
#define EP_TO_CPU_HEADER_MODULE_HDR_3f_GET(r) ((r).ep_to_cpu_header[3])
#define EP_TO_CPU_HEADER_MODULE_HDR_3f_SET(r,f) (r).ep_to_cpu_header[3]=((uint32)f)
#define EP_TO_CPU_HEADER_MODULE_HDR_2f_GET(r) ((r).ep_to_cpu_header[2])
#define EP_TO_CPU_HEADER_MODULE_HDR_2f_SET(r,f) (r).ep_to_cpu_header[2]=((uint32)f)
#define EP_TO_CPU_HEADER_MODULE_HDR_1f_GET(r) ((r).ep_to_cpu_header[1])
#define EP_TO_CPU_HEADER_MODULE_HDR_1f_SET(r,f) (r).ep_to_cpu_header[1]=((uint32)f)
#define EP_TO_CPU_HEADER_MODULE_HDR_0f_GET(r) ((r).ep_to_cpu_header[0])
#define EP_TO_CPU_HEADER_MODULE_HDR_0f_SET(r,f) (r).ep_to_cpu_header[0]=((uint32)f)

/*******************************************************************************
 * End of 'EP_TO_CPU_HEADER'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  FLUSH_CONTROL
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Flush enable control register
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Flush enable bit to drop out all packets in Tx FIFO without egressing any packets when set.
 */
#define FLUSH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program FLUSH_CONTROL.
 */
typedef union FLUSH_CONTROLr_s {
	uint32 v[1];
	uint32 flush_control[1];
	uint32 _flush_control;
} FLUSH_CONTROLr_t;

#define FLUSH_CONTROLr_CLR(r) (r).flush_control[0] = 0
#define FLUSH_CONTROLr_SET(r,d) (r).flush_control[0] = d
#define FLUSH_CONTROLr_GET(r) (r).flush_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define FLUSH_CONTROLr_FLUSHf_GET(r) (((r).flush_control[0]) & 0x1)
#define FLUSH_CONTROLr_FLUSHf_SET(r,f) (r).flush_control[0]=(((r).flush_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access FLUSH_CONTROL.
 */
#define WRITE_FLUSH_CONTROLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_FLUSH_CONTROL(bcm5607x_gport_lport_to_index_in_block[p]), (r._flush_control))
#define READ_FLUSH_CONTROLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_FLUSH_CONTROL(bcm5607x_gport_lport_to_index_in_block[p]), &(r._flush_control))

/*******************************************************************************
 * End of 'FLUSH_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  FP_COUNTER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     COUNTER TABLE FOR THE FP, FeatureSpecific-FP
 * SIZE:     66
 * FIELDS:
 *     PACKET_COUNTER   Packet Counter
 *     BYTE_COUNTER     Byte Counter
 *     RESERVED         Reserved
 *     EVEN_PARITY      Even parity.
 */
#define FP_COUNTER_TABLEm_MIN 0
#define FP_COUNTER_TABLEm_MAX 1023
#define FP_COUNTER_TABLEm_CMAX(u) 1023
#define FP_COUNTER_TABLEm_SIZE 9

/*
 * This structure should be used to declare and program FP_COUNTER_TABLE.
 */
typedef union FP_COUNTER_TABLEm_s {
	uint32 v[3];
	uint32 fp_counter_table[3];
	uint32 _fp_counter_table;
} FP_COUNTER_TABLEm_t;

#define FP_COUNTER_TABLEm_CLR(r) sal_memset(&((r)._fp_counter_table), 0, sizeof(FP_COUNTER_TABLEm_t))
#define FP_COUNTER_TABLEm_SET(r,i,d) (r).fp_counter_table[i] = d
#define FP_COUNTER_TABLEm_GET(r,i) (r).fp_counter_table[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_COUNTER_TABLEm_PACKET_COUNTERf_GET(r) (((r).fp_counter_table[0]) & 0x1fffffff)
#define FP_COUNTER_TABLEm_PACKET_COUNTERf_SET(r,f) (r).fp_counter_table[0]=(((r).fp_counter_table[0] & ~((uint32)0x1fffffff)) | (((uint32)f) & 0x1fffffff))
#define FP_COUNTER_TABLEm_BYTE_COUNTERf_GET(r,a) field_get((r).fp_counter_table,29,63,a)
#define FP_COUNTER_TABLEm_BYTE_COUNTERf_SET(r,a) field_set((r).fp_counter_table,29,63,a)
#define FP_COUNTER_TABLEm_RESERVEDf_GET(r) (((r).fp_counter_table[2]) & 0x1)
#define FP_COUNTER_TABLEm_RESERVEDf_SET(r,f) (r).fp_counter_table[2]=(((r).fp_counter_table[2] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define FP_COUNTER_TABLEm_EVEN_PARITYf_GET(r) ((((r).fp_counter_table[2]) >> 1) & 0x1)
#define FP_COUNTER_TABLEm_EVEN_PARITYf_SET(r,f) (r).fp_counter_table[2]=(((r).fp_counter_table[2] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access FP_COUNTER_TABLE.
 */
#define WRITE_FP_COUNTER_TABLEm(u,i,r) bcm5607x_mem_set(u, M_FP_COUNTER_TABLE(i), &(r._fp_counter_table), 3)
#define READ_FP_COUNTER_TABLEm(u,i,r) bcm5607x_mem_get(u, M_FP_COUNTER_TABLE(i), &(r._fp_counter_table), 3)

/*******************************************************************************
 * End of 'FP_COUNTER_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  FP_GLOBAL_MASK_TCAM
 * BLOCKS:   IPIPE
 * DESC:     PORT BITMAP TCAM ENTRY FOR EACH IFP_TCAM ENTRY.
 * SIZE:     133
 * FIELDS:
 *     VALID            VALID BIT
 *     FULL_KEY         Field created for sbus access to the entire key portion of the TCAM
 *     IPBM             1 bit for each port in the port bit map 
 *     KEY              Field created for sbus access to the entire key portion of the TCAM
 *     DGLP             DGLP 
 *     DW_IPBM_F0_DGLP  DGLP 
 *     DW_IPBM_F0_S_FIELD S_FIELD 
 *     S_FIELD          S_FIELD 
 *     DW_IPBM_F0_SVP_VALID SVP_VALID 
 *     DW_IPBM_F0_SPARE SPARE 
 *     FULL_MASK        Field created for sbus access to the entire mask portion of the TCAM
 *     IPBM_MASK        IPBM field MASK
 *     MASK             Field created for sbus access to the entire mask portion of the TCAM
 *     DGLP_MASK        DGLP 
 *     DW_IPBM_F0_DGLPMASK DGLP 
 *     DW_IPBM_F0_S_FIELDMASK S_FIELD 
 *     S_FIELD_MASK     S_FIELD 
 *     DW_IPBM_F0_SVP_VALIDMASK SVP_VALID 
 *     DW_IPBM_F0_SPAREMASK SPARE 
 */
#define FP_GLOBAL_MASK_TCAMm_MIN 0
#define FP_GLOBAL_MASK_TCAMm_MAX 1023
#define FP_GLOBAL_MASK_TCAMm_CMAX(u) 1023
#define FP_GLOBAL_MASK_TCAMm_SIZE 17

/*
 * This structure should be used to declare and program FP_GLOBAL_MASK_TCAM.
 */
typedef union FP_GLOBAL_MASK_TCAMm_s {
	uint32 v[5];
	uint32 fp_global_mask_tcam[5];
	uint32 _fp_global_mask_tcam;
} FP_GLOBAL_MASK_TCAMm_t;

#define FP_GLOBAL_MASK_TCAMm_CLR(r) sal_memset(&((r)._fp_global_mask_tcam), 0, sizeof(FP_GLOBAL_MASK_TCAMm_t))
#define FP_GLOBAL_MASK_TCAMm_SET(r,i,d) (r).fp_global_mask_tcam[i] = d
#define FP_GLOBAL_MASK_TCAMm_GET(r,i) (r).fp_global_mask_tcam[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_GLOBAL_MASK_TCAMm_VALIDf_GET(r) (((r).fp_global_mask_tcam[0]) & 0x1)
#define FP_GLOBAL_MASK_TCAMm_VALIDf_SET(r,f) (r).fp_global_mask_tcam[0]=(((r).fp_global_mask_tcam[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define FP_GLOBAL_MASK_TCAMm_FULL_KEYf_GET(r,a) field_get((r).fp_global_mask_tcam,1,66,a)
#define FP_GLOBAL_MASK_TCAMm_FULL_KEYf_SET(r,a) field_set((r).fp_global_mask_tcam,1,66,a)
#define FP_GLOBAL_MASK_TCAMm_IPBMf_GET(r,a) field_get((r).fp_global_mask_tcam,1,66,a)
#define FP_GLOBAL_MASK_TCAMm_IPBMf_SET(r,a) field_set((r).fp_global_mask_tcam,1,66,a)
#define FP_GLOBAL_MASK_TCAMm_KEYf_GET(r,a) field_get((r).fp_global_mask_tcam,1,66,a)
#define FP_GLOBAL_MASK_TCAMm_KEYf_SET(r,a) field_set((r).fp_global_mask_tcam,1,66,a)
#define FP_GLOBAL_MASK_TCAMm_DGLPf_GET(r) ((((r).fp_global_mask_tcam[0]) >> 1) & 0xffff)
#define FP_GLOBAL_MASK_TCAMm_DGLPf_SET(r,f) (r).fp_global_mask_tcam[0]=(((r).fp_global_mask_tcam[0] & ~((uint32)0xffff << 1)) | ((((uint32)f) & 0xffff) << 1))
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_DGLPf_GET(r) ((((r).fp_global_mask_tcam[0]) >> 1) & 0xffff)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_DGLPf_SET(r,f) (r).fp_global_mask_tcam[0]=(((r).fp_global_mask_tcam[0] & ~((uint32)0xffff << 1)) | ((((uint32)f) & 0xffff) << 1))
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_S_FIELDf_GET(r) field32_get((r).fp_global_mask_tcam,17,32)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_S_FIELDf_SET(r,f) field32_set((r).fp_global_mask_tcam,17,32,f)
#define FP_GLOBAL_MASK_TCAMm_S_FIELDf_GET(r) field32_get((r).fp_global_mask_tcam,17,32)
#define FP_GLOBAL_MASK_TCAMm_S_FIELDf_SET(r,f) field32_set((r).fp_global_mask_tcam,17,32,f)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_SVP_VALIDf_GET(r) ((((r).fp_global_mask_tcam[1]) >> 1) & 0x1)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_SVP_VALIDf_SET(r,f) (r).fp_global_mask_tcam[1]=(((r).fp_global_mask_tcam[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_SPAREf_GET(r,a) field_get((r).fp_global_mask_tcam,34,66,a)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_SPAREf_SET(r,a) field_set((r).fp_global_mask_tcam,34,66,a)
#define FP_GLOBAL_MASK_TCAMm_FULL_MASKf_GET(r,a) field_get((r).fp_global_mask_tcam,67,132,a)
#define FP_GLOBAL_MASK_TCAMm_FULL_MASKf_SET(r,a) field_set((r).fp_global_mask_tcam,67,132,a)
#define FP_GLOBAL_MASK_TCAMm_IPBM_MASKf_GET(r,a) field_get((r).fp_global_mask_tcam,67,132,a)
#define FP_GLOBAL_MASK_TCAMm_IPBM_MASKf_SET(r,a) field_set((r).fp_global_mask_tcam,67,132,a)
#define FP_GLOBAL_MASK_TCAMm_MASKf_GET(r,a) field_get((r).fp_global_mask_tcam,67,132,a)
#define FP_GLOBAL_MASK_TCAMm_MASKf_SET(r,a) field_set((r).fp_global_mask_tcam,67,132,a)
#define FP_GLOBAL_MASK_TCAMm_DGLP_MASKf_GET(r) ((((r).fp_global_mask_tcam[2]) >> 3) & 0xffff)
#define FP_GLOBAL_MASK_TCAMm_DGLP_MASKf_SET(r,f) (r).fp_global_mask_tcam[2]=(((r).fp_global_mask_tcam[2] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_DGLPMASKf_GET(r) ((((r).fp_global_mask_tcam[2]) >> 3) & 0xffff)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_DGLPMASKf_SET(r,f) (r).fp_global_mask_tcam[2]=(((r).fp_global_mask_tcam[2] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_S_FIELDMASKf_GET(r) field32_get((r).fp_global_mask_tcam,83,98)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_S_FIELDMASKf_SET(r,f) field32_set((r).fp_global_mask_tcam,83,98,f)
#define FP_GLOBAL_MASK_TCAMm_S_FIELD_MASKf_GET(r) field32_get((r).fp_global_mask_tcam,83,98)
#define FP_GLOBAL_MASK_TCAMm_S_FIELD_MASKf_SET(r,f) field32_set((r).fp_global_mask_tcam,83,98,f)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_SVP_VALIDMASKf_GET(r) ((((r).fp_global_mask_tcam[3]) >> 3) & 0x1)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_SVP_VALIDMASKf_SET(r,f) (r).fp_global_mask_tcam[3]=(((r).fp_global_mask_tcam[3] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_SPAREMASKf_GET(r,a) field_get((r).fp_global_mask_tcam,100,132,a)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_SPAREMASKf_SET(r,a) field_set((r).fp_global_mask_tcam,100,132,a)

/*
 * These macros can be used to access FP_GLOBAL_MASK_TCAM.
 */
#define WRITE_FP_GLOBAL_MASK_TCAMm(u,i,r) bcm5607x_tcam_mem_set(u, M_FP_GLOBAL_MASK_TCAM(i), &(r._fp_global_mask_tcam), 5, 1, 67, 66)
#define READ_FP_GLOBAL_MASK_TCAMm(u,i,r) bcm5607x_tcam_mem_get(u, M_FP_GLOBAL_MASK_TCAM(i), &(r._fp_global_mask_tcam), 5, 1, 67, 66)

/*******************************************************************************
 * End of 'FP_GLOBAL_MASK_TCAMm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  FP_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     METER TABLE STRUCTURES FOR THE FP, FeatureSpecific-FP
 * SIZE:     87
 * FIELDS:
 *     BUCKETCOUNT      Metering Bucket Count
 *     BUCKETSIZE       Threshold determines the size of Metering Bucket. This Threshold setting is not related to actual bandwidth rate number. The Bucket size is determined by the formula: BUCKETSIZE = (CBS or EBS or PBS in bits per second) / ((granularity for the current METER_GRAN in bytes per second) * 8)
 *     REFRESHCOUNT     Refresh count for Back Pressure Metering bucket. The Refresh count is determined by the formula: REFRESHCOUNT = (CIR or PIR in bits per second) / (refresh rate for the current METER_GRAN in bits per second)
 *     REFRESH_MODE     0 = trTCM refreshing mode1 = srTCM refreshing mode
 *     METER_GRAN       Selects the Bucket Count granularity when PKTS_BYTES = 0, or the number of tokens to subtract from the bucket when PKTS_BYTES == 1. For PKTS_BYTES = 0:   Refr Rate BC[0] BC BYTE BC MAX BS Gran BS MAX 0 8000bps 1/128Byte BC[7] 2Mbyte 512byte 2Mbyte 1 16000bps 1/64Byte BC[6] 4Mbyte 1Kbyte 4Mbyte 2 32000bps 1/32Byte BC[5] 8Mbyte 2Kbyte 8Mbyte 3 64000bps 1/16Byte BC[4] 16Mbyte 4Kbyte 16Mbyte 4 128000bps 1/8Byte BC[3] 32Mbyte 8Kbyte 32Mbyte 5 256000bps 1/4Byte BC[2] 64Mbyte 16Kbyte 64Mbyte 6 512000bps 1/2Byte BC[1] 128Mbyte 32Kbyte 128Mbyte 7 1000000bps 1Byte BC[0] 256Mbyte 64Kbyte 256Mbyte For PKTS_BYTES = 1:   Tokens Token Min Pkt Max Pkt Max Gbps Step Size Min Burst Max Burst   Per Pkt  Unit   Rate  Rate  Rate (Pkts/Sec) Size   Size 0 128000  1/128000 1   0.52   0.27   1       (1,4)   2.097 1 64000  1/64000   2   1.05   0.54   2       (1,8)   4.194 2 32000  1/32000   4   2.1    1.08   4       (1,16)  8.388 3 16000  1/16000   8   4.19   2.15   8       (1,32)  16.777 4 8000  1/8000    16   8.39   4.3    16      (1,65)  33.554 5 4000  1/4000    32   16.78  8.59   32      (1,131) 67.108 6 2000  1/2000    64   33.55  17.18  64      (1,262) 134.217 7 250   1/250     512  268.44 137.44 512     (1,2097) 1073.741
 *     PKTS_BYTES       Selects whether the meter operates on bytes or packets. This affects how the the METER_GRAN field is used. 0 = Meter operates on bytes (Default) 1 = Meter operates on packets 
 *     THRESHOLD_CHECK  Packet size threshold for TSN flow assigned to this meter index, 0: DEFAULT (backward XGS compatible), 1 to 16K bytes packet length.
 *     METER_MODE_TSN_MODIFIER Enable TSN Metering, 0: DEFAULT (backward compatible), 1: TSN Metering.
 *     METER_GRAN_MODE  Selecting the finer granularity, 0: DEFAULT (backward compatible), 1: Finer Granularity.
 *     EVEN_PARITY      Even parity.
 */
#define FP_METER_TABLEm_MIN 0
#define FP_METER_TABLEm_MAX 1023
#define FP_METER_TABLEm_CMAX(u) 1023
#define FP_METER_TABLEm_SIZE 11

/*
 * This structure should be used to declare and program FP_METER_TABLE.
 */
typedef union FP_METER_TABLEm_s {
	uint32 v[3];
	uint32 fp_meter_table[3];
	uint32 _fp_meter_table;
} FP_METER_TABLEm_t;

#define FP_METER_TABLEm_CLR(r) sal_memset(&((r)._fp_meter_table), 0, sizeof(FP_METER_TABLEm_t))
#define FP_METER_TABLEm_SET(r,i,d) (r).fp_meter_table[i] = d
#define FP_METER_TABLEm_GET(r,i) (r).fp_meter_table[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_meter_table[0]) & 0x3fffffff)
#define FP_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_meter_table[0]=(((r).fp_meter_table[0] & ~((uint32)0x3fffffff)) | (((uint32)f) & 0x3fffffff))
#define FP_METER_TABLEm_BUCKETSIZEf_GET(r) field32_get((r).fp_meter_table,30,41)
#define FP_METER_TABLEm_BUCKETSIZEf_SET(r,f) field32_set((r).fp_meter_table,30,41,f)
#define FP_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_meter_table[1]) >> 10) & 0x3fffff)
#define FP_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_meter_table[1]=(((r).fp_meter_table[1] & ~((uint32)0x3fffff << 10)) | ((((uint32)f) & 0x3fffff) << 10))
#define FP_METER_TABLEm_REFRESH_MODEf_GET(r) (((r).fp_meter_table[2]) & 0x3)
#define FP_METER_TABLEm_REFRESH_MODEf_SET(r,f) (r).fp_meter_table[2]=(((r).fp_meter_table[2] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_METER_TABLEm_METER_GRANf_GET(r) ((((r).fp_meter_table[2]) >> 2) & 0x7)
#define FP_METER_TABLEm_METER_GRANf_SET(r,f) (r).fp_meter_table[2]=(((r).fp_meter_table[2] & ~((uint32)0x7 << 2)) | ((((uint32)f) & 0x7) << 2))
#define FP_METER_TABLEm_PKTS_BYTESf_GET(r) ((((r).fp_meter_table[2]) >> 5) & 0x1)
#define FP_METER_TABLEm_PKTS_BYTESf_SET(r,f) (r).fp_meter_table[2]=(((r).fp_meter_table[2] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_METER_TABLEm_THRESHOLD_CHECKf_GET(r) ((((r).fp_meter_table[2]) >> 6) & 0x3fff)
#define FP_METER_TABLEm_THRESHOLD_CHECKf_SET(r,f) (r).fp_meter_table[2]=(((r).fp_meter_table[2] & ~((uint32)0x3fff << 6)) | ((((uint32)f) & 0x3fff) << 6))
#define FP_METER_TABLEm_METER_MODE_TSN_MODIFIERf_GET(r) ((((r).fp_meter_table[2]) >> 20) & 0x1)
#define FP_METER_TABLEm_METER_MODE_TSN_MODIFIERf_SET(r,f) (r).fp_meter_table[2]=(((r).fp_meter_table[2] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_METER_TABLEm_METER_GRAN_MODEf_GET(r) ((((r).fp_meter_table[2]) >> 21) & 0x1)
#define FP_METER_TABLEm_METER_GRAN_MODEf_SET(r,f) (r).fp_meter_table[2]=(((r).fp_meter_table[2] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define FP_METER_TABLEm_EVEN_PARITYf_GET(r) ((((r).fp_meter_table[2]) >> 22) & 0x1)
#define FP_METER_TABLEm_EVEN_PARITYf_SET(r,f) (r).fp_meter_table[2]=(((r).fp_meter_table[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))

/*
 * These macros can be used to access FP_METER_TABLE.
 */
#define WRITE_FP_METER_TABLEm(u,i,r) bcm5607x_mem_set(u, M_FP_METER_TABLE(i), &(r._fp_meter_table), 3)
#define READ_FP_METER_TABLEm(u,i,r) bcm5607x_mem_get(u, M_FP_METER_TABLE(i), &(r._fp_meter_table), 3)

/*******************************************************************************
 * End of 'FP_METER_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  FP_POLICY_TABLE
 * BLOCKS:   IPIPE
 * DESC:     POLICY TABLE FOR DETERMINING ACTIONS IN THE FP, FeatureSpecific-FP
 * SIZE:     321
 * FIELDS:
 *     IM0_MTP_INDEX    Overlay field added for TR compatibility
 *     MTP_INDEX0       MTP_INDEX0 is for Ingress Mirror only (IM0)
 *     EM0_MTP_INDEX    Overlay field added for TR compatibility
 *     MIRROR           Bits 8 & 9 are for Ingress Mirror only and bits 10 & 11 are for Egress Mirror only
 *     INGRESS_MIRROR   Overlay field added for TR compatibility
 *     EGRESS_MIRROR    Overlay field added for TR compatibility
 *     R_NEW_PKT_PRI    
 *     Y_NEW_PKT_PRI    
 *     G_NEW_PKT_PRI    
 *     R_COS_INT_PRI    
 *     Y_COS_INT_PRI    
 *     G_COS_INT_PRI    
 *     NEW_INPUT_PRIORITY New value for input priority.
 *     CHANGE_INPUT_PRIORITY Modify input priority value.
 *     REDIRECTION      REDIRECTION
 *     REDIRECTION_DGLP REDIRECTION_DGLP
 *     REDIRECTION_NHI  NHI for redirect_to_nhi. Valid values is same as depth of Next Hop Table
 *     REDIRECTION_PROFILE_INDEX REDIRECTION_PROFILE_INDEX
 *     REPLACE_PBM_BC_TYPE The replace pbm bc type is meant to distinguish whether the PBM to Broadcast is the VLAN PBM or picked from the redirection table
 *     REDIRECTION_TYPE REDIRECTION_TYPE
 *     REDIRECTION_NH   NH is the top bit in this field and is meant to distinguish between regular redirection and redirect_to_nhi
 *     MATCHED_RULE     
 *     ECMP_NH_INFO     ECMP_NH_INFO 
 *     PPD1_CLASS_TAG   PPD1_CLASS_TAG 
 *     NEXT_HOP_INDEX   NEXT_HOP_INDEX. Valid values is same as depth of Next Hop Table
 *     ECMP_PTR         ECMP group pointer.
 *     ECMP_HASH_SEL                    ECMP hash select:                0 - Hash Key and hash result itself from original per-chip programming model                1 - Salt 0 0 0 DIP, DIP only                2 - Salt 0 0 0 SIP, SIP only                3 - Salt 0 0 SIP DIP, SIP+DIP                4 - Salt DPORT SPORT DIP SIP, SIP+DIP+SPORT+DPORT                5 - Salt SPORT DPORT SIP DIP, SIP+DIP+SPORT+DPORT                6 - Salt 0 SPORT 0 SIP, SIP+SPORT                7 - Salt 0 DPORT 0 DIP, DIP+DPORT
 *     ECMP             ECMP falg.
 *     Y_NEW_DSCP       Y_NEW_DSCP 
 *     R_NEW_DSCP       R_NEW_DSCP 
 *     G_NEW_DSCP_TOS   G_NEW_DSCP
 *     METER_SHARING_MODE METER_SHARING_MODE 
 *     METER_SHARING_MODE_MODIFIER METER_SHARING_MODE_MODIFIER 
 *     METER_PAIR_MODE  METER_PAIR_MODE 
 *     METER_PAIR_MODE_MODIFIER METER_PAIR_MODE_MODIFIER 
 *     SHARED_METER_PAIR_INDEX SHARED_METER_PAIR_INDEX 
 *     RESERVED_115     Reserved bits due to size reduction of FP_METER_TABLE table  
 *     METER_PAIR_INDEX METER_PAIR_INDEX 
 *     RESERVED_126     Reserved bits due to size reduction of FP_METER_TABLE table 
 *     COUNTER_MODE     COUNTER_MODE 
 *     COUNTER_INDEX    COUNTER_INDEX 
 *     RESERVED_137     Reserved bits due to size reduction of FP_COUNTER_TABLE table 
 *     MIRROR_OVERRIDE  MIRROR_OVERRIDE 
 *     GREEN_TO_PID     GREEN_TO_PID 
 *     CHANGE_CPU_COS   CHANGE_CPU_COS: 0==NOP, 1=CHANGE_CPU_COS 
 *     R_CHANGE_DSCP    R_CHANGE_DSCP 
 *     R_COPY_TO_CPU    R_COPY_TO_CPU 
 *     R_DROP_PRECEDENCE R_DROP_PRECEDENCE 
 *     R_DROP           R_DROP 
 *     R_CHANGE_ECN     R_CHANGE_ECN 
 *     R_CHANGE_COS_OR_INT_PRI R_CHANGE_COS_OR_INT_PRI 
 *     R_CHANGE_PKT_PRI R_CHANGE_PKT_PRI 
 *     Y_CHANGE_DSCP    Y_CHANGE_DSCP 
 *     Y_COPY_TO_CPU    Y_COPY_TO_CPU 
 *     Y_DROP_PRECEDENCE Y_DROP_PRECEDENCE 
 *     Y_DROP           Y_DROP 
 *     Y_CHANGE_ECN     Y_CHANGE_ECN 
 *     Y_CHANGE_COS_OR_INT_PRI Y_CHANGE_COS_OR_INT_PRI 
 *     Y_CHANGE_PKT_PRI Y_CHANGE_PKT_PRI 
 *     G_DROP_PRECEDENCE G_DROP_PRECEDENCE 
 *     G_CHANGE_ECN     G_CHANGE_ECN 
 *     G_L3SW_CHANGE_L2_FIELDS G_L3SW_CHANGE_L2_FIELDS 
 *     G_L3SW_CHANGE_MACDA_OR_VLAN G_L3SW_CHANGE_L2_FIELDS 
 *     G_DROP           G_DROP 
 *     G_PACKET_REDIRECTION G_PACKET_REDIRECTION 
 *     G_COPY_TO_CPU    G_COPY_TO_CPU 
 *     G_CHANGE_DSCP_TOS G_CHANGE_DSCP_TOS 
 *     G_CHANGE_COS_OR_INT_PRI G_CHANGE_COS_OR_INT_PRI 
 *     G_CHANGE_PKT_PRI G_CHANGE_PKT_PRI 
 *     OAM_SET          OAM fields
 *     HEADER_ENCAP_INDEX Associated data for action (ASSIGN_HEADER_ENCAP_FIELDS). 
 *     PFC_STREAM_ID    Associated data for PFC_TRIGGER. 
 *     OAM_TAG_STATUS_CHECK_CONTROL Expected tag status and mask.
 *     OAM_UP_MEP       Indicates that this LMEP is configured as an UP MEP.
 *     OAM_TX           Indicates TX direction OAM PDU or data packet. Used as MSB of OAM_LM_BASE_PTR.
 *     OAM_LMEP_MDL     Configured MDL value for the LMEP.
 *     PFC_TC           Associated data for PFC_TRIGGER. 
 *     OAM_SERVICE_PRI_MAPPING_PTR This field concatenated with the internal priority in Irsel2 to lookup ING_SERVICE_PRI_MAP.
 *     OAM_LM_BASE_PTR  Base pointer to 4k deep LM packet counter table. MSB bit is OAM_TX
 *     RESERVED0        RESERVED
 *     PFC_TRIGGER      action: Trigger PFC frame. 
 *     ASSIGN_HEADER_ENCAP_FIELDS For Custom Header, this action will enable Custom Header encapsulation and HEADER_ENCAP_INDEX will provide index to a table which provides Custom Header fields; For MIML, this action will assign HEADER_ENCAP_INDEX, which indexes to a table which provides subfieds of MIML header.
 *     OAM_DM_TYPE      OAM delay measurement type.
 *     OAM_DM_EN        Enables OAM delay measurement.
 *     OAM_LM_EN        Enables OAM loss measurement.
 *     OAM_LMEP_EN      Entry is enabled for OAM loss/delay measurement.
 *     R_NEW_INT_CN     New value for R_CHANGE_INT_CN action.
 *     Y_NEW_INT_CN     New value for Y_CHANGE_INT_CN action.
 *     G_NEW_INT_CN     Values are: 00: Reset internal CN, 01: Set internal CN to 0x1, 10: Set internal CN to 0x2, 11: Set internal CN to 0x3,
 *     R_CHANGE_INT_CN  Modify red packet internal CN value.
 *     Y_CHANGE_INT_CN  Modify yellow packet internal CN value.
 *     G_CHANGE_INT_CN  Modify green packet internal CN value.
 *     CPU_COS          CPU_COS
 *     STU_SIZE         Indicates the STU size that the packet should be checked against. Any failure sets STU_ERROR and drops packet.
 *     MTU_SIZE         Indicates the MTU size that the packet should be checked against. Any failure sets MTU_ERROR and drops packet.
 *     APPLY_NETID_FILTERING Indicates that the NET_ID filtering should be done and the L2.BITMAP should be modified to exclude packets with same NET_ID as the egress ports NET_ID being forwarded.
 *     APPLY_PROXY_MAC_FILTERING Indicates the proxy MAC filtering should be applied.
 *     PKT_NET_ID_SOURCE Indicates the source of PBUS and egress PKT.NET_ID:0 = NET_ID =01 = Use ING port NET_ID2 = Use EGR port NET_ID3 = Use PKT.NET_ID
 *     CPU_OPCODE       Specifies 6 user defined CPU Opcodes in the CPU opcode vector for copy to CPU. 0: Invalid.
 *     SR_COPY_TO_CPU   0 = Noop1 = Copy to CPU SR duplicate and non-duplicate packets2 = Copy to CPU only SR non-duplicate packets3 = Reserved
 *     DROP_SR_FRAME    0 = Noop1 = Drop if packet is SR duplicate2 = Do not Drop if packet is SR duplicate 3 = Reserved
 *     DO_NOT_CUT_THROUGH 	If set, the packet is not eligible for cut-through in MMU.
 *     DO_NOT_URPF      DO_NOT_URPF.
 *     DO_NOT_CHANGE_TTL DO_NOT_CHANGE_TTL 
 *     USE_SVC_METER_COLOR Use Server Meter color 
 *     VXLAN_DECAP      Action resolution by IFP to indicate VXLAN DECAP.
 *     PDELAY_IN_HW     PBI.PDELAY_IN_HW is set to 1.
 *     SET_DGPP_TO_SGPP The DGPP is redirected by setting it to the SGPP value.
 *     ING_PTP_SOURCE_PORT_IDENTITY_MASK Selects one of 4 possible the 16 bits ING_PTP_SOURCE_PORT_IDENTITY MASKS.
 *     NEW_PTP_SOURCE_PORT_IDENTITY Defines a value that after masking with  PTP_SOURCE_PORT_IDENTITY_MASK can modify the Source Port Identity of the packet when MODIFY_PTP_SOURCE_PORT_IDENTITY =1.
 *     MODIFY_PTP_SOURCE_PORT_IDENTITY 0: Dont modify Source Port Identity of PTP message, 1: modify Source Port Identity of PTP message.
 *     QUEUE_EXTENSION_NUM Provides the queue extension number for 2-level scheduling.
 *     PARITY           parity
 */
#define FP_POLICY_TABLEm_MIN 0
#define FP_POLICY_TABLEm_MAX 1023
#define FP_POLICY_TABLEm_CMAX(u) 1023
#define FP_POLICY_TABLEm_SIZE 41

/*
 * This structure should be used to declare and program FP_POLICY_TABLE.
 */
typedef union FP_POLICY_TABLEm_s {
	uint32 v[11];
	uint32 fp_policy_table[11];
	uint32 _fp_policy_table;
} FP_POLICY_TABLEm_t;

#define FP_POLICY_TABLEm_CLR(r) sal_memset(&((r)._fp_policy_table), 0, sizeof(FP_POLICY_TABLEm_t))
#define FP_POLICY_TABLEm_SET(r,i,d) (r).fp_policy_table[i] = d
#define FP_POLICY_TABLEm_GET(r,i) (r).fp_policy_table[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_POLICY_TABLEm_IM0_MTP_INDEXf_GET(r) (((r).fp_policy_table[0]) & 0x3)
#define FP_POLICY_TABLEm_IM0_MTP_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_POLICY_TABLEm_MTP_INDEX0f_GET(r) (((r).fp_policy_table[0]) & 0x3)
#define FP_POLICY_TABLEm_MTP_INDEX0f_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_POLICY_TABLEm_EM0_MTP_INDEXf_GET(r) ((((r).fp_policy_table[0]) >> 4) & 0x3)
#define FP_POLICY_TABLEm_EM0_MTP_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define FP_POLICY_TABLEm_MIRRORf_GET(r) ((((r).fp_policy_table[0]) >> 8) & 0xf)
#define FP_POLICY_TABLEm_MIRRORf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define FP_POLICY_TABLEm_INGRESS_MIRRORf_GET(r) ((((r).fp_policy_table[0]) >> 8) & 0x3)
#define FP_POLICY_TABLEm_INGRESS_MIRRORf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define FP_POLICY_TABLEm_EGRESS_MIRRORf_GET(r) ((((r).fp_policy_table[0]) >> 10) & 0x3)
#define FP_POLICY_TABLEm_EGRESS_MIRRORf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define FP_POLICY_TABLEm_R_NEW_PKT_PRIf_GET(r) ((((r).fp_policy_table[0]) >> 12) & 0x7)
#define FP_POLICY_TABLEm_R_NEW_PKT_PRIf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define FP_POLICY_TABLEm_Y_NEW_PKT_PRIf_GET(r) ((((r).fp_policy_table[0]) >> 15) & 0x7)
#define FP_POLICY_TABLEm_Y_NEW_PKT_PRIf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define FP_POLICY_TABLEm_G_NEW_PKT_PRIf_GET(r) ((((r).fp_policy_table[0]) >> 18) & 0x7)
#define FP_POLICY_TABLEm_G_NEW_PKT_PRIf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define FP_POLICY_TABLEm_R_COS_INT_PRIf_GET(r) ((((r).fp_policy_table[0]) >> 21) & 0x1f)
#define FP_POLICY_TABLEm_R_COS_INT_PRIf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x1f << 21)) | ((((uint32)f) & 0x1f) << 21))
#define FP_POLICY_TABLEm_Y_COS_INT_PRIf_GET(r) ((((r).fp_policy_table[0]) >> 26) & 0x1f)
#define FP_POLICY_TABLEm_Y_COS_INT_PRIf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x1f << 26)) | ((((uint32)f) & 0x1f) << 26))
#define FP_POLICY_TABLEm_G_COS_INT_PRIf_GET(r) field32_get((r).fp_policy_table,31,35)
#define FP_POLICY_TABLEm_G_COS_INT_PRIf_SET(r,f) field32_set((r).fp_policy_table,31,35,f)
#define FP_POLICY_TABLEm_NEW_INPUT_PRIORITYf_GET(r) ((((r).fp_policy_table[1]) >> 4) & 0xf)
#define FP_POLICY_TABLEm_NEW_INPUT_PRIORITYf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define FP_POLICY_TABLEm_CHANGE_INPUT_PRIORITYf_GET(r) ((((r).fp_policy_table[1]) >> 8) & 0x1)
#define FP_POLICY_TABLEm_CHANGE_INPUT_PRIORITYf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_POLICY_TABLEm_REDIRECTIONf_GET(r) ((((r).fp_policy_table[1]) >> 9) & 0x1ffff)
#define FP_POLICY_TABLEm_REDIRECTIONf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0x1ffff << 9)) | ((((uint32)f) & 0x1ffff) << 9))
#define FP_POLICY_TABLEm_REDIRECTION_DGLPf_GET(r) ((((r).fp_policy_table[1]) >> 9) & 0xffff)
#define FP_POLICY_TABLEm_REDIRECTION_DGLPf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0xffff << 9)) | ((((uint32)f) & 0xffff) << 9))
#define FP_POLICY_TABLEm_REDIRECTION_NHIf_GET(r) ((((r).fp_policy_table[1]) >> 9) & 0x3fff)
#define FP_POLICY_TABLEm_REDIRECTION_NHIf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0x3fff << 9)) | ((((uint32)f) & 0x3fff) << 9))
#define FP_POLICY_TABLEm_REDIRECTION_PROFILE_INDEXf_GET(r) ((((r).fp_policy_table[1]) >> 9) & 0xff)
#define FP_POLICY_TABLEm_REDIRECTION_PROFILE_INDEXf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0xff << 9)) | ((((uint32)f) & 0xff) << 9))
#define FP_POLICY_TABLEm_REPLACE_PBM_BC_TYPEf_GET(r) ((((r).fp_policy_table[1]) >> 20) & 0x1)
#define FP_POLICY_TABLEm_REPLACE_PBM_BC_TYPEf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_POLICY_TABLEm_REDIRECTION_TYPEf_GET(r) ((((r).fp_policy_table[1]) >> 21) & 0x3)
#define FP_POLICY_TABLEm_REDIRECTION_TYPEf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define FP_POLICY_TABLEm_REDIRECTION_NHf_GET(r) ((((r).fp_policy_table[1]) >> 25) & 0x1)
#define FP_POLICY_TABLEm_REDIRECTION_NHf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define FP_POLICY_TABLEm_MATCHED_RULEf_GET(r) field32_get((r).fp_policy_table,58,65)
#define FP_POLICY_TABLEm_MATCHED_RULEf_SET(r,f) field32_set((r).fp_policy_table,58,65,f)
#define FP_POLICY_TABLEm_ECMP_NH_INFOf_GET(r) ((((r).fp_policy_table[2]) >> 2) & 0x7fff)
#define FP_POLICY_TABLEm_ECMP_NH_INFOf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x7fff << 2)) | ((((uint32)f) & 0x7fff) << 2))
#define FP_POLICY_TABLEm_PPD1_CLASS_TAGf_GET(r) ((((r).fp_policy_table[2]) >> 2) & 0x1fff)
#define FP_POLICY_TABLEm_PPD1_CLASS_TAGf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x1fff << 2)) | ((((uint32)f) & 0x1fff) << 2))
#define FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET(r) ((((r).fp_policy_table[2]) >> 2) & 0x1ff)
#define FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x1ff << 2)) | ((((uint32)f) & 0x1ff) << 2))
#define FP_POLICY_TABLEm_ECMP_PTRf_GET(r) ((((r).fp_policy_table[2]) >> 2) & 0xff)
#define FP_POLICY_TABLEm_ECMP_PTRf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define FP_POLICY_TABLEm_ECMP_HASH_SELf_GET(r) ((((r).fp_policy_table[2]) >> 10) & 0x7)
#define FP_POLICY_TABLEm_ECMP_HASH_SELf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define FP_POLICY_TABLEm_ECMPf_GET(r) ((((r).fp_policy_table[2]) >> 16) & 0x1)
#define FP_POLICY_TABLEm_ECMPf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define FP_POLICY_TABLEm_Y_NEW_DSCPf_GET(r) ((((r).fp_policy_table[2]) >> 17) & 0x3f)
#define FP_POLICY_TABLEm_Y_NEW_DSCPf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define FP_POLICY_TABLEm_R_NEW_DSCPf_GET(r) ((((r).fp_policy_table[2]) >> 23) & 0x3f)
#define FP_POLICY_TABLEm_R_NEW_DSCPf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x3f << 23)) | ((((uint32)f) & 0x3f) << 23))
#define FP_POLICY_TABLEm_G_NEW_DSCP_TOSf_GET(r) field32_get((r).fp_policy_table,93,98)
#define FP_POLICY_TABLEm_G_NEW_DSCP_TOSf_SET(r,f) field32_set((r).fp_policy_table,93,98,f)
#define FP_POLICY_TABLEm_METER_SHARING_MODEf_GET(r) ((((r).fp_policy_table[3]) >> 3) & 0x3)
#define FP_POLICY_TABLEm_METER_SHARING_MODEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x3 << 3)) | ((((uint32)f) & 0x3) << 3))
#define FP_POLICY_TABLEm_METER_SHARING_MODE_MODIFIERf_GET(r) ((((r).fp_policy_table[3]) >> 5) & 0x1)
#define FP_POLICY_TABLEm_METER_SHARING_MODE_MODIFIERf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_POLICY_TABLEm_METER_PAIR_MODEf_GET(r) ((((r).fp_policy_table[3]) >> 6) & 0x7)
#define FP_POLICY_TABLEm_METER_PAIR_MODEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define FP_POLICY_TABLEm_METER_PAIR_MODE_MODIFIERf_GET(r) ((((r).fp_policy_table[3]) >> 9) & 0x1)
#define FP_POLICY_TABLEm_METER_PAIR_MODE_MODIFIERf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_POLICY_TABLEm_SHARED_METER_PAIR_INDEXf_GET(r) ((((r).fp_policy_table[3]) >> 10) & 0x1ff)
#define FP_POLICY_TABLEm_SHARED_METER_PAIR_INDEXf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x1ff << 10)) | ((((uint32)f) & 0x1ff) << 10))
#define FP_POLICY_TABLEm_RESERVED_115f_GET(r) ((((r).fp_policy_table[3]) >> 19) & 0x3)
#define FP_POLICY_TABLEm_RESERVED_115f_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define FP_POLICY_TABLEm_METER_PAIR_INDEXf_GET(r) ((((r).fp_policy_table[3]) >> 21) & 0x1ff)
#define FP_POLICY_TABLEm_METER_PAIR_INDEXf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x1ff << 21)) | ((((uint32)f) & 0x1ff) << 21))
#define FP_POLICY_TABLEm_RESERVED_126f_GET(r) ((((r).fp_policy_table[3]) >> 30) & 0x3)
#define FP_POLICY_TABLEm_RESERVED_126f_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define FP_POLICY_TABLEm_COUNTER_MODEf_GET(r) (((r).fp_policy_table[4]) & 0x7)
#define FP_POLICY_TABLEm_COUNTER_MODEf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define FP_POLICY_TABLEm_COUNTER_INDEXf_GET(r) ((((r).fp_policy_table[4]) >> 3) & 0x3f)
#define FP_POLICY_TABLEm_COUNTER_INDEXf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x3f << 3)) | ((((uint32)f) & 0x3f) << 3))
#define FP_POLICY_TABLEm_RESERVED_137f_GET(r) ((((r).fp_policy_table[4]) >> 9) & 0x1)
#define FP_POLICY_TABLEm_RESERVED_137f_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_POLICY_TABLEm_MIRROR_OVERRIDEf_GET(r) ((((r).fp_policy_table[4]) >> 10) & 0x1)
#define FP_POLICY_TABLEm_MIRROR_OVERRIDEf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define FP_POLICY_TABLEm_GREEN_TO_PIDf_GET(r) ((((r).fp_policy_table[4]) >> 11) & 0x1)
#define FP_POLICY_TABLEm_GREEN_TO_PIDf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_POLICY_TABLEm_CHANGE_CPU_COSf_GET(r) ((((r).fp_policy_table[4]) >> 12) & 0x1)
#define FP_POLICY_TABLEm_CHANGE_CPU_COSf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_POLICY_TABLEm_R_CHANGE_DSCPf_GET(r) ((((r).fp_policy_table[4]) >> 13) & 0x3)
#define FP_POLICY_TABLEm_R_CHANGE_DSCPf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define FP_POLICY_TABLEm_R_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[4]) >> 15) & 0x7)
#define FP_POLICY_TABLEm_R_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define FP_POLICY_TABLEm_R_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[4]) >> 18) & 0x3)
#define FP_POLICY_TABLEm_R_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define FP_POLICY_TABLEm_R_DROPf_GET(r) ((((r).fp_policy_table[4]) >> 20) & 0x3)
#define FP_POLICY_TABLEm_R_DROPf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define FP_POLICY_TABLEm_R_CHANGE_ECNf_GET(r) ((((r).fp_policy_table[4]) >> 22) & 0x3)
#define FP_POLICY_TABLEm_R_CHANGE_ECNf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define FP_POLICY_TABLEm_R_CHANGE_COS_OR_INT_PRIf_GET(r) ((((r).fp_policy_table[4]) >> 24) & 0x7)
#define FP_POLICY_TABLEm_R_CHANGE_COS_OR_INT_PRIf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define FP_POLICY_TABLEm_R_CHANGE_PKT_PRIf_GET(r) ((((r).fp_policy_table[4]) >> 27) & 0x7)
#define FP_POLICY_TABLEm_R_CHANGE_PKT_PRIf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define FP_POLICY_TABLEm_Y_CHANGE_DSCPf_GET(r) ((((r).fp_policy_table[4]) >> 30) & 0x3)
#define FP_POLICY_TABLEm_Y_CHANGE_DSCPf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define FP_POLICY_TABLEm_Y_COPY_TO_CPUf_GET(r) (((r).fp_policy_table[5]) & 0x7)
#define FP_POLICY_TABLEm_Y_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define FP_POLICY_TABLEm_Y_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[5]) >> 3) & 0x3)
#define FP_POLICY_TABLEm_Y_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x3 << 3)) | ((((uint32)f) & 0x3) << 3))
#define FP_POLICY_TABLEm_Y_DROPf_GET(r) ((((r).fp_policy_table[5]) >> 5) & 0x3)
#define FP_POLICY_TABLEm_Y_DROPf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x3 << 5)) | ((((uint32)f) & 0x3) << 5))
#define FP_POLICY_TABLEm_Y_CHANGE_ECNf_GET(r) ((((r).fp_policy_table[5]) >> 7) & 0x3)
#define FP_POLICY_TABLEm_Y_CHANGE_ECNf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define FP_POLICY_TABLEm_Y_CHANGE_COS_OR_INT_PRIf_GET(r) ((((r).fp_policy_table[5]) >> 9) & 0x7)
#define FP_POLICY_TABLEm_Y_CHANGE_COS_OR_INT_PRIf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define FP_POLICY_TABLEm_Y_CHANGE_PKT_PRIf_GET(r) ((((r).fp_policy_table[5]) >> 12) & 0x7)
#define FP_POLICY_TABLEm_Y_CHANGE_PKT_PRIf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define FP_POLICY_TABLEm_G_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[5]) >> 15) & 0x3)
#define FP_POLICY_TABLEm_G_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x3 << 15)) | ((((uint32)f) & 0x3) << 15))
#define FP_POLICY_TABLEm_G_CHANGE_ECNf_GET(r) ((((r).fp_policy_table[5]) >> 17) & 0x3)
#define FP_POLICY_TABLEm_G_CHANGE_ECNf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x3 << 17)) | ((((uint32)f) & 0x3) << 17))
#define FP_POLICY_TABLEm_G_L3SW_CHANGE_L2_FIELDSf_GET(r) ((((r).fp_policy_table[5]) >> 19) & 0x7)
#define FP_POLICY_TABLEm_G_L3SW_CHANGE_L2_FIELDSf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define FP_POLICY_TABLEm_G_L3SW_CHANGE_MACDA_OR_VLANf_GET(r) ((((r).fp_policy_table[5]) >> 19) & 0x7)
#define FP_POLICY_TABLEm_G_L3SW_CHANGE_MACDA_OR_VLANf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define FP_POLICY_TABLEm_G_DROPf_GET(r) ((((r).fp_policy_table[5]) >> 22) & 0x3)
#define FP_POLICY_TABLEm_G_DROPf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define FP_POLICY_TABLEm_G_PACKET_REDIRECTIONf_GET(r) ((((r).fp_policy_table[5]) >> 24) & 0x7)
#define FP_POLICY_TABLEm_G_PACKET_REDIRECTIONf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define FP_POLICY_TABLEm_G_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[5]) >> 27) & 0x7)
#define FP_POLICY_TABLEm_G_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define FP_POLICY_TABLEm_G_CHANGE_DSCP_TOSf_GET(r) field32_get((r).fp_policy_table,190,192)
#define FP_POLICY_TABLEm_G_CHANGE_DSCP_TOSf_SET(r,f) field32_set((r).fp_policy_table,190,192,f)
#define FP_POLICY_TABLEm_G_CHANGE_COS_OR_INT_PRIf_GET(r) ((((r).fp_policy_table[6]) >> 1) & 0x7)
#define FP_POLICY_TABLEm_G_CHANGE_COS_OR_INT_PRIf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define FP_POLICY_TABLEm_G_CHANGE_PKT_PRIf_GET(r) ((((r).fp_policy_table[6]) >> 4) & 0x7)
#define FP_POLICY_TABLEm_G_CHANGE_PKT_PRIf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_POLICY_TABLEm_OAM_SETf_GET(r) field32_get((r).fp_policy_table,199,229)
#define FP_POLICY_TABLEm_OAM_SETf_SET(r,f) field32_set((r).fp_policy_table,199,229,f)
#define FP_POLICY_TABLEm_HEADER_ENCAP_INDEXf_GET(r) ((((r).fp_policy_table[6]) >> 7) & 0x3ff)
#define FP_POLICY_TABLEm_HEADER_ENCAP_INDEXf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x3ff << 7)) | ((((uint32)f) & 0x3ff) << 7))
#define FP_POLICY_TABLEm_PFC_STREAM_IDf_GET(r) ((((r).fp_policy_table[6]) >> 7) & 0xff)
#define FP_POLICY_TABLEm_PFC_STREAM_IDf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define FP_POLICY_TABLEm_OAM_TAG_STATUS_CHECK_CONTROLf_GET(r) ((((r).fp_policy_table[6]) >> 7) & 0xf)
#define FP_POLICY_TABLEm_OAM_TAG_STATUS_CHECK_CONTROLf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0xf << 7)) | ((((uint32)f) & 0xf) << 7))
#define FP_POLICY_TABLEm_OAM_UP_MEPf_GET(r) ((((r).fp_policy_table[6]) >> 12) & 0x1)
#define FP_POLICY_TABLEm_OAM_UP_MEPf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_POLICY_TABLEm_OAM_TXf_GET(r) ((((r).fp_policy_table[6]) >> 13) & 0x1)
#define FP_POLICY_TABLEm_OAM_TXf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_POLICY_TABLEm_OAM_LMEP_MDLf_GET(r) ((((r).fp_policy_table[6]) >> 14) & 0x7)
#define FP_POLICY_TABLEm_OAM_LMEP_MDLf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define FP_POLICY_TABLEm_PFC_TCf_GET(r) ((((r).fp_policy_table[6]) >> 17) & 0xff)
#define FP_POLICY_TABLEm_PFC_TCf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0xff << 17)) | ((((uint32)f) & 0xff) << 17))
#define FP_POLICY_TABLEm_OAM_SERVICE_PRI_MAPPING_PTRf_GET(r) ((((r).fp_policy_table[6]) >> 17) & 0xf)
#define FP_POLICY_TABLEm_OAM_SERVICE_PRI_MAPPING_PTRf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0xf << 17)) | ((((uint32)f) & 0xf) << 17))
#define FP_POLICY_TABLEm_OAM_LM_BASE_PTRf_GET(r) ((((r).fp_policy_table[6]) >> 21) & 0x7ff)
#define FP_POLICY_TABLEm_OAM_LM_BASE_PTRf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x7ff << 21)) | ((((uint32)f) & 0x7ff) << 21))
#define FP_POLICY_TABLEm_RESERVED0f_GET(r) (((r).fp_policy_table[7]) & 0x3)
#define FP_POLICY_TABLEm_RESERVED0f_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_POLICY_TABLEm_PFC_TRIGGERf_GET(r) (((r).fp_policy_table[7]) & 0x1)
#define FP_POLICY_TABLEm_PFC_TRIGGERf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define FP_POLICY_TABLEm_ASSIGN_HEADER_ENCAP_FIELDSf_GET(r) ((((r).fp_policy_table[7]) >> 1) & 0x1)
#define FP_POLICY_TABLEm_ASSIGN_HEADER_ENCAP_FIELDSf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_POLICY_TABLEm_OAM_DM_TYPEf_GET(r) ((((r).fp_policy_table[7]) >> 2) & 0x1)
#define FP_POLICY_TABLEm_OAM_DM_TYPEf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_POLICY_TABLEm_OAM_DM_ENf_GET(r) ((((r).fp_policy_table[7]) >> 3) & 0x1)
#define FP_POLICY_TABLEm_OAM_DM_ENf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define FP_POLICY_TABLEm_OAM_LM_ENf_GET(r) ((((r).fp_policy_table[7]) >> 4) & 0x1)
#define FP_POLICY_TABLEm_OAM_LM_ENf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define FP_POLICY_TABLEm_OAM_LMEP_ENf_GET(r) ((((r).fp_policy_table[7]) >> 5) & 0x1)
#define FP_POLICY_TABLEm_OAM_LMEP_ENf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_POLICY_TABLEm_R_NEW_INT_CNf_GET(r) ((((r).fp_policy_table[7]) >> 6) & 0x3)
#define FP_POLICY_TABLEm_R_NEW_INT_CNf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define FP_POLICY_TABLEm_Y_NEW_INT_CNf_GET(r) ((((r).fp_policy_table[7]) >> 8) & 0x3)
#define FP_POLICY_TABLEm_Y_NEW_INT_CNf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define FP_POLICY_TABLEm_G_NEW_INT_CNf_GET(r) ((((r).fp_policy_table[7]) >> 10) & 0x3)
#define FP_POLICY_TABLEm_G_NEW_INT_CNf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define FP_POLICY_TABLEm_R_CHANGE_INT_CNf_GET(r) ((((r).fp_policy_table[7]) >> 12) & 0x1)
#define FP_POLICY_TABLEm_R_CHANGE_INT_CNf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_POLICY_TABLEm_Y_CHANGE_INT_CNf_GET(r) ((((r).fp_policy_table[7]) >> 13) & 0x1)
#define FP_POLICY_TABLEm_Y_CHANGE_INT_CNf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_POLICY_TABLEm_G_CHANGE_INT_CNf_GET(r) ((((r).fp_policy_table[7]) >> 14) & 0x1)
#define FP_POLICY_TABLEm_G_CHANGE_INT_CNf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define FP_POLICY_TABLEm_CPU_COSf_GET(r) ((((r).fp_policy_table[7]) >> 15) & 0x3f)
#define FP_POLICY_TABLEm_CPU_COSf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x3f << 15)) | ((((uint32)f) & 0x3f) << 15))
#define FP_POLICY_TABLEm_STU_SIZEf_GET(r) field32_get((r).fp_policy_table,245,258)
#define FP_POLICY_TABLEm_STU_SIZEf_SET(r,f) field32_set((r).fp_policy_table,245,258,f)
#define FP_POLICY_TABLEm_MTU_SIZEf_GET(r) ((((r).fp_policy_table[8]) >> 3) & 0x3fff)
#define FP_POLICY_TABLEm_MTU_SIZEf_SET(r,f) (r).fp_policy_table[8]=(((r).fp_policy_table[8] & ~((uint32)0x3fff << 3)) | ((((uint32)f) & 0x3fff) << 3))
#define FP_POLICY_TABLEm_APPLY_NETID_FILTERINGf_GET(r) ((((r).fp_policy_table[8]) >> 18) & 0x1)
#define FP_POLICY_TABLEm_APPLY_NETID_FILTERINGf_SET(r,f) (r).fp_policy_table[8]=(((r).fp_policy_table[8] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define FP_POLICY_TABLEm_APPLY_PROXY_MAC_FILTERINGf_GET(r) ((((r).fp_policy_table[8]) >> 19) & 0x1)
#define FP_POLICY_TABLEm_APPLY_PROXY_MAC_FILTERINGf_SET(r,f) (r).fp_policy_table[8]=(((r).fp_policy_table[8] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_POLICY_TABLEm_PKT_NET_ID_SOURCEf_GET(r) ((((r).fp_policy_table[8]) >> 20) & 0x3)
#define FP_POLICY_TABLEm_PKT_NET_ID_SOURCEf_SET(r,f) (r).fp_policy_table[8]=(((r).fp_policy_table[8] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define FP_POLICY_TABLEm_CPU_OPCODEf_GET(r) ((((r).fp_policy_table[8]) >> 22) & 0x3f)
#define FP_POLICY_TABLEm_CPU_OPCODEf_SET(r,f) (r).fp_policy_table[8]=(((r).fp_policy_table[8] & ~((uint32)0x3f << 22)) | ((((uint32)f) & 0x3f) << 22))
#define FP_POLICY_TABLEm_SR_COPY_TO_CPUf_GET(r) field32_get((r).fp_policy_table,287,288)
#define FP_POLICY_TABLEm_SR_COPY_TO_CPUf_SET(r,f) field32_set((r).fp_policy_table,287,288,f)
#define FP_POLICY_TABLEm_DROP_SR_FRAMEf_GET(r) ((((r).fp_policy_table[9]) >> 1) & 0x3)
#define FP_POLICY_TABLEm_DROP_SR_FRAMEf_SET(r,f) (r).fp_policy_table[9]=(((r).fp_policy_table[9] & ~((uint32)0x3 << 1)) | ((((uint32)f) & 0x3) << 1))
#define FP_POLICY_TABLEm_DO_NOT_CUT_THROUGHf_GET(r) ((((r).fp_policy_table[9]) >> 3) & 0x1)
#define FP_POLICY_TABLEm_DO_NOT_CUT_THROUGHf_SET(r,f) (r).fp_policy_table[9]=(((r).fp_policy_table[9] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define FP_POLICY_TABLEm_DO_NOT_URPFf_GET(r) ((((r).fp_policy_table[9]) >> 4) & 0x1)
#define FP_POLICY_TABLEm_DO_NOT_URPFf_SET(r,f) (r).fp_policy_table[9]=(((r).fp_policy_table[9] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_GET(r) ((((r).fp_policy_table[9]) >> 5) & 0x1)
#define FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_SET(r,f) (r).fp_policy_table[9]=(((r).fp_policy_table[9] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_POLICY_TABLEm_USE_SVC_METER_COLORf_GET(r) ((((r).fp_policy_table[9]) >> 6) & 0x1)
#define FP_POLICY_TABLEm_USE_SVC_METER_COLORf_SET(r,f) (r).fp_policy_table[9]=(((r).fp_policy_table[9] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define FP_POLICY_TABLEm_VXLAN_DECAPf_GET(r) ((((r).fp_policy_table[9]) >> 7) & 0x1)
#define FP_POLICY_TABLEm_VXLAN_DECAPf_SET(r,f) (r).fp_policy_table[9]=(((r).fp_policy_table[9] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_POLICY_TABLEm_PDELAY_IN_HWf_GET(r) ((((r).fp_policy_table[9]) >> 8) & 0x1)
#define FP_POLICY_TABLEm_PDELAY_IN_HWf_SET(r,f) (r).fp_policy_table[9]=(((r).fp_policy_table[9] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_POLICY_TABLEm_SET_DGPP_TO_SGPPf_GET(r) ((((r).fp_policy_table[9]) >> 9) & 0x1)
#define FP_POLICY_TABLEm_SET_DGPP_TO_SGPPf_SET(r,f) (r).fp_policy_table[9]=(((r).fp_policy_table[9] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_POLICY_TABLEm_ING_PTP_SOURCE_PORT_IDENTITY_MASKf_GET(r) ((((r).fp_policy_table[9]) >> 10) & 0x3)
#define FP_POLICY_TABLEm_ING_PTP_SOURCE_PORT_IDENTITY_MASKf_SET(r,f) (r).fp_policy_table[9]=(((r).fp_policy_table[9] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define FP_POLICY_TABLEm_NEW_PTP_SOURCE_PORT_IDENTITYf_GET(r) ((((r).fp_policy_table[9]) >> 12) & 0xffff)
#define FP_POLICY_TABLEm_NEW_PTP_SOURCE_PORT_IDENTITYf_SET(r,f) (r).fp_policy_table[9]=(((r).fp_policy_table[9] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_POLICY_TABLEm_MODIFY_PTP_SOURCE_PORT_IDENTITYf_GET(r) ((((r).fp_policy_table[9]) >> 28) & 0x1)
#define FP_POLICY_TABLEm_MODIFY_PTP_SOURCE_PORT_IDENTITYf_SET(r,f) (r).fp_policy_table[9]=(((r).fp_policy_table[9] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define FP_POLICY_TABLEm_QUEUE_EXTENSION_NUMf_GET(r) ((((r).fp_policy_table[9]) >> 29) & 0x7)
#define FP_POLICY_TABLEm_QUEUE_EXTENSION_NUMf_SET(r,f) (r).fp_policy_table[9]=(((r).fp_policy_table[9] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))
#define FP_POLICY_TABLEm_PARITYf_GET(r) (((r).fp_policy_table[10]) & 0x1)
#define FP_POLICY_TABLEm_PARITYf_SET(r,f) (r).fp_policy_table[10]=(((r).fp_policy_table[10] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access FP_POLICY_TABLE.
 */
#define WRITE_FP_POLICY_TABLEm(u,i,r) bcm5607x_mem_set(u, M_FP_POLICY_TABLE(i), &(r._fp_policy_table), 11)
#define READ_FP_POLICY_TABLEm(u,i,r) bcm5607x_mem_get(u, M_FP_POLICY_TABLE(i), &(r._fp_policy_table), 11)

/*******************************************************************************
 * End of 'FP_POLICY_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  FP_PORT_FIELD_SEL
 * BLOCKS:   IPIPE
 * DESC:     FIELD SELECT VALUE FOR EACH SLICE IN THE ContentAware Processor, FeatureSpecific-FP
 * SIZE:     270
 * FIELDS:
 *     SLICE0_F1        F1 field for slice 0.
 *     SLICE0_F2        F2 field for slice 0
 *     SLICE0_F3        F3 field for slice 0
 *     SLICE0_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE0_DOUBLE_WIDE_MODE Double wide mode for slice 0 (0 == single wide, 1 == double wide)
 *     SLICE1_F1        F1 field for slice 1.
 *     SLICE1_F2        F2 field for slice 1
 *     SLICE1_F3        F3 field for slice 1
 *     SLICE1_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE1_DOUBLE_WIDE_MODE Double wide mode for slice 1 (0 == single wide, 1 == double wide)
 *     SLICE2_F1        F1 field for slice 2.
 *     SLICE2_F2        F2 field for slice 2
 *     SLICE2_F3        F3 field for slice 2
 *     SLICE2_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE2_DOUBLE_WIDE_MODE Double wide mode for slice 2 (0 == single wide, 1 == double wide)
 *     SLICE3_F1        F1 field for slice 3.
 *     SLICE3_F2        F2 field for slice 3
 *     SLICE3_F3        F3 field for slice 3
 *     SLICE3_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE3_DOUBLE_WIDE_MODE Double wide mode for slice 3 (0 == single wide, 1 == double wide)
 *     SLICE4_F1        F1 field for slice 4.
 *     SLICE4_F2        F2 field for slice 4
 *     SLICE4_F3        F3 field for slice 4
 *     SLICE4_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE4_DOUBLE_WIDE_MODE Double wide mode for slice 4 (0 == single wide, 1 == double wide)
 *     SLICE5_F1        F1 field for slice 5.
 *     SLICE5_F2        F2 field for slice 5
 *     SLICE5_F3        F3 field for slice 5
 *     SLICE5_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE5_DOUBLE_WIDE_MODE Double wide mode for slice 5 (0 == single wide, 1 == double wide)
 *     SLICE6_F1        F1 field for slice 6.
 *     SLICE6_F2        F2 field for slice 6
 *     SLICE6_F3        F3 field for slice 6
 *     SLICE6_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE6_DOUBLE_WIDE_MODE Double wide mode for slice 6 (0 == single wide, 1 == double wide)
 *     SLICE7_F1        F1 field for slice 7.
 *     SLICE7_F2        F2 field for slice 7
 *     SLICE7_F3        F3 field for slice 7
 *     SLICE7_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE7_DOUBLE_WIDE_MODE Double wide mode for slice 7 (0 == single wide, 1 == double wide)
 *     SLICE8_F1        F1 field for slice 8.
 *     SLICE8_F2        F2 field for slice 8
 *     SLICE8_F3        F3 field for slice 8
 *     SLICE8_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE8_DOUBLE_WIDE_MODE Double wide mode for slice 8 (0 == single wide, 1 == double wide)
 *     SLICE9_F1        F1 field for slice 9.
 *     SLICE9_F2        F2 field for slice 9
 *     SLICE9_F3        F3 field for slice 9
 *     SLICE9_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE9_DOUBLE_WIDE_MODE Double wide mode for slice 9 (0 == single wide, 1 == double wide)
 *     SLICE10_F1       F1 field for slice 10.
 *     SLICE10_F2       F2 field for slice 10
 *     SLICE10_F3       F3 field for slice 10
 *     SLICE10_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE10_DOUBLE_WIDE_MODE Double wide mode for slice 10 (0 == single wide, 1 == double wide)
 *     SLICE11_F1       F1 field for slice 11.
 *     SLICE11_F2       F2 field for slice 11
 *     SLICE11_F3       F3 field for slice 11
 *     SLICE11_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE11_DOUBLE_WIDE_MODE Double wide mode for slice 11 (0 == single wide, 1 == double wide)
 *     SLICE1_0_PAIRING Slice pairing for slices 0/1
 *     SLICE3_2_PAIRING Slice pairing for slices 2/3
 *     SLICE5_4_PAIRING Slice pairing for slices 4/5
 *     SLICE7_6_PAIRING Slice pairing for slices 6/7
 *     SLICE9_8_PAIRING Slice pairing for slices 8/9
 *     SLICE11_10_PAIRING Slice pairing for slices 11/10
 *     SLICE0_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE1_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE2_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE3_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE4_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE5_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE6_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE7_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE8_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE9_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE10_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE11_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE0_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE1_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE2_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE3_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE4_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE5_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE6_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE7_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE8_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE9_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE10_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE11_S_TYPE_SEL Represents selection controls to select the S_FIELD
 */
#define FP_PORT_FIELD_SELm_MIN 0
#define FP_PORT_FIELD_SELm_MAX 131
#define FP_PORT_FIELD_SELm_CMAX(u) 131
#define FP_PORT_FIELD_SELm_SIZE 34

/*
 * This structure should be used to declare and program FP_PORT_FIELD_SEL.
 */
typedef union FP_PORT_FIELD_SELm_s {
	uint32 v[9];
	uint32 fp_port_field_sel[9];
	uint32 _fp_port_field_sel;
} FP_PORT_FIELD_SELm_t;

#define FP_PORT_FIELD_SELm_CLR(r) sal_memset(&((r)._fp_port_field_sel), 0, sizeof(FP_PORT_FIELD_SELm_t))
#define FP_PORT_FIELD_SELm_SET(r,i,d) (r).fp_port_field_sel[i] = d
#define FP_PORT_FIELD_SELm_GET(r,i) (r).fp_port_field_sel[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_PORT_FIELD_SELm_SLICE0_F1f_GET(r) (((r).fp_port_field_sel[0]) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE0_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define FP_PORT_FIELD_SELm_SLICE0_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 4) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE0_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0x1f << 4)) | ((((uint32)f) & 0x1f) << 4))
#define FP_PORT_FIELD_SELm_SLICE0_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 9) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE0_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0xf << 9)) | ((((uint32)f) & 0xf) << 9))
#define FP_PORT_FIELD_SELm_SLICE0_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[0]) >> 13) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE0_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0x7 << 13)) | ((((uint32)f) & 0x7) << 13))
#define FP_PORT_FIELD_SELm_SLICE0_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[0]) >> 16) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE0_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define FP_PORT_FIELD_SELm_SLICE1_F1f_GET(r) ((((r).fp_port_field_sel[0]) >> 17) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE1_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0xf << 17)) | ((((uint32)f) & 0xf) << 17))
#define FP_PORT_FIELD_SELm_SLICE1_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 21) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE1_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0x1f << 21)) | ((((uint32)f) & 0x1f) << 21))
#define FP_PORT_FIELD_SELm_SLICE1_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 26) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE1_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0xf << 26)) | ((((uint32)f) & 0xf) << 26))
#define FP_PORT_FIELD_SELm_SLICE1_DOUBLE_WIDE_KEY_SELECTf_GET(r) field32_get((r).fp_port_field_sel,30,32)
#define FP_PORT_FIELD_SELm_SLICE1_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) field32_set((r).fp_port_field_sel,30,32,f)
#define FP_PORT_FIELD_SELm_SLICE1_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[1]) >> 1) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE1_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_PORT_FIELD_SELm_SLICE2_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 2) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE2_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0xf << 2)) | ((((uint32)f) & 0xf) << 2))
#define FP_PORT_FIELD_SELm_SLICE2_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 6) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE2_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0x1f << 6)) | ((((uint32)f) & 0x1f) << 6))
#define FP_PORT_FIELD_SELm_SLICE2_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 11) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE2_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0xf << 11)) | ((((uint32)f) & 0xf) << 11))
#define FP_PORT_FIELD_SELm_SLICE2_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[1]) >> 15) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE2_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define FP_PORT_FIELD_SELm_SLICE2_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[1]) >> 18) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE2_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define FP_PORT_FIELD_SELm_SLICE3_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 19) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE3_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0xf << 19)) | ((((uint32)f) & 0xf) << 19))
#define FP_PORT_FIELD_SELm_SLICE3_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 23) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE3_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0x1f << 23)) | ((((uint32)f) & 0x1f) << 23))
#define FP_PORT_FIELD_SELm_SLICE3_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 28) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE3_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define FP_PORT_FIELD_SELm_SLICE3_DOUBLE_WIDE_KEY_SELECTf_GET(r) (((r).fp_port_field_sel[2]) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE3_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define FP_PORT_FIELD_SELm_SLICE3_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[2]) >> 3) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE3_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define FP_PORT_FIELD_SELm_SLICE4_F1f_GET(r) ((((r).fp_port_field_sel[2]) >> 4) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE4_F1f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define FP_PORT_FIELD_SELm_SLICE4_F2f_GET(r) ((((r).fp_port_field_sel[2]) >> 8) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE4_F2f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0x1f << 8)) | ((((uint32)f) & 0x1f) << 8))
#define FP_PORT_FIELD_SELm_SLICE4_F3f_GET(r) ((((r).fp_port_field_sel[2]) >> 13) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE4_F3f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0xf << 13)) | ((((uint32)f) & 0xf) << 13))
#define FP_PORT_FIELD_SELm_SLICE4_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[2]) >> 17) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE4_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0x7 << 17)) | ((((uint32)f) & 0x7) << 17))
#define FP_PORT_FIELD_SELm_SLICE4_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[2]) >> 20) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE4_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_PORT_FIELD_SELm_SLICE5_F1f_GET(r) ((((r).fp_port_field_sel[2]) >> 21) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE5_F1f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0xf << 21)) | ((((uint32)f) & 0xf) << 21))
#define FP_PORT_FIELD_SELm_SLICE5_F2f_GET(r) ((((r).fp_port_field_sel[2]) >> 25) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE5_F2f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0x1f << 25)) | ((((uint32)f) & 0x1f) << 25))
#define FP_PORT_FIELD_SELm_SLICE5_F3f_GET(r) field32_get((r).fp_port_field_sel,94,97)
#define FP_PORT_FIELD_SELm_SLICE5_F3f_SET(r,f) field32_set((r).fp_port_field_sel,94,97,f)
#define FP_PORT_FIELD_SELm_SLICE5_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[3]) >> 2) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE5_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0x7 << 2)) | ((((uint32)f) & 0x7) << 2))
#define FP_PORT_FIELD_SELm_SLICE5_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[3]) >> 5) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE5_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_PORT_FIELD_SELm_SLICE6_F1f_GET(r) ((((r).fp_port_field_sel[3]) >> 6) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE6_F1f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0xf << 6)) | ((((uint32)f) & 0xf) << 6))
#define FP_PORT_FIELD_SELm_SLICE6_F2f_GET(r) ((((r).fp_port_field_sel[3]) >> 10) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE6_F2f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0x1f << 10)) | ((((uint32)f) & 0x1f) << 10))
#define FP_PORT_FIELD_SELm_SLICE6_F3f_GET(r) ((((r).fp_port_field_sel[3]) >> 15) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE6_F3f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0xf << 15)) | ((((uint32)f) & 0xf) << 15))
#define FP_PORT_FIELD_SELm_SLICE6_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[3]) >> 19) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE6_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define FP_PORT_FIELD_SELm_SLICE6_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[3]) >> 22) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE6_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define FP_PORT_FIELD_SELm_SLICE7_F1f_GET(r) ((((r).fp_port_field_sel[3]) >> 23) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE7_F1f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0xf << 23)) | ((((uint32)f) & 0xf) << 23))
#define FP_PORT_FIELD_SELm_SLICE7_F2f_GET(r) ((((r).fp_port_field_sel[3]) >> 27) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE7_F2f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0x1f << 27)) | ((((uint32)f) & 0x1f) << 27))
#define FP_PORT_FIELD_SELm_SLICE7_F3f_GET(r) (((r).fp_port_field_sel[4]) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE7_F3f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define FP_PORT_FIELD_SELm_SLICE7_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[4]) >> 4) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE7_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_PORT_FIELD_SELm_SLICE7_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[4]) >> 7) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE7_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_PORT_FIELD_SELm_SLICE8_F1f_GET(r) ((((r).fp_port_field_sel[4]) >> 8) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE8_F1f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define FP_PORT_FIELD_SELm_SLICE8_F2f_GET(r) ((((r).fp_port_field_sel[4]) >> 12) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE8_F2f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x1f << 12)) | ((((uint32)f) & 0x1f) << 12))
#define FP_PORT_FIELD_SELm_SLICE8_F3f_GET(r) ((((r).fp_port_field_sel[4]) >> 17) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE8_F3f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0xf << 17)) | ((((uint32)f) & 0xf) << 17))
#define FP_PORT_FIELD_SELm_SLICE8_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[4]) >> 21) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE8_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x7 << 21)) | ((((uint32)f) & 0x7) << 21))
#define FP_PORT_FIELD_SELm_SLICE8_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[4]) >> 24) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE8_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define FP_PORT_FIELD_SELm_SLICE9_F1f_GET(r) ((((r).fp_port_field_sel[4]) >> 25) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE9_F1f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0xf << 25)) | ((((uint32)f) & 0xf) << 25))
#define FP_PORT_FIELD_SELm_SLICE9_F2f_GET(r) field32_get((r).fp_port_field_sel,157,161)
#define FP_PORT_FIELD_SELm_SLICE9_F2f_SET(r,f) field32_set((r).fp_port_field_sel,157,161,f)
#define FP_PORT_FIELD_SELm_SLICE9_F3f_GET(r) ((((r).fp_port_field_sel[5]) >> 2) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE9_F3f_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0xf << 2)) | ((((uint32)f) & 0xf) << 2))
#define FP_PORT_FIELD_SELm_SLICE9_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[5]) >> 6) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE9_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define FP_PORT_FIELD_SELm_SLICE9_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[5]) >> 9) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE9_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_PORT_FIELD_SELm_SLICE10_F1f_GET(r) ((((r).fp_port_field_sel[5]) >> 10) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE10_F1f_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0xf << 10)) | ((((uint32)f) & 0xf) << 10))
#define FP_PORT_FIELD_SELm_SLICE10_F2f_GET(r) ((((r).fp_port_field_sel[5]) >> 14) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE10_F2f_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x1f << 14)) | ((((uint32)f) & 0x1f) << 14))
#define FP_PORT_FIELD_SELm_SLICE10_F3f_GET(r) ((((r).fp_port_field_sel[5]) >> 19) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE10_F3f_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0xf << 19)) | ((((uint32)f) & 0xf) << 19))
#define FP_PORT_FIELD_SELm_SLICE10_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[5]) >> 23) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE10_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x7 << 23)) | ((((uint32)f) & 0x7) << 23))
#define FP_PORT_FIELD_SELm_SLICE10_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[5]) >> 26) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE10_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define FP_PORT_FIELD_SELm_SLICE11_F1f_GET(r) ((((r).fp_port_field_sel[5]) >> 27) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE11_F1f_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0xf << 27)) | ((((uint32)f) & 0xf) << 27))
#define FP_PORT_FIELD_SELm_SLICE11_F2f_GET(r) field32_get((r).fp_port_field_sel,191,195)
#define FP_PORT_FIELD_SELm_SLICE11_F2f_SET(r,f) field32_set((r).fp_port_field_sel,191,195,f)
#define FP_PORT_FIELD_SELm_SLICE11_F3f_GET(r) ((((r).fp_port_field_sel[6]) >> 4) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE11_F3f_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define FP_PORT_FIELD_SELm_SLICE11_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[6]) >> 8) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE11_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0x7 << 8)) | ((((uint32)f) & 0x7) << 8))
#define FP_PORT_FIELD_SELm_SLICE11_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[6]) >> 11) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE11_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_PORT_FIELD_SELm_SLICE1_0_PAIRINGf_GET(r) ((((r).fp_port_field_sel[6]) >> 12) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE1_0_PAIRINGf_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_PORT_FIELD_SELm_SLICE3_2_PAIRINGf_GET(r) ((((r).fp_port_field_sel[6]) >> 13) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE3_2_PAIRINGf_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_PORT_FIELD_SELm_SLICE5_4_PAIRINGf_GET(r) ((((r).fp_port_field_sel[6]) >> 14) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE5_4_PAIRINGf_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define FP_PORT_FIELD_SELm_SLICE7_6_PAIRINGf_GET(r) ((((r).fp_port_field_sel[6]) >> 15) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE7_6_PAIRINGf_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define FP_PORT_FIELD_SELm_SLICE9_8_PAIRINGf_GET(r) ((((r).fp_port_field_sel[6]) >> 16) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE9_8_PAIRINGf_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define FP_PORT_FIELD_SELm_SLICE11_10_PAIRINGf_GET(r) ((((r).fp_port_field_sel[6]) >> 17) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE11_10_PAIRINGf_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define FP_PORT_FIELD_SELm_SLICE0_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[6]) >> 18) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE0_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define FP_PORT_FIELD_SELm_SLICE1_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[6]) >> 21) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE1_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0x7 << 21)) | ((((uint32)f) & 0x7) << 21))
#define FP_PORT_FIELD_SELm_SLICE2_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[6]) >> 24) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE2_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define FP_PORT_FIELD_SELm_SLICE3_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[6]) >> 27) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE3_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[6]=(((r).fp_port_field_sel[6] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define FP_PORT_FIELD_SELm_SLICE4_D_TYPE_SELf_GET(r) field32_get((r).fp_port_field_sel,222,224)
#define FP_PORT_FIELD_SELm_SLICE4_D_TYPE_SELf_SET(r,f) field32_set((r).fp_port_field_sel,222,224,f)
#define FP_PORT_FIELD_SELm_SLICE5_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[7]) >> 1) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE5_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[7]=(((r).fp_port_field_sel[7] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define FP_PORT_FIELD_SELm_SLICE6_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[7]) >> 4) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE6_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[7]=(((r).fp_port_field_sel[7] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_PORT_FIELD_SELm_SLICE7_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[7]) >> 7) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE7_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[7]=(((r).fp_port_field_sel[7] & ~((uint32)0x7 << 7)) | ((((uint32)f) & 0x7) << 7))
#define FP_PORT_FIELD_SELm_SLICE8_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[7]) >> 10) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE8_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[7]=(((r).fp_port_field_sel[7] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define FP_PORT_FIELD_SELm_SLICE9_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[7]) >> 13) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE9_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[7]=(((r).fp_port_field_sel[7] & ~((uint32)0x7 << 13)) | ((((uint32)f) & 0x7) << 13))
#define FP_PORT_FIELD_SELm_SLICE10_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[7]) >> 16) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE10_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[7]=(((r).fp_port_field_sel[7] & ~((uint32)0x7 << 16)) | ((((uint32)f) & 0x7) << 16))
#define FP_PORT_FIELD_SELm_SLICE11_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[7]) >> 19) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE11_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[7]=(((r).fp_port_field_sel[7] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define FP_PORT_FIELD_SELm_SLICE0_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[7]) >> 22) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE0_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[7]=(((r).fp_port_field_sel[7] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define FP_PORT_FIELD_SELm_SLICE1_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[7]) >> 24) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE1_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[7]=(((r).fp_port_field_sel[7] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define FP_PORT_FIELD_SELm_SLICE2_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[7]) >> 26) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE2_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[7]=(((r).fp_port_field_sel[7] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define FP_PORT_FIELD_SELm_SLICE3_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[7]) >> 28) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE3_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[7]=(((r).fp_port_field_sel[7] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define FP_PORT_FIELD_SELm_SLICE4_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[7]) >> 30) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE4_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[7]=(((r).fp_port_field_sel[7] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define FP_PORT_FIELD_SELm_SLICE5_S_TYPE_SELf_GET(r) (((r).fp_port_field_sel[8]) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE5_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[8]=(((r).fp_port_field_sel[8] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_PORT_FIELD_SELm_SLICE6_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[8]) >> 2) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE6_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[8]=(((r).fp_port_field_sel[8] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define FP_PORT_FIELD_SELm_SLICE7_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[8]) >> 4) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE7_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[8]=(((r).fp_port_field_sel[8] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define FP_PORT_FIELD_SELm_SLICE8_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[8]) >> 6) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE8_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[8]=(((r).fp_port_field_sel[8] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define FP_PORT_FIELD_SELm_SLICE9_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[8]) >> 8) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE9_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[8]=(((r).fp_port_field_sel[8] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define FP_PORT_FIELD_SELm_SLICE10_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[8]) >> 10) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE10_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[8]=(((r).fp_port_field_sel[8] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define FP_PORT_FIELD_SELm_SLICE11_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[8]) >> 12) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE11_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[8]=(((r).fp_port_field_sel[8] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))

/*
 * These macros can be used to access FP_PORT_FIELD_SEL.
 */
#define WRITE_FP_PORT_FIELD_SELm(u,i,r) bcm5607x_mem_set(u, M_FP_PORT_FIELD_SEL(i), &(r._fp_port_field_sel), 9)
#define READ_FP_PORT_FIELD_SELm(u,i,r) bcm5607x_mem_get(u, M_FP_PORT_FIELD_SEL(i), &(r._fp_port_field_sel), 9)

/*******************************************************************************
 * End of 'FP_PORT_FIELD_SELm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  FP_SLICE_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     FP_SLICE_ENABLE
 * SIZE:     32
 * FIELDS:
 *     FP_SLICE_ENABLE_ALL Overlay for all SLICE enable bits
 *     FP_SLICE_ENABLE_SLICE_0 FP_SLICE_ENABLE FOR IFP SLICE 0
 *     FP_SLICE_ENABLE_SLICE_1 FP_SLICE_ENABLE FOR IFP SLICE 1
 *     FP_SLICE_ENABLE_SLICE_2 FP_SLICE_ENABLE FOR IFP SLICE 2
 *     FP_SLICE_ENABLE_SLICE_3 FP_SLICE_ENABLE FOR IFP SLICE 3
 *     FP_SLICE_ENABLE_SLICE_4 FP_SLICE_ENABLE FOR IFP SLICE 4
 *     FP_SLICE_ENABLE_SLICE_5 FP_SLICE_ENABLE FOR IFP SLICE 5
 *     FP_SLICE_ENABLE_SLICE_6 FP_SLICE_ENABLE FOR IFP SLICE 6
 *     FP_SLICE_ENABLE_SLICE_7 FP_SLICE_ENABLE FOR IFP SLICE 7
 *     FP_LOOKUP_ENABLE_ALL Overlay for all look up enable bits
 *     FP_LOOKUP_ENABLE_SLICE_0 LOOKUP ENABLE FOR IFP SLICE 0
 *     FP_LOOKUP_ENABLE_SLICE_1 LOOKUP ENABLE FOR IFP SLICE 1
 *     FP_LOOKUP_ENABLE_SLICE_2 LOOKUP ENABLE FOR IFP SLICE 2
 *     FP_LOOKUP_ENABLE_SLICE_3 LOOKUP ENABLE FOR IFP SLICE 3
 *     FP_LOOKUP_ENABLE_SLICE_4 LOOKUP ENABLE FOR IFP SLICE 4
 *     FP_LOOKUP_ENABLE_SLICE_5 LOOKUP ENABLE FOR IFP SLICE 5
 *     FP_LOOKUP_ENABLE_SLICE_6 LOOKUP ENABLE FOR IFP SLICE 6
 *     FP_LOOKUP_ENABLE_SLICE_7 LOOKUP ENABLE FOR IFP SLICE 7
 */
#define FP_SLICE_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program FP_SLICE_ENABLE.
 */
typedef union FP_SLICE_ENABLEr_s {
	uint32 v[1];
	uint32 fp_slice_enable[1];
	uint32 _fp_slice_enable;
} FP_SLICE_ENABLEr_t;

#define FP_SLICE_ENABLEr_CLR(r) (r).fp_slice_enable[0] = 0
#define FP_SLICE_ENABLEr_SET(r,d) (r).fp_slice_enable[0] = d
#define FP_SLICE_ENABLEr_GET(r) (r).fp_slice_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_ALLf_GET(r) (((r).fp_slice_enable[0]) & 0xff)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_ALLf_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_GET(r) (((r).fp_slice_enable[0]) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_GET(r) ((((r).fp_slice_enable[0]) >> 1) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_GET(r) ((((r).fp_slice_enable[0]) >> 2) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_GET(r) ((((r).fp_slice_enable[0]) >> 3) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_GET(r) ((((r).fp_slice_enable[0]) >> 4) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_GET(r) ((((r).fp_slice_enable[0]) >> 5) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_GET(r) ((((r).fp_slice_enable[0]) >> 6) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_GET(r) ((((r).fp_slice_enable[0]) >> 7) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_ALLf_GET(r) ((((r).fp_slice_enable[0]) >> 8) & 0xff)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_ALLf_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_GET(r) ((((r).fp_slice_enable[0]) >> 8) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_GET(r) ((((r).fp_slice_enable[0]) >> 9) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_GET(r) ((((r).fp_slice_enable[0]) >> 10) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_GET(r) ((((r).fp_slice_enable[0]) >> 11) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_GET(r) ((((r).fp_slice_enable[0]) >> 12) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_GET(r) ((((r).fp_slice_enable[0]) >> 13) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_GET(r) ((((r).fp_slice_enable[0]) >> 14) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_GET(r) ((((r).fp_slice_enable[0]) >> 15) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))

/*
 * These macros can be used to access FP_SLICE_ENABLE.
 */
#define WRITE_FP_SLICE_ENABLEr(u,r) bcm5607x_reg_set(u,R_FP_SLICE_ENABLE,(r._fp_slice_enable))
#define READ_FP_SLICE_ENABLEr(u,r) bcm5607x_reg_get(u,R_FP_SLICE_ENABLE,&(r._fp_slice_enable))

/*******************************************************************************
 * End of 'FP_SLICE_ENABLEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  FP_SLICE_MAP
 * BLOCKS:   IPIPE
 * DESC:     SLICE MAPPING CONTROLS FOR IFP, FeatureSpecific-FP
 * SIZE:     48
 * FIELDS:
 *     VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 0 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 1 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 2 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 3 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 4 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 5 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 6 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 7 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 0 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 1 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 2 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 3 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 4 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 5 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 6 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 7 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 */
#define FP_SLICE_MAPm_MIN 0
#define FP_SLICE_MAPm_MAX 0
#define FP_SLICE_MAPm_CMAX(u) 0
#define FP_SLICE_MAPm_SIZE 6

/*
 * This structure should be used to declare and program FP_SLICE_MAP.
 */
typedef union FP_SLICE_MAPm_s {
	uint32 v[2];
	uint32 fp_slice_map[2];
	uint32 _fp_slice_map;
} FP_SLICE_MAPm_t;

#define FP_SLICE_MAPm_CLR(r) sal_memset(&((r)._fp_slice_map), 0, sizeof(FP_SLICE_MAPm_t))
#define FP_SLICE_MAPm_SET(r,i,d) (r).fp_slice_map[i] = d
#define FP_SLICE_MAPm_GET(r,i) (r).fp_slice_map[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) (((r).fp_slice_map[0]) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 3) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 6) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 9) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 12) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 15) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 18) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 21) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 21)) | ((((uint32)f) & 0x7) << 21))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 24) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 27) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) field32_get((r).fp_slice_map,30,32)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) field32_set((r).fp_slice_map,30,32,f)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[1]) >> 1) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[1]) >> 4) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[1]) >> 7) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32)0x7 << 7)) | ((((uint32)f) & 0x7) << 7))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[1]) >> 10) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[1]) >> 13) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32)0x7 << 13)) | ((((uint32)f) & 0x7) << 13))

/*
 * These macros can be used to access FP_SLICE_MAP.
 */
#define WRITE_FP_SLICE_MAPm(u,r) bcm5607x_mem_set(u, M_FP_SLICE_MAP, &(r._fp_slice_map), 2)
#define READ_FP_SLICE_MAPm(u,r) bcm5607x_mem_get(u, M_FP_SLICE_MAP, &(r._fp_slice_map), 2)

/*******************************************************************************
 * End of 'FP_SLICE_MAPm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  FP_STORM_CONTROL_METERS
 * BLOCKS:   IPIPE
 * DESC:     Storm control meters used in conjunction with the settings in the per port STORM_CONTROL_METERCONFIG register
 * SIZE:     54
 * FIELDS:
 *     BUCKETCOUNT      Bucket Count
 *     BUCKETSIZE       Bucket Size for Storm Control Meters 3'd0 = 4K Bytes 3'd1 = 16K Bytes 3'd2 = 64K Bytes 3'd3 = 256K Bytes 3'd4 = 1M Bytes 3'd5 = 4M Bytes 3'd6 = 8M Bytes 3'd7 = 16M Bytes
 *     REFRESHCOUNT     Refresh count for Storm Control Metering bucket.Every unit of REFRESH represents 64,000 bps, (bits per second). Example 1: To set metering rate to 500 Mbps (500,000,000 bps), should set REFRESH = 7812, Example 2: To set metering rate to 1 Gbps (1,000,000,000 bps), should set REFRESH = 15624.
 *     EVEN_PARITY      Even parity
 */
#define FP_STORM_CONTROL_METERSm_MIN 0
#define FP_STORM_CONTROL_METERSm_MAX 263
#define FP_STORM_CONTROL_METERSm_CMAX(u) 263
#define FP_STORM_CONTROL_METERSm_SIZE 7

/*
 * This structure should be used to declare and program FP_STORM_CONTROL_METERS.
 */
typedef union FP_STORM_CONTROL_METERSm_s {
	uint32 v[2];
	uint32 fp_storm_control_meters[2];
	uint32 _fp_storm_control_meters;
} FP_STORM_CONTROL_METERSm_t;

#define FP_STORM_CONTROL_METERSm_CLR(r) sal_memset(&((r)._fp_storm_control_meters), 0, sizeof(FP_STORM_CONTROL_METERSm_t))
#define FP_STORM_CONTROL_METERSm_SET(r,i,d) (r).fp_storm_control_meters[i] = d
#define FP_STORM_CONTROL_METERSm_GET(r,i) (r).fp_storm_control_meters[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_STORM_CONTROL_METERSm_BUCKETCOUNTf_GET(r) (((r).fp_storm_control_meters[0]) & 0x3fffffff)
#define FP_STORM_CONTROL_METERSm_BUCKETCOUNTf_SET(r,f) (r).fp_storm_control_meters[0]=(((r).fp_storm_control_meters[0] & ~((uint32)0x3fffffff)) | (((uint32)f) & 0x3fffffff))
#define FP_STORM_CONTROL_METERSm_BUCKETSIZEf_GET(r) field32_get((r).fp_storm_control_meters,30,32)
#define FP_STORM_CONTROL_METERSm_BUCKETSIZEf_SET(r,f) field32_set((r).fp_storm_control_meters,30,32,f)
#define FP_STORM_CONTROL_METERSm_REFRESHCOUNTf_GET(r) ((((r).fp_storm_control_meters[1]) >> 1) & 0xfffff)
#define FP_STORM_CONTROL_METERSm_REFRESHCOUNTf_SET(r,f) (r).fp_storm_control_meters[1]=(((r).fp_storm_control_meters[1] & ~((uint32)0xfffff << 1)) | ((((uint32)f) & 0xfffff) << 1))
#define FP_STORM_CONTROL_METERSm_EVEN_PARITYf_GET(r) ((((r).fp_storm_control_meters[1]) >> 21) & 0x1)
#define FP_STORM_CONTROL_METERSm_EVEN_PARITYf_SET(r,f) (r).fp_storm_control_meters[1]=(((r).fp_storm_control_meters[1] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))

/*
 * These macros can be used to access FP_STORM_CONTROL_METERS.
 */
#define WRITE_FP_STORM_CONTROL_METERSm(u,i,r) bcm5607x_mem_set(u, M_FP_STORM_CONTROL_METERS(i), &(r._fp_storm_control_meters), 2)
#define READ_FP_STORM_CONTROL_METERSm(u,i,r) bcm5607x_mem_get(u, M_FP_STORM_CONTROL_METERS(i), &(r._fp_storm_control_meters), 2)

/*******************************************************************************
 * End of 'FP_STORM_CONTROL_METERSm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  FP_TCAM
 * BLOCKS:   IPIPE
 * DESC:     TCAM FOR FP
 * SIZE:     474
 * FIELDS:
 *     VALID            VALID BIT
 *     FULL_KEY         Field created for sbus access to the entire key portion of the TCAM
 *     KEY              SW overlay: Key field combo of F1, F2, F3 and FIXED
 *     DOUBLE_WIDE_MODE DOUBLE_WIDE_MODE
 *     DW_DOUBLE_WIDE_MODE DW_DOUBLE_WIDE_MODE
 *     DATA_KEY         SW overlay for all (F1-F4) DW Key bits
 *     DWF4             DWF4
 *     DWF4_0_PORT_FIELD_SEL_TABLE_INDEX PORT_FIELD_SEL_TABLE_INDEX 
 *     DWF4_0_PORT_FIELD_SEL_TABLE_INDEX_MASK PORT_FIELD_SEL_TABLE_INDEX 
 *     F4               F4
 *     DWF4_1_TCP_FN    TCP_FN 
 *     DWF4_1_TCP_FN_MASK TCP_FN 
 *     DWF4_1_SPARE     SPARE 
 *     DWF4_1_SPARE_MASK SPARE 
 *     DWF3             DWF3 field
 *     FIXED            FIXED BITS
 *     FIXED_HIGIG      HIGIG 
 *     FIXED_FORWARDING_TYPE FORWARDING_TYPE 
 *     FIXED_SVP_OR_L3IIF L3_TYPE 
 *     FIXED_L3_TYPE    L3_TYPE 
 *     FIXED_L4_VALID   L4_VALID 
 *     FIXED_L3_ROUTABLE L3_ROUTABLE 
 *     FIXED_TUNNEL_TYPE_LOOPBACK_TYPE TUNNEL_TYPE 
 *     FIXED_DROP       DROP 
 *     FIXED_MIRROR_ONLY Mirror only copy of packet. (Only possible for HG). 
 *     FIXED_MIML_PRESENT MIML Present. 
 *     FIXED_CUSTOM_HEADER_PRESENT CUSTOM_HEADER Present. 
 *     FIXED_PREEMPTABLE_FRAME Preemptable Frame Present. 
 *     FIXED_PDELAY_REQ 1588 Pdelay_Req Present. 
 *     F3               F3 field
 *     F3_12_AUX_TAG_2  AUX Tag 2. One of Assigned_VNTAG, CNTAG or EHTAG, based on FP_SLICE_KEY_CONTROL.SLICE<0-11>_AUX_TAG_2_SEL setting
 *     F3_9_UDF1_95_64  UDF1_95_64 
 *     F3_7_RANGE_CHECK_RESULTS RANGE_CHECK_RESULTS 
 *     F3_8_IPV6_FL     IPV6_FL 
 *     F3_10_D_FIELD    D_FIELD 
 *     F3_11_SGLP       SGLP 
 *     F3_2_D_FIELD     D_FIELD 
 *     F3_3_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F3_4_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F3_5_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F3_6_LOOKUP_STATUS LOOKUP_STATUS 
 *     F3_0_CLASSIDS    CLASSIDS 
 *     F3_1_CLASSIDS    CLASSIDS 
 *     F3_13_ROCEV1_PACKET RROCEV1 Packet.
 *     F3_13_ROCEV2_PACKET RROCEV2 Packet.
 *     F3_13_ROCE_BTH_FLAGS Flags.
 *     F3_13_ROCE_BTH_DESTINATION_QP 24 bits QP in BTH.
 *     DWF2             DWF2 field
 *     DWF2_1_SIP       SIP 
 *     DWF2_1_SIP_MASK  SIP 
 *     DWF2_2_DIP       DIP 
 *     DWF2_2_DIP_MASK  DIP 
 *     DWF2_3_UDF2      UDF2 
 *     DWF2_3_UDF2_MASK UDF2 
 *     DWF2_6_PAYLOAD_SIP Payload IPV6 SIP 
 *     DWF2_6_PAYLOAD_SIP_MASK Payload IPV6 SIP 
 *     DWF2_7_PAYLOAD_DIP Payload IPV6 DIP 
 *     DWF2_7_PAYLOAD_DIP_MASK Payload IPV6 DIP 
 *     DWF2_0_SPARE     SPARE 
 *     DWF2_0_SPARE_MASK SPARE 
 *     DWF2_4_PAYLOAD_OUTER_VLAN_TAG Payload outer_vlan_tag 
 *     DWF2_4_PAYLOAD_OUTER_VLAN_TAG_MASK Payload outer_vlan_tag 
 *     DWF2_5_PAYLOAD_L4_DST Payload L4_DST 
 *     DWF2_5_PAYLOAD_L4_DST_MASK Payload L4_DST 
 *     F3_0_FORWARDING_FIELD FORWARDING_FIELD 
 *     F3_1_FORWARDING_FIELD FORWARDING_FIELD 
 *     F3_4_INNER_VLAN_TAG INNER_VLAN_TAG 
 *     F3_5_ETHERTYPE   ETHERTYPE 
 *     F3_6_INNER_VLAN_TAG INNER_VLAN_TAG 
 *     F3_11_SVP        SVP 
 *     F3_3_PACKET_FORMAT PACKET_FORMAT 
 *     F3_10_D_TYPE     D_TYPE 
 *     F3_2_D_TYPE      D_TYPE 
 *     F3_10_DGLP       DGLP 
 *     F3_2_S_FIELD     S_FIELD 
 *     F3_8_PACKET_FORMAT PACKET_FORMAT 
 *     F3_3_SWITCHING_TAG_STATUS SWITCHING_TAG_STATUS 
 *     F3_3_MH_OPCODE   MH_OPCODE 
 *     F3_0_SVP_L3IIF_OVERLAY SVP_L3IIF_OVERLAY 
 *     F3_1_OUTER_VLAN_ID OUTER_VLAN_ID 
 *     F3_7_INTERFACE_CLASSID INTERFACE_CLASSID 
 *     F3_8_SWITCHING_TAG_STATUS SWITCHING_TAG_STATUS 
 *     F3_3_PKT_RESOLUTION PKT_RESOLUTION 
 *     F3_8_INNER_TPID_ENCODE INNER_TPID_ENCODE 
 *     DWF2_0_LOOKUP_STATUS LOOKUP_STATUS 
 *     DWF2_0_LOOKUP_STATUS_MASK LOOKUP_STATUS 
 *     DWF2_4_PAYLOAD_ETHERTYPE Payload Ethertype 
 *     DWF2_4_PAYLOAD_ETHERTYPE_MASK Payload Ethertype 
 *     DWF2_5_PAYLOAD_L4_SRC Payload L4_SRC 
 *     DWF2_5_PAYLOAD_L4_SRC_MASK Payload L4_SRC 
 *     F3_8_OUTER_TPID_ENCODE OUTER_TPID_ENCODE 
 *     F3_8_SPARE       SPARE 
 *     F3_3_IP_INFO     IP_INFO 
 *     F3_11_SVP_VALID  SVP_VALID 
 *     F3_11_SPARE      SPARE 
 *     F3_4_SPARE       SPARE 
 *     F3_5_SPARE       SPARE 
 *     F3_6_SPARE       SPARE 
 *     F3_7_SPARE       SPARE 
 *     F3_9_MPLS_INFO   MPLS_INFO 
 *     F3_12_AUX_TAG_VALID_2 AUX Tag Valid 2
 *     F3_12_SPARE      SPARE 
 *     F3_3_SPARE       SPARE 
 *     F3_13_SPARE      SPARE 
 *     F3_9_SPARE       SPARE 
 *     F3_10_SPARE      SPARE 
 *     F3_2_SVP_VALID   SVP_VALID 
 *     F3_1_SPARE       SPARE 
 *     F3_2_MH_OPCODE   MH_OPCODE 
 *     F3_0_SPARE       SPARE 
 *     F2               F2 field
 *     F2_15_PAYLOAD_SIP Payload IPV6 SIP 
 *     F2_16_PAYLOAD_DIP Payload IPV6 DIP 
 *     F2_2_SIP         SIP 
 *     F2_3_DIP         DIP 
 *     F2_8_UDF1        UDF1
 *     F2_9_UDF2        UDF2
 *     F2_10_SIP_127_64 SIP_127_64 
 *     F2_12_MIML_SA    MIML SA 
 *     F2_11_DIP_127_96 DIP_127_96 
 *     F2_18_OUTER_SIP  Indicates Outer IPv4 SIP 
 *     F2_13_PAYLOAD_OUTER_VLAN_TAG Payload outer_vlan_tag 
 *     F2_14_PAYLOAD_L4_DST Payload L4_DST 
 *     F2_5_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F2_6_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F2_7_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F2_0_TTL_FN      TTL_FN 
 *     F2_1_TTL_FN      TTL_FN 
 *     F2_4_TTL_FN      TTL_FN 
 *     F2_17_SR_NETID_MATCH Indicates whether the PKT.NET_ID matches the DGPP.NET_ID0: PKT.NET_ID != DGPP.NET_ID or PKT.NET_ID = 0 or DGPP.NET_ID = 01: PKT.NET_ID = DGPP.NET_IDNote that when DGPP.NET_ID = 0 or PKT.NET_ID = 0 the SR_NETID_MATCH = 0
 *     F2_17_INT_PRI    Internal Priority
 *     DWF2_4_PAYLOAD_MACSA Payload MACSA 
 *     DWF2_4_PAYLOAD_MACSA_MASK Payload MACSA 
 *     DWF2_0_RANGE_CHECK_RESULTS RANGE_CHECK_RESULTS 
 *     DWF2_0_RANGE_CHECK_RESULTS_MASK RANGE_CHECK_RESULTS 
 *     DWF2_5_PAYLOAD_TOS_FN Payload TOS_FN 
 *     DWF2_5_PAYLOAD_TOS_FN_MASK Payload TOS_FN 
 *     F2_17_TSN_CIRCUIT_ID Indicates TSN circuit ID. This is the Base Circuit ID before adding the offset
 *     F2_0_TCP_FN      TCP_FN 
 *     F2_1_TCP_FN      TCP_FN 
 *     F2_4_TCP_FN      TCP_FN 
 *     DWF2_5_PAYLOAD_IP_PROTOCOL_LAST_NH Payload IP_PROTOCOL_LAST_NH 
 *     DWF2_5_PAYLOAD_IP_PROTOCOL_LAST_NH_MASK Payload IP_PROTOCOL_LAST_NH 
 *     F2_4_IPV6_FL     IPV6_FL 
 *     F2_0_IPFLAG      IPFLAG 
 *     F2_1_IP_FRAG_INFO IP_FRAG_INFO 
 *     F2_13_PAYLOAD_ETHERTYPE Payload Ethertype 
 *     F2_14_PAYLOAD_L4_SRC Payload L4_SRC 
 *     F2_5_ETHERTYPE   ETHERTYPE 
 *     F2_6_ETHERTYPE   ETHERTYPE 
 *     F2_7_ETHERTYPE   EtherType 
 *     F2_0_TOS_FN      TOS_FN 
 *     F2_1_TOS_FN      TOS_FN 
 *     F2_17_SR_FLOW_ID Indicates the Seamless Redundancy FLOW_ID. This is the Base FLOW_ID before Adding the Offset
 *     DWF2_5_PAYLOAD_DIP Payload IPV4 DIP 
 *     DWF2_5_PAYLOAD_DIP_MASK Payload IPV4 DIP 
 *     F2_0_L4_DST      L4_DST 
 *     F2_1_L4_DST      L4_DST 
 *     DWF2_0_INTERFACE_CLASSID INTERFACE_CLASSID 
 *     DWF2_0_INTERFACE_CLASSID_MASK INTERFACE_CLASSID 
 *     F2_17_PKT_NET_ID_VALID Indicates whether the PKT.NET_ID is valid or not. 0: not valid, 1: valid.
 *     F2_17_PKT_LAN_ID_VALID Indicates whether the PKT.LAN_ID is valid or not. 0: not valid, 1: valid.
 *     F2_11_SA         SA 
 *     F2_13_PAYLOAD_MACSA Payload MACSA 
 *     F2_5_SA          SA 
 *     F2_6_SA          SA 
 *     F2_18_OUTER_DIP  Indicates Outer IPv4 DIP 
 *     F2_14_PAYLOAD_TOS_FN Payload TOS_FN 
 *     F2_7_TTL_FN      TTL_FN 
 *     F2_17_SR_FLOW_RX_TAG_ERROR Indicates SR frame with SR tag error
 *     F2_17_SR_FLOW_RX_ERROR Indicates SR frames received with Error
 *     F2_4_TOS_FN      TOS_FN 
 *     F2_17_VLAN_SR_LAN_ID Seamless Redundancy LAN ID assigned to this VLAN. 0 : LAN_A1 : LAN_B
 *     F2_17_VLAN_SR_ENABLE When set Indicates  that Seamless Redundancy is enabled on this VLAN
 *     DWF2_0_DIP       DIP 
 *     DWF2_0_DIP_MASK  DIP 
 *     F2_17_EGR_SR_MODE Seamless Redundancy mode of egress port.0 = Mode 1 1 = Mode 2 2 = Mode 3 3 = Mode 44 = Mode 5 5 = Mode 6 6 = Mode 7 7 = Mode 8
 *     F2_17_EGR_SR_NET_ID Seamless Redundancy Network ID assigned to this port.
 *     F2_0_L4_SRC      L4_SRC 
 *     F2_1_L4_SRC      L4_SRC 
 *     F2_14_PAYLOAD_IP_PROTOCOL_LAST_NH Payload IP_PROTOCOL_LAST_NH 
 *     F2_7_IP_PROTOCOL_LAST_NH IP_PROTOCOL_LAST_NH 
 *     F2_4_LAST_NH     LAST_NH 
 *     F2_17_EGR_SR_LAN_ID Seamless Redundancy LAN ID assigned to this port. Applies when SR_ROLE = 1 or 2 (HSR or PRP) only0 : LAN_A1 : LAN_B
 *     F2_17_EGR_SR_TYPE Seamless Redundancy Type assigned to this port0 = None (Ethernet)1 = PRP2 = HSR3 = 802.1CB4 = Modified PRP5-7= reservedModified PRP is when RCT Tag is moved to start of the frame
 *     F2_17_EGR_SR_PORT_ROLE Seamless Redundancy Role of this port0: Inter-Link1: Seamless Redundancy duplicate Port
 *     F2_17_EGR_SR_ENABLE Seamless Redundancy Enable0: Seamless redundancy is disabled on this port, do standard L2 switching1: Seamless redundancy is enabled on this port
 *     F2_12_MIML_DA    MIML DA 
 *     F2_14_PAYLOAD_DIP Payload IPV4 DIP 
 *     F2_7_DIP         DIP 
 *     F2_17_ING_SR_MODE Seamless Redundancy mode of ingress port.0 = Mode 1 1 = Mode 2 2 = Mode 3 3 = Mode 44 = Mode 5 5 = Mode 6 6 = Mode 7 7 = Mode 8
 *     F2_4_INT_CN      CongestionClass field in the HiGig header.
 *     F2_17_ING_SR_NET_ID Seamless Redundancy Network ID assigned to this port.
 *     DWF2_4_PAYLOAD_MACDA Payload MACDA 
 *     DWF2_4_PAYLOAD_MACDA_MASK Payload MACDA 
 *     DWF2_5_PAYLOAD_SIP Payload IPV4 SIP 
 *     DWF2_5_PAYLOAD_SIP_MASK Payload IPV4 SIP 
 *     F2_4_SPARE       SPARE 
 *     F2_17_ING_SR_LAN_ID Seamless Redundancy LAN ID assigned to this port. Applies when SR_ROLE = 1 or 2 (HSR or PRP) only0: LAN_A1: LAN_B
 *     F2_17_ING_SR_TYPE Seamless Redundancy Type assigned to this port0 = None (Ethernet)1 = PRP2 = HSR3 = 802.1CB4 = Modified PRP5-7= reservedModified PRP is when RCT Tag is moved to start of the frame
 *     F2_0_IP_PROTOCOL_LAST_NH IP_PROTOCOL_LAST_NH 
 *     F2_1_IP_PROTOCOL_LAST_NH IP_PROTOCOL_LAST_NH 
 *     F2_17_ING_SR_PORT_ROLE Seamless Redundancy Role of this port0: Inter-Link1: Seamless Redundancy duplicate Port
 *     F2_17_ING_SR_ENABLE Seamless Redundancy Enable0: Seamless redundancy is disabled on this port, do standard L2 switching1: Seamless redundancy is enabled on this port
 *     F2_17_PKT_NET_ID The NET_ID encoded in the SR Tag of this pack. Applies to PKT.SR_TYPE = PRP only0: Reserved for HSR 1-7: NET_ID
 *     F2_17_PKT_LAN_ID The LAN_ID encoded in the SR Tag of this packet. Applies to PKT.SR_TYPE = HSR or PRP 0: LAN_A1: LAN_B
 *     F2_10_DIP_127_64 DIP_127_64 
 *     F2_4_DIP_127_64  DIP_127_64 
 *     F2_18_INNER_PAYLOAD_DA Indicates Inner MACDA 
 *     F2_0_DIP         DIP
 *     F2_1_DIP         DIP
 *     F2_17_PKT_SR_TYPE Seamless Redundancy Tag Type of this packet0: None (standard Ethernet )1: PRP 2: HSR 3: 802.1CB 4: Modified PRP5-7: reservedModified PRP is when RCT Tag is moved to start of the frame
 *     F2_17_SR_ETHERTYPE Indicates whether this packet has SR supervisory Ethertype or not0 = Non-Supervisory Ethertype1 = PRP/HSR Supervisory Ethertype 1 (default for HSR/PRP)2 = PRP/HSR Supervisory Ethertype 23 = 801.CB Supervisory Ethertype
 *     DWF2_0_SIP       SIP 
 *     DWF2_0_SIP_MASK  SIP 
 *     F2_17_DA_TYPE    Indicates the Destination MAC Type:0 = Default, MAC_DA is an SR_MAC_ADDRESS (DAN)1 = MAC_DA is a LINK_LOCAL_MAC_ADDRESS2 = MAC_DA belonging to SAN3 = MAC_DA is a SR_SUPERVISORY_MAC_ADDRES address for HSR. PRP or 802.1CB
 *     F2_17_DA_HIT     0 = MAC_DA not found in L2 Table1 = MAC_DA found in L2 Table and result is a DGPP2 = MAC_DA found in L2 Table and result is an L2MC3 = reserved
 *     F2_17_SA_HIT     0 = MAC_SA not found in L2 Table1 = MAC_SA found in L2 Table on the correct port or correct L2MC2 = MAC_SA found in L2 Table on a wrong port or wrong L2MC (station move)3 = MAC_SA found on correct L2MC destination
 *     F2_17_SR_FLOW_UNEXPECTED_FRAME Indicates SR frames with unexpected SR tag
 *     F2_17_SA_SAN     Indicates this Source MAC address belongs to SAN. 0: DAN, 1: SAN.
 *     F2_17_PTP_MESSAGE_TYPE Indicates the PTP message Type field.
 *     F2_11_DA         DA 
 *     F2_13_PAYLOAD_MACDA Payload MACDA 
 *     F2_5_DA          DA 
 *     F2_7_DA          DA 
 *     F2_14_PAYLOAD_SIP Payload IPV4 SIP 
 *     F2_6_SIP         SIP
 *     F2_17_PTP_SOURCE_PORT_IDENTITY Indicates the Source Port Identity of PTP message.
 *     DWF2_5_SPARE     SPARE. 
 *     DWF2_5_SPARE_MASK SPARE. 
 *     F2_0_SIP         SIP
 *     F2_1_SIP         SIP
 *     F2_12_MIML_TAG   MIML TAG 
 *     F2_17_PTP_DOMAIN_ID_MISMATCH Indicates that the packet is received from a port that does not support the packets Domain ID.
 *     F2_17_PACKET_IS_1588 Indicates this packet is a PTP packet.
 *     F2_17_TAF_BYTELEFT_IS_NULL If Gate is open at SOP and for a single cell packet "packet_byte_cnt > Gate ByteLeft Value", it will assert TAF_DROP and BYTELEFT_IS_NULL = 1.If Gate stays open from SOP to EOP for a multi cell packet and "packet_byte_cnt > Gate ByteLeft Value" at EOP, Gate will assert TAF_PURGE and BYTELEFT_IS_NULL = 1.
 *     DWF1             DWF1 field
 *     DWF1_1_PAYLOAD_L4_DST Payload L4_DST 
 *     DWF1_1_PAYLOAD_L4_DST_MASK Payload L4_DST 
 *     DWF1_0_TTL_FN1   TTL_FN1 
 *     DWF1_0_TTL_FN1_MASK TTL_FN1 
 *     DWF1_2_ROCEV1_PACKET RROCEV1 Packet.
 *     DWF1_2_ROCEV1_PACKET_MASK RROCEV1 Packet.
 *     F2_17_TAF_DROP   TAF_DROP get asserted by TAF Gate at SOP: (1) If Gate is closed or (2) Gate is open and for a single cell packet "packet_byte_cnt > Gate ByteLeft Value".
 *     F2_17_TAF_COS_PROFILE TAF COS profile assigned to a packet when packet's SOP passed through the Gate.
 *     DWF1_2_ROCEV2_PACKET RROCEV2 Packet.
 *     DWF1_2_ROCEV2_PACKET_MASK RROCEV2 Packet.
 *     DWF1_2_ROCE_BTH_FLAGS Flags.
 *     DWF1_2_ROCE_BTH_FLAGS_MASK Flags.
 *     F2_17_TAF_GATE_STATE_AT_SOP TAF Gate State when packet SOP passed through Gate:0 : Gate close1 : Gate open
 *     F2_17_TAF_GATE_ID TAF Gate ID assigned to this packet.
 *     DWF1_0_IP_FRAG_INFO IP_FRAG_INFO 
 *     DWF1_0_IP_FRAG_INFO_MASK IP_FRAG_INFO 
 *     DWF1_2_ROCE_BTH_DESTINATION_QP 24 bits QP in BTH.
 *     DWF1_2_ROCE_BTH_DESTINATION_QP_MASK 24 bits QP in BTH.
 *     DWF1_0_L4_DST    L4_DST 
 *     DWF1_0_L4_DST_MASK L4_DST 
 *     F2_12_SPARE      SPARE 
 *     F2_14_SPARE      SPARE. 
 *     F2_6_SPARE       SPARE 
 *     F2_18_PAYLOAD_TOS Indicates Payload (inner) IP TOS 
 *     F2_17_TAF_ENABLE Time Aware Filtering Policing (TAF) Enable0: TAF is disabled on ingress port for this frame.1: TAF is enabled on ingress port.
 *     F2_17_SPARE      SPARE 
 *     DWF1_1_PAYLOAD_L4_SRC Payload L4_SRC 
 *     DWF1_1_PAYLOAD_L4_SRC_MASK Payload L4_SRC 
 *     F2_18_INT_CN     Indicates INT_CN derived from outer IPhdr.ECN 
 *     F2_18_SPARE      SPARE 
 *     DWF1_0_L4_SRC    L4_SRC 
 *     DWF1_0_L4_SRC_MASK L4_SRC 
 *     F1               F1 field
 *     F1_13_AUX_TAG_1  AUX Tag 1. EHTAG, based on FP_SLICE_KEY_CONTROL.SLICE<0-7>_AUX_TAG_1_SEL setting
 *     F1_9_UDF1_31_0   UDF1_31_0
 *     F1_10_D_FIELD    D_FIELD 
 *     F1_11_SGLP       SGLP 
 *     F1_1_D_FIELD     D_FIELD 
 *     F1_2_D_FIELD     D_FIELD 
 *     F1_3_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F1_4_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F1_5_LOOKUP_STATUS LOOKUP_STATUS 
 *     F1_6_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F1_7_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F1_0_CLASSIDS    CLASSIDS 
 *     F1_12_OUTER_VLAN_ID OUTER_VLAN_ID 
 *     F1_8_IP_PROTOCOL_LAST_NH IP_PROTOCOL_LAST_NH 
 *     F1_14_MY_STATION_HIT_STATUS 1 bit my station hit.
 *     F1_15_PACKET_IS_1588 Indicates this packet is a PTP packet.
 *     F1_15_PTP_DOMAIN_ID Indicates the PTP (1588) Domain ID of this packet.
 *     F1_14_VXLAN_CLASS_ID_VALID 1 bit Class ID from VXLAN_CLASS_ID TCAM.
 *     F1_14_VXLAN_VN_ID 24 bits VXLAN ID.
 *     DWF1_1_PAYLOAD_TOS_FN Payload TOS_FN 
 *     DWF1_1_PAYLOAD_TOS_FN_MASK Payload TOS_FN 
 *     DWF1_2_ROCE_BTH_OPCODE 8 bits OPCODE in BTH.
 *     DWF1_2_ROCE_BTH_OPCODE_MASK 8 bits OPCODE in BTH.
 *     F1_8_TOS_FN      TOS_FN
 *     F1_15_PORT_PTP_DOMAIN_ID Indicates the PTP (1588) Domain IDs supported by Ingress Port as a bitmap.
 *     F1_0_FORWARDING_FIELD FORWARDING_FIELD 
 *     F1_12_CLASSIDS   CLASSIDS 
 *     DWF1_1_PAYLOAD_IP_PROTOCOL_LAST_NH Payload IP_PROTOCOL_LAST_NH 
 *     DWF1_1_PAYLOAD_IP_PROTOCOL_LAST_NH_MASK Payload IP_PROTOCOL_LAST_NH 
 *     F1_15_ROCEV1_PACKET RROCEV1 Packet.
 *     DWF1_0_D_FIELD   D_FIELD 
 *     DWF1_0_D_FIELD_MASK D_FIELD 
 *     DWF1_2_ROCE_BTH_PARTITION_KEY 16 bits Partition Key in BTH.
 *     DWF1_2_ROCE_BTH_PARTITION_KEY_MASK 16 bits Partition Key in BTH.
 *     F1_15_ROCEV2_PACKET RROCEV2 Packet.
 *     F1_15_ROCE_BTH_OPCODE 8 bits OPCODE in BTH.
 *     F1_3_INNER_VLAN_TAG INNER_VLAN_TAG 
 *     F1_4_ETHERTYPE   ETHERTYPE 
 *     F1_5_INNER_VLAN_TAG INNER_VLAN_TAG 
 *     F1_11_SVP        SVP 
 *     F1_7_CLASSIDS_11_6 CLASSIDS
 *     F1_8_CLASSIDS_11_6 CLASSIDS
 *     F1_6_PACKET_FORMAT PACKET_FORMAT 
 *     F1_10_D_TYPE     D_TYPE 
 *     F1_1_D_TYPE      D_TYPE 
 *     F1_2_D_TYPE      D_TYPE 
 *     F1_10_DGLP       DGLP 
 *     F1_1_S_FIELD     S_FIELD 
 *     F1_2_MH_OPCODE   MH_OPCODE 
 *     DWF1_1_SPARE     SPARE. 
 *     DWF1_1_SPARE_MASK SPARE. 
 *     F1_6_SWITCHING_TAG_STATUS SWITHCING_TAG_STATUS 
 *     F1_2_CLASSIDS    CLASSIDS 
 *     F1_7_FORWARDING_FIELD FORWARDING_FIELD 
 *     F1_8_FORWARDING_FIELD FORWARDING_FIELD 
 *     F1_6_MH_OPCODE   MH_OPCODE 
 *     F1_15_ROCE_BTH_PARTITION_KEY 16 bits Partition Key in BTH.
 *     F1_12_SVP        SVP 
 *     F1_0_SVP_L3_IIF  SVP_L3_IIF 
 *     F1_6_PKT_RESOLUTION PKT_RESOLUTION 
 *     F1_14_VXLAN_CLASS_ID 6 bits Class ID from VXLAN_CLASS_ID TCAM.
 *     DWF1_2_SPARE     SPARE. 
 *     DWF1_2_SPARE_MASK SPARE. 
 *     DWF1_0_D_TYPE    D_TYPE 
 *     DWF1_0_D_TYPE_MASK D_TYPE 
 *     F1_6_IP_INFO     IP_INFO 
 *     F1_11_SVP_VALID  SVP_VALID 
 *     F1_11_SPARE      SPARE 
 *     F1_4_SPARE       SPARE 
 *     F1_3_OUTER_TPID_ENCODE OUTER_TPID_ENCODE 
 *     F1_5_INNER_TPID_ENCODE INNER_TPID_ENCODE 
 *     F1_9_MPLS_INFO   MPLS_INFO 
 *     F1_13_AUX_TAG_VALID_1 AUX Tag Valid 1
 *     F1_14_VXLAN_ETHERNET VXLAN packet indication.
 *     F1_13_SPARE      SPARE 
 *     F1_6_SPARE       SPARE 
 *     DWF1_0_INT_CN    CongestionClass field in the HiGig header. 
 *     DWF1_0_INT_CN_MASK CongestionClass field in the HiGig header. 
 *     F1_14_IP_TUNNEL_TERMINATION From VFP, indicates whether to use Tunnel or Payload header fields for Hashing.
 *     F1_2_SPARE       SPARE 
 *     F1_3_SPARE       SPARE 
 *     F1_5_SPARE       SPARE 
 *     F1_9_SPARE       SPARE 
 *     F1_14_PAYLOAD_VLAN_TAG_STATUS Incoming VXLAN L2 payload VLAN tag status, 0 = untagged, 1 = single inner-tag, 2 = single outer-tag, 3 = double tagged.
 *     F1_7_MPLS_INFO   MPLS_INFO 
 *     F1_8_INT_CN      CongestionClass field in the HiGig header.
 *     F1_10_SPARE      SPARE 
 *     DWF1_0_SPARE     SPARE 
 *     DWF1_0_SPARE_MASK SPARE 
 *     F1_1_SVP_VALID   SVP_VALID 
 *     F1_1_MH_OPCODE   MH_OPCODE 
 *     F1_7_SPARE       SPARE 
 *     F1_8_SPARE       SPARE 
 *     F1_14_VNID_LOOKUP_HIT_STATUS VLAN_XLATE table VNID lookup status signal. 1 = VNID entry found in VLAN_XLATE lookup, 0 = VNID entry not found .
 *     F1_0_SPARE       SPARE 
 *     F1_14_SPARE      SPARE 
 *     RESERVED_DW      RESERVED
 *     FULL_MASK        Field created for sbus access to the entire mask portion of the TCAM
 *     MASK             F1,F2,F3, FIXED fields MASK
 *     DOUBLE_WIDE_MODE_MASK DOUBLE_WIDE_MODE_MASK
 *     DW_DOUBLE_WIDE_MODE_MASK DW_DOUBLE_WIDE_MODE_MASK
 *     DATA_MASK        SW overlay for all (F1-F4) DW mask bits
 *     DWF4_MASK        DWF4 MASK
 *     F4_MASK          F4 MASK
 *     DWF3_MASK        DWF3 field MASK
 *     FIXED_MASK       FIXED MASK
 *     FIXED_HIGIG_MASK HIGIG 
 *     FIXED_FORWARDING_TYPE_MASK FORWARDING_TYPE 
 *     FIXED_SVP_OR_L3IIF_MASK L3_TYPE 
 *     FIXED_L3_TYPE_MASK L3_TYPE 
 *     FIXED_L4_VALID_MASK L4_VALID 
 *     FIXED_L3_ROUTABLE_MASK L3_ROUTABLE 
 *     FIXED_TUNNEL_TYPE_LOOPBACK_TYPE_MASK TUNNEL_TYPE 
 *     FIXED_DROP_MASK  DROP 
 *     FIXED_MIRROR_ONLY_MASK Mirror only copy of packet. (Only possible for HG). 
 *     FIXED_MIML_PRESENT_MASK MIML Present. 
 *     FIXED_CUSTOM_HEADER_PRESENT_MASK CUSTOM_HEADER Present. 
 *     FIXED_PREEMPTABLE_FRAME_MASK Preemptable Frame Present. 
 *     FIXED_PDELAY_REQ_MASK 1588 Pdelay_Req Present. 
 *     F3_MASK          F3 field MASK
 *     F3_12_AUX_TAG_2_MASK AUX Tag 2. One of Assigned_VNTAG, CNTAG or EHTAG, based on FP_SLICE_KEY_CONTROL.SLICE<0-11>_AUX_TAG_2_SEL setting
 *     F3_9_UDF1_95_64_MASK UDF1_95_64 
 *     F3_7_RANGE_CHECK_RESULTS_MASK RANGE_CHECK_RESULTS 
 *     F3_8_IPV6_FL_MASK IPV6_FL 
 *     F3_10_D_FIELD_MASK D_FIELD 
 *     F3_11_SGLP_MASK  SGLP 
 *     F3_2_D_FIELD_MASK D_FIELD 
 *     F3_3_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F3_4_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F3_5_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F3_6_LOOKUP_STATUS_MASK LOOKUP_STATUS 
 *     F3_0_CLASSIDS_MASK CLASSIDS 
 *     F3_1_CLASSIDS_MASK CLASSIDS 
 *     F3_13_ROCEV1_PACKET_MASK RROCEV1 Packet.
 *     F3_13_ROCEV2_PACKET_MASK RROCEV2 Packet.
 *     F3_13_ROCE_BTH_FLAGS_MASK Flags.
 *     F3_13_ROCE_BTH_DESTINATION_QP_MASK 24 bits QP in BTH.
 *     DWF2_MASK        DWF2 field MASK
 *     F3_0_FORWARDING_FIELD_MASK FORWARDING_FIELD 
 *     F3_1_FORWARDING_FIELD_MASK FORWARDING_FIELD 
 *     F3_4_INNER_VLAN_TAG_MASK INNER_VLAN_TAG 
 *     F3_5_ETHERTYPE_MASK ETHERTYPE 
 *     F3_6_INNER_VLAN_TAG_MASK INNER_VLAN_TAG 
 *     F3_11_SVP_MASK   SVP 
 *     F3_3_PACKET_FORMAT_MASK PACKET_FORMAT 
 *     F3_10_D_TYPE_MASK D_TYPE 
 *     F3_2_D_TYPE_MASK D_TYPE 
 *     F3_10_DGLP_MASK  DGLP 
 *     F3_2_S_FIELD_MASK S_FIELD 
 *     F3_8_PACKET_FORMAT_MASK PACKET_FORMAT 
 *     F3_3_SWITCHING_TAG_STATUS_MASK SWITCHING_TAG_STATUS 
 *     F3_3_MH_OPCODE_MASK MH_OPCODE 
 *     F3_0_SVP_L3IIF_OVERLAY_MASK SVP_L3IIF_OVERLAY 
 *     F3_1_OUTER_VLAN_ID_MASK OUTER_VLAN_ID 
 *     F3_7_INTERFACE_CLASSID_MASK INTERFACE_CLASSID 
 *     F3_8_SWITCHING_TAG_STATUS_MASK SWITCHING_TAG_STATUS 
 *     F3_3_PKT_RESOLUTION_MASK PKT_RESOLUTION 
 *     F3_8_INNER_TPID_ENCODE_MASK INNER_TPID_ENCODE 
 *     F3_8_OUTER_TPID_ENCODE_MASK OUTER_TPID_ENCODE 
 *     F3_8_SPARE_MASK  SPARE 
 *     F3_3_IP_INFO_MASK IP_INFO 
 *     F3_11_SVP_VALID_MASK SVP_VALID 
 *     F3_11_SPARE_MASK SPARE 
 *     F3_4_SPARE_MASK  SPARE 
 *     F3_5_SPARE_MASK  SPARE 
 *     F3_6_SPARE_MASK  SPARE 
 *     F3_7_SPARE_MASK  SPARE 
 *     F3_9_MPLS_INFO_MASK MPLS_INFO 
 *     F3_12_AUX_TAG_VALID_2_MASK AUX Tag Valid 2
 *     F3_12_SPARE_MASK SPARE 
 *     F3_3_SPARE_MASK  SPARE 
 *     F3_13_SPARE_MASK SPARE 
 *     F3_9_SPARE_MASK  SPARE 
 *     F3_10_SPARE_MASK SPARE 
 *     F3_2_SVP_VALID_MASK SVP_VALID 
 *     F3_1_SPARE_MASK  SPARE 
 *     F3_2_MH_OPCODE_MASK MH_OPCODE 
 *     F3_0_SPARE_MASK  SPARE 
 *     F2_15_PAYLOAD_SIP_MASK Payload IPV6 SIP 
 *     F2_16_PAYLOAD_DIP_MASK Payload IPV6 DIP 
 *     F2_2_SIP_MASK    SIP 
 *     F2_3_DIP_MASK    DIP 
 *     F2_8_UDF1_MASK   UDF1
 *     F2_9_UDF2_MASK   UDF2
 *     F2_MASK          F2 field MASK
 *     F2_10_SIP_127_64_MASK SIP_127_64 
 *     F2_12_MIML_SA_MASK MIML SA 
 *     F2_11_DIP_127_96_MASK DIP_127_96 
 *     F2_18_OUTER_SIP_MASK Indicates Outer IPv4 SIP 
 *     F2_13_PAYLOAD_OUTER_VLAN_TAG_MASK Payload outer_vlan_tag 
 *     F2_14_PAYLOAD_L4_DST_MASK Payload L4_DST 
 *     F2_5_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F2_6_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F2_7_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F2_0_TTL_FN_MASK TTL_FN 
 *     F2_1_TTL_FN_MASK TTL_FN 
 *     F2_4_TTL_FN_MASK TTL_FN 
 *     F2_17_SR_NETID_MATCH_MASK Indicates whether the PKT.NET_ID matches the DGPP.NET_ID0: PKT.NET_ID != DGPP.NET_ID or PKT.NET_ID = 0 or DGPP.NET_ID = 01: PKT.NET_ID = DGPP.NET_IDNote that when DGPP.NET_ID = 0 or PKT.NET_ID = 0 the SR_NETID_MATCH = 0
 *     F2_17_INT_PRI_MASK Internal Priority
 *     F2_17_TSN_CIRCUIT_ID_MASK Indicates TSN circuit ID. This is the Base Circuit ID before adding the offset
 *     F2_0_TCP_FN_MASK TCP_FN 
 *     F2_1_TCP_FN_MASK TCP_FN 
 *     F2_4_TCP_FN_MASK TCP_FN 
 *     F2_4_IPV6_FL_MASK IPV6_FL 
 *     F2_0_IPFLAG_MASK IPFLAG 
 *     F2_1_IP_FRAG_INFO_MASK IP_FRAG_INFO 
 *     F2_13_PAYLOAD_ETHERTYPE_MASK Payload Ethertype 
 *     F2_14_PAYLOAD_L4_SRC_MASK Payload L4_SRC 
 *     F2_5_ETHERTYPE_MASK ETHERTYPE 
 *     F2_6_ETHERTYPE_MASK ETHERTYPE 
 *     F2_7_ETHERTYPE_MASK EtherType 
 *     F2_0_TOS_FN_MASK TOS_FN 
 *     F2_1_TOS_FN_MASK TOS_FN 
 *     F2_17_SR_FLOW_ID_MASK Indicates the Seamless Redundancy FLOW_ID. This is the Base FLOW_ID before Adding the Offset
 *     F2_0_L4_DST_MASK L4_DST 
 *     F2_1_L4_DST_MASK L4_DST 
 *     F2_17_PKT_NET_ID_VALID_MASK Indicates whether the PKT.NET_ID is valid or not. 0: not valid, 1: valid.
 *     F2_17_PKT_LAN_ID_VALID_MASK Indicates whether the PKT.LAN_ID is valid or not. 0: not valid, 1: valid.
 *     F2_11_SA_MASK    SA 
 *     F2_13_PAYLOAD_MACSA_MASK Payload MACSA 
 *     F2_5_SA_MASK     SA 
 *     F2_6_SA_MASK     SA 
 *     F2_18_OUTER_DIP_MASK Indicates Outer IPv4 DIP 
 *     F2_14_PAYLOAD_TOS_FN_MASK Payload TOS_FN 
 *     F2_7_TTL_FN_MASK TTL_FN 
 *     F2_17_SR_FLOW_RX_TAG_ERROR_MASK Indicates SR frame with SR tag error
 *     F2_17_SR_FLOW_RX_ERROR_MASK Indicates SR frames received with Error
 *     F2_4_TOS_FN_MASK TOS_FN 
 *     F2_17_VLAN_SR_LAN_ID_MASK Seamless Redundancy LAN ID assigned to this VLAN. 0 : LAN_A1 : LAN_B
 *     F2_17_VLAN_SR_ENABLE_MASK When set Indicates  that Seamless Redundancy is enabled on this VLAN
 *     F2_17_EGR_SR_MODE_MASK Seamless Redundancy mode of egress port.0 = Mode 1 1 = Mode 2 2 = Mode 3 3 = Mode 44 = Mode 5 5 = Mode 6 6 = Mode 7 7 = Mode 8
 *     F2_17_EGR_SR_NET_ID_MASK Seamless Redundancy Network ID assigned to this port.
 *     F2_0_L4_SRC_MASK L4_SRC 
 *     F2_1_L4_SRC_MASK L4_SRC 
 *     F2_14_PAYLOAD_IP_PROTOCOL_LAST_NH_MASK Payload IP_PROTOCOL_LAST_NH 
 *     F2_7_IP_PROTOCOL_LAST_NH_MASK IP_PROTOCOL_LAST_NH 
 *     F2_4_LAST_NH_MASK LAST_NH 
 *     F2_17_EGR_SR_LAN_ID_MASK Seamless Redundancy LAN ID assigned to this port. Applies when SR_ROLE = 1 or 2 (HSR or PRP) only0 : LAN_A1 : LAN_B
 *     F2_17_EGR_SR_TYPE_MASK Seamless Redundancy Type assigned to this port0 = None (Ethernet)1 = PRP2 = HSR3 = 802.1CB4 = Modified PRP5-7= reservedModified PRP is when RCT Tag is moved to start of the frame
 *     F2_17_EGR_SR_PORT_ROLE_MASK Seamless Redundancy Role of this port0: Inter-Link1: Seamless Redundancy duplicate Port
 *     F2_17_EGR_SR_ENABLE_MASK Seamless Redundancy Enable0: Seamless redundancy is disabled on this port, do standard L2 switching1: Seamless redundancy is enabled on this port
 *     F2_12_MIML_DA_MASK MIML DA 
 *     F2_14_PAYLOAD_DIP_MASK Payload IPV4 DIP 
 *     F2_7_DIP_MASK    DIP 
 *     F2_17_ING_SR_MODE_MASK Seamless Redundancy mode of ingress port.0 = Mode 1 1 = Mode 2 2 = Mode 3 3 = Mode 44 = Mode 5 5 = Mode 6 6 = Mode 7 7 = Mode 8
 *     F2_4_INT_CN_MASK CongestionClass field in the HiGig header.
 *     F2_17_ING_SR_NET_ID_MASK Seamless Redundancy Network ID assigned to this port.
 *     F2_4_SPARE_MASK  SPARE 
 *     F2_17_ING_SR_LAN_ID_MASK Seamless Redundancy LAN ID assigned to this port. Applies when SR_ROLE = 1 or 2 (HSR or PRP) only0: LAN_A1: LAN_B
 *     F2_17_ING_SR_TYPE_MASK Seamless Redundancy Type assigned to this port0 = None (Ethernet)1 = PRP2 = HSR3 = 802.1CB4 = Modified PRP5-7= reservedModified PRP is when RCT Tag is moved to start of the frame
 *     F2_0_IP_PROTOCOL_LAST_NH_MASK IP_PROTOCOL_LAST_NH 
 *     F2_1_IP_PROTOCOL_LAST_NH_MASK IP_PROTOCOL_LAST_NH 
 *     F2_17_ING_SR_PORT_ROLE_MASK Seamless Redundancy Role of this port0: Inter-Link1: Seamless Redundancy duplicate Port
 *     F2_17_ING_SR_ENABLE_MASK Seamless Redundancy Enable0: Seamless redundancy is disabled on this port, do standard L2 switching1: Seamless redundancy is enabled on this port
 *     F2_17_PKT_NET_ID_MASK The NET_ID encoded in the SR Tag of this pack. Applies to PKT.SR_TYPE = PRP only0: Reserved for HSR 1-7: NET_ID
 *     F2_17_PKT_LAN_ID_MASK The LAN_ID encoded in the SR Tag of this packet. Applies to PKT.SR_TYPE = HSR or PRP 0: LAN_A1: LAN_B
 *     F2_10_DIP_127_64_MASK DIP_127_64 
 *     F2_4_DIP_127_64_MASK DIP_127_64 
 *     F2_18_INNER_PAYLOAD_DA_MASK Indicates Inner MACDA 
 *     F2_0_DIP_MASK    DIP
 *     F2_1_DIP_MASK    DIP
 *     F2_17_PKT_SR_TYPE_MASK Seamless Redundancy Tag Type of this packet0: None (standard Ethernet )1: PRP 2: HSR 3: 802.1CB 4: Modified PRP5-7: reservedModified PRP is when RCT Tag is moved to start of the frame
 *     F2_17_SR_ETHERTYPE_MASK Indicates whether this packet has SR supervisory Ethertype or not0 = Non-Supervisory Ethertype1 = PRP/HSR Supervisory Ethertype 1 (default for HSR/PRP)2 = PRP/HSR Supervisory Ethertype 23 = 801.CB Supervisory Ethertype
 *     F2_17_DA_TYPE_MASK Indicates the Destination MAC Type:0 = Default, MAC_DA is an SR_MAC_ADDRESS (DAN)1 = MAC_DA is a LINK_LOCAL_MAC_ADDRESS2 = MAC_DA belonging to SAN3 = MAC_DA is a SR_SUPERVISORY_MAC_ADDRES address for HSR. PRP or 802.1CB
 *     F2_17_DA_HIT_MASK 0 = MAC_DA not found in L2 Table1 = MAC_DA found in L2 Table and result is a DGPP2 = MAC_DA found in L2 Table and result is an L2MC3 = reserved
 *     F2_17_SA_HIT_MASK 0 = MAC_SA not found in L2 Table1 = MAC_SA found in L2 Table on the correct port or correct L2MC2 = MAC_SA found in L2 Table on a wrong port or wrong L2MC (station move)3 = MAC_SA found on correct L2MC destination
 *     F2_17_SR_FLOW_UNEXPECTED_FRAME_MASK Indicates SR frames with unexpected SR tag
 *     F2_17_SA_SAN_MASK Indicates this Source MAC address belongs to SAN. 0: DAN, 1: SAN.
 *     F2_17_PTP_MESSAGE_TYPE_MASK Indicates the PTP message Type field.
 *     F2_11_DA_MASK    DA 
 *     F2_13_PAYLOAD_MACDA_MASK Payload MACDA 
 *     F2_5_DA_MASK     DA 
 *     F2_7_DA_MASK     DA 
 *     F2_14_PAYLOAD_SIP_MASK Payload IPV4 SIP 
 *     F2_6_SIP_MASK    SIP
 *     F2_17_PTP_SOURCE_PORT_IDENTITY_MASK Indicates the Source Port Identity of PTP message.
 *     F2_0_SIP_MASK    SIP
 *     F2_1_SIP_MASK    SIP
 *     F2_12_MIML_TAG_MASK MIML TAG 
 *     F2_17_PTP_DOMAIN_ID_MISMATCH_MASK Indicates that the packet is received from a port that does not support the packets Domain ID.
 *     F2_17_PACKET_IS_1588_MASK Indicates this packet is a PTP packet.
 *     F2_17_TAF_BYTELEFT_IS_NULL_MASK If Gate is open at SOP and for a single cell packet "packet_byte_cnt > Gate ByteLeft Value", it will assert TAF_DROP and BYTELEFT_IS_NULL = 1.If Gate stays open from SOP to EOP for a multi cell packet and "packet_byte_cnt > Gate ByteLeft Value" at EOP, Gate will assert TAF_PURGE and BYTELEFT_IS_NULL = 1.
 *     DWF1_MASK        DWF1 field MASK
 *     F2_17_TAF_DROP_MASK TAF_DROP get asserted by TAF Gate at SOP: (1) If Gate is closed or (2) Gate is open and for a single cell packet "packet_byte_cnt > Gate ByteLeft Value".
 *     F2_17_TAF_COS_PROFILE_MASK TAF COS profile assigned to a packet when packet's SOP passed through the Gate.
 *     F2_17_TAF_GATE_STATE_AT_SOP_MASK TAF Gate State when packet SOP passed through Gate:0 : Gate close1 : Gate open
 *     F2_17_TAF_GATE_ID_MASK TAF Gate ID assigned to this packet.
 *     F2_12_SPARE_MASK SPARE 
 *     F2_14_SPARE_MASK SPARE. 
 *     F2_6_SPARE_MASK  SPARE 
 *     F2_18_PAYLOAD_TOS_MASK Indicates Payload (inner) IP TOS 
 *     F2_17_TAF_ENABLE_MASK Time Aware Filtering Policing (TAF) Enable0: TAF is disabled on ingress port for this frame.1: TAF is enabled on ingress port.
 *     F2_17_SPARE_MASK SPARE 
 *     F2_18_INT_CN_MASK Indicates INT_CN derived from outer IPhdr.ECN 
 *     F2_18_SPARE_MASK SPARE 
 *     F1_MASK          F1 field MASK
 *     F1_13_AUX_TAG_1_MASK AUX Tag 1. EHTAG, based on FP_SLICE_KEY_CONTROL.SLICE<0-7>_AUX_TAG_1_SEL setting
 *     F1_9_UDF1_31_0_MASK UDF1_31_0
 *     F1_10_D_FIELD_MASK D_FIELD 
 *     F1_11_SGLP_MASK  SGLP 
 *     F1_1_D_FIELD_MASK D_FIELD 
 *     F1_2_D_FIELD_MASK D_FIELD 
 *     F1_3_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F1_4_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F1_5_LOOKUP_STATUS_MASK LOOKUP_STATUS 
 *     F1_6_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F1_7_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F1_0_CLASSIDS_MASK CLASSIDS 
 *     F1_12_OUTER_VLAN_ID_MASK OUTER_VLAN_ID 
 *     F1_8_IP_PROTOCOL_LAST_NH_MASK IP_PROTOCOL_LAST_NH 
 *     F1_14_MY_STATION_HIT_STATUS_MASK 1 bit my station hit.
 *     F1_15_PACKET_IS_1588_MASK Indicates this packet is a PTP packet.
 *     F1_15_PTP_DOMAIN_ID_MASK Indicates the PTP (1588) Domain ID of this packet.
 *     F1_14_VXLAN_CLASS_ID_VALID_MASK 1 bit Class ID from VXLAN_CLASS_ID TCAM.
 *     F1_14_VXLAN_VN_ID_MASK 24 bits VXLAN ID.
 *     F1_8_TOS_FN_MASK TOS_FN
 *     F1_15_PORT_PTP_DOMAIN_ID_MASK Indicates the PTP (1588) Domain IDs supported by Ingress Port as a bitmap.
 *     F1_0_FORWARDING_FIELD_MASK FORWARDING_FIELD 
 *     F1_12_CLASSIDS_MASK CLASSIDS 
 *     F1_15_ROCEV1_PACKET_MASK RROCEV1 Packet.
 *     F1_15_ROCEV2_PACKET_MASK RROCEV2 Packet.
 *     F1_15_ROCE_BTH_OPCODE_MASK 8 bits OPCODE in BTH.
 *     F1_3_INNER_VLAN_TAG_MASK INNER_VLAN_TAG 
 *     F1_4_ETHERTYPE_MASK ETHERTYPE 
 *     F1_5_INNER_VLAN_TAG_MASK INNER_VLAN_TAG 
 *     F1_11_SVP_MASK   SVP 
 *     F1_7_CLASSIDS_11_6_MASK CLASSIDS
 *     F1_8_CLASSIDS_11_6_MASK CLASSIDS
 *     F1_6_PACKET_FORMAT_MASK PACKET_FORMAT 
 *     F1_10_D_TYPE_MASK D_TYPE 
 *     F1_1_D_TYPE_MASK D_TYPE 
 *     F1_2_D_TYPE_MASK D_TYPE 
 *     F1_10_DGLP_MASK  DGLP 
 *     F1_1_S_FIELD_MASK S_FIELD 
 *     F1_2_MH_OPCODE_MASK MH_OPCODE 
 *     F1_6_SWITCHING_TAG_STATUS_MASK SWITHCING_TAG_STATUS 
 *     F1_2_CLASSIDS_MASK CLASSIDS 
 *     F1_7_FORWARDING_FIELD_MASK FORWARDING_FIELD 
 *     F1_8_FORWARDING_FIELD_MASK FORWARDING_FIELD 
 *     F1_6_MH_OPCODE_MASK MH_OPCODE 
 *     F1_15_ROCE_BTH_PARTITION_KEY_MASK 16 bits Partition Key in BTH.
 *     F1_12_SVP_MASK   SVP 
 *     F1_0_SVP_L3_IIF_MASK SVP_L3_IIF 
 *     F1_6_PKT_RESOLUTION_MASK PKT_RESOLUTION 
 *     F1_14_VXLAN_CLASS_ID_MASK 6 bits Class ID from VXLAN_CLASS_ID TCAM.
 *     F1_6_IP_INFO_MASK IP_INFO 
 *     F1_11_SVP_VALID_MASK SVP_VALID 
 *     F1_11_SPARE_MASK SPARE 
 *     F1_4_SPARE_MASK  SPARE 
 *     F1_3_OUTER_TPID_ENCODE_MASK OUTER_TPID_ENCODE 
 *     F1_5_INNER_TPID_ENCODE_MASK INNER_TPID_ENCODE 
 *     F1_9_MPLS_INFO_MASK MPLS_INFO 
 *     F1_13_AUX_TAG_VALID_1_MASK AUX Tag Valid 1
 *     F1_14_VXLAN_ETHERNET_MASK VXLAN packet indication.
 *     F1_13_SPARE_MASK SPARE 
 *     F1_6_SPARE_MASK  SPARE 
 *     F1_14_IP_TUNNEL_TERMINATION_MASK From VFP, indicates whether to use Tunnel or Payload header fields for Hashing.
 *     F1_2_SPARE_MASK  SPARE 
 *     F1_3_SPARE_MASK  SPARE 
 *     F1_5_SPARE_MASK  SPARE 
 *     F1_9_SPARE_MASK  SPARE 
 *     F1_14_PAYLOAD_VLAN_TAG_STATUS_MASK Incoming VXLAN L2 payload VLAN tag status, 0 = untagged, 1 = single inner-tag, 2 = single outer-tag, 3 = double tagged.
 *     F1_7_MPLS_INFO_MASK MPLS_INFO 
 *     F1_8_INT_CN_MASK CongestionClass field in the HiGig header.
 *     F1_10_SPARE_MASK SPARE 
 *     F1_1_SVP_VALID_MASK SVP_VALID 
 *     F1_1_MH_OPCODE_MASK MH_OPCODE 
 *     F1_7_SPARE_MASK  SPARE 
 *     F1_8_SPARE_MASK  SPARE 
 *     F1_14_VNID_LOOKUP_HIT_STATUS_MASK VLAN_XLATE table VNID lookup status signal. 1 = VNID entry found in VLAN_XLATE lookup, 0 = VNID entry not found .
 *     F1_0_SPARE_MASK  SPARE 
 *     F1_14_SPARE_MASK SPARE 
 *     RESERVED_DW_MASK RESERVED_MASK
 */
#define FP_TCAMm_MIN 0
#define FP_TCAMm_MAX 1023
#define FP_TCAMm_CMAX(u) 1023
#define FP_TCAMm_SIZE 60

/*
 * This structure should be used to declare and program FP_TCAM.
 */
typedef union FP_TCAMm_s {
	uint32 v[15];
	uint32 fp_tcam[15];
	uint32 _fp_tcam;
} FP_TCAMm_t;

#define FP_TCAMm_CLR(r) sal_memset(&((r)._fp_tcam), 0, sizeof(FP_TCAMm_t))
#define FP_TCAMm_SET(r,i,d) (r).fp_tcam[i] = d
#define FP_TCAMm_GET(r,i) (r).fp_tcam[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_TCAMm_VALIDf_GET(r) (((r).fp_tcam[0]) & 0x3)
#define FP_TCAMm_VALIDf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_TCAMm_FULL_KEYf_GET(r,a) field_get((r).fp_tcam,2,237,a)
#define FP_TCAMm_FULL_KEYf_SET(r,a) field_set((r).fp_tcam,2,237,a)
#define FP_TCAMm_KEYf_GET(r,a) field_get((r).fp_tcam,2,237,a)
#define FP_TCAMm_KEYf_SET(r,a) field_set((r).fp_tcam,2,237,a)
#define FP_TCAMm_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_tcam[0]) >> 2) & 0x1)
#define FP_TCAMm_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_TCAMm_DW_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_tcam[0]) >> 2) & 0x1)
#define FP_TCAMm_DW_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_TCAMm_DATA_KEYf_GET(r,a) field_get((r).fp_tcam,3,237,a)
#define FP_TCAMm_DATA_KEYf_SET(r,a) field_set((r).fp_tcam,3,237,a)
#define FP_TCAMm_DWF4f_GET(r) ((((r).fp_tcam[0]) >> 3) & 0xff)
#define FP_TCAMm_DWF4f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define FP_TCAMm_DWF4_0_PORT_FIELD_SEL_TABLE_INDEXf_GET(r) ((((r).fp_tcam[0]) >> 3) & 0xff)
#define FP_TCAMm_DWF4_0_PORT_FIELD_SEL_TABLE_INDEXf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define FP_TCAMm_DWF4_0_PORT_FIELD_SEL_TABLE_INDEX_MASKf_GET(r) ((((r).fp_tcam[0]) >> 3) & 0xff)
#define FP_TCAMm_DWF4_0_PORT_FIELD_SEL_TABLE_INDEX_MASKf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define FP_TCAMm_F4f_GET(r) ((((r).fp_tcam[0]) >> 3) & 0xff)
#define FP_TCAMm_F4f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define FP_TCAMm_DWF4_1_TCP_FNf_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x3f)
#define FP_TCAMm_DWF4_1_TCP_FNf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x3f << 3)) | ((((uint32)f) & 0x3f) << 3))
#define FP_TCAMm_DWF4_1_TCP_FN_MASKf_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x3f)
#define FP_TCAMm_DWF4_1_TCP_FN_MASKf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x3f << 3)) | ((((uint32)f) & 0x3f) << 3))
#define FP_TCAMm_DWF4_1_SPAREf_GET(r) ((((r).fp_tcam[0]) >> 9) & 0x3)
#define FP_TCAMm_DWF4_1_SPAREf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define FP_TCAMm_DWF4_1_SPARE_MASKf_GET(r) ((((r).fp_tcam[0]) >> 9) & 0x3)
#define FP_TCAMm_DWF4_1_SPARE_MASKf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define FP_TCAMm_DWF3f_GET(r) field32_get((r).fp_tcam,11,42)
#define FP_TCAMm_DWF3f_SET(r,f) field32_set((r).fp_tcam,11,42,f)
#define FP_TCAMm_FIXEDf_GET(r) ((((r).fp_tcam[0]) >> 11) & 0x1fffff)
#define FP_TCAMm_FIXEDf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1fffff << 11)) | ((((uint32)f) & 0x1fffff) << 11))
#define FP_TCAMm_FIXED_HIGIGf_GET(r) ((((r).fp_tcam[0]) >> 11) & 0x1)
#define FP_TCAMm_FIXED_HIGIGf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_TCAMm_FIXED_FORWARDING_TYPEf_GET(r) ((((r).fp_tcam[0]) >> 12) & 0x7)
#define FP_TCAMm_FIXED_FORWARDING_TYPEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define FP_TCAMm_FIXED_SVP_OR_L3IIFf_GET(r) ((((r).fp_tcam[0]) >> 15) & 0x1)
#define FP_TCAMm_FIXED_SVP_OR_L3IIFf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define FP_TCAMm_FIXED_L3_TYPEf_GET(r) ((((r).fp_tcam[0]) >> 16) & 0xf)
#define FP_TCAMm_FIXED_L3_TYPEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define FP_TCAMm_FIXED_L4_VALIDf_GET(r) ((((r).fp_tcam[0]) >> 20) & 0x1)
#define FP_TCAMm_FIXED_L4_VALIDf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_TCAMm_FIXED_L3_ROUTABLEf_GET(r) ((((r).fp_tcam[0]) >> 21) & 0x1)
#define FP_TCAMm_FIXED_L3_ROUTABLEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define FP_TCAMm_FIXED_TUNNEL_TYPE_LOOPBACK_TYPEf_GET(r) ((((r).fp_tcam[0]) >> 22) & 0xf)
#define FP_TCAMm_FIXED_TUNNEL_TYPE_LOOPBACK_TYPEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0xf << 22)) | ((((uint32)f) & 0xf) << 22))
#define FP_TCAMm_FIXED_DROPf_GET(r) ((((r).fp_tcam[0]) >> 26) & 0x1)
#define FP_TCAMm_FIXED_DROPf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define FP_TCAMm_FIXED_MIRROR_ONLYf_GET(r) ((((r).fp_tcam[0]) >> 27) & 0x1)
#define FP_TCAMm_FIXED_MIRROR_ONLYf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define FP_TCAMm_FIXED_MIML_PRESENTf_GET(r) ((((r).fp_tcam[0]) >> 28) & 0x1)
#define FP_TCAMm_FIXED_MIML_PRESENTf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define FP_TCAMm_FIXED_CUSTOM_HEADER_PRESENTf_GET(r) ((((r).fp_tcam[0]) >> 29) & 0x1)
#define FP_TCAMm_FIXED_CUSTOM_HEADER_PRESENTf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define FP_TCAMm_FIXED_PREEMPTABLE_FRAMEf_GET(r) ((((r).fp_tcam[0]) >> 30) & 0x1)
#define FP_TCAMm_FIXED_PREEMPTABLE_FRAMEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define FP_TCAMm_FIXED_PDELAY_REQf_GET(r) ((((r).fp_tcam[0]) >> 31) & 0x1)
#define FP_TCAMm_FIXED_PDELAY_REQf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define FP_TCAMm_F3f_GET(r,a) field_get((r).fp_tcam,32,70,a)
#define FP_TCAMm_F3f_SET(r,a) field_set((r).fp_tcam,32,70,a)
#define FP_TCAMm_F3_12_AUX_TAG_2f_GET(r) ((r).fp_tcam[1])
#define FP_TCAMm_F3_12_AUX_TAG_2f_SET(r,f) (r).fp_tcam[1]=((uint32)f)
#define FP_TCAMm_F3_9_UDF1_95_64f_GET(r) ((r).fp_tcam[1])
#define FP_TCAMm_F3_9_UDF1_95_64f_SET(r,f) (r).fp_tcam[1]=((uint32)f)
#define FP_TCAMm_F3_7_RANGE_CHECK_RESULTSf_GET(r) (((r).fp_tcam[1]) & 0xffffff)
#define FP_TCAMm_F3_7_RANGE_CHECK_RESULTSf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffffff)) | (((uint32)f) & 0xffffff))
#define FP_TCAMm_F3_8_IPV6_FLf_GET(r) (((r).fp_tcam[1]) & 0xfffff)
#define FP_TCAMm_F3_8_IPV6_FLf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xfffff)) | (((uint32)f) & 0xfffff))
#define FP_TCAMm_F3_10_D_FIELDf_GET(r) (((r).fp_tcam[1]) & 0xffff)
#define FP_TCAMm_F3_10_D_FIELDf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define FP_TCAMm_F3_11_SGLPf_GET(r) (((r).fp_tcam[1]) & 0xffff)
#define FP_TCAMm_F3_11_SGLPf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define FP_TCAMm_F3_2_D_FIELDf_GET(r) (((r).fp_tcam[1]) & 0xffff)
#define FP_TCAMm_F3_2_D_FIELDf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define FP_TCAMm_F3_3_OUTER_VLAN_TAGf_GET(r) (((r).fp_tcam[1]) & 0xffff)
#define FP_TCAMm_F3_3_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define FP_TCAMm_F3_4_OUTER_VLAN_TAGf_GET(r) (((r).fp_tcam[1]) & 0xffff)
#define FP_TCAMm_F3_4_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define FP_TCAMm_F3_5_OUTER_VLAN_TAGf_GET(r) (((r).fp_tcam[1]) & 0xffff)
#define FP_TCAMm_F3_5_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define FP_TCAMm_F3_6_LOOKUP_STATUSf_GET(r) (((r).fp_tcam[1]) & 0xffff)
#define FP_TCAMm_F3_6_LOOKUP_STATUSf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define FP_TCAMm_F3_0_CLASSIDSf_GET(r) (((r).fp_tcam[1]) & 0xfff)
#define FP_TCAMm_F3_0_CLASSIDSf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define FP_TCAMm_F3_1_CLASSIDSf_GET(r) (((r).fp_tcam[1]) & 0xfff)
#define FP_TCAMm_F3_1_CLASSIDSf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define FP_TCAMm_F3_13_ROCEV1_PACKETf_GET(r) (((r).fp_tcam[1]) & 0x1)
#define FP_TCAMm_F3_13_ROCEV1_PACKETf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define FP_TCAMm_F3_13_ROCEV2_PACKETf_GET(r) ((((r).fp_tcam[1]) >> 1) & 0x1)
#define FP_TCAMm_F3_13_ROCEV2_PACKETf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_TCAMm_F3_13_ROCE_BTH_FLAGSf_GET(r) ((((r).fp_tcam[1]) >> 2) & 0xff)
#define FP_TCAMm_F3_13_ROCE_BTH_FLAGSf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define FP_TCAMm_F3_13_ROCE_BTH_DESTINATION_QPf_GET(r) field32_get((r).fp_tcam,42,65)
#define FP_TCAMm_F3_13_ROCE_BTH_DESTINATION_QPf_SET(r,f) field32_set((r).fp_tcam,42,65,f)
#define FP_TCAMm_DWF2f_GET(r,a) field_get((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2f_SET(r,a) field_set((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_1_SIPf_GET(r,a) field_get((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_1_SIPf_SET(r,a) field_set((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_1_SIP_MASKf_GET(r,a) field_get((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_1_SIP_MASKf_SET(r,a) field_set((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_2_DIPf_GET(r,a) field_get((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_2_DIPf_SET(r,a) field_set((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_2_DIP_MASKf_GET(r,a) field_get((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_2_DIP_MASKf_SET(r,a) field_set((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_3_UDF2f_GET(r,a) field_get((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_3_UDF2f_SET(r,a) field_set((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_3_UDF2_MASKf_GET(r,a) field_get((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_3_UDF2_MASKf_SET(r,a) field_set((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_6_PAYLOAD_SIPf_GET(r,a) field_get((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_6_PAYLOAD_SIPf_SET(r,a) field_set((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_6_PAYLOAD_SIP_MASKf_GET(r,a) field_get((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_6_PAYLOAD_SIP_MASKf_SET(r,a) field_set((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_7_PAYLOAD_DIPf_GET(r,a) field_get((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_7_PAYLOAD_DIPf_SET(r,a) field_set((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_7_PAYLOAD_DIP_MASKf_GET(r,a) field_get((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_7_PAYLOAD_DIP_MASKf_SET(r,a) field_set((r).fp_tcam,43,170,a)
#define FP_TCAMm_DWF2_0_SPAREf_GET(r) ((((r).fp_tcam[1]) >> 11) & 0xffff)
#define FP_TCAMm_DWF2_0_SPAREf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 11)) | ((((uint32)f) & 0xffff) << 11))
#define FP_TCAMm_DWF2_0_SPARE_MASKf_GET(r) ((((r).fp_tcam[1]) >> 11) & 0xffff)
#define FP_TCAMm_DWF2_0_SPARE_MASKf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 11)) | ((((uint32)f) & 0xffff) << 11))
#define FP_TCAMm_DWF2_4_PAYLOAD_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[1]) >> 11) & 0xffff)
#define FP_TCAMm_DWF2_4_PAYLOAD_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 11)) | ((((uint32)f) & 0xffff) << 11))
#define FP_TCAMm_DWF2_4_PAYLOAD_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[1]) >> 11) & 0xffff)
#define FP_TCAMm_DWF2_4_PAYLOAD_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 11)) | ((((uint32)f) & 0xffff) << 11))
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_DSTf_GET(r) ((((r).fp_tcam[1]) >> 11) & 0xffff)
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_DSTf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 11)) | ((((uint32)f) & 0xffff) << 11))
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_DST_MASKf_GET(r) ((((r).fp_tcam[1]) >> 11) & 0xffff)
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_DST_MASKf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 11)) | ((((uint32)f) & 0xffff) << 11))
#define FP_TCAMm_F3_0_FORWARDING_FIELDf_GET(r) ((((r).fp_tcam[1]) >> 12) & 0xfff)
#define FP_TCAMm_F3_0_FORWARDING_FIELDf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))
#define FP_TCAMm_F3_1_FORWARDING_FIELDf_GET(r) ((((r).fp_tcam[1]) >> 12) & 0xfff)
#define FP_TCAMm_F3_1_FORWARDING_FIELDf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))
#define FP_TCAMm_F3_4_INNER_VLAN_TAGf_GET(r) ((((r).fp_tcam[1]) >> 16) & 0xffff)
#define FP_TCAMm_F3_4_INNER_VLAN_TAGf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))
#define FP_TCAMm_F3_5_ETHERTYPEf_GET(r) ((((r).fp_tcam[1]) >> 16) & 0xffff)
#define FP_TCAMm_F3_5_ETHERTYPEf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))
#define FP_TCAMm_F3_6_INNER_VLAN_TAGf_GET(r) ((((r).fp_tcam[1]) >> 16) & 0xffff)
#define FP_TCAMm_F3_6_INNER_VLAN_TAGf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))
#define FP_TCAMm_F3_11_SVPf_GET(r) ((((r).fp_tcam[1]) >> 16) & 0x7fff)
#define FP_TCAMm_F3_11_SVPf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x7fff << 16)) | ((((uint32)f) & 0x7fff) << 16))
#define FP_TCAMm_F3_3_PACKET_FORMATf_GET(r) ((((r).fp_tcam[1]) >> 16) & 0xf)
#define FP_TCAMm_F3_3_PACKET_FORMATf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define FP_TCAMm_F3_10_D_TYPEf_GET(r) ((((r).fp_tcam[1]) >> 16) & 0x7)
#define FP_TCAMm_F3_10_D_TYPEf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x7 << 16)) | ((((uint32)f) & 0x7) << 16))
#define FP_TCAMm_F3_2_D_TYPEf_GET(r) ((((r).fp_tcam[1]) >> 16) & 0x7)
#define FP_TCAMm_F3_2_D_TYPEf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x7 << 16)) | ((((uint32)f) & 0x7) << 16))
#define FP_TCAMm_F3_10_DGLPf_GET(r) field32_get((r).fp_tcam,51,66)
#define FP_TCAMm_F3_10_DGLPf_SET(r,f) field32_set((r).fp_tcam,51,66,f)
#define FP_TCAMm_F3_2_S_FIELDf_GET(r) field32_get((r).fp_tcam,51,66)
#define FP_TCAMm_F3_2_S_FIELDf_SET(r,f) field32_set((r).fp_tcam,51,66,f)
#define FP_TCAMm_F3_8_PACKET_FORMATf_GET(r) ((((r).fp_tcam[1]) >> 20) & 0xf)
#define FP_TCAMm_F3_8_PACKET_FORMATf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define FP_TCAMm_F3_3_SWITCHING_TAG_STATUSf_GET(r) ((((r).fp_tcam[1]) >> 20) & 0x3)
#define FP_TCAMm_F3_3_SWITCHING_TAG_STATUSf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define FP_TCAMm_F3_3_MH_OPCODEf_GET(r) ((((r).fp_tcam[1]) >> 22) & 0x7)
#define FP_TCAMm_F3_3_MH_OPCODEf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x7 << 22)) | ((((uint32)f) & 0x7) << 22))
#define FP_TCAMm_F3_0_SVP_L3IIF_OVERLAYf_GET(r) field32_get((r).fp_tcam,56,68)
#define FP_TCAMm_F3_0_SVP_L3IIF_OVERLAYf_SET(r,f) field32_set((r).fp_tcam,56,68,f)
#define FP_TCAMm_F3_1_OUTER_VLAN_IDf_GET(r) field32_get((r).fp_tcam,56,67)
#define FP_TCAMm_F3_1_OUTER_VLAN_IDf_SET(r,f) field32_set((r).fp_tcam,56,67,f)
#define FP_TCAMm_F3_7_INTERFACE_CLASSIDf_GET(r) ((((r).fp_tcam[1]) >> 24) & 0xff)
#define FP_TCAMm_F3_7_INTERFACE_CLASSIDf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define FP_TCAMm_F3_8_SWITCHING_TAG_STATUSf_GET(r) ((((r).fp_tcam[1]) >> 24) & 0x3)
#define FP_TCAMm_F3_8_SWITCHING_TAG_STATUSf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define FP_TCAMm_F3_3_PKT_RESOLUTIONf_GET(r) ((((r).fp_tcam[1]) >> 25) & 0x1f)
#define FP_TCAMm_F3_3_PKT_RESOLUTIONf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x1f << 25)) | ((((uint32)f) & 0x1f) << 25))
#define FP_TCAMm_F3_8_INNER_TPID_ENCODEf_GET(r) ((((r).fp_tcam[1]) >> 26) & 0x3)
#define FP_TCAMm_F3_8_INNER_TPID_ENCODEf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define FP_TCAMm_DWF2_0_LOOKUP_STATUSf_GET(r) field32_get((r).fp_tcam,59,74)
#define FP_TCAMm_DWF2_0_LOOKUP_STATUSf_SET(r,f) field32_set((r).fp_tcam,59,74,f)
#define FP_TCAMm_DWF2_0_LOOKUP_STATUS_MASKf_GET(r) field32_get((r).fp_tcam,59,74)
#define FP_TCAMm_DWF2_0_LOOKUP_STATUS_MASKf_SET(r,f) field32_set((r).fp_tcam,59,74,f)
#define FP_TCAMm_DWF2_4_PAYLOAD_ETHERTYPEf_GET(r) field32_get((r).fp_tcam,59,74)
#define FP_TCAMm_DWF2_4_PAYLOAD_ETHERTYPEf_SET(r,f) field32_set((r).fp_tcam,59,74,f)
#define FP_TCAMm_DWF2_4_PAYLOAD_ETHERTYPE_MASKf_GET(r) field32_get((r).fp_tcam,59,74)
#define FP_TCAMm_DWF2_4_PAYLOAD_ETHERTYPE_MASKf_SET(r,f) field32_set((r).fp_tcam,59,74,f)
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_SRCf_GET(r) field32_get((r).fp_tcam,59,74)
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_SRCf_SET(r,f) field32_set((r).fp_tcam,59,74,f)
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_SRC_MASKf_GET(r) field32_get((r).fp_tcam,59,74)
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_SRC_MASKf_SET(r,f) field32_set((r).fp_tcam,59,74,f)
#define FP_TCAMm_F3_8_OUTER_TPID_ENCODEf_GET(r) ((((r).fp_tcam[1]) >> 28) & 0x3)
#define FP_TCAMm_F3_8_OUTER_TPID_ENCODEf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define FP_TCAMm_F3_8_SPAREf_GET(r) field32_get((r).fp_tcam,62,70)
#define FP_TCAMm_F3_8_SPAREf_SET(r,f) field32_set((r).fp_tcam,62,70,f)
#define FP_TCAMm_F3_3_IP_INFOf_GET(r) field32_get((r).fp_tcam,62,64)
#define FP_TCAMm_F3_3_IP_INFOf_SET(r,f) field32_set((r).fp_tcam,62,64,f)
#define FP_TCAMm_F3_11_SVP_VALIDf_GET(r) ((((r).fp_tcam[1]) >> 31) & 0x1)
#define FP_TCAMm_F3_11_SVP_VALIDf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define FP_TCAMm_F3_11_SPAREf_GET(r) (((r).fp_tcam[2]) & 0x7f)
#define FP_TCAMm_F3_11_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define FP_TCAMm_F3_4_SPAREf_GET(r) (((r).fp_tcam[2]) & 0x7f)
#define FP_TCAMm_F3_4_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define FP_TCAMm_F3_5_SPAREf_GET(r) (((r).fp_tcam[2]) & 0x7f)
#define FP_TCAMm_F3_5_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define FP_TCAMm_F3_6_SPAREf_GET(r) (((r).fp_tcam[2]) & 0x7f)
#define FP_TCAMm_F3_6_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define FP_TCAMm_F3_7_SPAREf_GET(r) (((r).fp_tcam[2]) & 0x7f)
#define FP_TCAMm_F3_7_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define FP_TCAMm_F3_9_MPLS_INFOf_GET(r) (((r).fp_tcam[2]) & 0x3)
#define FP_TCAMm_F3_9_MPLS_INFOf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_TCAMm_F3_12_AUX_TAG_VALID_2f_GET(r) (((r).fp_tcam[2]) & 0x1)
#define FP_TCAMm_F3_12_AUX_TAG_VALID_2f_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define FP_TCAMm_F3_12_SPAREf_GET(r) ((((r).fp_tcam[2]) >> 1) & 0x3f)
#define FP_TCAMm_F3_12_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3f << 1)) | ((((uint32)f) & 0x3f) << 1))
#define FP_TCAMm_F3_3_SPAREf_GET(r) ((((r).fp_tcam[2]) >> 1) & 0x3f)
#define FP_TCAMm_F3_3_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3f << 1)) | ((((uint32)f) & 0x3f) << 1))
#define FP_TCAMm_F3_13_SPAREf_GET(r) ((((r).fp_tcam[2]) >> 2) & 0x1f)
#define FP_TCAMm_F3_13_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x1f << 2)) | ((((uint32)f) & 0x1f) << 2))
#define FP_TCAMm_F3_9_SPAREf_GET(r) ((((r).fp_tcam[2]) >> 2) & 0x1f)
#define FP_TCAMm_F3_9_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x1f << 2)) | ((((uint32)f) & 0x1f) << 2))
#define FP_TCAMm_F3_10_SPAREf_GET(r) ((((r).fp_tcam[2]) >> 3) & 0xf)
#define FP_TCAMm_F3_10_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xf << 3)) | ((((uint32)f) & 0xf) << 3))
#define FP_TCAMm_F3_2_SVP_VALIDf_GET(r) ((((r).fp_tcam[2]) >> 3) & 0x1)
#define FP_TCAMm_F3_2_SVP_VALIDf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define FP_TCAMm_F3_1_SPAREf_GET(r) ((((r).fp_tcam[2]) >> 4) & 0x7)
#define FP_TCAMm_F3_1_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_TCAMm_F3_2_MH_OPCODEf_GET(r) ((((r).fp_tcam[2]) >> 4) & 0x7)
#define FP_TCAMm_F3_2_MH_OPCODEf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_TCAMm_F3_0_SPAREf_GET(r) ((((r).fp_tcam[2]) >> 5) & 0x3)
#define FP_TCAMm_F3_0_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3 << 5)) | ((((uint32)f) & 0x3) << 5))
#define FP_TCAMm_F2f_GET(r,a) field_get((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2f_SET(r,a) field_set((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_15_PAYLOAD_SIPf_GET(r,a) field_get((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_15_PAYLOAD_SIPf_SET(r,a) field_set((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_16_PAYLOAD_DIPf_GET(r,a) field_get((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_16_PAYLOAD_DIPf_SET(r,a) field_set((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_2_SIPf_GET(r,a) field_get((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_2_SIPf_SET(r,a) field_set((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_3_DIPf_GET(r,a) field_get((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_3_DIPf_SET(r,a) field_set((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_8_UDF1f_GET(r,a) field_get((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_8_UDF1f_SET(r,a) field_set((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_9_UDF2f_GET(r,a) field_get((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_9_UDF2f_SET(r,a) field_set((r).fp_tcam,71,198,a)
#define FP_TCAMm_F2_10_SIP_127_64f_GET(r,a) field_get((r).fp_tcam,71,134,a)
#define FP_TCAMm_F2_10_SIP_127_64f_SET(r,a) field_set((r).fp_tcam,71,134,a)
#define FP_TCAMm_F2_12_MIML_SAf_GET(r,a) field_get((r).fp_tcam,71,118,a)
#define FP_TCAMm_F2_12_MIML_SAf_SET(r,a) field_set((r).fp_tcam,71,118,a)
#define FP_TCAMm_F2_11_DIP_127_96f_GET(r) field32_get((r).fp_tcam,71,102)
#define FP_TCAMm_F2_11_DIP_127_96f_SET(r,f) field32_set((r).fp_tcam,71,102,f)
#define FP_TCAMm_F2_18_OUTER_SIPf_GET(r) field32_get((r).fp_tcam,71,102)
#define FP_TCAMm_F2_18_OUTER_SIPf_SET(r,f) field32_set((r).fp_tcam,71,102,f)
#define FP_TCAMm_F2_13_PAYLOAD_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[2]) >> 7) & 0xffff)
#define FP_TCAMm_F2_13_PAYLOAD_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F2_14_PAYLOAD_L4_DSTf_GET(r) ((((r).fp_tcam[2]) >> 7) & 0xffff)
#define FP_TCAMm_F2_14_PAYLOAD_L4_DSTf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F2_5_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[2]) >> 7) & 0xffff)
#define FP_TCAMm_F2_5_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F2_6_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[2]) >> 7) & 0xffff)
#define FP_TCAMm_F2_6_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F2_7_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[2]) >> 7) & 0xffff)
#define FP_TCAMm_F2_7_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F2_0_TTL_FNf_GET(r) ((((r).fp_tcam[2]) >> 7) & 0xff)
#define FP_TCAMm_F2_0_TTL_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define FP_TCAMm_F2_1_TTL_FNf_GET(r) ((((r).fp_tcam[2]) >> 7) & 0xff)
#define FP_TCAMm_F2_1_TTL_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define FP_TCAMm_F2_4_TTL_FNf_GET(r) ((((r).fp_tcam[2]) >> 7) & 0xff)
#define FP_TCAMm_F2_4_TTL_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define FP_TCAMm_F2_17_SR_NETID_MATCHf_GET(r) ((((r).fp_tcam[2]) >> 7) & 0x1)
#define FP_TCAMm_F2_17_SR_NETID_MATCHf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_TCAMm_F2_17_INT_PRIf_GET(r) ((((r).fp_tcam[2]) >> 8) & 0xf)
#define FP_TCAMm_F2_17_INT_PRIf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define FP_TCAMm_DWF2_4_PAYLOAD_MACSAf_GET(r,a) field_get((r).fp_tcam,75,122,a)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACSAf_SET(r,a) field_set((r).fp_tcam,75,122,a)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACSA_MASKf_GET(r,a) field_get((r).fp_tcam,75,122,a)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACSA_MASKf_SET(r,a) field_set((r).fp_tcam,75,122,a)
#define FP_TCAMm_DWF2_0_RANGE_CHECK_RESULTSf_GET(r) field32_get((r).fp_tcam,75,98)
#define FP_TCAMm_DWF2_0_RANGE_CHECK_RESULTSf_SET(r,f) field32_set((r).fp_tcam,75,98,f)
#define FP_TCAMm_DWF2_0_RANGE_CHECK_RESULTS_MASKf_GET(r) field32_get((r).fp_tcam,75,98)
#define FP_TCAMm_DWF2_0_RANGE_CHECK_RESULTS_MASKf_SET(r,f) field32_set((r).fp_tcam,75,98,f)
#define FP_TCAMm_DWF2_5_PAYLOAD_TOS_FNf_GET(r) ((((r).fp_tcam[2]) >> 11) & 0xff)
#define FP_TCAMm_DWF2_5_PAYLOAD_TOS_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 11)) | ((((uint32)f) & 0xff) << 11))
#define FP_TCAMm_DWF2_5_PAYLOAD_TOS_FN_MASKf_GET(r) ((((r).fp_tcam[2]) >> 11) & 0xff)
#define FP_TCAMm_DWF2_5_PAYLOAD_TOS_FN_MASKf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 11)) | ((((uint32)f) & 0xff) << 11))
#define FP_TCAMm_F2_17_TSN_CIRCUIT_IDf_GET(r) ((((r).fp_tcam[2]) >> 12) & 0xfff)
#define FP_TCAMm_F2_17_TSN_CIRCUIT_IDf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))
#define FP_TCAMm_F2_0_TCP_FNf_GET(r) ((((r).fp_tcam[2]) >> 15) & 0x3f)
#define FP_TCAMm_F2_0_TCP_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3f << 15)) | ((((uint32)f) & 0x3f) << 15))
#define FP_TCAMm_F2_1_TCP_FNf_GET(r) ((((r).fp_tcam[2]) >> 15) & 0x3f)
#define FP_TCAMm_F2_1_TCP_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3f << 15)) | ((((uint32)f) & 0x3f) << 15))
#define FP_TCAMm_F2_4_TCP_FNf_GET(r) ((((r).fp_tcam[2]) >> 15) & 0x3f)
#define FP_TCAMm_F2_4_TCP_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3f << 15)) | ((((uint32)f) & 0x3f) << 15))
#define FP_TCAMm_DWF2_5_PAYLOAD_IP_PROTOCOL_LAST_NHf_GET(r) ((((r).fp_tcam[2]) >> 19) & 0xff)
#define FP_TCAMm_DWF2_5_PAYLOAD_IP_PROTOCOL_LAST_NHf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 19)) | ((((uint32)f) & 0xff) << 19))
#define FP_TCAMm_DWF2_5_PAYLOAD_IP_PROTOCOL_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[2]) >> 19) & 0xff)
#define FP_TCAMm_DWF2_5_PAYLOAD_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 19)) | ((((uint32)f) & 0xff) << 19))
#define FP_TCAMm_F2_4_IPV6_FLf_GET(r) field32_get((r).fp_tcam,85,104)
#define FP_TCAMm_F2_4_IPV6_FLf_SET(r,f) field32_set((r).fp_tcam,85,104,f)
#define FP_TCAMm_F2_0_IPFLAGf_GET(r) ((((r).fp_tcam[2]) >> 21) & 0x3)
#define FP_TCAMm_F2_0_IPFLAGf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define FP_TCAMm_F2_1_IP_FRAG_INFOf_GET(r) ((((r).fp_tcam[2]) >> 21) & 0x3)
#define FP_TCAMm_F2_1_IP_FRAG_INFOf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define FP_TCAMm_F2_13_PAYLOAD_ETHERTYPEf_GET(r) field32_get((r).fp_tcam,87,102)
#define FP_TCAMm_F2_13_PAYLOAD_ETHERTYPEf_SET(r,f) field32_set((r).fp_tcam,87,102,f)
#define FP_TCAMm_F2_14_PAYLOAD_L4_SRCf_GET(r) field32_get((r).fp_tcam,87,102)
#define FP_TCAMm_F2_14_PAYLOAD_L4_SRCf_SET(r,f) field32_set((r).fp_tcam,87,102,f)
#define FP_TCAMm_F2_5_ETHERTYPEf_GET(r) field32_get((r).fp_tcam,87,102)
#define FP_TCAMm_F2_5_ETHERTYPEf_SET(r,f) field32_set((r).fp_tcam,87,102,f)
#define FP_TCAMm_F2_6_ETHERTYPEf_GET(r) field32_get((r).fp_tcam,87,102)
#define FP_TCAMm_F2_6_ETHERTYPEf_SET(r,f) field32_set((r).fp_tcam,87,102,f)
#define FP_TCAMm_F2_7_ETHERTYPEf_GET(r) field32_get((r).fp_tcam,87,102)
#define FP_TCAMm_F2_7_ETHERTYPEf_SET(r,f) field32_set((r).fp_tcam,87,102,f)
#define FP_TCAMm_F2_0_TOS_FNf_GET(r) ((((r).fp_tcam[2]) >> 23) & 0xff)
#define FP_TCAMm_F2_0_TOS_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 23)) | ((((uint32)f) & 0xff) << 23))
#define FP_TCAMm_F2_1_TOS_FNf_GET(r) ((((r).fp_tcam[2]) >> 23) & 0xff)
#define FP_TCAMm_F2_1_TOS_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 23)) | ((((uint32)f) & 0xff) << 23))
#define FP_TCAMm_F2_17_SR_FLOW_IDf_GET(r) field32_get((r).fp_tcam,88,100)
#define FP_TCAMm_F2_17_SR_FLOW_IDf_SET(r,f) field32_set((r).fp_tcam,88,100,f)
#define FP_TCAMm_DWF2_5_PAYLOAD_DIPf_GET(r) field32_get((r).fp_tcam,91,122)
#define FP_TCAMm_DWF2_5_PAYLOAD_DIPf_SET(r,f) field32_set((r).fp_tcam,91,122,f)
#define FP_TCAMm_DWF2_5_PAYLOAD_DIP_MASKf_GET(r) field32_get((r).fp_tcam,91,122)
#define FP_TCAMm_DWF2_5_PAYLOAD_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,91,122,f)
#define FP_TCAMm_F2_0_L4_DSTf_GET(r) field32_get((r).fp_tcam,95,110)
#define FP_TCAMm_F2_0_L4_DSTf_SET(r,f) field32_set((r).fp_tcam,95,110,f)
#define FP_TCAMm_F2_1_L4_DSTf_GET(r) field32_get((r).fp_tcam,95,110)
#define FP_TCAMm_F2_1_L4_DSTf_SET(r,f) field32_set((r).fp_tcam,95,110,f)
#define FP_TCAMm_DWF2_0_INTERFACE_CLASSIDf_GET(r) ((((r).fp_tcam[3]) >> 3) & 0xff)
#define FP_TCAMm_DWF2_0_INTERFACE_CLASSIDf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define FP_TCAMm_DWF2_0_INTERFACE_CLASSID_MASKf_GET(r) ((((r).fp_tcam[3]) >> 3) & 0xff)
#define FP_TCAMm_DWF2_0_INTERFACE_CLASSID_MASKf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define FP_TCAMm_F2_17_PKT_NET_ID_VALIDf_GET(r) ((((r).fp_tcam[3]) >> 5) & 0x1)
#define FP_TCAMm_F2_17_PKT_NET_ID_VALIDf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_TCAMm_F2_17_PKT_LAN_ID_VALIDf_GET(r) ((((r).fp_tcam[3]) >> 6) & 0x1)
#define FP_TCAMm_F2_17_PKT_LAN_ID_VALIDf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define FP_TCAMm_F2_11_SAf_GET(r,a) field_get((r).fp_tcam,103,150,a)
#define FP_TCAMm_F2_11_SAf_SET(r,a) field_set((r).fp_tcam,103,150,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACSAf_GET(r,a) field_get((r).fp_tcam,103,150,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACSAf_SET(r,a) field_set((r).fp_tcam,103,150,a)
#define FP_TCAMm_F2_5_SAf_GET(r,a) field_get((r).fp_tcam,103,150,a)
#define FP_TCAMm_F2_5_SAf_SET(r,a) field_set((r).fp_tcam,103,150,a)
#define FP_TCAMm_F2_6_SAf_GET(r,a) field_get((r).fp_tcam,103,150,a)
#define FP_TCAMm_F2_6_SAf_SET(r,a) field_set((r).fp_tcam,103,150,a)
#define FP_TCAMm_F2_18_OUTER_DIPf_GET(r) field32_get((r).fp_tcam,103,134)
#define FP_TCAMm_F2_18_OUTER_DIPf_SET(r,f) field32_set((r).fp_tcam,103,134,f)
#define FP_TCAMm_F2_14_PAYLOAD_TOS_FNf_GET(r) ((((r).fp_tcam[3]) >> 7) & 0xff)
#define FP_TCAMm_F2_14_PAYLOAD_TOS_FNf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define FP_TCAMm_F2_7_TTL_FNf_GET(r) ((((r).fp_tcam[3]) >> 7) & 0xff)
#define FP_TCAMm_F2_7_TTL_FNf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define FP_TCAMm_F2_17_SR_FLOW_RX_TAG_ERRORf_GET(r) ((((r).fp_tcam[3]) >> 7) & 0x1)
#define FP_TCAMm_F2_17_SR_FLOW_RX_TAG_ERRORf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_TCAMm_F2_17_SR_FLOW_RX_ERRORf_GET(r) ((((r).fp_tcam[3]) >> 8) & 0x1)
#define FP_TCAMm_F2_17_SR_FLOW_RX_ERRORf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_TCAMm_F2_4_TOS_FNf_GET(r) ((((r).fp_tcam[3]) >> 9) & 0xff)
#define FP_TCAMm_F2_4_TOS_FNf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 9)) | ((((uint32)f) & 0xff) << 9))
#define FP_TCAMm_F2_17_VLAN_SR_LAN_IDf_GET(r) ((((r).fp_tcam[3]) >> 9) & 0x1)
#define FP_TCAMm_F2_17_VLAN_SR_LAN_IDf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_TCAMm_F2_17_VLAN_SR_ENABLEf_GET(r) ((((r).fp_tcam[3]) >> 10) & 0x1)
#define FP_TCAMm_F2_17_VLAN_SR_ENABLEf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define FP_TCAMm_DWF2_0_DIPf_GET(r) field32_get((r).fp_tcam,107,138)
#define FP_TCAMm_DWF2_0_DIPf_SET(r,f) field32_set((r).fp_tcam,107,138,f)
#define FP_TCAMm_DWF2_0_DIP_MASKf_GET(r) field32_get((r).fp_tcam,107,138)
#define FP_TCAMm_DWF2_0_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,107,138,f)
#define FP_TCAMm_F2_17_EGR_SR_MODEf_GET(r) ((((r).fp_tcam[3]) >> 11) & 0x7)
#define FP_TCAMm_F2_17_EGR_SR_MODEf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x7 << 11)) | ((((uint32)f) & 0x7) << 11))
#define FP_TCAMm_F2_17_EGR_SR_NET_IDf_GET(r) ((((r).fp_tcam[3]) >> 14) & 0x7)
#define FP_TCAMm_F2_17_EGR_SR_NET_IDf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define FP_TCAMm_F2_0_L4_SRCf_GET(r) ((((r).fp_tcam[3]) >> 15) & 0xffff)
#define FP_TCAMm_F2_0_L4_SRCf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xffff << 15)) | ((((uint32)f) & 0xffff) << 15))
#define FP_TCAMm_F2_1_L4_SRCf_GET(r) ((((r).fp_tcam[3]) >> 15) & 0xffff)
#define FP_TCAMm_F2_1_L4_SRCf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xffff << 15)) | ((((uint32)f) & 0xffff) << 15))
#define FP_TCAMm_F2_14_PAYLOAD_IP_PROTOCOL_LAST_NHf_GET(r) ((((r).fp_tcam[3]) >> 15) & 0xff)
#define FP_TCAMm_F2_14_PAYLOAD_IP_PROTOCOL_LAST_NHf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 15)) | ((((uint32)f) & 0xff) << 15))
#define FP_TCAMm_F2_7_IP_PROTOCOL_LAST_NHf_GET(r) ((((r).fp_tcam[3]) >> 15) & 0xff)
#define FP_TCAMm_F2_7_IP_PROTOCOL_LAST_NHf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 15)) | ((((uint32)f) & 0xff) << 15))
#define FP_TCAMm_F2_4_LAST_NHf_GET(r) ((((r).fp_tcam[3]) >> 17) & 0xff)
#define FP_TCAMm_F2_4_LAST_NHf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 17)) | ((((uint32)f) & 0xff) << 17))
#define FP_TCAMm_F2_17_EGR_SR_LAN_IDf_GET(r) ((((r).fp_tcam[3]) >> 17) & 0x1)
#define FP_TCAMm_F2_17_EGR_SR_LAN_IDf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define FP_TCAMm_F2_17_EGR_SR_TYPEf_GET(r) ((((r).fp_tcam[3]) >> 18) & 0x7)
#define FP_TCAMm_F2_17_EGR_SR_TYPEf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define FP_TCAMm_F2_17_EGR_SR_PORT_ROLEf_GET(r) ((((r).fp_tcam[3]) >> 21) & 0x1)
#define FP_TCAMm_F2_17_EGR_SR_PORT_ROLEf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define FP_TCAMm_F2_17_EGR_SR_ENABLEf_GET(r) ((((r).fp_tcam[3]) >> 22) & 0x1)
#define FP_TCAMm_F2_17_EGR_SR_ENABLEf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define FP_TCAMm_F2_12_MIML_DAf_GET(r,a) field_get((r).fp_tcam,119,166,a)
#define FP_TCAMm_F2_12_MIML_DAf_SET(r,a) field_set((r).fp_tcam,119,166,a)
#define FP_TCAMm_F2_14_PAYLOAD_DIPf_GET(r) field32_get((r).fp_tcam,119,150)
#define FP_TCAMm_F2_14_PAYLOAD_DIPf_SET(r,f) field32_set((r).fp_tcam,119,150,f)
#define FP_TCAMm_F2_7_DIPf_GET(r) field32_get((r).fp_tcam,119,150)
#define FP_TCAMm_F2_7_DIPf_SET(r,f) field32_set((r).fp_tcam,119,150,f)
#define FP_TCAMm_F2_17_ING_SR_MODEf_GET(r) ((((r).fp_tcam[3]) >> 23) & 0x7)
#define FP_TCAMm_F2_17_ING_SR_MODEf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x7 << 23)) | ((((uint32)f) & 0x7) << 23))
#define FP_TCAMm_F2_4_INT_CNf_GET(r) ((((r).fp_tcam[3]) >> 25) & 0x3)
#define FP_TCAMm_F2_4_INT_CNf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x3 << 25)) | ((((uint32)f) & 0x3) << 25))
#define FP_TCAMm_F2_17_ING_SR_NET_IDf_GET(r) ((((r).fp_tcam[3]) >> 26) & 0x7)
#define FP_TCAMm_F2_17_ING_SR_NET_IDf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x7 << 26)) | ((((uint32)f) & 0x7) << 26))
#define FP_TCAMm_DWF2_4_PAYLOAD_MACDAf_GET(r,a) field_get((r).fp_tcam,123,170,a)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACDAf_SET(r,a) field_set((r).fp_tcam,123,170,a)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACDA_MASKf_GET(r,a) field_get((r).fp_tcam,123,170,a)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACDA_MASKf_SET(r,a) field_set((r).fp_tcam,123,170,a)
#define FP_TCAMm_DWF2_5_PAYLOAD_SIPf_GET(r) field32_get((r).fp_tcam,123,154)
#define FP_TCAMm_DWF2_5_PAYLOAD_SIPf_SET(r,f) field32_set((r).fp_tcam,123,154,f)
#define FP_TCAMm_DWF2_5_PAYLOAD_SIP_MASKf_GET(r) field32_get((r).fp_tcam,123,154)
#define FP_TCAMm_DWF2_5_PAYLOAD_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,123,154,f)
#define FP_TCAMm_F2_4_SPAREf_GET(r) field32_get((r).fp_tcam,123,134)
#define FP_TCAMm_F2_4_SPAREf_SET(r,f) field32_set((r).fp_tcam,123,134,f)
#define FP_TCAMm_F2_17_ING_SR_LAN_IDf_GET(r) ((((r).fp_tcam[3]) >> 29) & 0x1)
#define FP_TCAMm_F2_17_ING_SR_LAN_IDf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define FP_TCAMm_F2_17_ING_SR_TYPEf_GET(r) field32_get((r).fp_tcam,126,128)
#define FP_TCAMm_F2_17_ING_SR_TYPEf_SET(r,f) field32_set((r).fp_tcam,126,128,f)
#define FP_TCAMm_F2_0_IP_PROTOCOL_LAST_NHf_GET(r) field32_get((r).fp_tcam,127,134)
#define FP_TCAMm_F2_0_IP_PROTOCOL_LAST_NHf_SET(r,f) field32_set((r).fp_tcam,127,134,f)
#define FP_TCAMm_F2_1_IP_PROTOCOL_LAST_NHf_GET(r) field32_get((r).fp_tcam,127,134)
#define FP_TCAMm_F2_1_IP_PROTOCOL_LAST_NHf_SET(r,f) field32_set((r).fp_tcam,127,134,f)
#define FP_TCAMm_F2_17_ING_SR_PORT_ROLEf_GET(r) ((((r).fp_tcam[4]) >> 1) & 0x1)
#define FP_TCAMm_F2_17_ING_SR_PORT_ROLEf_SET(r,f) (r).fp_tcam[4]=(((r).fp_tcam[4] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_TCAMm_F2_17_ING_SR_ENABLEf_GET(r) ((((r).fp_tcam[4]) >> 2) & 0x1)
#define FP_TCAMm_F2_17_ING_SR_ENABLEf_SET(r,f) (r).fp_tcam[4]=(((r).fp_tcam[4] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_TCAMm_F2_17_PKT_NET_IDf_GET(r) ((((r).fp_tcam[4]) >> 3) & 0x7)
#define FP_TCAMm_F2_17_PKT_NET_IDf_SET(r,f) (r).fp_tcam[4]=(((r).fp_tcam[4] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define FP_TCAMm_F2_17_PKT_LAN_IDf_GET(r) ((((r).fp_tcam[4]) >> 6) & 0x1)
#define FP_TCAMm_F2_17_PKT_LAN_IDf_SET(r,f) (r).fp_tcam[4]=(((r).fp_tcam[4] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define FP_TCAMm_F2_10_DIP_127_64f_GET(r,a) field_get((r).fp_tcam,135,198,a)
#define FP_TCAMm_F2_10_DIP_127_64f_SET(r,a) field_set((r).fp_tcam,135,198,a)
#define FP_TCAMm_F2_4_DIP_127_64f_GET(r,a) field_get((r).fp_tcam,135,198,a)
#define FP_TCAMm_F2_4_DIP_127_64f_SET(r,a) field_set((r).fp_tcam,135,198,a)
#define FP_TCAMm_F2_18_INNER_PAYLOAD_DAf_GET(r,a) field_get((r).fp_tcam,135,182,a)
#define FP_TCAMm_F2_18_INNER_PAYLOAD_DAf_SET(r,a) field_set((r).fp_tcam,135,182,a)
#define FP_TCAMm_F2_0_DIPf_GET(r) field32_get((r).fp_tcam,135,166)
#define FP_TCAMm_F2_0_DIPf_SET(r,f) field32_set((r).fp_tcam,135,166,f)
#define FP_TCAMm_F2_1_DIPf_GET(r) field32_get((r).fp_tcam,135,166)
#define FP_TCAMm_F2_1_DIPf_SET(r,f) field32_set((r).fp_tcam,135,166,f)
#define FP_TCAMm_F2_17_PKT_SR_TYPEf_GET(r) ((((r).fp_tcam[4]) >> 7) & 0x7)
#define FP_TCAMm_F2_17_PKT_SR_TYPEf_SET(r,f) (r).fp_tcam[4]=(((r).fp_tcam[4] & ~((uint32)0x7 << 7)) | ((((uint32)f) & 0x7) << 7))
#define FP_TCAMm_F2_17_SR_ETHERTYPEf_GET(r) ((((r).fp_tcam[4]) >> 10) & 0x3)
#define FP_TCAMm_F2_17_SR_ETHERTYPEf_SET(r,f) (r).fp_tcam[4]=(((r).fp_tcam[4] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define FP_TCAMm_DWF2_0_SIPf_GET(r) field32_get((r).fp_tcam,139,170)
#define FP_TCAMm_DWF2_0_SIPf_SET(r,f) field32_set((r).fp_tcam,139,170,f)
#define FP_TCAMm_DWF2_0_SIP_MASKf_GET(r) field32_get((r).fp_tcam,139,170)
#define FP_TCAMm_DWF2_0_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,139,170,f)
#define FP_TCAMm_F2_17_DA_TYPEf_GET(r) ((((r).fp_tcam[4]) >> 12) & 0x3)
#define FP_TCAMm_F2_17_DA_TYPEf_SET(r,f) (r).fp_tcam[4]=(((r).fp_tcam[4] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define FP_TCAMm_F2_17_DA_HITf_GET(r) ((((r).fp_tcam[4]) >> 14) & 0x3)
#define FP_TCAMm_F2_17_DA_HITf_SET(r,f) (r).fp_tcam[4]=(((r).fp_tcam[4] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define FP_TCAMm_F2_17_SA_HITf_GET(r) ((((r).fp_tcam[4]) >> 16) & 0x3)
#define FP_TCAMm_F2_17_SA_HITf_SET(r,f) (r).fp_tcam[4]=(((r).fp_tcam[4] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define FP_TCAMm_F2_17_SR_FLOW_UNEXPECTED_FRAMEf_GET(r) ((((r).fp_tcam[4]) >> 18) & 0x1)
#define FP_TCAMm_F2_17_SR_FLOW_UNEXPECTED_FRAMEf_SET(r,f) (r).fp_tcam[4]=(((r).fp_tcam[4] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define FP_TCAMm_F2_17_SA_SANf_GET(r) ((((r).fp_tcam[4]) >> 19) & 0x1)
#define FP_TCAMm_F2_17_SA_SANf_SET(r,f) (r).fp_tcam[4]=(((r).fp_tcam[4] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_TCAMm_F2_17_PTP_MESSAGE_TYPEf_GET(r) ((((r).fp_tcam[4]) >> 20) & 0xf)
#define FP_TCAMm_F2_17_PTP_MESSAGE_TYPEf_SET(r,f) (r).fp_tcam[4]=(((r).fp_tcam[4] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define FP_TCAMm_F2_11_DAf_GET(r,a) field_get((r).fp_tcam,151,198,a)
#define FP_TCAMm_F2_11_DAf_SET(r,a) field_set((r).fp_tcam,151,198,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACDAf_GET(r,a) field_get((r).fp_tcam,151,198,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACDAf_SET(r,a) field_set((r).fp_tcam,151,198,a)
#define FP_TCAMm_F2_5_DAf_GET(r,a) field_get((r).fp_tcam,151,198,a)
#define FP_TCAMm_F2_5_DAf_SET(r,a) field_set((r).fp_tcam,151,198,a)
#define FP_TCAMm_F2_7_DAf_GET(r,a) field_get((r).fp_tcam,151,198,a)
#define FP_TCAMm_F2_7_DAf_SET(r,a) field_set((r).fp_tcam,151,198,a)
#define FP_TCAMm_F2_14_PAYLOAD_SIPf_GET(r) field32_get((r).fp_tcam,151,182)
#define FP_TCAMm_F2_14_PAYLOAD_SIPf_SET(r,f) field32_set((r).fp_tcam,151,182,f)
#define FP_TCAMm_F2_6_SIPf_GET(r) field32_get((r).fp_tcam,151,182)
#define FP_TCAMm_F2_6_SIPf_SET(r,f) field32_set((r).fp_tcam,151,182,f)
#define FP_TCAMm_F2_17_PTP_SOURCE_PORT_IDENTITYf_GET(r) field32_get((r).fp_tcam,152,167)
#define FP_TCAMm_F2_17_PTP_SOURCE_PORT_IDENTITYf_SET(r,f) field32_set((r).fp_tcam,152,167,f)
#define FP_TCAMm_DWF2_5_SPAREf_GET(r) field32_get((r).fp_tcam,155,170)
#define FP_TCAMm_DWF2_5_SPAREf_SET(r,f) field32_set((r).fp_tcam,155,170,f)
#define FP_TCAMm_DWF2_5_SPARE_MASKf_GET(r) field32_get((r).fp_tcam,155,170)
#define FP_TCAMm_DWF2_5_SPARE_MASKf_SET(r,f) field32_set((r).fp_tcam,155,170,f)
#define FP_TCAMm_F2_0_SIPf_GET(r) field32_get((r).fp_tcam,167,198)
#define FP_TCAMm_F2_0_SIPf_SET(r,f) field32_set((r).fp_tcam,167,198,f)
#define FP_TCAMm_F2_1_SIPf_GET(r) field32_get((r).fp_tcam,167,198)
#define FP_TCAMm_F2_1_SIPf_SET(r,f) field32_set((r).fp_tcam,167,198,f)
#define FP_TCAMm_F2_12_MIML_TAGf_GET(r) ((((r).fp_tcam[5]) >> 7) & 0xffff)
#define FP_TCAMm_F2_12_MIML_TAGf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F2_17_PTP_DOMAIN_ID_MISMATCHf_GET(r) ((((r).fp_tcam[5]) >> 8) & 0x1)
#define FP_TCAMm_F2_17_PTP_DOMAIN_ID_MISMATCHf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_TCAMm_F2_17_PACKET_IS_1588f_GET(r) ((((r).fp_tcam[5]) >> 9) & 0x1)
#define FP_TCAMm_F2_17_PACKET_IS_1588f_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_TCAMm_F2_17_TAF_BYTELEFT_IS_NULLf_GET(r) ((((r).fp_tcam[5]) >> 10) & 0x1)
#define FP_TCAMm_F2_17_TAF_BYTELEFT_IS_NULLf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define FP_TCAMm_DWF1f_GET(r,a) field_get((r).fp_tcam,171,236,a)
#define FP_TCAMm_DWF1f_SET(r,a) field_set((r).fp_tcam,171,236,a)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_DSTf_GET(r) ((((r).fp_tcam[5]) >> 11) & 0xffff)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_DSTf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xffff << 11)) | ((((uint32)f) & 0xffff) << 11))
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_DST_MASKf_GET(r) ((((r).fp_tcam[5]) >> 11) & 0xffff)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_DST_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xffff << 11)) | ((((uint32)f) & 0xffff) << 11))
#define FP_TCAMm_DWF1_0_TTL_FN1f_GET(r) ((((r).fp_tcam[5]) >> 11) & 0xff)
#define FP_TCAMm_DWF1_0_TTL_FN1f_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xff << 11)) | ((((uint32)f) & 0xff) << 11))
#define FP_TCAMm_DWF1_0_TTL_FN1_MASKf_GET(r) ((((r).fp_tcam[5]) >> 11) & 0xff)
#define FP_TCAMm_DWF1_0_TTL_FN1_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xff << 11)) | ((((uint32)f) & 0xff) << 11))
#define FP_TCAMm_DWF1_2_ROCEV1_PACKETf_GET(r) ((((r).fp_tcam[5]) >> 11) & 0x1)
#define FP_TCAMm_DWF1_2_ROCEV1_PACKETf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_TCAMm_DWF1_2_ROCEV1_PACKET_MASKf_GET(r) ((((r).fp_tcam[5]) >> 11) & 0x1)
#define FP_TCAMm_DWF1_2_ROCEV1_PACKET_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_TCAMm_F2_17_TAF_DROPf_GET(r) ((((r).fp_tcam[5]) >> 11) & 0x1)
#define FP_TCAMm_F2_17_TAF_DROPf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_TCAMm_F2_17_TAF_COS_PROFILEf_GET(r) ((((r).fp_tcam[5]) >> 12) & 0xf)
#define FP_TCAMm_F2_17_TAF_COS_PROFILEf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define FP_TCAMm_DWF1_2_ROCEV2_PACKETf_GET(r) ((((r).fp_tcam[5]) >> 12) & 0x1)
#define FP_TCAMm_DWF1_2_ROCEV2_PACKETf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_TCAMm_DWF1_2_ROCEV2_PACKET_MASKf_GET(r) ((((r).fp_tcam[5]) >> 12) & 0x1)
#define FP_TCAMm_DWF1_2_ROCEV2_PACKET_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_TCAMm_DWF1_2_ROCE_BTH_FLAGSf_GET(r) ((((r).fp_tcam[5]) >> 13) & 0xff)
#define FP_TCAMm_DWF1_2_ROCE_BTH_FLAGSf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xff << 13)) | ((((uint32)f) & 0xff) << 13))
#define FP_TCAMm_DWF1_2_ROCE_BTH_FLAGS_MASKf_GET(r) ((((r).fp_tcam[5]) >> 13) & 0xff)
#define FP_TCAMm_DWF1_2_ROCE_BTH_FLAGS_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xff << 13)) | ((((uint32)f) & 0xff) << 13))
#define FP_TCAMm_F2_17_TAF_GATE_STATE_AT_SOPf_GET(r) ((((r).fp_tcam[5]) >> 16) & 0x1)
#define FP_TCAMm_F2_17_TAF_GATE_STATE_AT_SOPf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define FP_TCAMm_F2_17_TAF_GATE_IDf_GET(r) ((((r).fp_tcam[5]) >> 17) & 0x7f)
#define FP_TCAMm_F2_17_TAF_GATE_IDf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x7f << 17)) | ((((uint32)f) & 0x7f) << 17))
#define FP_TCAMm_DWF1_0_IP_FRAG_INFOf_GET(r) ((((r).fp_tcam[5]) >> 19) & 0x3)
#define FP_TCAMm_DWF1_0_IP_FRAG_INFOf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define FP_TCAMm_DWF1_0_IP_FRAG_INFO_MASKf_GET(r) ((((r).fp_tcam[5]) >> 19) & 0x3)
#define FP_TCAMm_DWF1_0_IP_FRAG_INFO_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define FP_TCAMm_DWF1_2_ROCE_BTH_DESTINATION_QPf_GET(r) field32_get((r).fp_tcam,181,204)
#define FP_TCAMm_DWF1_2_ROCE_BTH_DESTINATION_QPf_SET(r,f) field32_set((r).fp_tcam,181,204,f)
#define FP_TCAMm_DWF1_2_ROCE_BTH_DESTINATION_QP_MASKf_GET(r) field32_get((r).fp_tcam,181,204)
#define FP_TCAMm_DWF1_2_ROCE_BTH_DESTINATION_QP_MASKf_SET(r,f) field32_set((r).fp_tcam,181,204,f)
#define FP_TCAMm_DWF1_0_L4_DSTf_GET(r) field32_get((r).fp_tcam,181,196)
#define FP_TCAMm_DWF1_0_L4_DSTf_SET(r,f) field32_set((r).fp_tcam,181,196,f)
#define FP_TCAMm_DWF1_0_L4_DST_MASKf_GET(r) field32_get((r).fp_tcam,181,196)
#define FP_TCAMm_DWF1_0_L4_DST_MASKf_SET(r,f) field32_set((r).fp_tcam,181,196,f)
#define FP_TCAMm_F2_12_SPAREf_GET(r) field32_get((r).fp_tcam,183,198)
#define FP_TCAMm_F2_12_SPAREf_SET(r,f) field32_set((r).fp_tcam,183,198,f)
#define FP_TCAMm_F2_14_SPAREf_GET(r) field32_get((r).fp_tcam,183,198)
#define FP_TCAMm_F2_14_SPAREf_SET(r,f) field32_set((r).fp_tcam,183,198,f)
#define FP_TCAMm_F2_6_SPAREf_GET(r) field32_get((r).fp_tcam,183,198)
#define FP_TCAMm_F2_6_SPAREf_SET(r,f) field32_set((r).fp_tcam,183,198,f)
#define FP_TCAMm_F2_18_PAYLOAD_TOSf_GET(r) ((((r).fp_tcam[5]) >> 23) & 0xff)
#define FP_TCAMm_F2_18_PAYLOAD_TOSf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xff << 23)) | ((((uint32)f) & 0xff) << 23))
#define FP_TCAMm_F2_17_TAF_ENABLEf_GET(r) ((((r).fp_tcam[5]) >> 24) & 0x1)
#define FP_TCAMm_F2_17_TAF_ENABLEf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define FP_TCAMm_F2_17_SPAREf_GET(r) field32_get((r).fp_tcam,185,198)
#define FP_TCAMm_F2_17_SPAREf_SET(r,f) field32_set((r).fp_tcam,185,198,f)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_SRCf_GET(r) field32_get((r).fp_tcam,187,202)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_SRCf_SET(r,f) field32_set((r).fp_tcam,187,202,f)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_SRC_MASKf_GET(r) field32_get((r).fp_tcam,187,202)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_SRC_MASKf_SET(r,f) field32_set((r).fp_tcam,187,202,f)
#define FP_TCAMm_F2_18_INT_CNf_GET(r) field32_get((r).fp_tcam,191,192)
#define FP_TCAMm_F2_18_INT_CNf_SET(r,f) field32_set((r).fp_tcam,191,192,f)
#define FP_TCAMm_F2_18_SPAREf_GET(r) ((((r).fp_tcam[6]) >> 1) & 0x3f)
#define FP_TCAMm_F2_18_SPAREf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x3f << 1)) | ((((uint32)f) & 0x3f) << 1))
#define FP_TCAMm_DWF1_0_L4_SRCf_GET(r) ((((r).fp_tcam[6]) >> 5) & 0xffff)
#define FP_TCAMm_DWF1_0_L4_SRCf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 5)) | ((((uint32)f) & 0xffff) << 5))
#define FP_TCAMm_DWF1_0_L4_SRC_MASKf_GET(r) ((((r).fp_tcam[6]) >> 5) & 0xffff)
#define FP_TCAMm_DWF1_0_L4_SRC_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 5)) | ((((uint32)f) & 0xffff) << 5))
#define FP_TCAMm_F1f_GET(r,a) field_get((r).fp_tcam,199,237,a)
#define FP_TCAMm_F1f_SET(r,a) field_set((r).fp_tcam,199,237,a)
#define FP_TCAMm_F1_13_AUX_TAG_1f_GET(r) field32_get((r).fp_tcam,199,230)
#define FP_TCAMm_F1_13_AUX_TAG_1f_SET(r,f) field32_set((r).fp_tcam,199,230,f)
#define FP_TCAMm_F1_9_UDF1_31_0f_GET(r) field32_get((r).fp_tcam,199,230)
#define FP_TCAMm_F1_9_UDF1_31_0f_SET(r,f) field32_set((r).fp_tcam,199,230,f)
#define FP_TCAMm_F1_10_D_FIELDf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0xffff)
#define FP_TCAMm_F1_10_D_FIELDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F1_11_SGLPf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0xffff)
#define FP_TCAMm_F1_11_SGLPf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F1_1_D_FIELDf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0xffff)
#define FP_TCAMm_F1_1_D_FIELDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F1_2_D_FIELDf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0xffff)
#define FP_TCAMm_F1_2_D_FIELDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F1_3_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0xffff)
#define FP_TCAMm_F1_3_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F1_4_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0xffff)
#define FP_TCAMm_F1_4_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F1_5_LOOKUP_STATUSf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0xffff)
#define FP_TCAMm_F1_5_LOOKUP_STATUSf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F1_6_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0xffff)
#define FP_TCAMm_F1_6_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F1_7_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0xffff)
#define FP_TCAMm_F1_7_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F1_0_CLASSIDSf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0xfff)
#define FP_TCAMm_F1_0_CLASSIDSf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xfff << 7)) | ((((uint32)f) & 0xfff) << 7))
#define FP_TCAMm_F1_12_OUTER_VLAN_IDf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0xfff)
#define FP_TCAMm_F1_12_OUTER_VLAN_IDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xfff << 7)) | ((((uint32)f) & 0xfff) << 7))
#define FP_TCAMm_F1_8_IP_PROTOCOL_LAST_NHf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0xff)
#define FP_TCAMm_F1_8_IP_PROTOCOL_LAST_NHf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define FP_TCAMm_F1_14_MY_STATION_HIT_STATUSf_GET(r) ((((r).fp_tcam[6]) >> 7) & 0x1)
#define FP_TCAMm_F1_14_MY_STATION_HIT_STATUSf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_TCAMm_F1_15_PACKET_IS_1588f_GET(r) ((((r).fp_tcam[6]) >> 7) & 0x1)
#define FP_TCAMm_F1_15_PACKET_IS_1588f_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_TCAMm_F1_15_PTP_DOMAIN_IDf_GET(r) ((((r).fp_tcam[6]) >> 8) & 0xff)
#define FP_TCAMm_F1_15_PTP_DOMAIN_IDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define FP_TCAMm_F1_14_VXLAN_CLASS_ID_VALIDf_GET(r) ((((r).fp_tcam[6]) >> 8) & 0x1)
#define FP_TCAMm_F1_14_VXLAN_CLASS_ID_VALIDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_TCAMm_F1_14_VXLAN_VN_IDf_GET(r) field32_get((r).fp_tcam,201,224)
#define FP_TCAMm_F1_14_VXLAN_VN_IDf_SET(r,f) field32_set((r).fp_tcam,201,224,f)
#define FP_TCAMm_DWF1_1_PAYLOAD_TOS_FNf_GET(r) ((((r).fp_tcam[6]) >> 11) & 0xff)
#define FP_TCAMm_DWF1_1_PAYLOAD_TOS_FNf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 11)) | ((((uint32)f) & 0xff) << 11))
#define FP_TCAMm_DWF1_1_PAYLOAD_TOS_FN_MASKf_GET(r) ((((r).fp_tcam[6]) >> 11) & 0xff)
#define FP_TCAMm_DWF1_1_PAYLOAD_TOS_FN_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 11)) | ((((uint32)f) & 0xff) << 11))
#define FP_TCAMm_DWF1_2_ROCE_BTH_OPCODEf_GET(r) ((((r).fp_tcam[6]) >> 13) & 0xff)
#define FP_TCAMm_DWF1_2_ROCE_BTH_OPCODEf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 13)) | ((((uint32)f) & 0xff) << 13))
#define FP_TCAMm_DWF1_2_ROCE_BTH_OPCODE_MASKf_GET(r) ((((r).fp_tcam[6]) >> 13) & 0xff)
#define FP_TCAMm_DWF1_2_ROCE_BTH_OPCODE_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 13)) | ((((uint32)f) & 0xff) << 13))
#define FP_TCAMm_F1_8_TOS_FNf_GET(r) ((((r).fp_tcam[6]) >> 15) & 0xff)
#define FP_TCAMm_F1_8_TOS_FNf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 15)) | ((((uint32)f) & 0xff) << 15))
#define FP_TCAMm_F1_15_PORT_PTP_DOMAIN_IDf_GET(r) ((((r).fp_tcam[6]) >> 16) & 0xf)
#define FP_TCAMm_F1_15_PORT_PTP_DOMAIN_IDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define FP_TCAMm_F1_0_FORWARDING_FIELDf_GET(r) ((((r).fp_tcam[6]) >> 19) & 0xfff)
#define FP_TCAMm_F1_0_FORWARDING_FIELDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xfff << 19)) | ((((uint32)f) & 0xfff) << 19))
#define FP_TCAMm_F1_12_CLASSIDSf_GET(r) ((((r).fp_tcam[6]) >> 19) & 0xfff)
#define FP_TCAMm_F1_12_CLASSIDSf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xfff << 19)) | ((((uint32)f) & 0xfff) << 19))
#define FP_TCAMm_DWF1_1_PAYLOAD_IP_PROTOCOL_LAST_NHf_GET(r) ((((r).fp_tcam[6]) >> 19) & 0xff)
#define FP_TCAMm_DWF1_1_PAYLOAD_IP_PROTOCOL_LAST_NHf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 19)) | ((((uint32)f) & 0xff) << 19))
#define FP_TCAMm_DWF1_1_PAYLOAD_IP_PROTOCOL_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[6]) >> 19) & 0xff)
#define FP_TCAMm_DWF1_1_PAYLOAD_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 19)) | ((((uint32)f) & 0xff) << 19))
#define FP_TCAMm_F1_15_ROCEV1_PACKETf_GET(r) ((((r).fp_tcam[6]) >> 20) & 0x1)
#define FP_TCAMm_F1_15_ROCEV1_PACKETf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_TCAMm_DWF1_0_D_FIELDf_GET(r) field32_get((r).fp_tcam,213,228)
#define FP_TCAMm_DWF1_0_D_FIELDf_SET(r,f) field32_set((r).fp_tcam,213,228,f)
#define FP_TCAMm_DWF1_0_D_FIELD_MASKf_GET(r) field32_get((r).fp_tcam,213,228)
#define FP_TCAMm_DWF1_0_D_FIELD_MASKf_SET(r,f) field32_set((r).fp_tcam,213,228,f)
#define FP_TCAMm_DWF1_2_ROCE_BTH_PARTITION_KEYf_GET(r) field32_get((r).fp_tcam,213,228)
#define FP_TCAMm_DWF1_2_ROCE_BTH_PARTITION_KEYf_SET(r,f) field32_set((r).fp_tcam,213,228,f)
#define FP_TCAMm_DWF1_2_ROCE_BTH_PARTITION_KEY_MASKf_GET(r) field32_get((r).fp_tcam,213,228)
#define FP_TCAMm_DWF1_2_ROCE_BTH_PARTITION_KEY_MASKf_SET(r,f) field32_set((r).fp_tcam,213,228,f)
#define FP_TCAMm_F1_15_ROCEV2_PACKETf_GET(r) ((((r).fp_tcam[6]) >> 21) & 0x1)
#define FP_TCAMm_F1_15_ROCEV2_PACKETf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define FP_TCAMm_F1_15_ROCE_BTH_OPCODEf_GET(r) ((((r).fp_tcam[6]) >> 22) & 0xff)
#define FP_TCAMm_F1_15_ROCE_BTH_OPCODEf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 22)) | ((((uint32)f) & 0xff) << 22))
#define FP_TCAMm_F1_3_INNER_VLAN_TAGf_GET(r) field32_get((r).fp_tcam,215,230)
#define FP_TCAMm_F1_3_INNER_VLAN_TAGf_SET(r,f) field32_set((r).fp_tcam,215,230,f)
#define FP_TCAMm_F1_4_ETHERTYPEf_GET(r) field32_get((r).fp_tcam,215,230)
#define FP_TCAMm_F1_4_ETHERTYPEf_SET(r,f) field32_set((r).fp_tcam,215,230,f)
#define FP_TCAMm_F1_5_INNER_VLAN_TAGf_GET(r) field32_get((r).fp_tcam,215,230)
#define FP_TCAMm_F1_5_INNER_VLAN_TAGf_SET(r,f) field32_set((r).fp_tcam,215,230,f)
#define FP_TCAMm_F1_11_SVPf_GET(r) field32_get((r).fp_tcam,215,229)
#define FP_TCAMm_F1_11_SVPf_SET(r,f) field32_set((r).fp_tcam,215,229,f)
#define FP_TCAMm_F1_7_CLASSIDS_11_6f_GET(r) ((((r).fp_tcam[6]) >> 23) & 0x3f)
#define FP_TCAMm_F1_7_CLASSIDS_11_6f_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x3f << 23)) | ((((uint32)f) & 0x3f) << 23))
#define FP_TCAMm_F1_8_CLASSIDS_11_6f_GET(r) ((((r).fp_tcam[6]) >> 23) & 0x3f)
#define FP_TCAMm_F1_8_CLASSIDS_11_6f_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x3f << 23)) | ((((uint32)f) & 0x3f) << 23))
#define FP_TCAMm_F1_6_PACKET_FORMATf_GET(r) ((((r).fp_tcam[6]) >> 23) & 0xf)
#define FP_TCAMm_F1_6_PACKET_FORMATf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xf << 23)) | ((((uint32)f) & 0xf) << 23))
#define FP_TCAMm_F1_10_D_TYPEf_GET(r) ((((r).fp_tcam[6]) >> 23) & 0x7)
#define FP_TCAMm_F1_10_D_TYPEf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7 << 23)) | ((((uint32)f) & 0x7) << 23))
#define FP_TCAMm_F1_1_D_TYPEf_GET(r) ((((r).fp_tcam[6]) >> 23) & 0x7)
#define FP_TCAMm_F1_1_D_TYPEf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7 << 23)) | ((((uint32)f) & 0x7) << 23))
#define FP_TCAMm_F1_2_D_TYPEf_GET(r) ((((r).fp_tcam[6]) >> 23) & 0x7)
#define FP_TCAMm_F1_2_D_TYPEf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7 << 23)) | ((((uint32)f) & 0x7) << 23))
#define FP_TCAMm_F1_10_DGLPf_GET(r) field32_get((r).fp_tcam,218,233)
#define FP_TCAMm_F1_10_DGLPf_SET(r,f) field32_set((r).fp_tcam,218,233,f)
#define FP_TCAMm_F1_1_S_FIELDf_GET(r) field32_get((r).fp_tcam,218,233)
#define FP_TCAMm_F1_1_S_FIELDf_SET(r,f) field32_set((r).fp_tcam,218,233,f)
#define FP_TCAMm_F1_2_MH_OPCODEf_GET(r) ((((r).fp_tcam[6]) >> 26) & 0x7)
#define FP_TCAMm_F1_2_MH_OPCODEf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7 << 26)) | ((((uint32)f) & 0x7) << 26))
#define FP_TCAMm_DWF1_1_SPAREf_GET(r) field32_get((r).fp_tcam,219,236)
#define FP_TCAMm_DWF1_1_SPAREf_SET(r,f) field32_set((r).fp_tcam,219,236,f)
#define FP_TCAMm_DWF1_1_SPARE_MASKf_GET(r) field32_get((r).fp_tcam,219,236)
#define FP_TCAMm_DWF1_1_SPARE_MASKf_SET(r,f) field32_set((r).fp_tcam,219,236,f)
#define FP_TCAMm_F1_6_SWITCHING_TAG_STATUSf_GET(r) ((((r).fp_tcam[6]) >> 27) & 0x3)
#define FP_TCAMm_F1_6_SWITCHING_TAG_STATUSf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x3 << 27)) | ((((uint32)f) & 0x3) << 27))
#define FP_TCAMm_F1_2_CLASSIDSf_GET(r) field32_get((r).fp_tcam,221,232)
#define FP_TCAMm_F1_2_CLASSIDSf_SET(r,f) field32_set((r).fp_tcam,221,232,f)
#define FP_TCAMm_F1_7_FORWARDING_FIELDf_GET(r) field32_get((r).fp_tcam,221,232)
#define FP_TCAMm_F1_7_FORWARDING_FIELDf_SET(r,f) field32_set((r).fp_tcam,221,232,f)
#define FP_TCAMm_F1_8_FORWARDING_FIELDf_GET(r) field32_get((r).fp_tcam,221,232)
#define FP_TCAMm_F1_8_FORWARDING_FIELDf_SET(r,f) field32_set((r).fp_tcam,221,232,f)
#define FP_TCAMm_F1_6_MH_OPCODEf_GET(r) ((((r).fp_tcam[6]) >> 29) & 0x7)
#define FP_TCAMm_F1_6_MH_OPCODEf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))
#define FP_TCAMm_F1_15_ROCE_BTH_PARTITION_KEYf_GET(r) field32_get((r).fp_tcam,222,237)
#define FP_TCAMm_F1_15_ROCE_BTH_PARTITION_KEYf_SET(r,f) field32_set((r).fp_tcam,222,237,f)
#define FP_TCAMm_F1_12_SVPf_GET(r) field32_get((r).fp_tcam,223,237)
#define FP_TCAMm_F1_12_SVPf_SET(r,f) field32_set((r).fp_tcam,223,237,f)
#define FP_TCAMm_F1_0_SVP_L3_IIFf_GET(r) field32_get((r).fp_tcam,223,235)
#define FP_TCAMm_F1_0_SVP_L3_IIFf_SET(r,f) field32_set((r).fp_tcam,223,235,f)
#define FP_TCAMm_F1_6_PKT_RESOLUTIONf_GET(r) (((r).fp_tcam[7]) & 0x1f)
#define FP_TCAMm_F1_6_PKT_RESOLUTIONf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))
#define FP_TCAMm_F1_14_VXLAN_CLASS_IDf_GET(r) ((((r).fp_tcam[7]) >> 1) & 0x3f)
#define FP_TCAMm_F1_14_VXLAN_CLASS_IDf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3f << 1)) | ((((uint32)f) & 0x3f) << 1))
#define FP_TCAMm_DWF1_2_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 5) & 0xff)
#define FP_TCAMm_DWF1_2_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xff << 5)) | ((((uint32)f) & 0xff) << 5))
#define FP_TCAMm_DWF1_2_SPARE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 5) & 0xff)
#define FP_TCAMm_DWF1_2_SPARE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xff << 5)) | ((((uint32)f) & 0xff) << 5))
#define FP_TCAMm_DWF1_0_D_TYPEf_GET(r) ((((r).fp_tcam[7]) >> 5) & 0x7)
#define FP_TCAMm_DWF1_0_D_TYPEf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 5)) | ((((uint32)f) & 0x7) << 5))
#define FP_TCAMm_DWF1_0_D_TYPE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 5) & 0x7)
#define FP_TCAMm_DWF1_0_D_TYPE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 5)) | ((((uint32)f) & 0x7) << 5))
#define FP_TCAMm_F1_6_IP_INFOf_GET(r) ((((r).fp_tcam[7]) >> 5) & 0x7)
#define FP_TCAMm_F1_6_IP_INFOf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 5)) | ((((uint32)f) & 0x7) << 5))
#define FP_TCAMm_F1_11_SVP_VALIDf_GET(r) ((((r).fp_tcam[7]) >> 6) & 0x1)
#define FP_TCAMm_F1_11_SVP_VALIDf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define FP_TCAMm_F1_11_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 7) & 0x7f)
#define FP_TCAMm_F1_11_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define FP_TCAMm_F1_4_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 7) & 0x7f)
#define FP_TCAMm_F1_4_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define FP_TCAMm_F1_3_OUTER_TPID_ENCODEf_GET(r) ((((r).fp_tcam[7]) >> 7) & 0x3)
#define FP_TCAMm_F1_3_OUTER_TPID_ENCODEf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define FP_TCAMm_F1_5_INNER_TPID_ENCODEf_GET(r) ((((r).fp_tcam[7]) >> 7) & 0x3)
#define FP_TCAMm_F1_5_INNER_TPID_ENCODEf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define FP_TCAMm_F1_9_MPLS_INFOf_GET(r) ((((r).fp_tcam[7]) >> 7) & 0x3)
#define FP_TCAMm_F1_9_MPLS_INFOf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define FP_TCAMm_F1_13_AUX_TAG_VALID_1f_GET(r) ((((r).fp_tcam[7]) >> 7) & 0x1)
#define FP_TCAMm_F1_13_AUX_TAG_VALID_1f_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_TCAMm_F1_14_VXLAN_ETHERNETf_GET(r) ((((r).fp_tcam[7]) >> 7) & 0x1)
#define FP_TCAMm_F1_14_VXLAN_ETHERNETf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_TCAMm_F1_13_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 8) & 0x3f)
#define FP_TCAMm_F1_13_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3f << 8)) | ((((uint32)f) & 0x3f) << 8))
#define FP_TCAMm_F1_6_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 8) & 0x3f)
#define FP_TCAMm_F1_6_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3f << 8)) | ((((uint32)f) & 0x3f) << 8))
#define FP_TCAMm_DWF1_0_INT_CNf_GET(r) ((((r).fp_tcam[7]) >> 8) & 0x3)
#define FP_TCAMm_DWF1_0_INT_CNf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define FP_TCAMm_DWF1_0_INT_CN_MASKf_GET(r) ((((r).fp_tcam[7]) >> 8) & 0x3)
#define FP_TCAMm_DWF1_0_INT_CN_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define FP_TCAMm_F1_14_IP_TUNNEL_TERMINATIONf_GET(r) ((((r).fp_tcam[7]) >> 8) & 0x1)
#define FP_TCAMm_F1_14_IP_TUNNEL_TERMINATIONf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_TCAMm_F1_2_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 9) & 0x1f)
#define FP_TCAMm_F1_2_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1f << 9)) | ((((uint32)f) & 0x1f) << 9))
#define FP_TCAMm_F1_3_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 9) & 0x1f)
#define FP_TCAMm_F1_3_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1f << 9)) | ((((uint32)f) & 0x1f) << 9))
#define FP_TCAMm_F1_5_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 9) & 0x1f)
#define FP_TCAMm_F1_5_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1f << 9)) | ((((uint32)f) & 0x1f) << 9))
#define FP_TCAMm_F1_9_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 9) & 0x1f)
#define FP_TCAMm_F1_9_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1f << 9)) | ((((uint32)f) & 0x1f) << 9))
#define FP_TCAMm_F1_14_PAYLOAD_VLAN_TAG_STATUSf_GET(r) ((((r).fp_tcam[7]) >> 9) & 0x3)
#define FP_TCAMm_F1_14_PAYLOAD_VLAN_TAG_STATUSf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define FP_TCAMm_F1_7_MPLS_INFOf_GET(r) ((((r).fp_tcam[7]) >> 9) & 0x3)
#define FP_TCAMm_F1_7_MPLS_INFOf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define FP_TCAMm_F1_8_INT_CNf_GET(r) ((((r).fp_tcam[7]) >> 9) & 0x3)
#define FP_TCAMm_F1_8_INT_CNf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define FP_TCAMm_F1_10_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 10) & 0xf)
#define FP_TCAMm_F1_10_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xf << 10)) | ((((uint32)f) & 0xf) << 10))
#define FP_TCAMm_DWF1_0_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 10) & 0x7)
#define FP_TCAMm_DWF1_0_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define FP_TCAMm_DWF1_0_SPARE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 10) & 0x7)
#define FP_TCAMm_DWF1_0_SPARE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define FP_TCAMm_F1_1_SVP_VALIDf_GET(r) ((((r).fp_tcam[7]) >> 10) & 0x1)
#define FP_TCAMm_F1_1_SVP_VALIDf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define FP_TCAMm_F1_1_MH_OPCODEf_GET(r) ((((r).fp_tcam[7]) >> 11) & 0x7)
#define FP_TCAMm_F1_1_MH_OPCODEf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 11)) | ((((uint32)f) & 0x7) << 11))
#define FP_TCAMm_F1_7_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 11) & 0x7)
#define FP_TCAMm_F1_7_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 11)) | ((((uint32)f) & 0x7) << 11))
#define FP_TCAMm_F1_8_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 11) & 0x7)
#define FP_TCAMm_F1_8_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 11)) | ((((uint32)f) & 0x7) << 11))
#define FP_TCAMm_F1_14_VNID_LOOKUP_HIT_STATUSf_GET(r) ((((r).fp_tcam[7]) >> 11) & 0x1)
#define FP_TCAMm_F1_14_VNID_LOOKUP_HIT_STATUSf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_TCAMm_F1_0_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 12) & 0x3)
#define FP_TCAMm_F1_0_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define FP_TCAMm_F1_14_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 12) & 0x3)
#define FP_TCAMm_F1_14_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define FP_TCAMm_RESERVED_DWf_GET(r) ((((r).fp_tcam[7]) >> 13) & 0x1)
#define FP_TCAMm_RESERVED_DWf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_TCAMm_FULL_MASKf_GET(r,a) field_get((r).fp_tcam,238,473,a)
#define FP_TCAMm_FULL_MASKf_SET(r,a) field_set((r).fp_tcam,238,473,a)
#define FP_TCAMm_MASKf_GET(r,a) field_get((r).fp_tcam,238,473,a)
#define FP_TCAMm_MASKf_SET(r,a) field_set((r).fp_tcam,238,473,a)
#define FP_TCAMm_DOUBLE_WIDE_MODE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 14) & 0x1)
#define FP_TCAMm_DOUBLE_WIDE_MODE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define FP_TCAMm_DW_DOUBLE_WIDE_MODE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 14) & 0x1)
#define FP_TCAMm_DW_DOUBLE_WIDE_MODE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define FP_TCAMm_DATA_MASKf_GET(r,a) field_get((r).fp_tcam,239,473,a)
#define FP_TCAMm_DATA_MASKf_SET(r,a) field_set((r).fp_tcam,239,473,a)
#define FP_TCAMm_DWF4_MASKf_GET(r) ((((r).fp_tcam[7]) >> 15) & 0xff)
#define FP_TCAMm_DWF4_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xff << 15)) | ((((uint32)f) & 0xff) << 15))
#define FP_TCAMm_F4_MASKf_GET(r) ((((r).fp_tcam[7]) >> 15) & 0xff)
#define FP_TCAMm_F4_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xff << 15)) | ((((uint32)f) & 0xff) << 15))
#define FP_TCAMm_DWF3_MASKf_GET(r) field32_get((r).fp_tcam,247,278)
#define FP_TCAMm_DWF3_MASKf_SET(r,f) field32_set((r).fp_tcam,247,278,f)
#define FP_TCAMm_FIXED_MASKf_GET(r) field32_get((r).fp_tcam,247,267)
#define FP_TCAMm_FIXED_MASKf_SET(r,f) field32_set((r).fp_tcam,247,267,f)
#define FP_TCAMm_FIXED_HIGIG_MASKf_GET(r) ((((r).fp_tcam[7]) >> 23) & 0x1)
#define FP_TCAMm_FIXED_HIGIG_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define FP_TCAMm_FIXED_FORWARDING_TYPE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 24) & 0x7)
#define FP_TCAMm_FIXED_FORWARDING_TYPE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define FP_TCAMm_FIXED_SVP_OR_L3IIF_MASKf_GET(r) ((((r).fp_tcam[7]) >> 27) & 0x1)
#define FP_TCAMm_FIXED_SVP_OR_L3IIF_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define FP_TCAMm_FIXED_L3_TYPE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 28) & 0xf)
#define FP_TCAMm_FIXED_L3_TYPE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define FP_TCAMm_FIXED_L4_VALID_MASKf_GET(r) (((r).fp_tcam[8]) & 0x1)
#define FP_TCAMm_FIXED_L4_VALID_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define FP_TCAMm_FIXED_L3_ROUTABLE_MASKf_GET(r) ((((r).fp_tcam[8]) >> 1) & 0x1)
#define FP_TCAMm_FIXED_L3_ROUTABLE_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_TCAMm_FIXED_TUNNEL_TYPE_LOOPBACK_TYPE_MASKf_GET(r) ((((r).fp_tcam[8]) >> 2) & 0xf)
#define FP_TCAMm_FIXED_TUNNEL_TYPE_LOOPBACK_TYPE_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xf << 2)) | ((((uint32)f) & 0xf) << 2))
#define FP_TCAMm_FIXED_DROP_MASKf_GET(r) ((((r).fp_tcam[8]) >> 6) & 0x1)
#define FP_TCAMm_FIXED_DROP_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define FP_TCAMm_FIXED_MIRROR_ONLY_MASKf_GET(r) ((((r).fp_tcam[8]) >> 7) & 0x1)
#define FP_TCAMm_FIXED_MIRROR_ONLY_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_TCAMm_FIXED_MIML_PRESENT_MASKf_GET(r) ((((r).fp_tcam[8]) >> 8) & 0x1)
#define FP_TCAMm_FIXED_MIML_PRESENT_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_TCAMm_FIXED_CUSTOM_HEADER_PRESENT_MASKf_GET(r) ((((r).fp_tcam[8]) >> 9) & 0x1)
#define FP_TCAMm_FIXED_CUSTOM_HEADER_PRESENT_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_TCAMm_FIXED_PREEMPTABLE_FRAME_MASKf_GET(r) ((((r).fp_tcam[8]) >> 10) & 0x1)
#define FP_TCAMm_FIXED_PREEMPTABLE_FRAME_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define FP_TCAMm_FIXED_PDELAY_REQ_MASKf_GET(r) ((((r).fp_tcam[8]) >> 11) & 0x1)
#define FP_TCAMm_FIXED_PDELAY_REQ_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_TCAMm_F3_MASKf_GET(r,a) field_get((r).fp_tcam,268,306,a)
#define FP_TCAMm_F3_MASKf_SET(r,a) field_set((r).fp_tcam,268,306,a)
#define FP_TCAMm_F3_12_AUX_TAG_2_MASKf_GET(r) field32_get((r).fp_tcam,268,299)
#define FP_TCAMm_F3_12_AUX_TAG_2_MASKf_SET(r,f) field32_set((r).fp_tcam,268,299,f)
#define FP_TCAMm_F3_9_UDF1_95_64_MASKf_GET(r) field32_get((r).fp_tcam,268,299)
#define FP_TCAMm_F3_9_UDF1_95_64_MASKf_SET(r,f) field32_set((r).fp_tcam,268,299,f)
#define FP_TCAMm_F3_7_RANGE_CHECK_RESULTS_MASKf_GET(r) field32_get((r).fp_tcam,268,291)
#define FP_TCAMm_F3_7_RANGE_CHECK_RESULTS_MASKf_SET(r,f) field32_set((r).fp_tcam,268,291,f)
#define FP_TCAMm_F3_8_IPV6_FL_MASKf_GET(r) ((((r).fp_tcam[8]) >> 12) & 0xfffff)
#define FP_TCAMm_F3_8_IPV6_FL_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xfffff << 12)) | ((((uint32)f) & 0xfffff) << 12))
#define FP_TCAMm_F3_10_D_FIELD_MASKf_GET(r) ((((r).fp_tcam[8]) >> 12) & 0xffff)
#define FP_TCAMm_F3_10_D_FIELD_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F3_11_SGLP_MASKf_GET(r) ((((r).fp_tcam[8]) >> 12) & 0xffff)
#define FP_TCAMm_F3_11_SGLP_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F3_2_D_FIELD_MASKf_GET(r) ((((r).fp_tcam[8]) >> 12) & 0xffff)
#define FP_TCAMm_F3_2_D_FIELD_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F3_3_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[8]) >> 12) & 0xffff)
#define FP_TCAMm_F3_3_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F3_4_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[8]) >> 12) & 0xffff)
#define FP_TCAMm_F3_4_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F3_5_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[8]) >> 12) & 0xffff)
#define FP_TCAMm_F3_5_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F3_6_LOOKUP_STATUS_MASKf_GET(r) ((((r).fp_tcam[8]) >> 12) & 0xffff)
#define FP_TCAMm_F3_6_LOOKUP_STATUS_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F3_0_CLASSIDS_MASKf_GET(r) ((((r).fp_tcam[8]) >> 12) & 0xfff)
#define FP_TCAMm_F3_0_CLASSIDS_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))
#define FP_TCAMm_F3_1_CLASSIDS_MASKf_GET(r) ((((r).fp_tcam[8]) >> 12) & 0xfff)
#define FP_TCAMm_F3_1_CLASSIDS_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))
#define FP_TCAMm_F3_13_ROCEV1_PACKET_MASKf_GET(r) ((((r).fp_tcam[8]) >> 12) & 0x1)
#define FP_TCAMm_F3_13_ROCEV1_PACKET_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_TCAMm_F3_13_ROCEV2_PACKET_MASKf_GET(r) ((((r).fp_tcam[8]) >> 13) & 0x1)
#define FP_TCAMm_F3_13_ROCEV2_PACKET_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_TCAMm_F3_13_ROCE_BTH_FLAGS_MASKf_GET(r) ((((r).fp_tcam[8]) >> 14) & 0xff)
#define FP_TCAMm_F3_13_ROCE_BTH_FLAGS_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xff << 14)) | ((((uint32)f) & 0xff) << 14))
#define FP_TCAMm_F3_13_ROCE_BTH_DESTINATION_QP_MASKf_GET(r) field32_get((r).fp_tcam,278,301)
#define FP_TCAMm_F3_13_ROCE_BTH_DESTINATION_QP_MASKf_SET(r,f) field32_set((r).fp_tcam,278,301,f)
#define FP_TCAMm_DWF2_MASKf_GET(r,a) field_get((r).fp_tcam,279,406,a)
#define FP_TCAMm_DWF2_MASKf_SET(r,a) field_set((r).fp_tcam,279,406,a)
#define FP_TCAMm_F3_0_FORWARDING_FIELD_MASKf_GET(r) field32_get((r).fp_tcam,280,291)
#define FP_TCAMm_F3_0_FORWARDING_FIELD_MASKf_SET(r,f) field32_set((r).fp_tcam,280,291,f)
#define FP_TCAMm_F3_1_FORWARDING_FIELD_MASKf_GET(r) field32_get((r).fp_tcam,280,291)
#define FP_TCAMm_F3_1_FORWARDING_FIELD_MASKf_SET(r,f) field32_set((r).fp_tcam,280,291,f)
#define FP_TCAMm_F3_4_INNER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,284,299)
#define FP_TCAMm_F3_4_INNER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,284,299,f)
#define FP_TCAMm_F3_5_ETHERTYPE_MASKf_GET(r) field32_get((r).fp_tcam,284,299)
#define FP_TCAMm_F3_5_ETHERTYPE_MASKf_SET(r,f) field32_set((r).fp_tcam,284,299,f)
#define FP_TCAMm_F3_6_INNER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,284,299)
#define FP_TCAMm_F3_6_INNER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,284,299,f)
#define FP_TCAMm_F3_11_SVP_MASKf_GET(r) field32_get((r).fp_tcam,284,298)
#define FP_TCAMm_F3_11_SVP_MASKf_SET(r,f) field32_set((r).fp_tcam,284,298,f)
#define FP_TCAMm_F3_3_PACKET_FORMAT_MASKf_GET(r) ((((r).fp_tcam[8]) >> 28) & 0xf)
#define FP_TCAMm_F3_3_PACKET_FORMAT_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define FP_TCAMm_F3_10_D_TYPE_MASKf_GET(r) ((((r).fp_tcam[8]) >> 28) & 0x7)
#define FP_TCAMm_F3_10_D_TYPE_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x7 << 28)) | ((((uint32)f) & 0x7) << 28))
#define FP_TCAMm_F3_2_D_TYPE_MASKf_GET(r) ((((r).fp_tcam[8]) >> 28) & 0x7)
#define FP_TCAMm_F3_2_D_TYPE_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x7 << 28)) | ((((uint32)f) & 0x7) << 28))
#define FP_TCAMm_F3_10_DGLP_MASKf_GET(r) field32_get((r).fp_tcam,287,302)
#define FP_TCAMm_F3_10_DGLP_MASKf_SET(r,f) field32_set((r).fp_tcam,287,302,f)
#define FP_TCAMm_F3_2_S_FIELD_MASKf_GET(r) field32_get((r).fp_tcam,287,302)
#define FP_TCAMm_F3_2_S_FIELD_MASKf_SET(r,f) field32_set((r).fp_tcam,287,302,f)
#define FP_TCAMm_F3_8_PACKET_FORMAT_MASKf_GET(r) (((r).fp_tcam[9]) & 0xf)
#define FP_TCAMm_F3_8_PACKET_FORMAT_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define FP_TCAMm_F3_3_SWITCHING_TAG_STATUS_MASKf_GET(r) (((r).fp_tcam[9]) & 0x3)
#define FP_TCAMm_F3_3_SWITCHING_TAG_STATUS_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_TCAMm_F3_3_MH_OPCODE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 2) & 0x7)
#define FP_TCAMm_F3_3_MH_OPCODE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7 << 2)) | ((((uint32)f) & 0x7) << 2))
#define FP_TCAMm_F3_0_SVP_L3IIF_OVERLAY_MASKf_GET(r) ((((r).fp_tcam[9]) >> 4) & 0x1fff)
#define FP_TCAMm_F3_0_SVP_L3IIF_OVERLAY_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1fff << 4)) | ((((uint32)f) & 0x1fff) << 4))
#define FP_TCAMm_F3_1_OUTER_VLAN_ID_MASKf_GET(r) ((((r).fp_tcam[9]) >> 4) & 0xfff)
#define FP_TCAMm_F3_1_OUTER_VLAN_ID_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xfff << 4)) | ((((uint32)f) & 0xfff) << 4))
#define FP_TCAMm_F3_7_INTERFACE_CLASSID_MASKf_GET(r) ((((r).fp_tcam[9]) >> 4) & 0xff)
#define FP_TCAMm_F3_7_INTERFACE_CLASSID_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xff << 4)) | ((((uint32)f) & 0xff) << 4))
#define FP_TCAMm_F3_8_SWITCHING_TAG_STATUS_MASKf_GET(r) ((((r).fp_tcam[9]) >> 4) & 0x3)
#define FP_TCAMm_F3_8_SWITCHING_TAG_STATUS_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define FP_TCAMm_F3_3_PKT_RESOLUTION_MASKf_GET(r) ((((r).fp_tcam[9]) >> 5) & 0x1f)
#define FP_TCAMm_F3_3_PKT_RESOLUTION_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1f << 5)) | ((((uint32)f) & 0x1f) << 5))
#define FP_TCAMm_F3_8_INNER_TPID_ENCODE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 6) & 0x3)
#define FP_TCAMm_F3_8_INNER_TPID_ENCODE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define FP_TCAMm_F3_8_OUTER_TPID_ENCODE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 8) & 0x3)
#define FP_TCAMm_F3_8_OUTER_TPID_ENCODE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define FP_TCAMm_F3_8_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 10) & 0x1ff)
#define FP_TCAMm_F3_8_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1ff << 10)) | ((((uint32)f) & 0x1ff) << 10))
#define FP_TCAMm_F3_3_IP_INFO_MASKf_GET(r) ((((r).fp_tcam[9]) >> 10) & 0x7)
#define FP_TCAMm_F3_3_IP_INFO_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define FP_TCAMm_F3_11_SVP_VALID_MASKf_GET(r) ((((r).fp_tcam[9]) >> 11) & 0x1)
#define FP_TCAMm_F3_11_SVP_VALID_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_TCAMm_F3_11_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0x7f)
#define FP_TCAMm_F3_11_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7f << 12)) | ((((uint32)f) & 0x7f) << 12))
#define FP_TCAMm_F3_4_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0x7f)
#define FP_TCAMm_F3_4_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7f << 12)) | ((((uint32)f) & 0x7f) << 12))
#define FP_TCAMm_F3_5_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0x7f)
#define FP_TCAMm_F3_5_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7f << 12)) | ((((uint32)f) & 0x7f) << 12))
#define FP_TCAMm_F3_6_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0x7f)
#define FP_TCAMm_F3_6_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7f << 12)) | ((((uint32)f) & 0x7f) << 12))
#define FP_TCAMm_F3_7_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0x7f)
#define FP_TCAMm_F3_7_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7f << 12)) | ((((uint32)f) & 0x7f) << 12))
#define FP_TCAMm_F3_9_MPLS_INFO_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0x3)
#define FP_TCAMm_F3_9_MPLS_INFO_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define FP_TCAMm_F3_12_AUX_TAG_VALID_2_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0x1)
#define FP_TCAMm_F3_12_AUX_TAG_VALID_2_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_TCAMm_F3_12_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 13) & 0x3f)
#define FP_TCAMm_F3_12_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3f << 13)) | ((((uint32)f) & 0x3f) << 13))
#define FP_TCAMm_F3_3_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 13) & 0x3f)
#define FP_TCAMm_F3_3_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3f << 13)) | ((((uint32)f) & 0x3f) << 13))
#define FP_TCAMm_F3_13_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 14) & 0x1f)
#define FP_TCAMm_F3_13_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1f << 14)) | ((((uint32)f) & 0x1f) << 14))
#define FP_TCAMm_F3_9_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 14) & 0x1f)
#define FP_TCAMm_F3_9_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1f << 14)) | ((((uint32)f) & 0x1f) << 14))
#define FP_TCAMm_F3_10_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 15) & 0xf)
#define FP_TCAMm_F3_10_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xf << 15)) | ((((uint32)f) & 0xf) << 15))
#define FP_TCAMm_F3_2_SVP_VALID_MASKf_GET(r) ((((r).fp_tcam[9]) >> 15) & 0x1)
#define FP_TCAMm_F3_2_SVP_VALID_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define FP_TCAMm_F3_1_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 16) & 0x7)
#define FP_TCAMm_F3_1_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7 << 16)) | ((((uint32)f) & 0x7) << 16))
#define FP_TCAMm_F3_2_MH_OPCODE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 16) & 0x7)
#define FP_TCAMm_F3_2_MH_OPCODE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7 << 16)) | ((((uint32)f) & 0x7) << 16))
#define FP_TCAMm_F3_0_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 17) & 0x3)
#define FP_TCAMm_F3_0_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3 << 17)) | ((((uint32)f) & 0x3) << 17))
#define FP_TCAMm_F2_15_PAYLOAD_SIP_MASKf_GET(r,a) field_get((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_15_PAYLOAD_SIP_MASKf_SET(r,a) field_set((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_16_PAYLOAD_DIP_MASKf_GET(r,a) field_get((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_16_PAYLOAD_DIP_MASKf_SET(r,a) field_set((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_2_SIP_MASKf_GET(r,a) field_get((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_2_SIP_MASKf_SET(r,a) field_set((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_3_DIP_MASKf_GET(r,a) field_get((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_3_DIP_MASKf_SET(r,a) field_set((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_8_UDF1_MASKf_GET(r,a) field_get((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_8_UDF1_MASKf_SET(r,a) field_set((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_9_UDF2_MASKf_GET(r,a) field_get((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_9_UDF2_MASKf_SET(r,a) field_set((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_MASKf_GET(r,a) field_get((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_MASKf_SET(r,a) field_set((r).fp_tcam,307,434,a)
#define FP_TCAMm_F2_10_SIP_127_64_MASKf_GET(r,a) field_get((r).fp_tcam,307,370,a)
#define FP_TCAMm_F2_10_SIP_127_64_MASKf_SET(r,a) field_set((r).fp_tcam,307,370,a)
#define FP_TCAMm_F2_12_MIML_SA_MASKf_GET(r,a) field_get((r).fp_tcam,307,354,a)
#define FP_TCAMm_F2_12_MIML_SA_MASKf_SET(r,a) field_set((r).fp_tcam,307,354,a)
#define FP_TCAMm_F2_11_DIP_127_96_MASKf_GET(r) field32_get((r).fp_tcam,307,338)
#define FP_TCAMm_F2_11_DIP_127_96_MASKf_SET(r,f) field32_set((r).fp_tcam,307,338,f)
#define FP_TCAMm_F2_18_OUTER_SIP_MASKf_GET(r) field32_get((r).fp_tcam,307,338)
#define FP_TCAMm_F2_18_OUTER_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,307,338,f)
#define FP_TCAMm_F2_13_PAYLOAD_OUTER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,307,322)
#define FP_TCAMm_F2_13_PAYLOAD_OUTER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,307,322,f)
#define FP_TCAMm_F2_14_PAYLOAD_L4_DST_MASKf_GET(r) field32_get((r).fp_tcam,307,322)
#define FP_TCAMm_F2_14_PAYLOAD_L4_DST_MASKf_SET(r,f) field32_set((r).fp_tcam,307,322,f)
#define FP_TCAMm_F2_5_OUTER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,307,322)
#define FP_TCAMm_F2_5_OUTER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,307,322,f)
#define FP_TCAMm_F2_6_OUTER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,307,322)
#define FP_TCAMm_F2_6_OUTER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,307,322,f)
#define FP_TCAMm_F2_7_OUTER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,307,322)
#define FP_TCAMm_F2_7_OUTER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,307,322,f)
#define FP_TCAMm_F2_0_TTL_FN_MASKf_GET(r) ((((r).fp_tcam[9]) >> 19) & 0xff)
#define FP_TCAMm_F2_0_TTL_FN_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xff << 19)) | ((((uint32)f) & 0xff) << 19))
#define FP_TCAMm_F2_1_TTL_FN_MASKf_GET(r) ((((r).fp_tcam[9]) >> 19) & 0xff)
#define FP_TCAMm_F2_1_TTL_FN_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xff << 19)) | ((((uint32)f) & 0xff) << 19))
#define FP_TCAMm_F2_4_TTL_FN_MASKf_GET(r) ((((r).fp_tcam[9]) >> 19) & 0xff)
#define FP_TCAMm_F2_4_TTL_FN_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xff << 19)) | ((((uint32)f) & 0xff) << 19))
#define FP_TCAMm_F2_17_SR_NETID_MATCH_MASKf_GET(r) ((((r).fp_tcam[9]) >> 19) & 0x1)
#define FP_TCAMm_F2_17_SR_NETID_MATCH_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_TCAMm_F2_17_INT_PRI_MASKf_GET(r) ((((r).fp_tcam[9]) >> 20) & 0xf)
#define FP_TCAMm_F2_17_INT_PRI_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define FP_TCAMm_F2_17_TSN_CIRCUIT_ID_MASKf_GET(r) field32_get((r).fp_tcam,312,323)
#define FP_TCAMm_F2_17_TSN_CIRCUIT_ID_MASKf_SET(r,f) field32_set((r).fp_tcam,312,323,f)
#define FP_TCAMm_F2_0_TCP_FN_MASKf_GET(r) field32_get((r).fp_tcam,315,320)
#define FP_TCAMm_F2_0_TCP_FN_MASKf_SET(r,f) field32_set((r).fp_tcam,315,320,f)
#define FP_TCAMm_F2_1_TCP_FN_MASKf_GET(r) field32_get((r).fp_tcam,315,320)
#define FP_TCAMm_F2_1_TCP_FN_MASKf_SET(r,f) field32_set((r).fp_tcam,315,320,f)
#define FP_TCAMm_F2_4_TCP_FN_MASKf_GET(r) field32_get((r).fp_tcam,315,320)
#define FP_TCAMm_F2_4_TCP_FN_MASKf_SET(r,f) field32_set((r).fp_tcam,315,320,f)
#define FP_TCAMm_F2_4_IPV6_FL_MASKf_GET(r) ((((r).fp_tcam[10]) >> 1) & 0xfffff)
#define FP_TCAMm_F2_4_IPV6_FL_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xfffff << 1)) | ((((uint32)f) & 0xfffff) << 1))
#define FP_TCAMm_F2_0_IPFLAG_MASKf_GET(r) ((((r).fp_tcam[10]) >> 1) & 0x3)
#define FP_TCAMm_F2_0_IPFLAG_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x3 << 1)) | ((((uint32)f) & 0x3) << 1))
#define FP_TCAMm_F2_1_IP_FRAG_INFO_MASKf_GET(r) ((((r).fp_tcam[10]) >> 1) & 0x3)
#define FP_TCAMm_F2_1_IP_FRAG_INFO_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x3 << 1)) | ((((uint32)f) & 0x3) << 1))
#define FP_TCAMm_F2_13_PAYLOAD_ETHERTYPE_MASKf_GET(r) ((((r).fp_tcam[10]) >> 3) & 0xffff)
#define FP_TCAMm_F2_13_PAYLOAD_ETHERTYPE_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_TCAMm_F2_14_PAYLOAD_L4_SRC_MASKf_GET(r) ((((r).fp_tcam[10]) >> 3) & 0xffff)
#define FP_TCAMm_F2_14_PAYLOAD_L4_SRC_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_TCAMm_F2_5_ETHERTYPE_MASKf_GET(r) ((((r).fp_tcam[10]) >> 3) & 0xffff)
#define FP_TCAMm_F2_5_ETHERTYPE_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_TCAMm_F2_6_ETHERTYPE_MASKf_GET(r) ((((r).fp_tcam[10]) >> 3) & 0xffff)
#define FP_TCAMm_F2_6_ETHERTYPE_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_TCAMm_F2_7_ETHERTYPE_MASKf_GET(r) ((((r).fp_tcam[10]) >> 3) & 0xffff)
#define FP_TCAMm_F2_7_ETHERTYPE_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_TCAMm_F2_0_TOS_FN_MASKf_GET(r) ((((r).fp_tcam[10]) >> 3) & 0xff)
#define FP_TCAMm_F2_0_TOS_FN_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define FP_TCAMm_F2_1_TOS_FN_MASKf_GET(r) ((((r).fp_tcam[10]) >> 3) & 0xff)
#define FP_TCAMm_F2_1_TOS_FN_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define FP_TCAMm_F2_17_SR_FLOW_ID_MASKf_GET(r) ((((r).fp_tcam[10]) >> 4) & 0x1fff)
#define FP_TCAMm_F2_17_SR_FLOW_ID_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x1fff << 4)) | ((((uint32)f) & 0x1fff) << 4))
#define FP_TCAMm_F2_0_L4_DST_MASKf_GET(r) ((((r).fp_tcam[10]) >> 11) & 0xffff)
#define FP_TCAMm_F2_0_L4_DST_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xffff << 11)) | ((((uint32)f) & 0xffff) << 11))
#define FP_TCAMm_F2_1_L4_DST_MASKf_GET(r) ((((r).fp_tcam[10]) >> 11) & 0xffff)
#define FP_TCAMm_F2_1_L4_DST_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xffff << 11)) | ((((uint32)f) & 0xffff) << 11))
#define FP_TCAMm_F2_17_PKT_NET_ID_VALID_MASKf_GET(r) ((((r).fp_tcam[10]) >> 17) & 0x1)
#define FP_TCAMm_F2_17_PKT_NET_ID_VALID_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define FP_TCAMm_F2_17_PKT_LAN_ID_VALID_MASKf_GET(r) ((((r).fp_tcam[10]) >> 18) & 0x1)
#define FP_TCAMm_F2_17_PKT_LAN_ID_VALID_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define FP_TCAMm_F2_11_SA_MASKf_GET(r,a) field_get((r).fp_tcam,339,386,a)
#define FP_TCAMm_F2_11_SA_MASKf_SET(r,a) field_set((r).fp_tcam,339,386,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACSA_MASKf_GET(r,a) field_get((r).fp_tcam,339,386,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACSA_MASKf_SET(r,a) field_set((r).fp_tcam,339,386,a)
#define FP_TCAMm_F2_5_SA_MASKf_GET(r,a) field_get((r).fp_tcam,339,386,a)
#define FP_TCAMm_F2_5_SA_MASKf_SET(r,a) field_set((r).fp_tcam,339,386,a)
#define FP_TCAMm_F2_6_SA_MASKf_GET(r,a) field_get((r).fp_tcam,339,386,a)
#define FP_TCAMm_F2_6_SA_MASKf_SET(r,a) field_set((r).fp_tcam,339,386,a)
#define FP_TCAMm_F2_18_OUTER_DIP_MASKf_GET(r) field32_get((r).fp_tcam,339,370)
#define FP_TCAMm_F2_18_OUTER_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,339,370,f)
#define FP_TCAMm_F2_14_PAYLOAD_TOS_FN_MASKf_GET(r) ((((r).fp_tcam[10]) >> 19) & 0xff)
#define FP_TCAMm_F2_14_PAYLOAD_TOS_FN_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xff << 19)) | ((((uint32)f) & 0xff) << 19))
#define FP_TCAMm_F2_7_TTL_FN_MASKf_GET(r) ((((r).fp_tcam[10]) >> 19) & 0xff)
#define FP_TCAMm_F2_7_TTL_FN_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xff << 19)) | ((((uint32)f) & 0xff) << 19))
#define FP_TCAMm_F2_17_SR_FLOW_RX_TAG_ERROR_MASKf_GET(r) ((((r).fp_tcam[10]) >> 19) & 0x1)
#define FP_TCAMm_F2_17_SR_FLOW_RX_TAG_ERROR_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_TCAMm_F2_17_SR_FLOW_RX_ERROR_MASKf_GET(r) ((((r).fp_tcam[10]) >> 20) & 0x1)
#define FP_TCAMm_F2_17_SR_FLOW_RX_ERROR_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_TCAMm_F2_4_TOS_FN_MASKf_GET(r) ((((r).fp_tcam[10]) >> 21) & 0xff)
#define FP_TCAMm_F2_4_TOS_FN_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xff << 21)) | ((((uint32)f) & 0xff) << 21))
#define FP_TCAMm_F2_17_VLAN_SR_LAN_ID_MASKf_GET(r) ((((r).fp_tcam[10]) >> 21) & 0x1)
#define FP_TCAMm_F2_17_VLAN_SR_LAN_ID_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define FP_TCAMm_F2_17_VLAN_SR_ENABLE_MASKf_GET(r) ((((r).fp_tcam[10]) >> 22) & 0x1)
#define FP_TCAMm_F2_17_VLAN_SR_ENABLE_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define FP_TCAMm_F2_17_EGR_SR_MODE_MASKf_GET(r) ((((r).fp_tcam[10]) >> 23) & 0x7)
#define FP_TCAMm_F2_17_EGR_SR_MODE_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x7 << 23)) | ((((uint32)f) & 0x7) << 23))
#define FP_TCAMm_F2_17_EGR_SR_NET_ID_MASKf_GET(r) ((((r).fp_tcam[10]) >> 26) & 0x7)
#define FP_TCAMm_F2_17_EGR_SR_NET_ID_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x7 << 26)) | ((((uint32)f) & 0x7) << 26))
#define FP_TCAMm_F2_0_L4_SRC_MASKf_GET(r) field32_get((r).fp_tcam,347,362)
#define FP_TCAMm_F2_0_L4_SRC_MASKf_SET(r,f) field32_set((r).fp_tcam,347,362,f)
#define FP_TCAMm_F2_1_L4_SRC_MASKf_GET(r) field32_get((r).fp_tcam,347,362)
#define FP_TCAMm_F2_1_L4_SRC_MASKf_SET(r,f) field32_set((r).fp_tcam,347,362,f)
#define FP_TCAMm_F2_14_PAYLOAD_IP_PROTOCOL_LAST_NH_MASKf_GET(r) field32_get((r).fp_tcam,347,354)
#define FP_TCAMm_F2_14_PAYLOAD_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) field32_set((r).fp_tcam,347,354,f)
#define FP_TCAMm_F2_7_IP_PROTOCOL_LAST_NH_MASKf_GET(r) field32_get((r).fp_tcam,347,354)
#define FP_TCAMm_F2_7_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) field32_set((r).fp_tcam,347,354,f)
#define FP_TCAMm_F2_4_LAST_NH_MASKf_GET(r) field32_get((r).fp_tcam,349,356)
#define FP_TCAMm_F2_4_LAST_NH_MASKf_SET(r,f) field32_set((r).fp_tcam,349,356,f)
#define FP_TCAMm_F2_17_EGR_SR_LAN_ID_MASKf_GET(r) ((((r).fp_tcam[10]) >> 29) & 0x1)
#define FP_TCAMm_F2_17_EGR_SR_LAN_ID_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define FP_TCAMm_F2_17_EGR_SR_TYPE_MASKf_GET(r) field32_get((r).fp_tcam,350,352)
#define FP_TCAMm_F2_17_EGR_SR_TYPE_MASKf_SET(r,f) field32_set((r).fp_tcam,350,352,f)
#define FP_TCAMm_F2_17_EGR_SR_PORT_ROLE_MASKf_GET(r) ((((r).fp_tcam[11]) >> 1) & 0x1)
#define FP_TCAMm_F2_17_EGR_SR_PORT_ROLE_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_TCAMm_F2_17_EGR_SR_ENABLE_MASKf_GET(r) ((((r).fp_tcam[11]) >> 2) & 0x1)
#define FP_TCAMm_F2_17_EGR_SR_ENABLE_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_TCAMm_F2_12_MIML_DA_MASKf_GET(r,a) field_get((r).fp_tcam,355,402,a)
#define FP_TCAMm_F2_12_MIML_DA_MASKf_SET(r,a) field_set((r).fp_tcam,355,402,a)
#define FP_TCAMm_F2_14_PAYLOAD_DIP_MASKf_GET(r) field32_get((r).fp_tcam,355,386)
#define FP_TCAMm_F2_14_PAYLOAD_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,355,386,f)
#define FP_TCAMm_F2_7_DIP_MASKf_GET(r) field32_get((r).fp_tcam,355,386)
#define FP_TCAMm_F2_7_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,355,386,f)
#define FP_TCAMm_F2_17_ING_SR_MODE_MASKf_GET(r) ((((r).fp_tcam[11]) >> 3) & 0x7)
#define FP_TCAMm_F2_17_ING_SR_MODE_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define FP_TCAMm_F2_4_INT_CN_MASKf_GET(r) ((((r).fp_tcam[11]) >> 5) & 0x3)
#define FP_TCAMm_F2_4_INT_CN_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x3 << 5)) | ((((uint32)f) & 0x3) << 5))
#define FP_TCAMm_F2_17_ING_SR_NET_ID_MASKf_GET(r) ((((r).fp_tcam[11]) >> 6) & 0x7)
#define FP_TCAMm_F2_17_ING_SR_NET_ID_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define FP_TCAMm_F2_4_SPARE_MASKf_GET(r) ((((r).fp_tcam[11]) >> 7) & 0xfff)
#define FP_TCAMm_F2_4_SPARE_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0xfff << 7)) | ((((uint32)f) & 0xfff) << 7))
#define FP_TCAMm_F2_17_ING_SR_LAN_ID_MASKf_GET(r) ((((r).fp_tcam[11]) >> 9) & 0x1)
#define FP_TCAMm_F2_17_ING_SR_LAN_ID_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_TCAMm_F2_17_ING_SR_TYPE_MASKf_GET(r) ((((r).fp_tcam[11]) >> 10) & 0x7)
#define FP_TCAMm_F2_17_ING_SR_TYPE_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define FP_TCAMm_F2_0_IP_PROTOCOL_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[11]) >> 11) & 0xff)
#define FP_TCAMm_F2_0_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0xff << 11)) | ((((uint32)f) & 0xff) << 11))
#define FP_TCAMm_F2_1_IP_PROTOCOL_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[11]) >> 11) & 0xff)
#define FP_TCAMm_F2_1_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0xff << 11)) | ((((uint32)f) & 0xff) << 11))
#define FP_TCAMm_F2_17_ING_SR_PORT_ROLE_MASKf_GET(r) ((((r).fp_tcam[11]) >> 13) & 0x1)
#define FP_TCAMm_F2_17_ING_SR_PORT_ROLE_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_TCAMm_F2_17_ING_SR_ENABLE_MASKf_GET(r) ((((r).fp_tcam[11]) >> 14) & 0x1)
#define FP_TCAMm_F2_17_ING_SR_ENABLE_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define FP_TCAMm_F2_17_PKT_NET_ID_MASKf_GET(r) ((((r).fp_tcam[11]) >> 15) & 0x7)
#define FP_TCAMm_F2_17_PKT_NET_ID_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define FP_TCAMm_F2_17_PKT_LAN_ID_MASKf_GET(r) ((((r).fp_tcam[11]) >> 18) & 0x1)
#define FP_TCAMm_F2_17_PKT_LAN_ID_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define FP_TCAMm_F2_10_DIP_127_64_MASKf_GET(r,a) field_get((r).fp_tcam,371,434,a)
#define FP_TCAMm_F2_10_DIP_127_64_MASKf_SET(r,a) field_set((r).fp_tcam,371,434,a)
#define FP_TCAMm_F2_4_DIP_127_64_MASKf_GET(r,a) field_get((r).fp_tcam,371,434,a)
#define FP_TCAMm_F2_4_DIP_127_64_MASKf_SET(r,a) field_set((r).fp_tcam,371,434,a)
#define FP_TCAMm_F2_18_INNER_PAYLOAD_DA_MASKf_GET(r,a) field_get((r).fp_tcam,371,418,a)
#define FP_TCAMm_F2_18_INNER_PAYLOAD_DA_MASKf_SET(r,a) field_set((r).fp_tcam,371,418,a)
#define FP_TCAMm_F2_0_DIP_MASKf_GET(r) field32_get((r).fp_tcam,371,402)
#define FP_TCAMm_F2_0_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,371,402,f)
#define FP_TCAMm_F2_1_DIP_MASKf_GET(r) field32_get((r).fp_tcam,371,402)
#define FP_TCAMm_F2_1_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,371,402,f)
#define FP_TCAMm_F2_17_PKT_SR_TYPE_MASKf_GET(r) ((((r).fp_tcam[11]) >> 19) & 0x7)
#define FP_TCAMm_F2_17_PKT_SR_TYPE_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define FP_TCAMm_F2_17_SR_ETHERTYPE_MASKf_GET(r) ((((r).fp_tcam[11]) >> 22) & 0x3)
#define FP_TCAMm_F2_17_SR_ETHERTYPE_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define FP_TCAMm_F2_17_DA_TYPE_MASKf_GET(r) ((((r).fp_tcam[11]) >> 24) & 0x3)
#define FP_TCAMm_F2_17_DA_TYPE_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define FP_TCAMm_F2_17_DA_HIT_MASKf_GET(r) ((((r).fp_tcam[11]) >> 26) & 0x3)
#define FP_TCAMm_F2_17_DA_HIT_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define FP_TCAMm_F2_17_SA_HIT_MASKf_GET(r) ((((r).fp_tcam[11]) >> 28) & 0x3)
#define FP_TCAMm_F2_17_SA_HIT_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define FP_TCAMm_F2_17_SR_FLOW_UNEXPECTED_FRAME_MASKf_GET(r) ((((r).fp_tcam[11]) >> 30) & 0x1)
#define FP_TCAMm_F2_17_SR_FLOW_UNEXPECTED_FRAME_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define FP_TCAMm_F2_17_SA_SAN_MASKf_GET(r) ((((r).fp_tcam[11]) >> 31) & 0x1)
#define FP_TCAMm_F2_17_SA_SAN_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define FP_TCAMm_F2_17_PTP_MESSAGE_TYPE_MASKf_GET(r) (((r).fp_tcam[12]) & 0xf)
#define FP_TCAMm_F2_17_PTP_MESSAGE_TYPE_MASKf_SET(r,f) (r).fp_tcam[12]=(((r).fp_tcam[12] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define FP_TCAMm_F2_11_DA_MASKf_GET(r,a) field_get((r).fp_tcam,387,434,a)
#define FP_TCAMm_F2_11_DA_MASKf_SET(r,a) field_set((r).fp_tcam,387,434,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACDA_MASKf_GET(r,a) field_get((r).fp_tcam,387,434,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACDA_MASKf_SET(r,a) field_set((r).fp_tcam,387,434,a)
#define FP_TCAMm_F2_5_DA_MASKf_GET(r,a) field_get((r).fp_tcam,387,434,a)
#define FP_TCAMm_F2_5_DA_MASKf_SET(r,a) field_set((r).fp_tcam,387,434,a)
#define FP_TCAMm_F2_7_DA_MASKf_GET(r,a) field_get((r).fp_tcam,387,434,a)
#define FP_TCAMm_F2_7_DA_MASKf_SET(r,a) field_set((r).fp_tcam,387,434,a)
#define FP_TCAMm_F2_14_PAYLOAD_SIP_MASKf_GET(r) field32_get((r).fp_tcam,387,418)
#define FP_TCAMm_F2_14_PAYLOAD_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,387,418,f)
#define FP_TCAMm_F2_6_SIP_MASKf_GET(r) field32_get((r).fp_tcam,387,418)
#define FP_TCAMm_F2_6_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,387,418,f)
#define FP_TCAMm_F2_17_PTP_SOURCE_PORT_IDENTITY_MASKf_GET(r) ((((r).fp_tcam[12]) >> 4) & 0xffff)
#define FP_TCAMm_F2_17_PTP_SOURCE_PORT_IDENTITY_MASKf_SET(r,f) (r).fp_tcam[12]=(((r).fp_tcam[12] & ~((uint32)0xffff << 4)) | ((((uint32)f) & 0xffff) << 4))
#define FP_TCAMm_F2_0_SIP_MASKf_GET(r) field32_get((r).fp_tcam,403,434)
#define FP_TCAMm_F2_0_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,403,434,f)
#define FP_TCAMm_F2_1_SIP_MASKf_GET(r) field32_get((r).fp_tcam,403,434)
#define FP_TCAMm_F2_1_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,403,434,f)
#define FP_TCAMm_F2_12_MIML_TAG_MASKf_GET(r) field32_get((r).fp_tcam,403,418)
#define FP_TCAMm_F2_12_MIML_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,403,418,f)
#define FP_TCAMm_F2_17_PTP_DOMAIN_ID_MISMATCH_MASKf_GET(r) ((((r).fp_tcam[12]) >> 20) & 0x1)
#define FP_TCAMm_F2_17_PTP_DOMAIN_ID_MISMATCH_MASKf_SET(r,f) (r).fp_tcam[12]=(((r).fp_tcam[12] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_TCAMm_F2_17_PACKET_IS_1588_MASKf_GET(r) ((((r).fp_tcam[12]) >> 21) & 0x1)
#define FP_TCAMm_F2_17_PACKET_IS_1588_MASKf_SET(r,f) (r).fp_tcam[12]=(((r).fp_tcam[12] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define FP_TCAMm_F2_17_TAF_BYTELEFT_IS_NULL_MASKf_GET(r) ((((r).fp_tcam[12]) >> 22) & 0x1)
#define FP_TCAMm_F2_17_TAF_BYTELEFT_IS_NULL_MASKf_SET(r,f) (r).fp_tcam[12]=(((r).fp_tcam[12] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define FP_TCAMm_DWF1_MASKf_GET(r,a) field_get((r).fp_tcam,407,472,a)
#define FP_TCAMm_DWF1_MASKf_SET(r,a) field_set((r).fp_tcam,407,472,a)
#define FP_TCAMm_F2_17_TAF_DROP_MASKf_GET(r) ((((r).fp_tcam[12]) >> 23) & 0x1)
#define FP_TCAMm_F2_17_TAF_DROP_MASKf_SET(r,f) (r).fp_tcam[12]=(((r).fp_tcam[12] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define FP_TCAMm_F2_17_TAF_COS_PROFILE_MASKf_GET(r) ((((r).fp_tcam[12]) >> 24) & 0xf)
#define FP_TCAMm_F2_17_TAF_COS_PROFILE_MASKf_SET(r,f) (r).fp_tcam[12]=(((r).fp_tcam[12] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define FP_TCAMm_F2_17_TAF_GATE_STATE_AT_SOP_MASKf_GET(r) ((((r).fp_tcam[12]) >> 28) & 0x1)
#define FP_TCAMm_F2_17_TAF_GATE_STATE_AT_SOP_MASKf_SET(r,f) (r).fp_tcam[12]=(((r).fp_tcam[12] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define FP_TCAMm_F2_17_TAF_GATE_ID_MASKf_GET(r) field32_get((r).fp_tcam,413,419)
#define FP_TCAMm_F2_17_TAF_GATE_ID_MASKf_SET(r,f) field32_set((r).fp_tcam,413,419,f)
#define FP_TCAMm_F2_12_SPARE_MASKf_GET(r) ((((r).fp_tcam[13]) >> 3) & 0xffff)
#define FP_TCAMm_F2_12_SPARE_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_TCAMm_F2_14_SPARE_MASKf_GET(r) ((((r).fp_tcam[13]) >> 3) & 0xffff)
#define FP_TCAMm_F2_14_SPARE_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_TCAMm_F2_6_SPARE_MASKf_GET(r) ((((r).fp_tcam[13]) >> 3) & 0xffff)
#define FP_TCAMm_F2_6_SPARE_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_TCAMm_F2_18_PAYLOAD_TOS_MASKf_GET(r) ((((r).fp_tcam[13]) >> 3) & 0xff)
#define FP_TCAMm_F2_18_PAYLOAD_TOS_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define FP_TCAMm_F2_17_TAF_ENABLE_MASKf_GET(r) ((((r).fp_tcam[13]) >> 4) & 0x1)
#define FP_TCAMm_F2_17_TAF_ENABLE_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define FP_TCAMm_F2_17_SPARE_MASKf_GET(r) ((((r).fp_tcam[13]) >> 5) & 0x3fff)
#define FP_TCAMm_F2_17_SPARE_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x3fff << 5)) | ((((uint32)f) & 0x3fff) << 5))
#define FP_TCAMm_F2_18_INT_CN_MASKf_GET(r) ((((r).fp_tcam[13]) >> 11) & 0x3)
#define FP_TCAMm_F2_18_INT_CN_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x3 << 11)) | ((((uint32)f) & 0x3) << 11))
#define FP_TCAMm_F2_18_SPARE_MASKf_GET(r) ((((r).fp_tcam[13]) >> 13) & 0x3f)
#define FP_TCAMm_F2_18_SPARE_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x3f << 13)) | ((((uint32)f) & 0x3f) << 13))
#define FP_TCAMm_F1_MASKf_GET(r,a) field_get((r).fp_tcam,435,473,a)
#define FP_TCAMm_F1_MASKf_SET(r,a) field_set((r).fp_tcam,435,473,a)
#define FP_TCAMm_F1_13_AUX_TAG_1_MASKf_GET(r) field32_get((r).fp_tcam,435,466)
#define FP_TCAMm_F1_13_AUX_TAG_1_MASKf_SET(r,f) field32_set((r).fp_tcam,435,466,f)
#define FP_TCAMm_F1_9_UDF1_31_0_MASKf_GET(r) field32_get((r).fp_tcam,435,466)
#define FP_TCAMm_F1_9_UDF1_31_0_MASKf_SET(r,f) field32_set((r).fp_tcam,435,466,f)
#define FP_TCAMm_F1_10_D_FIELD_MASKf_GET(r) field32_get((r).fp_tcam,435,450)
#define FP_TCAMm_F1_10_D_FIELD_MASKf_SET(r,f) field32_set((r).fp_tcam,435,450,f)
#define FP_TCAMm_F1_11_SGLP_MASKf_GET(r) field32_get((r).fp_tcam,435,450)
#define FP_TCAMm_F1_11_SGLP_MASKf_SET(r,f) field32_set((r).fp_tcam,435,450,f)
#define FP_TCAMm_F1_1_D_FIELD_MASKf_GET(r) field32_get((r).fp_tcam,435,450)
#define FP_TCAMm_F1_1_D_FIELD_MASKf_SET(r,f) field32_set((r).fp_tcam,435,450,f)
#define FP_TCAMm_F1_2_D_FIELD_MASKf_GET(r) field32_get((r).fp_tcam,435,450)
#define FP_TCAMm_F1_2_D_FIELD_MASKf_SET(r,f) field32_set((r).fp_tcam,435,450,f)
#define FP_TCAMm_F1_3_OUTER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,435,450)
#define FP_TCAMm_F1_3_OUTER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,435,450,f)
#define FP_TCAMm_F1_4_OUTER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,435,450)
#define FP_TCAMm_F1_4_OUTER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,435,450,f)
#define FP_TCAMm_F1_5_LOOKUP_STATUS_MASKf_GET(r) field32_get((r).fp_tcam,435,450)
#define FP_TCAMm_F1_5_LOOKUP_STATUS_MASKf_SET(r,f) field32_set((r).fp_tcam,435,450,f)
#define FP_TCAMm_F1_6_OUTER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,435,450)
#define FP_TCAMm_F1_6_OUTER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,435,450,f)
#define FP_TCAMm_F1_7_OUTER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,435,450)
#define FP_TCAMm_F1_7_OUTER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,435,450,f)
#define FP_TCAMm_F1_0_CLASSIDS_MASKf_GET(r) ((((r).fp_tcam[13]) >> 19) & 0xfff)
#define FP_TCAMm_F1_0_CLASSIDS_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xfff << 19)) | ((((uint32)f) & 0xfff) << 19))
#define FP_TCAMm_F1_12_OUTER_VLAN_ID_MASKf_GET(r) ((((r).fp_tcam[13]) >> 19) & 0xfff)
#define FP_TCAMm_F1_12_OUTER_VLAN_ID_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xfff << 19)) | ((((uint32)f) & 0xfff) << 19))
#define FP_TCAMm_F1_8_IP_PROTOCOL_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[13]) >> 19) & 0xff)
#define FP_TCAMm_F1_8_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xff << 19)) | ((((uint32)f) & 0xff) << 19))
#define FP_TCAMm_F1_14_MY_STATION_HIT_STATUS_MASKf_GET(r) ((((r).fp_tcam[13]) >> 19) & 0x1)
#define FP_TCAMm_F1_14_MY_STATION_HIT_STATUS_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_TCAMm_F1_15_PACKET_IS_1588_MASKf_GET(r) ((((r).fp_tcam[13]) >> 19) & 0x1)
#define FP_TCAMm_F1_15_PACKET_IS_1588_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_TCAMm_F1_15_PTP_DOMAIN_ID_MASKf_GET(r) ((((r).fp_tcam[13]) >> 20) & 0xff)
#define FP_TCAMm_F1_15_PTP_DOMAIN_ID_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xff << 20)) | ((((uint32)f) & 0xff) << 20))
#define FP_TCAMm_F1_14_VXLAN_CLASS_ID_VALID_MASKf_GET(r) ((((r).fp_tcam[13]) >> 20) & 0x1)
#define FP_TCAMm_F1_14_VXLAN_CLASS_ID_VALID_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_TCAMm_F1_14_VXLAN_VN_ID_MASKf_GET(r) field32_get((r).fp_tcam,437,460)
#define FP_TCAMm_F1_14_VXLAN_VN_ID_MASKf_SET(r,f) field32_set((r).fp_tcam,437,460,f)
#define FP_TCAMm_F1_8_TOS_FN_MASKf_GET(r) field32_get((r).fp_tcam,443,450)
#define FP_TCAMm_F1_8_TOS_FN_MASKf_SET(r,f) field32_set((r).fp_tcam,443,450,f)
#define FP_TCAMm_F1_15_PORT_PTP_DOMAIN_ID_MASKf_GET(r) ((((r).fp_tcam[13]) >> 28) & 0xf)
#define FP_TCAMm_F1_15_PORT_PTP_DOMAIN_ID_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define FP_TCAMm_F1_0_FORWARDING_FIELD_MASKf_GET(r) field32_get((r).fp_tcam,447,458)
#define FP_TCAMm_F1_0_FORWARDING_FIELD_MASKf_SET(r,f) field32_set((r).fp_tcam,447,458,f)
#define FP_TCAMm_F1_12_CLASSIDS_MASKf_GET(r) field32_get((r).fp_tcam,447,458)
#define FP_TCAMm_F1_12_CLASSIDS_MASKf_SET(r,f) field32_set((r).fp_tcam,447,458,f)
#define FP_TCAMm_F1_15_ROCEV1_PACKET_MASKf_GET(r) (((r).fp_tcam[14]) & 0x1)
#define FP_TCAMm_F1_15_ROCEV1_PACKET_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define FP_TCAMm_F1_15_ROCEV2_PACKET_MASKf_GET(r) ((((r).fp_tcam[14]) >> 1) & 0x1)
#define FP_TCAMm_F1_15_ROCEV2_PACKET_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_TCAMm_F1_15_ROCE_BTH_OPCODE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 2) & 0xff)
#define FP_TCAMm_F1_15_ROCE_BTH_OPCODE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define FP_TCAMm_F1_3_INNER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[14]) >> 3) & 0xffff)
#define FP_TCAMm_F1_3_INNER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_TCAMm_F1_4_ETHERTYPE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 3) & 0xffff)
#define FP_TCAMm_F1_4_ETHERTYPE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_TCAMm_F1_5_INNER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[14]) >> 3) & 0xffff)
#define FP_TCAMm_F1_5_INNER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xffff << 3)) | ((((uint32)f) & 0xffff) << 3))
#define FP_TCAMm_F1_11_SVP_MASKf_GET(r) ((((r).fp_tcam[14]) >> 3) & 0x7fff)
#define FP_TCAMm_F1_11_SVP_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7fff << 3)) | ((((uint32)f) & 0x7fff) << 3))
#define FP_TCAMm_F1_7_CLASSIDS_11_6_MASKf_GET(r) ((((r).fp_tcam[14]) >> 3) & 0x3f)
#define FP_TCAMm_F1_7_CLASSIDS_11_6_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3f << 3)) | ((((uint32)f) & 0x3f) << 3))
#define FP_TCAMm_F1_8_CLASSIDS_11_6_MASKf_GET(r) ((((r).fp_tcam[14]) >> 3) & 0x3f)
#define FP_TCAMm_F1_8_CLASSIDS_11_6_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3f << 3)) | ((((uint32)f) & 0x3f) << 3))
#define FP_TCAMm_F1_6_PACKET_FORMAT_MASKf_GET(r) ((((r).fp_tcam[14]) >> 3) & 0xf)
#define FP_TCAMm_F1_6_PACKET_FORMAT_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xf << 3)) | ((((uint32)f) & 0xf) << 3))
#define FP_TCAMm_F1_10_D_TYPE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 3) & 0x7)
#define FP_TCAMm_F1_10_D_TYPE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define FP_TCAMm_F1_1_D_TYPE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 3) & 0x7)
#define FP_TCAMm_F1_1_D_TYPE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define FP_TCAMm_F1_2_D_TYPE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 3) & 0x7)
#define FP_TCAMm_F1_2_D_TYPE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define FP_TCAMm_F1_10_DGLP_MASKf_GET(r) ((((r).fp_tcam[14]) >> 6) & 0xffff)
#define FP_TCAMm_F1_10_DGLP_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xffff << 6)) | ((((uint32)f) & 0xffff) << 6))
#define FP_TCAMm_F1_1_S_FIELD_MASKf_GET(r) ((((r).fp_tcam[14]) >> 6) & 0xffff)
#define FP_TCAMm_F1_1_S_FIELD_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xffff << 6)) | ((((uint32)f) & 0xffff) << 6))
#define FP_TCAMm_F1_2_MH_OPCODE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 6) & 0x7)
#define FP_TCAMm_F1_2_MH_OPCODE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define FP_TCAMm_F1_6_SWITCHING_TAG_STATUS_MASKf_GET(r) ((((r).fp_tcam[14]) >> 7) & 0x3)
#define FP_TCAMm_F1_6_SWITCHING_TAG_STATUS_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define FP_TCAMm_F1_2_CLASSIDS_MASKf_GET(r) ((((r).fp_tcam[14]) >> 9) & 0xfff)
#define FP_TCAMm_F1_2_CLASSIDS_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xfff << 9)) | ((((uint32)f) & 0xfff) << 9))
#define FP_TCAMm_F1_7_FORWARDING_FIELD_MASKf_GET(r) ((((r).fp_tcam[14]) >> 9) & 0xfff)
#define FP_TCAMm_F1_7_FORWARDING_FIELD_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xfff << 9)) | ((((uint32)f) & 0xfff) << 9))
#define FP_TCAMm_F1_8_FORWARDING_FIELD_MASKf_GET(r) ((((r).fp_tcam[14]) >> 9) & 0xfff)
#define FP_TCAMm_F1_8_FORWARDING_FIELD_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xfff << 9)) | ((((uint32)f) & 0xfff) << 9))
#define FP_TCAMm_F1_6_MH_OPCODE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 9) & 0x7)
#define FP_TCAMm_F1_6_MH_OPCODE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define FP_TCAMm_F1_15_ROCE_BTH_PARTITION_KEY_MASKf_GET(r) ((((r).fp_tcam[14]) >> 10) & 0xffff)
#define FP_TCAMm_F1_15_ROCE_BTH_PARTITION_KEY_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xffff << 10)) | ((((uint32)f) & 0xffff) << 10))
#define FP_TCAMm_F1_12_SVP_MASKf_GET(r) ((((r).fp_tcam[14]) >> 11) & 0x7fff)
#define FP_TCAMm_F1_12_SVP_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7fff << 11)) | ((((uint32)f) & 0x7fff) << 11))
#define FP_TCAMm_F1_0_SVP_L3_IIF_MASKf_GET(r) ((((r).fp_tcam[14]) >> 11) & 0x1fff)
#define FP_TCAMm_F1_0_SVP_L3_IIF_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1fff << 11)) | ((((uint32)f) & 0x1fff) << 11))
#define FP_TCAMm_F1_6_PKT_RESOLUTION_MASKf_GET(r) ((((r).fp_tcam[14]) >> 12) & 0x1f)
#define FP_TCAMm_F1_6_PKT_RESOLUTION_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1f << 12)) | ((((uint32)f) & 0x1f) << 12))
#define FP_TCAMm_F1_14_VXLAN_CLASS_ID_MASKf_GET(r) ((((r).fp_tcam[14]) >> 13) & 0x3f)
#define FP_TCAMm_F1_14_VXLAN_CLASS_ID_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3f << 13)) | ((((uint32)f) & 0x3f) << 13))
#define FP_TCAMm_F1_6_IP_INFO_MASKf_GET(r) ((((r).fp_tcam[14]) >> 17) & 0x7)
#define FP_TCAMm_F1_6_IP_INFO_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 17)) | ((((uint32)f) & 0x7) << 17))
#define FP_TCAMm_F1_11_SVP_VALID_MASKf_GET(r) ((((r).fp_tcam[14]) >> 18) & 0x1)
#define FP_TCAMm_F1_11_SVP_VALID_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define FP_TCAMm_F1_11_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 19) & 0x7f)
#define FP_TCAMm_F1_11_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7f << 19)) | ((((uint32)f) & 0x7f) << 19))
#define FP_TCAMm_F1_4_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 19) & 0x7f)
#define FP_TCAMm_F1_4_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7f << 19)) | ((((uint32)f) & 0x7f) << 19))
#define FP_TCAMm_F1_3_OUTER_TPID_ENCODE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 19) & 0x3)
#define FP_TCAMm_F1_3_OUTER_TPID_ENCODE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define FP_TCAMm_F1_5_INNER_TPID_ENCODE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 19) & 0x3)
#define FP_TCAMm_F1_5_INNER_TPID_ENCODE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define FP_TCAMm_F1_9_MPLS_INFO_MASKf_GET(r) ((((r).fp_tcam[14]) >> 19) & 0x3)
#define FP_TCAMm_F1_9_MPLS_INFO_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define FP_TCAMm_F1_13_AUX_TAG_VALID_1_MASKf_GET(r) ((((r).fp_tcam[14]) >> 19) & 0x1)
#define FP_TCAMm_F1_13_AUX_TAG_VALID_1_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_TCAMm_F1_14_VXLAN_ETHERNET_MASKf_GET(r) ((((r).fp_tcam[14]) >> 19) & 0x1)
#define FP_TCAMm_F1_14_VXLAN_ETHERNET_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_TCAMm_F1_13_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 20) & 0x3f)
#define FP_TCAMm_F1_13_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define FP_TCAMm_F1_6_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 20) & 0x3f)
#define FP_TCAMm_F1_6_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define FP_TCAMm_F1_14_IP_TUNNEL_TERMINATION_MASKf_GET(r) ((((r).fp_tcam[14]) >> 20) & 0x1)
#define FP_TCAMm_F1_14_IP_TUNNEL_TERMINATION_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_TCAMm_F1_2_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 21) & 0x1f)
#define FP_TCAMm_F1_2_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1f << 21)) | ((((uint32)f) & 0x1f) << 21))
#define FP_TCAMm_F1_3_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 21) & 0x1f)
#define FP_TCAMm_F1_3_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1f << 21)) | ((((uint32)f) & 0x1f) << 21))
#define FP_TCAMm_F1_5_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 21) & 0x1f)
#define FP_TCAMm_F1_5_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1f << 21)) | ((((uint32)f) & 0x1f) << 21))
#define FP_TCAMm_F1_9_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 21) & 0x1f)
#define FP_TCAMm_F1_9_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1f << 21)) | ((((uint32)f) & 0x1f) << 21))
#define FP_TCAMm_F1_14_PAYLOAD_VLAN_TAG_STATUS_MASKf_GET(r) ((((r).fp_tcam[14]) >> 21) & 0x3)
#define FP_TCAMm_F1_14_PAYLOAD_VLAN_TAG_STATUS_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define FP_TCAMm_F1_7_MPLS_INFO_MASKf_GET(r) ((((r).fp_tcam[14]) >> 21) & 0x3)
#define FP_TCAMm_F1_7_MPLS_INFO_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define FP_TCAMm_F1_8_INT_CN_MASKf_GET(r) ((((r).fp_tcam[14]) >> 21) & 0x3)
#define FP_TCAMm_F1_8_INT_CN_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define FP_TCAMm_F1_10_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 22) & 0xf)
#define FP_TCAMm_F1_10_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xf << 22)) | ((((uint32)f) & 0xf) << 22))
#define FP_TCAMm_F1_1_SVP_VALID_MASKf_GET(r) ((((r).fp_tcam[14]) >> 22) & 0x1)
#define FP_TCAMm_F1_1_SVP_VALID_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define FP_TCAMm_F1_1_MH_OPCODE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 23) & 0x7)
#define FP_TCAMm_F1_1_MH_OPCODE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 23)) | ((((uint32)f) & 0x7) << 23))
#define FP_TCAMm_F1_7_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 23) & 0x7)
#define FP_TCAMm_F1_7_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 23)) | ((((uint32)f) & 0x7) << 23))
#define FP_TCAMm_F1_8_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 23) & 0x7)
#define FP_TCAMm_F1_8_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 23)) | ((((uint32)f) & 0x7) << 23))
#define FP_TCAMm_F1_14_VNID_LOOKUP_HIT_STATUS_MASKf_GET(r) ((((r).fp_tcam[14]) >> 23) & 0x1)
#define FP_TCAMm_F1_14_VNID_LOOKUP_HIT_STATUS_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define FP_TCAMm_F1_0_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 24) & 0x3)
#define FP_TCAMm_F1_0_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define FP_TCAMm_F1_14_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 24) & 0x3)
#define FP_TCAMm_F1_14_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define FP_TCAMm_RESERVED_DW_MASKf_GET(r) ((((r).fp_tcam[14]) >> 25) & 0x1)
#define FP_TCAMm_RESERVED_DW_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))

/*
 * These macros can be used to access FP_TCAM.
 */
#define WRITE_FP_TCAMm(u,i,r) bcm5607x_tcam_mem_set(u, M_FP_TCAM(i), &(r._fp_tcam), 15, 2, 238, 236)
#define READ_FP_TCAMm(u,i,r) bcm5607x_tcam_mem_get(u, M_FP_TCAM(i), &(r._fp_tcam), 15, 2, 238, 236)

/*******************************************************************************
 * End of 'FP_TCAMm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  FP_UDF_OFFSET
 * BLOCKS:   IPIPE
 * DESC:     IFP UDF offset table
 * SIZE:     73
 * FIELDS:
 *     UDF1_OFFSET0     Offset value for UDF1.0
 *     UDF1_ADD_GRE_OPTIONS0 Control bit to enable adding GRE option headers
 *     UDF1_ADD_IPV4_OPTIONS0 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET1     Offset value for UDF1.1
 *     UDF1_ADD_GRE_OPTIONS1 Control bit to enable adding GRE option headers
 *     UDF1_ADD_IPV4_OPTIONS1 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET2     Offset value for UDF1.2
 *     UDF1_ADD_GRE_OPTIONS2 Control bit to enable adding GRE option headers
 *     UDF1_ADD_IPV4_OPTIONS2 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET3     Offset value for UDF1.3
 *     UDF1_ADD_GRE_OPTIONS3 Control bit to enable adding GRE option headers
 *     UDF1_ADD_IPV4_OPTIONS3 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET0     Offset value for UDF2.0
 *     UDF2_ADD_GRE_OPTIONS0 Control bit to enable adding GRE option headers
 *     UDF2_ADD_IPV4_OPTIONS0 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET1     Offset value for UDF2.1
 *     UDF2_ADD_GRE_OPTIONS1 Control bit to enable adding GRE option headers
 *     UDF2_ADD_IPV4_OPTIONS1 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET2     Offset value for UDF2.2
 *     UDF2_ADD_GRE_OPTIONS2 Control bit to enable adding GRE option headers
 *     UDF2_ADD_IPV4_OPTIONS2 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET3     Offset value for UDF2.3
 *     UDF2_ADD_GRE_OPTIONS3 Control bit to enable adding GRE option headers
 *     UDF2_ADD_IPV4_OPTIONS3 Control bit to enable adding the IPv4 header option length
 *     PORT_FIELD_SEL_INDEX0 Used to index into the FP_PORT_FIELD_SEL table (if packet indexing is enabled) and FP_PORT_SELECT_TYPE equals 0
 *     PORT_FIELD_SEL_INDEX1 Used to index into the FP_PORT_FIELD_SEL table (if packet indexing is enabled) and FP_PORT_SELECT_TYPE equals 1
 *     EVEN_PARITY      PARITY BIT to make the entry parity even.
 */
#define FP_UDF_OFFSETm_MIN 0
#define FP_UDF_OFFSETm_MAX 383
#define FP_UDF_OFFSETm_CMAX(u) 383
#define FP_UDF_OFFSETm_SIZE 10

/*
 * This structure should be used to declare and program FP_UDF_OFFSET.
 */
typedef union FP_UDF_OFFSETm_s {
	uint32 v[3];
	uint32 fp_udf_offset[3];
	uint32 _fp_udf_offset;
} FP_UDF_OFFSETm_t;

#define FP_UDF_OFFSETm_CLR(r) sal_memset(&((r)._fp_udf_offset), 0, sizeof(FP_UDF_OFFSETm_t))
#define FP_UDF_OFFSETm_SET(r,i,d) (r).fp_udf_offset[i] = d
#define FP_UDF_OFFSETm_GET(r,i) (r).fp_udf_offset[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_UDF_OFFSETm_UDF1_OFFSET0f_GET(r) (((r).fp_udf_offset[0]) & 0x1f)
#define FP_UDF_OFFSETm_UDF1_OFFSET0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS0f_GET(r) ((((r).fp_udf_offset[0]) >> 5) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET(r) ((((r).fp_udf_offset[0]) >> 6) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define FP_UDF_OFFSETm_UDF1_OFFSET1f_GET(r) ((((r).fp_udf_offset[0]) >> 7) & 0x1f)
#define FP_UDF_OFFSETm_UDF1_OFFSET1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1f << 7)) | ((((uint32)f) & 0x1f) << 7))
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS1f_GET(r) ((((r).fp_udf_offset[0]) >> 12) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET(r) ((((r).fp_udf_offset[0]) >> 13) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_UDF_OFFSETm_UDF1_OFFSET2f_GET(r) ((((r).fp_udf_offset[0]) >> 14) & 0x1f)
#define FP_UDF_OFFSETm_UDF1_OFFSET2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1f << 14)) | ((((uint32)f) & 0x1f) << 14))
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS2f_GET(r) ((((r).fp_udf_offset[0]) >> 19) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET(r) ((((r).fp_udf_offset[0]) >> 20) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_UDF_OFFSETm_UDF1_OFFSET3f_GET(r) ((((r).fp_udf_offset[0]) >> 21) & 0x1f)
#define FP_UDF_OFFSETm_UDF1_OFFSET3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1f << 21)) | ((((uint32)f) & 0x1f) << 21))
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS3f_GET(r) ((((r).fp_udf_offset[0]) >> 26) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET(r) ((((r).fp_udf_offset[0]) >> 27) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define FP_UDF_OFFSETm_UDF2_OFFSET0f_GET(r) field32_get((r).fp_udf_offset,28,32)
#define FP_UDF_OFFSETm_UDF2_OFFSET0f_SET(r,f) field32_set((r).fp_udf_offset,28,32,f)
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS0f_GET(r) ((((r).fp_udf_offset[1]) >> 1) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS0f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET(r) ((((r).fp_udf_offset[1]) >> 2) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_UDF_OFFSETm_UDF2_OFFSET1f_GET(r) ((((r).fp_udf_offset[1]) >> 3) & 0x1f)
#define FP_UDF_OFFSETm_UDF2_OFFSET1f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1f << 3)) | ((((uint32)f) & 0x1f) << 3))
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS1f_GET(r) ((((r).fp_udf_offset[1]) >> 8) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS1f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET(r) ((((r).fp_udf_offset[1]) >> 9) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_UDF_OFFSETm_UDF2_OFFSET2f_GET(r) ((((r).fp_udf_offset[1]) >> 10) & 0x1f)
#define FP_UDF_OFFSETm_UDF2_OFFSET2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1f << 10)) | ((((uint32)f) & 0x1f) << 10))
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS2f_GET(r) ((((r).fp_udf_offset[1]) >> 15) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET(r) ((((r).fp_udf_offset[1]) >> 16) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define FP_UDF_OFFSETm_UDF2_OFFSET3f_GET(r) ((((r).fp_udf_offset[1]) >> 17) & 0x1f)
#define FP_UDF_OFFSETm_UDF2_OFFSET3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS3f_GET(r) ((((r).fp_udf_offset[1]) >> 22) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET(r) ((((r).fp_udf_offset[1]) >> 23) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX0f_GET(r) ((((r).fp_udf_offset[1]) >> 24) & 0xff)
#define FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX0f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX1f_GET(r) (((r).fp_udf_offset[2]) & 0xff)
#define FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX1f_SET(r,f) (r).fp_udf_offset[2]=(((r).fp_udf_offset[2] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define FP_UDF_OFFSETm_EVEN_PARITYf_GET(r) ((((r).fp_udf_offset[2]) >> 8) & 0x1)
#define FP_UDF_OFFSETm_EVEN_PARITYf_SET(r,f) (r).fp_udf_offset[2]=(((r).fp_udf_offset[2] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))

/*
 * These macros can be used to access FP_UDF_OFFSET.
 */
#define WRITE_FP_UDF_OFFSETm(u,i,r) bcm5607x_mem_set(u, M_FP_UDF_OFFSET(i), &(r._fp_udf_offset), 3)
#define READ_FP_UDF_OFFSETm(u,i,r) bcm5607x_mem_get(u, M_FP_UDF_OFFSET(i), &(r._fp_udf_offset), 3)

/*******************************************************************************
 * End of 'FP_UDF_OFFSETm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  FRM_LENGTH
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Maximum Frame Length.
 * SIZE:     32
 * FIELDS:
 *     MAXFR            Defines a 14-Bit maximum frame length used by the MAC receive logic to check frames.
 */
#define FRM_LENGTHr_SIZE 4

/*
 * This structure should be used to declare and program FRM_LENGTH.
 */
typedef union FRM_LENGTHr_s {
	uint32 v[1];
	uint32 frm_length[1];
	uint32 _frm_length;
} FRM_LENGTHr_t;

#define FRM_LENGTHr_CLR(r) (r).frm_length[0] = 0
#define FRM_LENGTHr_SET(r,d) (r).frm_length[0] = d
#define FRM_LENGTHr_GET(r) (r).frm_length[0]

/*
 * These macros can be used to access individual fields.
 */
#define FRM_LENGTHr_MAXFRf_GET(r) (((r).frm_length[0]) & 0x3fff)
#define FRM_LENGTHr_MAXFRf_SET(r,f) (r).frm_length[0]=(((r).frm_length[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))

/*
 * These macros can be used to access FRM_LENGTH.
 */
#define WRITE_FRM_LENGTHr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_FRM_LENGTH(bcm5607x_gport_lport_to_index_in_block[p]), (r._frm_length))
#define READ_FRM_LENGTHr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_FRM_LENGTH(bcm5607x_gport_lport_to_index_in_block[p]), &(r._frm_length))

/*******************************************************************************
 * End of 'FRM_LENGTHr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GBLLIMITRESETLIMIT
 * BLOCKS:   MMU
 * DESC:     Global cell set/reset limit
 * SIZE:     32
 * FIELDS:
 *     GBLCELLRESETLIMIT After the available cell counter global shared pool is depleted below the reset level, the backpressure state of the shared pool is reset.(TOTALDYNCELLUSED<GBLCELLRESETLIMIT)The RESETLIMIT can be set to the same value or a value lower than the CELLSETLIMIT.
 */
#define GBLLIMITRESETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program GBLLIMITRESETLIMIT.
 */
typedef union GBLLIMITRESETLIMITr_s {
	uint32 v[1];
	uint32 gbllimitresetlimit[1];
	uint32 _gbllimitresetlimit;
} GBLLIMITRESETLIMITr_t;

#define GBLLIMITRESETLIMITr_CLR(r) (r).gbllimitresetlimit[0] = 0
#define GBLLIMITRESETLIMITr_SET(r,d) (r).gbllimitresetlimit[0] = d
#define GBLLIMITRESETLIMITr_GET(r) (r).gbllimitresetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define GBLLIMITRESETLIMITr_GBLCELLRESETLIMITf_GET(r) (((r).gbllimitresetlimit[0]) & 0x1fffff)
#define GBLLIMITRESETLIMITr_GBLCELLRESETLIMITf_SET(r,f) (r).gbllimitresetlimit[0]=(((r).gbllimitresetlimit[0] & ~((uint32)0x1fffff)) | (((uint32)f) & 0x1fffff))

/*
 * These macros can be used to access GBLLIMITRESETLIMIT.
 */
#define WRITE_GBLLIMITRESETLIMITr(u,r) bcm5607x_reg_set(u,R_GBLLIMITRESETLIMIT,(r._gbllimitresetlimit))
#define READ_GBLLIMITRESETLIMITr(u,r) bcm5607x_reg_get(u,R_GBLLIMITRESETLIMIT,&(r._gbllimitresetlimit))

/*******************************************************************************
 * End of 'GBLLIMITRESETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GBLLIMITSETLIMIT
 * BLOCKS:   MMU
 * DESC:     Global cell set/reset limit
 * SIZE:     32
 * FIELDS:
 *     GBLCELLSETLIMIT  After the available cell counter in the global shared pool is depleted below the RESET level, the counter must rise above this XOFF threshold for the backpressure state of the shared pool is set.(criterion:TOTALDYNCELLUSED>=GBLCELLSETLIMIT)
 */
#define GBLLIMITSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program GBLLIMITSETLIMIT.
 */
typedef union GBLLIMITSETLIMITr_s {
	uint32 v[1];
	uint32 gbllimitsetlimit[1];
	uint32 _gbllimitsetlimit;
} GBLLIMITSETLIMITr_t;

#define GBLLIMITSETLIMITr_CLR(r) (r).gbllimitsetlimit[0] = 0
#define GBLLIMITSETLIMITr_SET(r,d) (r).gbllimitsetlimit[0] = d
#define GBLLIMITSETLIMITr_GET(r) (r).gbllimitsetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define GBLLIMITSETLIMITr_GBLCELLSETLIMITf_GET(r) (((r).gbllimitsetlimit[0]) & 0x1fffff)
#define GBLLIMITSETLIMITr_GBLCELLSETLIMITf_SET(r,f) (r).gbllimitsetlimit[0]=(((r).gbllimitsetlimit[0] & ~((uint32)0x1fffff)) | (((uint32)f) & 0x1fffff))

/*
 * These macros can be used to access GBLLIMITSETLIMIT.
 */
#define WRITE_GBLLIMITSETLIMITr(u,r) bcm5607x_reg_set(u,R_GBLLIMITSETLIMIT,(r._gbllimitsetlimit))
#define READ_GBLLIMITSETLIMITr(u,r) bcm5607x_reg_get(u,R_GBLLIMITSETLIMIT,&(r._gbllimitsetlimit))

/*******************************************************************************
 * End of 'GBLLIMITSETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * SWFORMAT:  GLP
 * BLOCKS:  
 * DESC:     Global Logical Port
 * SIZE:     16
 * FIELDS:
 *     PORT             Port number if T=0
 *     TGID             
 *     MODID            if T=1 then GLP is TGID otherwise GLP is {MODID, PORT}
 *     T                if T=1 then GLP is TGID otherwise GLP is {MODID, PORT}
 */
#define GLP_SIZE 2

/*
 * This structure should be used to declare and program GLP.
 */
typedef union GLP_s {
	uint32 v[1];
	uint32 glp[1];
	uint32 _glp;
} GLP_t;

#define GLP_CLR(r) (r).glp[0] = 0
#define GLP_SET(r,d) (r).glp[0] = d
#define GLP_GET(r) (r).glp[0]

/*
 * These macros can be used to access individual fields.
 */
#define GLP_PORTf_GET(r) (((r).glp[0]) & 0x7f)
#define GLP_PORTf_SET(r,f) (r).glp[0]=(((r).glp[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define GLP_TGIDf_GET(r) (((r).glp[0]) & 0x7f)
#define GLP_TGIDf_SET(r,f) (r).glp[0]=(((r).glp[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define GLP_MODIDf_GET(r) ((((r).glp[0]) >> 7) & 0xff)
#define GLP_MODIDf_SET(r,f) (r).glp[0]=(((r).glp[0] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define GLP_Tf_GET(r) ((((r).glp[0]) >> 15) & 0x1)
#define GLP_Tf_SET(r,f) (r).glp[0]=(((r).glp[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))

/*******************************************************************************
 * End of 'GLP'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GMII_EEE_DELAY_ENTRY_TIMER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     GMII_EEE LPI timer
 * SIZE:     32
 * FIELDS:
 *     GMII_EEE_LPI_TIMER This is the duration for which condition to move to LPI state must be satisfied, at the end of which MAC transitions to LPI State. The decrement unit is 1 micro-second.This register is meant for 1000 Mbps speed.
 */
#define GMII_EEE_DELAY_ENTRY_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program GMII_EEE_DELAY_ENTRY_TIMER.
 */
typedef union GMII_EEE_DELAY_ENTRY_TIMERr_s {
	uint32 v[1];
	uint32 gmii_eee_delay_entry_timer[1];
	uint32 _gmii_eee_delay_entry_timer;
} GMII_EEE_DELAY_ENTRY_TIMERr_t;

#define GMII_EEE_DELAY_ENTRY_TIMERr_CLR(r) (r).gmii_eee_delay_entry_timer[0] = 0
#define GMII_EEE_DELAY_ENTRY_TIMERr_SET(r,d) (r).gmii_eee_delay_entry_timer[0] = d
#define GMII_EEE_DELAY_ENTRY_TIMERr_GET(r) (r).gmii_eee_delay_entry_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define GMII_EEE_DELAY_ENTRY_TIMERr_GMII_EEE_LPI_TIMERf_GET(r) ((r).gmii_eee_delay_entry_timer[0])
#define GMII_EEE_DELAY_ENTRY_TIMERr_GMII_EEE_LPI_TIMERf_SET(r,f) (r).gmii_eee_delay_entry_timer[0]=((uint32)f)

/*
 * These macros can be used to access GMII_EEE_DELAY_ENTRY_TIMER.
 */
#define WRITE_GMII_EEE_DELAY_ENTRY_TIMERr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GMII_EEE_DELAY_ENTRY_TIMER(bcm5607x_gport_lport_to_index_in_block[p]), (r._gmii_eee_delay_entry_timer))
#define READ_GMII_EEE_DELAY_ENTRY_TIMERr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GMII_EEE_DELAY_ENTRY_TIMER(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gmii_eee_delay_entry_timer))

/*******************************************************************************
 * End of 'GMII_EEE_DELAY_ENTRY_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GMII_EEE_WAKE_TIMER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     GMII_EEE Wake timer
 * SIZE:     32
 * FIELDS:
 *     GMII_EEE_WAKE_TIMER_FLD This is the duration for which MAC must wait to go back to ACTIVE state from LPI state when it receives packet for transmission. The decrement unit is 1 micro-second.This register is meant for 1000 Mbps speed.
 */
#define GMII_EEE_WAKE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program GMII_EEE_WAKE_TIMER.
 */
typedef union GMII_EEE_WAKE_TIMERr_s {
	uint32 v[1];
	uint32 gmii_eee_wake_timer[1];
	uint32 _gmii_eee_wake_timer;
} GMII_EEE_WAKE_TIMERr_t;

#define GMII_EEE_WAKE_TIMERr_CLR(r) (r).gmii_eee_wake_timer[0] = 0
#define GMII_EEE_WAKE_TIMERr_SET(r,d) (r).gmii_eee_wake_timer[0] = d
#define GMII_EEE_WAKE_TIMERr_GET(r) (r).gmii_eee_wake_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define GMII_EEE_WAKE_TIMERr_GMII_EEE_WAKE_TIMER_FLDf_GET(r) (((r).gmii_eee_wake_timer[0]) & 0xffff)
#define GMII_EEE_WAKE_TIMERr_GMII_EEE_WAKE_TIMER_FLDf_SET(r,f) (r).gmii_eee_wake_timer[0]=(((r).gmii_eee_wake_timer[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access GMII_EEE_WAKE_TIMER.
 */
#define WRITE_GMII_EEE_WAKE_TIMERr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GMII_EEE_WAKE_TIMER(bcm5607x_gport_lport_to_index_in_block[p]), (r._gmii_eee_wake_timer))
#define READ_GMII_EEE_WAKE_TIMERr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GMII_EEE_WAKE_TIMER(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gmii_eee_wake_timer))

/*******************************************************************************
 * End of 'GMII_EEE_WAKE_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_AUX_SEL
 * BLOCKS:   IPROC
 * DESC:     GPIO Auxiliary logic select register

 * SIZE:     32
 * FIELDS:
 *     AUX_SEL          GPIO Auxiliary logic select register. This register provides the ability of the GPIO bus to select between direct software control and the dedicated alternative interface logic. When the appropriate bit is set to 1, this enables the alternative interface logic bit, which takes control of the 3 associated bits (in, out and enable) in the interface. When the appropriate bit is logic 0, the control of the respective GPIO interface bit is dictated by the APB master through software. 
 */
#define GPIO_AUX_SELr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_AUX_SEL.
 */
typedef union GPIO_AUX_SELr_s {
	uint32 v[1];
	uint32 gpio_aux_sel[1];
	uint32 _gpio_aux_sel;
} GPIO_AUX_SELr_t;

#define GPIO_AUX_SELr_CLR(r) (r).gpio_aux_sel[0] = 0
#define GPIO_AUX_SELr_SET(r,d) (r).gpio_aux_sel[0] = d
#define GPIO_AUX_SELr_GET(r) (r).gpio_aux_sel[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_AUX_SELr_AUX_SELf_GET(r) ((r).gpio_aux_sel[0])
#define GPIO_AUX_SELr_AUX_SELf_SET(r,f) (r).gpio_aux_sel[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_AUX_SEL.
 */
#define READ_GPIO_AUX_SELr(u,r) bcm5607x_read32(u, R_GPIO_AUX_SEL, &(r._gpio_aux_sel))
#define WRITE_GPIO_AUX_SELr(u,r) bcm5607x_write32(u, R_GPIO_AUX_SEL, (r._gpio_aux_sel))

/*******************************************************************************
 * End of 'GPIO_AUX_SELr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_DATA_IN
 * BLOCKS:   IPROC
 * DESC:     GPIO Data in register

 * SIZE:     32
 * FIELDS:
 *     DATA_IN          GPIO Data input register used to read the value on the external GPIO pins. This register always samples the data on the GPIO pins, even when the GPIO pads are configured as output, the value sent out on the GPIO is reflected on the GP_DIN register. Default vaule depends on the default values of GP_RES_EN, GP_PAD_RES and values driven to GPIO inputs."
 */
#define GPIO_DATA_INr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_DATA_IN.
 */
typedef union GPIO_DATA_INr_s {
	uint32 v[1];
	uint32 gpio_data_in[1];
	uint32 _gpio_data_in;
} GPIO_DATA_INr_t;

#define GPIO_DATA_INr_CLR(r) (r).gpio_data_in[0] = 0
#define GPIO_DATA_INr_SET(r,d) (r).gpio_data_in[0] = d
#define GPIO_DATA_INr_GET(r) (r).gpio_data_in[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_DATA_INr_DATA_INf_GET(r) ((r).gpio_data_in[0])
#define GPIO_DATA_INr_DATA_INf_SET(r,f) (r).gpio_data_in[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_DATA_IN.
 */
#define READ_GPIO_DATA_INr(u,r) bcm5607x_read32(u, R_GPIO_DATA_IN, &(r._gpio_data_in))
#define WRITE_GPIO_DATA_INr(u,r) bcm5607x_write32(u, R_GPIO_DATA_IN, (r._gpio_data_in))

/*******************************************************************************
 * End of 'GPIO_DATA_INr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_DATA_OUT
 * BLOCKS:   IPROC
 * DESC:     GPIO Data out register

 * SIZE:     32
 * FIELDS:
 *     DATA_OUT         GPIO Data out register used to write data out to the external GPIO pins. When the corresponding bit in the GP_EN register is programmed to logic 1,  the pin is configured as an output, and writing data to a bit drives the data out on the pad. Reading from a bit indicates the last value written to the register. If the corresponding bit within the GP_EN register is programmed to logic 0, configuring the pad as an input, then writing has no effect.
 */
#define GPIO_DATA_OUTr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_DATA_OUT.
 */
typedef union GPIO_DATA_OUTr_s {
	uint32 v[1];
	uint32 gpio_data_out[1];
	uint32 _gpio_data_out;
} GPIO_DATA_OUTr_t;

#define GPIO_DATA_OUTr_CLR(r) (r).gpio_data_out[0] = 0
#define GPIO_DATA_OUTr_SET(r,d) (r).gpio_data_out[0] = d
#define GPIO_DATA_OUTr_GET(r) (r).gpio_data_out[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_DATA_OUTr_DATA_OUTf_GET(r) ((r).gpio_data_out[0])
#define GPIO_DATA_OUTr_DATA_OUTf_SET(r,f) (r).gpio_data_out[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_DATA_OUT.
 */
#define READ_GPIO_DATA_OUTr(u,r) bcm5607x_read32(u, R_GPIO_DATA_OUT, &(r._gpio_data_out))
#define WRITE_GPIO_DATA_OUTr(u,r) bcm5607x_write32(u, R_GPIO_DATA_OUT, (r._gpio_data_out))

/*******************************************************************************
 * End of 'GPIO_DATA_OUTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_INIT_VAL
 * BLOCKS:   IPROC
 * DESC:     GPIO Initial value register

 * SIZE:     32
 * FIELDS:
 *     INIT_VAL         GPIO Initial value register. This register captures the value driven into the external GPIO pins during reset. The captured value can be used by the firmware for system specific configurations. Default vaule depends on default values of GP_RES_EN, GP_PAD_RES and values driven to GPIO inputs (same as GP_DATA_IN)
 */
#define GPIO_INIT_VALr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INIT_VAL.
 */
typedef union GPIO_INIT_VALr_s {
	uint32 v[1];
	uint32 gpio_init_val[1];
	uint32 _gpio_init_val;
} GPIO_INIT_VALr_t;

#define GPIO_INIT_VALr_CLR(r) (r).gpio_init_val[0] = 0
#define GPIO_INIT_VALr_SET(r,d) (r).gpio_init_val[0] = d
#define GPIO_INIT_VALr_GET(r) (r).gpio_init_val[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INIT_VALr_INIT_VALf_GET(r) ((r).gpio_init_val[0])
#define GPIO_INIT_VALr_INIT_VALf_SET(r,f) (r).gpio_init_val[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_INIT_VAL.
 */
#define READ_GPIO_INIT_VALr(u,r) bcm5607x_read32(u, R_GPIO_INIT_VAL, &(r._gpio_init_val))
#define WRITE_GPIO_INIT_VALr(u,r) bcm5607x_write32(u, R_GPIO_INIT_VAL, (r._gpio_init_val))

/*******************************************************************************
 * End of 'GPIO_INIT_VALr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_INT_CLR
 * BLOCKS:   IPROC
 * DESC:     GPIO interrupt clear register

 * SIZE:     32
 * FIELDS:
 *     INT_CLR          GPIO interrupt clear register. Writing a 1 to any bit in this register clears the corresponding interrupt signal. Writing a 0 has no effect. 
 */
#define GPIO_INT_CLRr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_CLR.
 */
typedef union GPIO_INT_CLRr_s {
	uint32 v[1];
	uint32 gpio_int_clr[1];
	uint32 _gpio_int_clr;
} GPIO_INT_CLRr_t;

#define GPIO_INT_CLRr_CLR(r) (r).gpio_int_clr[0] = 0
#define GPIO_INT_CLRr_SET(r,d) (r).gpio_int_clr[0] = d
#define GPIO_INT_CLRr_GET(r) (r).gpio_int_clr[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_CLRr_INT_CLRf_GET(r) ((r).gpio_int_clr[0])
#define GPIO_INT_CLRr_INT_CLRf_SET(r,f) (r).gpio_int_clr[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_INT_CLR.
 */
#define READ_GPIO_INT_CLRr(u,r) bcm5607x_read32(u, R_GPIO_INT_CLR, &(r._gpio_int_clr))
#define WRITE_GPIO_INT_CLRr(u,r) bcm5607x_write32(u, R_GPIO_INT_CLR, (r._gpio_int_clr))

/*******************************************************************************
 * End of 'GPIO_INT_CLRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_INT_DE
 * BLOCKS:   IPROC
 * DESC:     GPIO interrupt dual edge register

 * SIZE:     32
 * FIELDS:
 *     INT_DE           GPIO interrupt dual edge register. This register is used in conjunction with the GP_INT_TYPE register. If a bit in the GP_INT_TYPE register is programmed to edge detect, then setting the corresponding GP_INT_DE bit to logic 1 enables interrupt generation on both rising and falling edges, regardless of the value programmed into the GP_INT_EDGE register. Clearing the bit to logic 0 allows edge selection to be controlled by the GP_INT_EDGE register. This register does not have any effect on level sensitive interrupt generation.
 */
#define GPIO_INT_DEr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_DE.
 */
typedef union GPIO_INT_DEr_s {
	uint32 v[1];
	uint32 gpio_int_de[1];
	uint32 _gpio_int_de;
} GPIO_INT_DEr_t;

#define GPIO_INT_DEr_CLR(r) (r).gpio_int_de[0] = 0
#define GPIO_INT_DEr_SET(r,d) (r).gpio_int_de[0] = d
#define GPIO_INT_DEr_GET(r) (r).gpio_int_de[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_DEr_INT_DEf_GET(r) ((r).gpio_int_de[0])
#define GPIO_INT_DEr_INT_DEf_SET(r,f) (r).gpio_int_de[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_INT_DE.
 */
#define READ_GPIO_INT_DEr(u,r) bcm5607x_read32(u, R_GPIO_INT_DE, &(r._gpio_int_de))
#define WRITE_GPIO_INT_DEr(u,r) bcm5607x_write32(u, R_GPIO_INT_DE, (r._gpio_int_de))

/*******************************************************************************
 * End of 'GPIO_INT_DEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_INT_EDGE
 * BLOCKS:   IPROC
 * DESC:     GPIO interrupt edge/level selection register

 * SIZE:     32
 * FIELDS:
 *     INT_EDGE         GPIO interrupt edge/level selection register. Setting a bit to logic 1 selects a rising edge or a high level type of interrupt while clearing the bit to logic 0 selects falling edge or low level interrupt generation. The choice of edge triggered or level sensitive interrupt generation depends on the value set in GP_INT_TYPE register.If the corresponding bit in the GP_INT_DE register is set to logic 1, this register is ignored.
 */
#define GPIO_INT_EDGEr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_EDGE.
 */
typedef union GPIO_INT_EDGEr_s {
	uint32 v[1];
	uint32 gpio_int_edge[1];
	uint32 _gpio_int_edge;
} GPIO_INT_EDGEr_t;

#define GPIO_INT_EDGEr_CLR(r) (r).gpio_int_edge[0] = 0
#define GPIO_INT_EDGEr_SET(r,d) (r).gpio_int_edge[0] = d
#define GPIO_INT_EDGEr_GET(r) (r).gpio_int_edge[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_EDGEr_INT_EDGEf_GET(r) ((r).gpio_int_edge[0])
#define GPIO_INT_EDGEr_INT_EDGEf_SET(r,f) (r).gpio_int_edge[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_INT_EDGE.
 */
#define READ_GPIO_INT_EDGEr(u,r) bcm5607x_read32(u, R_GPIO_INT_EDGE, &(r._gpio_int_edge))
#define WRITE_GPIO_INT_EDGEr(u,r) bcm5607x_write32(u, R_GPIO_INT_EDGE, (r._gpio_int_edge))

/*******************************************************************************
 * End of 'GPIO_INT_EDGEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_INT_MSK
 * BLOCKS:   IPROC
 * DESC:     GPIO interrupt mask register

 * SIZE:     32
 * FIELDS:
 *     INT_MSK          GPIO interrupt mask register.  Setting the respective bits in this register permits the generation of an interrupt for the respective GPIO input. The interrupt generation is masked by setting the respective bit in this register to logic 0. 
 */
#define GPIO_INT_MSKr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_MSK.
 */
typedef union GPIO_INT_MSKr_s {
	uint32 v[1];
	uint32 gpio_int_msk[1];
	uint32 _gpio_int_msk;
} GPIO_INT_MSKr_t;

#define GPIO_INT_MSKr_CLR(r) (r).gpio_int_msk[0] = 0
#define GPIO_INT_MSKr_SET(r,d) (r).gpio_int_msk[0] = d
#define GPIO_INT_MSKr_GET(r) (r).gpio_int_msk[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_MSKr_INT_MSKf_GET(r) ((r).gpio_int_msk[0])
#define GPIO_INT_MSKr_INT_MSKf_SET(r,f) (r).gpio_int_msk[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_INT_MSK.
 */
#define READ_GPIO_INT_MSKr(u,r) bcm5607x_read32(u, R_GPIO_INT_MSK, &(r._gpio_int_msk))
#define WRITE_GPIO_INT_MSKr(u,r) bcm5607x_write32(u, R_GPIO_INT_MSK, (r._gpio_int_msk))

/*******************************************************************************
 * End of 'GPIO_INT_MSKr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_INT_MSTAT
 * BLOCKS:   IPROC
 * DESC:     GPIO interrupt masked status register

 * SIZE:     32
 * FIELDS:
 *     INT_MSTAT        GPIO interrupt masked status register. This register contains the resulting masked interrupt status. If a bit is 1, an interrupt has been generated by the unmasked interrupt pin, if 0, an interrupt has not been generated or has been masked by GP_INT_MASK. 
 */
#define GPIO_INT_MSTATr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_MSTAT.
 */
typedef union GPIO_INT_MSTATr_s {
	uint32 v[1];
	uint32 gpio_int_mstat[1];
	uint32 _gpio_int_mstat;
} GPIO_INT_MSTATr_t;

#define GPIO_INT_MSTATr_CLR(r) (r).gpio_int_mstat[0] = 0
#define GPIO_INT_MSTATr_SET(r,d) (r).gpio_int_mstat[0] = d
#define GPIO_INT_MSTATr_GET(r) (r).gpio_int_mstat[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_MSTATr_INT_MSTATf_GET(r) ((r).gpio_int_mstat[0])
#define GPIO_INT_MSTATr_INT_MSTATf_SET(r,f) (r).gpio_int_mstat[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_INT_MSTAT.
 */
#define READ_GPIO_INT_MSTATr(u,r) bcm5607x_read32(u, R_GPIO_INT_MSTAT, &(r._gpio_int_mstat))
#define WRITE_GPIO_INT_MSTATr(u,r) bcm5607x_write32(u, R_GPIO_INT_MSTAT, (r._gpio_int_mstat))

/*******************************************************************************
 * End of 'GPIO_INT_MSTATr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_INT_STAT
 * BLOCKS:   IPROC
 * DESC:     GPIO interrupt status register

 * SIZE:     32
 * FIELDS:
 *     INT_STAT         GPIO interrupt status register. This register contains the unmasked interrupt status.  During a read, if a bit is set to logic 1, the interrupt trigger condition has been detected.  If a bit is logic 0, this indicates that the interrupt has not triggered.
 */
#define GPIO_INT_STATr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_STAT.
 */
typedef union GPIO_INT_STATr_s {
	uint32 v[1];
	uint32 gpio_int_stat[1];
	uint32 _gpio_int_stat;
} GPIO_INT_STATr_t;

#define GPIO_INT_STATr_CLR(r) (r).gpio_int_stat[0] = 0
#define GPIO_INT_STATr_SET(r,d) (r).gpio_int_stat[0] = d
#define GPIO_INT_STATr_GET(r) (r).gpio_int_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_STATr_INT_STATf_GET(r) ((r).gpio_int_stat[0])
#define GPIO_INT_STATr_INT_STATf_SET(r,f) (r).gpio_int_stat[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_INT_STAT.
 */
#define READ_GPIO_INT_STATr(u,r) bcm5607x_read32(u, R_GPIO_INT_STAT, &(r._gpio_int_stat))
#define WRITE_GPIO_INT_STATr(u,r) bcm5607x_write32(u, R_GPIO_INT_STAT, (r._gpio_int_stat))

/*******************************************************************************
 * End of 'GPIO_INT_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_INT_TYPE
 * BLOCKS:   IPROC
 * DESC:     GPIO interrupt type register

 * SIZE:     32
 * FIELDS:
 *     INT_TYPE         GPIO interrupt type register, defines the type of interrupt. When a bit is set to logic 1, the corresponding GPIO input provides a level sensitive interrupt and when the bit is set to logic 0, the pin provides an edge sensitive interrupt.
 */
#define GPIO_INT_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_INT_TYPE.
 */
typedef union GPIO_INT_TYPEr_s {
	uint32 v[1];
	uint32 gpio_int_type[1];
	uint32 _gpio_int_type;
} GPIO_INT_TYPEr_t;

#define GPIO_INT_TYPEr_CLR(r) (r).gpio_int_type[0] = 0
#define GPIO_INT_TYPEr_SET(r,d) (r).gpio_int_type[0] = d
#define GPIO_INT_TYPEr_GET(r) (r).gpio_int_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_INT_TYPEr_INT_TYPEf_GET(r) ((r).gpio_int_type[0])
#define GPIO_INT_TYPEr_INT_TYPEf_SET(r,f) (r).gpio_int_type[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_INT_TYPE.
 */
#define READ_GPIO_INT_TYPEr(u,r) bcm5607x_read32(u, R_GPIO_INT_TYPE, &(r._gpio_int_type))
#define WRITE_GPIO_INT_TYPEr(u,r) bcm5607x_write32(u, R_GPIO_INT_TYPE, (r._gpio_int_type))

/*******************************************************************************
 * End of 'GPIO_INT_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_OUT_EN
 * BLOCKS:   IPROC
 * DESC:     GPIO drive enable register

 * SIZE:     32
 * FIELDS:
 *     OUT_ENABLE       GPIO driver enable register. Setting a bit to logic 1 enables the corresponding GPIO pad as an output driver otherwise it is configured as a receiver . When a bit is set low to logic 0, the driver is disabled.
 */
#define GPIO_OUT_ENr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_OUT_EN.
 */
typedef union GPIO_OUT_ENr_s {
	uint32 v[1];
	uint32 gpio_out_en[1];
	uint32 _gpio_out_en;
} GPIO_OUT_ENr_t;

#define GPIO_OUT_ENr_CLR(r) (r).gpio_out_en[0] = 0
#define GPIO_OUT_ENr_SET(r,d) (r).gpio_out_en[0] = d
#define GPIO_OUT_ENr_GET(r) (r).gpio_out_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_OUT_ENr_OUT_ENABLEf_GET(r) ((r).gpio_out_en[0])
#define GPIO_OUT_ENr_OUT_ENABLEf_SET(r,f) (r).gpio_out_en[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_OUT_EN.
 */
#define READ_GPIO_OUT_ENr(u,r) bcm5607x_read32(u, R_GPIO_OUT_EN, &(r._gpio_out_en))
#define WRITE_GPIO_OUT_ENr(u,r) bcm5607x_write32(u, R_GPIO_OUT_EN, (r._gpio_out_en))

/*******************************************************************************
 * End of 'GPIO_OUT_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_PAD_RES
 * BLOCKS:   IPROC
 * DESC:     GPIO Pad resister selection

 * SIZE:     32
 * FIELDS:
 *     PAD_RES          GPIO Pad resister selection. This register designates the polarity of the on-chip resister on the GPIO pin. If set to logic 1 the resister will be a pull-up or if set to logic 0 the resistor will be a pull-down. The corresponding bit in the GP_RES_EN  register must be set to logic 1 for this bit to be activated.
 */
#define GPIO_PAD_RESr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_PAD_RES.
 */
typedef union GPIO_PAD_RESr_s {
	uint32 v[1];
	uint32 gpio_pad_res[1];
	uint32 _gpio_pad_res;
} GPIO_PAD_RESr_t;

#define GPIO_PAD_RESr_CLR(r) (r).gpio_pad_res[0] = 0
#define GPIO_PAD_RESr_SET(r,d) (r).gpio_pad_res[0] = d
#define GPIO_PAD_RESr_GET(r) (r).gpio_pad_res[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_PAD_RESr_PAD_RESf_GET(r) ((r).gpio_pad_res[0])
#define GPIO_PAD_RESr_PAD_RESf_SET(r,f) (r).gpio_pad_res[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_PAD_RES.
 */
#define READ_GPIO_PAD_RESr(u,r) bcm5607x_read32(u, R_GPIO_PAD_RES, &(r._gpio_pad_res))
#define WRITE_GPIO_PAD_RESr(u,r) bcm5607x_write32(u, R_GPIO_PAD_RES, (r._gpio_pad_res))

/*******************************************************************************
 * End of 'GPIO_PAD_RESr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_PRB_ENABLE
 * BLOCKS:   IPROC
 * DESC:             GPIO Prb_en register. 
This registers selects the probe data to be output on the GPIO pins, and enables GPIO pins as a test output port.

 * SIZE:     32
 * FIELDS:
 *     PRB_SEL          "0 : selects to output probe data 01 : selects to output probe data 1
 *     TEST_SEL         0 : GPIO port is not selected as a test output port1 : GPIO port is selected as a test output port
 */
#define GPIO_PRB_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_PRB_ENABLE.
 */
typedef union GPIO_PRB_ENABLEr_s {
	uint32 v[1];
	uint32 gpio_prb_enable[1];
	uint32 _gpio_prb_enable;
} GPIO_PRB_ENABLEr_t;

#define GPIO_PRB_ENABLEr_CLR(r) (r).gpio_prb_enable[0] = 0
#define GPIO_PRB_ENABLEr_SET(r,d) (r).gpio_prb_enable[0] = d
#define GPIO_PRB_ENABLEr_GET(r) (r).gpio_prb_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_PRB_ENABLEr_PRB_SELf_GET(r) (((r).gpio_prb_enable[0]) & 0x1)
#define GPIO_PRB_ENABLEr_PRB_SELf_SET(r,f) (r).gpio_prb_enable[0]=(((r).gpio_prb_enable[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define GPIO_PRB_ENABLEr_TEST_SELf_GET(r) ((((r).gpio_prb_enable[0]) >> 1) & 0x1)
#define GPIO_PRB_ENABLEr_TEST_SELf_SET(r,f) (r).gpio_prb_enable[0]=(((r).gpio_prb_enable[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access GPIO_PRB_ENABLE.
 */
#define READ_GPIO_PRB_ENABLEr(u,r) bcm5607x_read32(u, R_GPIO_PRB_ENABLE, &(r._gpio_prb_enable))
#define WRITE_GPIO_PRB_ENABLEr(u,r) bcm5607x_write32(u, R_GPIO_PRB_ENABLE, (r._gpio_prb_enable))

/*******************************************************************************
 * End of 'GPIO_PRB_ENABLEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_PRB_OE
 * BLOCKS:   IPROC
 * DESC:             GPIO Prb_OE register. 
This registers configures the direction of each GPIO when in PRB_SEL mode."0x0MEM

 * SIZE:     32
 * FIELDS:
 *     GP_PRB_OE        0 : if PRB_SEL=0, GPIO port is configured as an output port (default)1 : If PRB_SEL=1, GPIO port is configured as an input port
 */
#define GPIO_PRB_OEr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_PRB_OE.
 */
typedef union GPIO_PRB_OEr_s {
	uint32 v[1];
	uint32 gpio_prb_oe[1];
	uint32 _gpio_prb_oe;
} GPIO_PRB_OEr_t;

#define GPIO_PRB_OEr_CLR(r) (r).gpio_prb_oe[0] = 0
#define GPIO_PRB_OEr_SET(r,d) (r).gpio_prb_oe[0] = d
#define GPIO_PRB_OEr_GET(r) (r).gpio_prb_oe[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_PRB_OEr_GP_PRB_OEf_GET(r) ((r).gpio_prb_oe[0])
#define GPIO_PRB_OEr_GP_PRB_OEf_SET(r,f) (r).gpio_prb_oe[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_PRB_OE.
 */
#define READ_GPIO_PRB_OEr(u,r) bcm5607x_read32(u, R_GPIO_PRB_OE, &(r._gpio_prb_oe))
#define WRITE_GPIO_PRB_OEr(u,r) bcm5607x_write32(u, R_GPIO_PRB_OE, (r._gpio_prb_oe))

/*******************************************************************************
 * End of 'GPIO_PRB_OEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPIO_RES_EN
 * BLOCKS:   IPROC
 * DESC:     GPIO Pad resister enable

 * SIZE:     32
 * FIELDS:
 *     RES_EN           GPIO Pad resister enable. This register enables the designation of the on-chip resister from the GP_PAD_RES register. If set to logic 1 the on-chip resistor is enabled otherwise clearing this bit to logic 0 disables the resistor. 
 */
#define GPIO_RES_ENr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_RES_EN.
 */
typedef union GPIO_RES_ENr_s {
	uint32 v[1];
	uint32 gpio_res_en[1];
	uint32 _gpio_res_en;
} GPIO_RES_ENr_t;

#define GPIO_RES_ENr_CLR(r) (r).gpio_res_en[0] = 0
#define GPIO_RES_ENr_SET(r,d) (r).gpio_res_en[0] = d
#define GPIO_RES_ENr_GET(r) (r).gpio_res_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPIO_RES_ENr_RES_ENf_GET(r) ((r).gpio_res_en[0])
#define GPIO_RES_ENr_RES_ENf_SET(r,f) (r).gpio_res_en[0]=((uint32)f)

/*
 * These macros can be used to access GPIO_RES_EN.
 */
#define READ_GPIO_RES_ENr(u,r) bcm5607x_read32(u, R_GPIO_RES_EN, &(r._gpio_res_en))
#define WRITE_GPIO_RES_ENr(u,r) bcm5607x_write32(u, R_GPIO_RES_EN, (r._gpio_res_en))

/*******************************************************************************
 * End of 'GPIO_RES_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPORT_CONFIG
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     GPORT configuration Register
 * SIZE:     32
 * FIELDS:
 *     GPORT_EN         Enable GPORT. GPORT will not read GBOD buffer/Write GBODE buffer if this bit is disabled. 
 *     CLR_CNT          Clear all 8 GE port statistic Counters.
 */
#define GPORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_CONFIG.
 */
typedef union GPORT_CONFIGr_s {
	uint32 v[1];
	uint32 gport_config[1];
	uint32 _gport_config;
} GPORT_CONFIGr_t;

#define GPORT_CONFIGr_CLR(r) (r).gport_config[0] = 0
#define GPORT_CONFIGr_SET(r,d) (r).gport_config[0] = d
#define GPORT_CONFIGr_GET(r) (r).gport_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPORT_CONFIGr_GPORT_ENf_GET(r) (((r).gport_config[0]) & 0x1)
#define GPORT_CONFIGr_GPORT_ENf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define GPORT_CONFIGr_CLR_CNTf_GET(r) ((((r).gport_config[0]) >> 1) & 0x1)
#define GPORT_CONFIGr_CLR_CNTf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access GPORT_CONFIG.
 */
#define WRITE_GPORT_CONFIGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GPORT_CONFIG, (r._gport_config))
#define READ_GPORT_CONFIGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GPORT_CONFIG, &(r._gport_config))

/*******************************************************************************
 * End of 'GPORT_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPORT_LINK_STATUS_TO_CMIC
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     This is used to swizzle the gp_to_cmic_link_status from [7:0] to [0:7].
 * SIZE:     32
 * FIELDS:
 *     TRANSPOSE         a value of 1 will swizzle the gp_to_cmic_link_status from [7:0] to [0:7].  This may be needed due to physical mirroring of the gport block. 
 */
#define GPORT_LINK_STATUS_TO_CMICr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_LINK_STATUS_TO_CMIC.
 */
typedef union GPORT_LINK_STATUS_TO_CMICr_s {
	uint32 v[1];
	uint32 gport_link_status_to_cmic[1];
	uint32 _gport_link_status_to_cmic;
} GPORT_LINK_STATUS_TO_CMICr_t;

#define GPORT_LINK_STATUS_TO_CMICr_CLR(r) (r).gport_link_status_to_cmic[0] = 0
#define GPORT_LINK_STATUS_TO_CMICr_SET(r,d) (r).gport_link_status_to_cmic[0] = d
#define GPORT_LINK_STATUS_TO_CMICr_GET(r) (r).gport_link_status_to_cmic[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPORT_LINK_STATUS_TO_CMICr_TRANSPOSEf_GET(r) (((r).gport_link_status_to_cmic[0]) & 0x1)
#define GPORT_LINK_STATUS_TO_CMICr_TRANSPOSEf_SET(r,f) (r).gport_link_status_to_cmic[0]=(((r).gport_link_status_to_cmic[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access GPORT_LINK_STATUS_TO_CMIC.
 */
#define WRITE_GPORT_LINK_STATUS_TO_CMICr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GPORT_LINK_STATUS_TO_CMIC, (r._gport_link_status_to_cmic))
#define READ_GPORT_LINK_STATUS_TO_CMICr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GPORT_LINK_STATUS_TO_CMIC, &(r._gport_link_status_to_cmic))

/*******************************************************************************
 * End of 'GPORT_LINK_STATUS_TO_CMICr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPORT_RSV_MASK
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     GPORT RSV MASK register, used to purge packet data received from the MACs
 * SIZE:     32
 * FIELDS:
 *     MASK                             Control which RSV bits cause packets to be purged:                          bit 17 NOT USED -- Runt (Not Used; runts are filtered)                          bit 16 Frame truncated due to overflow                                         bit 15 Unicast                           bit 14 VLAN                           bit 13 Unsupported op code                           bit 12 Pause received                          bit 11 Control frame received                          bit 10 Dribble nibble                          bit 9 Broadcast                           bit 8 Multicast                           bit 7 Receive ok                           bit 6 Length out of range                          bit 5 Length error                           bit 4 CRC error                           bit 3 Rx frame GMII code error                           bit 2 Carrier event                           bit 1 Stacked VLAN frame                          bit 0 Received Frame Aligment Error 
 */
#define GPORT_RSV_MASKr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_RSV_MASK.
 */
typedef union GPORT_RSV_MASKr_s {
	uint32 v[1];
	uint32 gport_rsv_mask[1];
	uint32 _gport_rsv_mask;
} GPORT_RSV_MASKr_t;

#define GPORT_RSV_MASKr_CLR(r) (r).gport_rsv_mask[0] = 0
#define GPORT_RSV_MASKr_SET(r,d) (r).gport_rsv_mask[0] = d
#define GPORT_RSV_MASKr_GET(r) (r).gport_rsv_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPORT_RSV_MASKr_MASKf_GET(r) (((r).gport_rsv_mask[0]) & 0x3ffff)
#define GPORT_RSV_MASKr_MASKf_SET(r,f) (r).gport_rsv_mask[0]=(((r).gport_rsv_mask[0] & ~((uint32)0x3ffff)) | (((uint32)f) & 0x3ffff))

/*
 * These macros can be used to access GPORT_RSV_MASK.
 */
#define WRITE_GPORT_RSV_MASKr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GPORT_RSV_MASK, (r._gport_rsv_mask))
#define READ_GPORT_RSV_MASKr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GPORT_RSV_MASK, &(r._gport_rsv_mask))

/*******************************************************************************
 * End of 'GPORT_RSV_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GPORT_STAT_UPDATE_MASK
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     GPORT STAT_UPDATE MASK register, used to control the statistic counter update in the Ingress
 * SIZE:     32
 * FIELDS:
 *     MASK                             Control which RSV event should have the statistic counter updated in the Ingress :                          bit 17 NOT USED -- Runt (Not Used; runts are filtered)                          bit 16 Frame truncated due to overflow                                         bit 15 Unicast                           bit 14 VLAN                           bit 13 Unsupported op code                           bit 12 Pause received                          bit 11 Control frame received                          bit 10 Dribble nibble                          bit 9 Broadcast                           bit 8 Multicast                           bit 7 Receive ok                           bit 6 Length out of range                          bit 5 Length error                           bit 4 CRC error                           bit 3 Rx frame GMII code error                           bit 2 Carrier event                           bit 1 Stacked VLAN frame                          bit 0 Received Frame Aligment Error 
 */
#define GPORT_STAT_UPDATE_MASKr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_STAT_UPDATE_MASK.
 */
typedef union GPORT_STAT_UPDATE_MASKr_s {
	uint32 v[1];
	uint32 gport_stat_update_mask[1];
	uint32 _gport_stat_update_mask;
} GPORT_STAT_UPDATE_MASKr_t;

#define GPORT_STAT_UPDATE_MASKr_CLR(r) (r).gport_stat_update_mask[0] = 0
#define GPORT_STAT_UPDATE_MASKr_SET(r,d) (r).gport_stat_update_mask[0] = d
#define GPORT_STAT_UPDATE_MASKr_GET(r) (r).gport_stat_update_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPORT_STAT_UPDATE_MASKr_MASKf_GET(r) (((r).gport_stat_update_mask[0]) & 0x3ffff)
#define GPORT_STAT_UPDATE_MASKr_MASKf_SET(r,f) (r).gport_stat_update_mask[0]=(((r).gport_stat_update_mask[0] & ~((uint32)0x3ffff)) | (((uint32)f) & 0x3ffff))

/*
 * These macros can be used to access GPORT_STAT_UPDATE_MASK.
 */
#define WRITE_GPORT_STAT_UPDATE_MASKr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GPORT_STAT_UPDATE_MASK, (r._gport_stat_update_mask))
#define READ_GPORT_STAT_UPDATE_MASKr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GPORT_STAT_UPDATE_MASK, &(r._gport_stat_update_mask))

/*******************************************************************************
 * End of 'GPORT_STAT_UPDATE_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GRALN
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Receive Alignment Error Frame Counter
 * SIZE:     32
 */
#define GRALNr_SIZE 4

/*
 * This structure should be used to declare and program GRALN.
 */
typedef union GRALNr_s {
	uint32 v[1];
	uint32 graln[1];
	uint32 _graln;
} GRALNr_t;

#define GRALNr_CLR(r) (r).graln[0] = 0
#define GRALNr_SET(r,d) (r).graln[0] = d
#define GRALNr_GET(r) (r).graln[0]


/*
 * These macros can be used to access GRALN.
 */
#define WRITE_GRALNr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GRALN(bcm5607x_gport_lport_to_index_in_block[p]), (r._graln))
#define READ_GRALNr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GRALN(bcm5607x_gport_lport_to_index_in_block[p]), &(r._graln))

/*******************************************************************************
 * End of 'GRALNr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GRBCA
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Receive Broadcast Frame Counter
 * SIZE:     32
 */
#define GRBCAr_SIZE 4

/*
 * This structure should be used to declare and program GRBCA.
 */
typedef union GRBCAr_s {
	uint32 v[1];
	uint32 grbca[1];
	uint32 _grbca;
} GRBCAr_t;

#define GRBCAr_CLR(r) (r).grbca[0] = 0
#define GRBCAr_SET(r,d) (r).grbca[0] = d
#define GRBCAr_GET(r) (r).grbca[0]


/*
 * These macros can be used to access GRBCA.
 */
#define WRITE_GRBCAr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GRBCA(bcm5607x_gport_lport_to_index_in_block[p]), (r._grbca))
#define READ_GRBCAr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GRBCA(bcm5607x_gport_lport_to_index_in_block[p]), &(r._grbca))

/*******************************************************************************
 * End of 'GRBCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GRBYT
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Receive Byte Counter
 * SIZE:     32
 */
#define GRBYTr_SIZE 4

/*
 * This structure should be used to declare and program GRBYT.
 */
typedef union GRBYTr_s {
	uint32 v[1];
	uint32 grbyt[1];
	uint32 _grbyt;
} GRBYTr_t;

#define GRBYTr_CLR(r) (r).grbyt[0] = 0
#define GRBYTr_SET(r,d) (r).grbyt[0] = d
#define GRBYTr_GET(r) (r).grbyt[0]


/*
 * These macros can be used to access GRBYT.
 */
#define WRITE_GRBYTr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GRBYT(bcm5607x_gport_lport_to_index_in_block[p]), (r._grbyt))
#define READ_GRBYTr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GRBYT(bcm5607x_gport_lport_to_index_in_block[p]), &(r._grbyt))

/*******************************************************************************
 * End of 'GRBYTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GRFCS
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Receive FCS Error Frame Counter
 * SIZE:     32
 */
#define GRFCSr_SIZE 4

/*
 * This structure should be used to declare and program GRFCS.
 */
typedef union GRFCSr_s {
	uint32 v[1];
	uint32 grfcs[1];
	uint32 _grfcs;
} GRFCSr_t;

#define GRFCSr_CLR(r) (r).grfcs[0] = 0
#define GRFCSr_SET(r,d) (r).grfcs[0] = d
#define GRFCSr_GET(r) (r).grfcs[0]


/*
 * These macros can be used to access GRFCS.
 */
#define WRITE_GRFCSr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GRFCS(bcm5607x_gport_lport_to_index_in_block[p]), (r._grfcs))
#define READ_GRFCSr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GRFCS(bcm5607x_gport_lport_to_index_in_block[p]), &(r._grfcs))

/*******************************************************************************
 * End of 'GRFCSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GRMCA
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Receive Multicast Frame Counter
 * SIZE:     32
 */
#define GRMCAr_SIZE 4

/*
 * This structure should be used to declare and program GRMCA.
 */
typedef union GRMCAr_s {
	uint32 v[1];
	uint32 grmca[1];
	uint32 _grmca;
} GRMCAr_t;

#define GRMCAr_CLR(r) (r).grmca[0] = 0
#define GRMCAr_SET(r,d) (r).grmca[0] = d
#define GRMCAr_GET(r) (r).grmca[0]


/*
 * These macros can be used to access GRMCA.
 */
#define WRITE_GRMCAr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GRMCA(bcm5607x_gport_lport_to_index_in_block[p]), (r._grmca))
#define READ_GRMCAr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GRMCA(bcm5607x_gport_lport_to_index_in_block[p]), &(r._grmca))

/*******************************************************************************
 * End of 'GRMCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GROVR
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Receive Oversized Frame Counter
 * SIZE:     32
 */
#define GROVRr_SIZE 4

/*
 * This structure should be used to declare and program GROVR.
 */
typedef union GROVRr_s {
	uint32 v[1];
	uint32 grovr[1];
	uint32 _grovr;
} GROVRr_t;

#define GROVRr_CLR(r) (r).grovr[0] = 0
#define GROVRr_SET(r,d) (r).grovr[0] = d
#define GROVRr_GET(r) (r).grovr[0]


/*
 * These macros can be used to access GROVR.
 */
#define WRITE_GROVRr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GROVR(bcm5607x_gport_lport_to_index_in_block[p]), (r._grovr))
#define READ_GROVRr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GROVR(bcm5607x_gport_lport_to_index_in_block[p]), &(r._grovr))

/*******************************************************************************
 * End of 'GROVRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GRPKT
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Receive frame Counter
 * SIZE:     32
 */
#define GRPKTr_SIZE 4

/*
 * This structure should be used to declare and program GRPKT.
 */
typedef union GRPKTr_s {
	uint32 v[1];
	uint32 grpkt[1];
	uint32 _grpkt;
} GRPKTr_t;

#define GRPKTr_CLR(r) (r).grpkt[0] = 0
#define GRPKTr_SET(r,d) (r).grpkt[0] = d
#define GRPKTr_GET(r) (r).grpkt[0]


/*
 * These macros can be used to access GRPKT.
 */
#define WRITE_GRPKTr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GRPKT(bcm5607x_gport_lport_to_index_in_block[p]), (r._grpkt))
#define READ_GRPKTr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GRPKT(bcm5607x_gport_lport_to_index_in_block[p]), &(r._grpkt))

/*******************************************************************************
 * End of 'GRPKTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GRUC
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Receive Unicast Counter
 * SIZE:     32
 */
#define GRUCr_SIZE 4

/*
 * This structure should be used to declare and program GRUC.
 */
typedef union GRUCr_s {
	uint32 v[1];
	uint32 gruc[1];
	uint32 _gruc;
} GRUCr_t;

#define GRUCr_CLR(r) (r).gruc[0] = 0
#define GRUCr_SET(r,d) (r).gruc[0] = d
#define GRUCr_GET(r) (r).gruc[0]


/*
 * These macros can be used to access GRUC.
 */
#define WRITE_GRUCr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GRUC(bcm5607x_gport_lport_to_index_in_block[p]), (r._gruc))
#define READ_GRUCr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GRUC(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gruc))

/*******************************************************************************
 * End of 'GRUCr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GRXPF
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Receive Pause Frame Counter
 * SIZE:     32
 */
#define GRXPFr_SIZE 4

/*
 * This structure should be used to declare and program GRXPF.
 */
typedef union GRXPFr_s {
	uint32 v[1];
	uint32 grxpf[1];
	uint32 _grxpf;
} GRXPFr_t;

#define GRXPFr_CLR(r) (r).grxpf[0] = 0
#define GRXPFr_SET(r,d) (r).grxpf[0] = d
#define GRXPFr_GET(r) (r).grxpf[0]


/*
 * These macros can be used to access GRXPF.
 */
#define WRITE_GRXPFr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GRXPF(bcm5607x_gport_lport_to_index_in_block[p]), (r._grxpf))
#define READ_GRXPFr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GRXPF(bcm5607x_gport_lport_to_index_in_block[p]), &(r._grxpf))

/*******************************************************************************
 * End of 'GRXPFr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GRX_EEE_LPI_DURATION_COUNTER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     RX EEE LPI Duration Counter.
 * SIZE:     32
 */
#define GRX_EEE_LPI_DURATION_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program GRX_EEE_LPI_DURATION_COUNTER.
 */
typedef union GRX_EEE_LPI_DURATION_COUNTERr_s {
	uint32 v[1];
	uint32 grx_eee_lpi_duration_counter[1];
	uint32 _grx_eee_lpi_duration_counter;
} GRX_EEE_LPI_DURATION_COUNTERr_t;

#define GRX_EEE_LPI_DURATION_COUNTERr_CLR(r) (r).grx_eee_lpi_duration_counter[0] = 0
#define GRX_EEE_LPI_DURATION_COUNTERr_SET(r,d) (r).grx_eee_lpi_duration_counter[0] = d
#define GRX_EEE_LPI_DURATION_COUNTERr_GET(r) (r).grx_eee_lpi_duration_counter[0]


/*
 * These macros can be used to access GRX_EEE_LPI_DURATION_COUNTER.
 */
#define WRITE_GRX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GRX_EEE_LPI_DURATION_COUNTER(bcm5607x_gport_lport_to_index_in_block[p]), (r._grx_eee_lpi_duration_counter))
#define READ_GRX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GRX_EEE_LPI_DURATION_COUNTER(bcm5607x_gport_lport_to_index_in_block[p]), &(r._grx_eee_lpi_duration_counter))

/*******************************************************************************
 * End of 'GRX_EEE_LPI_DURATION_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GRX_EEE_LPI_EVENT_COUNTER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     RX EEE LPI Event Counter.
 * SIZE:     32
 */
#define GRX_EEE_LPI_EVENT_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program GRX_EEE_LPI_EVENT_COUNTER.
 */
typedef union GRX_EEE_LPI_EVENT_COUNTERr_s {
	uint32 v[1];
	uint32 grx_eee_lpi_event_counter[1];
	uint32 _grx_eee_lpi_event_counter;
} GRX_EEE_LPI_EVENT_COUNTERr_t;

#define GRX_EEE_LPI_EVENT_COUNTERr_CLR(r) (r).grx_eee_lpi_event_counter[0] = 0
#define GRX_EEE_LPI_EVENT_COUNTERr_SET(r,d) (r).grx_eee_lpi_event_counter[0] = d
#define GRX_EEE_LPI_EVENT_COUNTERr_GET(r) (r).grx_eee_lpi_event_counter[0]


/*
 * These macros can be used to access GRX_EEE_LPI_EVENT_COUNTER.
 */
#define WRITE_GRX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GRX_EEE_LPI_EVENT_COUNTER(bcm5607x_gport_lport_to_index_in_block[p]), (r._grx_eee_lpi_event_counter))
#define READ_GRX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GRX_EEE_LPI_EVENT_COUNTER(bcm5607x_gport_lport_to_index_in_block[p]), &(r._grx_eee_lpi_event_counter))

/*******************************************************************************
 * End of 'GRX_EEE_LPI_EVENT_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GTBCA
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Transmit Broadcast Frame Counter
 * SIZE:     32
 */
#define GTBCAr_SIZE 4

/*
 * This structure should be used to declare and program GTBCA.
 */
typedef union GTBCAr_s {
	uint32 v[1];
	uint32 gtbca[1];
	uint32 _gtbca;
} GTBCAr_t;

#define GTBCAr_CLR(r) (r).gtbca[0] = 0
#define GTBCAr_SET(r,d) (r).gtbca[0] = d
#define GTBCAr_GET(r) (r).gtbca[0]


/*
 * These macros can be used to access GTBCA.
 */
#define WRITE_GTBCAr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GTBCA(bcm5607x_gport_lport_to_index_in_block[p]), (r._gtbca))
#define READ_GTBCAr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GTBCA(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gtbca))

/*******************************************************************************
 * End of 'GTBCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GTBYT
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Transmit Byte Counter
 * SIZE:     32
 */
#define GTBYTr_SIZE 4

/*
 * This structure should be used to declare and program GTBYT.
 */
typedef union GTBYTr_s {
	uint32 v[1];
	uint32 gtbyt[1];
	uint32 _gtbyt;
} GTBYTr_t;

#define GTBYTr_CLR(r) (r).gtbyt[0] = 0
#define GTBYTr_SET(r,d) (r).gtbyt[0] = d
#define GTBYTr_GET(r) (r).gtbyt[0]


/*
 * These macros can be used to access GTBYT.
 */
#define WRITE_GTBYTr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GTBYT(bcm5607x_gport_lport_to_index_in_block[p]), (r._gtbyt))
#define READ_GTBYTr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GTBYT(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gtbyt))

/*******************************************************************************
 * End of 'GTBYTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GTFCS
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Transmit FCS Error Counter
 * SIZE:     32
 */
#define GTFCSr_SIZE 4

/*
 * This structure should be used to declare and program GTFCS.
 */
typedef union GTFCSr_s {
	uint32 v[1];
	uint32 gtfcs[1];
	uint32 _gtfcs;
} GTFCSr_t;

#define GTFCSr_CLR(r) (r).gtfcs[0] = 0
#define GTFCSr_SET(r,d) (r).gtfcs[0] = d
#define GTFCSr_GET(r) (r).gtfcs[0]


/*
 * These macros can be used to access GTFCS.
 */
#define WRITE_GTFCSr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GTFCS(bcm5607x_gport_lport_to_index_in_block[p]), (r._gtfcs))
#define READ_GTFCSr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GTFCS(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gtfcs))

/*******************************************************************************
 * End of 'GTFCSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GTMCA
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Transmit Multicast Frame Counter
 * SIZE:     32
 */
#define GTMCAr_SIZE 4

/*
 * This structure should be used to declare and program GTMCA.
 */
typedef union GTMCAr_s {
	uint32 v[1];
	uint32 gtmca[1];
	uint32 _gtmca;
} GTMCAr_t;

#define GTMCAr_CLR(r) (r).gtmca[0] = 0
#define GTMCAr_SET(r,d) (r).gtmca[0] = d
#define GTMCAr_GET(r) (r).gtmca[0]


/*
 * These macros can be used to access GTMCA.
 */
#define WRITE_GTMCAr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GTMCA(bcm5607x_gport_lport_to_index_in_block[p]), (r._gtmca))
#define READ_GTMCAr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GTMCA(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gtmca))

/*******************************************************************************
 * End of 'GTMCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GTOVR
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Transmit Oversize Packet Counter
 * SIZE:     32
 */
#define GTOVRr_SIZE 4

/*
 * This structure should be used to declare and program GTOVR.
 */
typedef union GTOVRr_s {
	uint32 v[1];
	uint32 gtovr[1];
	uint32 _gtovr;
} GTOVRr_t;

#define GTOVRr_CLR(r) (r).gtovr[0] = 0
#define GTOVRr_SET(r,d) (r).gtovr[0] = d
#define GTOVRr_GET(r) (r).gtovr[0]


/*
 * These macros can be used to access GTOVR.
 */
#define WRITE_GTOVRr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GTOVR(bcm5607x_gport_lport_to_index_in_block[p]), (r._gtovr))
#define READ_GTOVRr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GTOVR(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gtovr))

/*******************************************************************************
 * End of 'GTOVRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GTPKT
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Transmit frame Counter
 * SIZE:     32
 */
#define GTPKTr_SIZE 4

/*
 * This structure should be used to declare and program GTPKT.
 */
typedef union GTPKTr_s {
	uint32 v[1];
	uint32 gtpkt[1];
	uint32 _gtpkt;
} GTPKTr_t;

#define GTPKTr_CLR(r) (r).gtpkt[0] = 0
#define GTPKTr_SET(r,d) (r).gtpkt[0] = d
#define GTPKTr_GET(r) (r).gtpkt[0]


/*
 * These macros can be used to access GTPKT.
 */
#define WRITE_GTPKTr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GTPKT(bcm5607x_gport_lport_to_index_in_block[p]), (r._gtpkt))
#define READ_GTPKTr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GTPKT(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gtpkt))

/*******************************************************************************
 * End of 'GTPKTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GTUC
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Transmit Unicast Counter
 * SIZE:     32
 */
#define GTUCr_SIZE 4

/*
 * This structure should be used to declare and program GTUC.
 */
typedef union GTUCr_s {
	uint32 v[1];
	uint32 gtuc[1];
	uint32 _gtuc;
} GTUCr_t;

#define GTUCr_CLR(r) (r).gtuc[0] = 0
#define GTUCr_SET(r,d) (r).gtuc[0] = d
#define GTUCr_GET(r) (r).gtuc[0]


/*
 * These macros can be used to access GTUC.
 */
#define WRITE_GTUCr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GTUC(bcm5607x_gport_lport_to_index_in_block[p]), (r._gtuc))
#define READ_GTUCr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GTUC(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gtuc))

/*******************************************************************************
 * End of 'GTUCr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GTXPF
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Transmit Pause Control Frame Counter
 * SIZE:     32
 */
#define GTXPFr_SIZE 4

/*
 * This structure should be used to declare and program GTXPF.
 */
typedef union GTXPFr_s {
	uint32 v[1];
	uint32 gtxpf[1];
	uint32 _gtxpf;
} GTXPFr_t;

#define GTXPFr_CLR(r) (r).gtxpf[0] = 0
#define GTXPFr_SET(r,d) (r).gtxpf[0] = d
#define GTXPFr_GET(r) (r).gtxpf[0]


/*
 * These macros can be used to access GTXPF.
 */
#define WRITE_GTXPFr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GTXPF(bcm5607x_gport_lport_to_index_in_block[p]), (r._gtxpf))
#define READ_GTXPFr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GTXPF(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gtxpf))

/*******************************************************************************
 * End of 'GTXPFr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GTX_EEE_LPI_DURATION_COUNTER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     TX EEE LPI Duration Counter.
 * SIZE:     32
 */
#define GTX_EEE_LPI_DURATION_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program GTX_EEE_LPI_DURATION_COUNTER.
 */
typedef union GTX_EEE_LPI_DURATION_COUNTERr_s {
	uint32 v[1];
	uint32 gtx_eee_lpi_duration_counter[1];
	uint32 _gtx_eee_lpi_duration_counter;
} GTX_EEE_LPI_DURATION_COUNTERr_t;

#define GTX_EEE_LPI_DURATION_COUNTERr_CLR(r) (r).gtx_eee_lpi_duration_counter[0] = 0
#define GTX_EEE_LPI_DURATION_COUNTERr_SET(r,d) (r).gtx_eee_lpi_duration_counter[0] = d
#define GTX_EEE_LPI_DURATION_COUNTERr_GET(r) (r).gtx_eee_lpi_duration_counter[0]


/*
 * These macros can be used to access GTX_EEE_LPI_DURATION_COUNTER.
 */
#define WRITE_GTX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GTX_EEE_LPI_DURATION_COUNTER(bcm5607x_gport_lport_to_index_in_block[p]), (r._gtx_eee_lpi_duration_counter))
#define READ_GTX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GTX_EEE_LPI_DURATION_COUNTER(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gtx_eee_lpi_duration_counter))

/*******************************************************************************
 * End of 'GTX_EEE_LPI_DURATION_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  GTX_EEE_LPI_EVENT_COUNTER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     TX EEE LPI Event Counter.
 * SIZE:     32
 */
#define GTX_EEE_LPI_EVENT_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program GTX_EEE_LPI_EVENT_COUNTER.
 */
typedef union GTX_EEE_LPI_EVENT_COUNTERr_s {
	uint32 v[1];
	uint32 gtx_eee_lpi_event_counter[1];
	uint32 _gtx_eee_lpi_event_counter;
} GTX_EEE_LPI_EVENT_COUNTERr_t;

#define GTX_EEE_LPI_EVENT_COUNTERr_CLR(r) (r).gtx_eee_lpi_event_counter[0] = 0
#define GTX_EEE_LPI_EVENT_COUNTERr_SET(r,d) (r).gtx_eee_lpi_event_counter[0] = d
#define GTX_EEE_LPI_EVENT_COUNTERr_GET(r) (r).gtx_eee_lpi_event_counter[0]


/*
 * These macros can be used to access GTX_EEE_LPI_EVENT_COUNTER.
 */
#define WRITE_GTX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_GTX_EEE_LPI_EVENT_COUNTER(bcm5607x_gport_lport_to_index_in_block[p]), (r._gtx_eee_lpi_event_counter))
#define READ_GTX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_GTX_EEE_LPI_EVENT_COUNTER(bcm5607x_gport_lport_to_index_in_block[p]), &(r._gtx_eee_lpi_event_counter))

/*******************************************************************************
 * End of 'GTX_EEE_LPI_EVENT_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Hash Control Register
 * SIZE:     32
 * FIELDS:
 *     NON_UC_TRUNK_HASH_MOD_PORT_ENABLE If set to 1, enable factoring MOD_ID/port into non-unicast trunk block mask hashing
 *     NON_UC_TRUNK_HASH_SRC_ENABLE If set to 1, enable factoring source MAC or source IP into non-unicast trunk block mask hashing
 *     NON_UC_TRUNK_HASH_DST_ENABLE If set to 1, enable factoring destination MAC or destination IP into non-unicast trunk block mask hashing
 *     UC_TRUNK_HASH_USE_SRC_PORT If set to 1, use source port in unicast trunk hash
 *     ECMP_HASH_UDF    ECMP hash offset.
 *     ECMP_HASH_USE_DIP Use DIP for ECMP hashing.
 *     ECMP_HASH_SEL    Selects ECMP hashing algorithm.
 *     L2_AND_VLAN_MAC_HASH_SELECT Selects hashing algorithm used for L2 table lookups
 *     L3_HASH_SELECT   Selects hashing algorithm used for L3 table lookups
 *     ENABLE_DRACO1_5_HASH If set to 1, enable using Draco 1.5 hashing for unicast trunk
 *     USE_TCP_UDP_PORTS If set to 1, use TCP/UDP ports for unicast trunk hashing
 *     ECMP_HASH_USE_RTAG7 Use RTAG7 hash for ECMP hashing.
 *     NON_UC_TRUNK_HASH_USE_RTAG7 Use RTAG7 hash for non unicast trunk hashing.
 *     ECMP_HASH_FIELD_UPPER_BITS_COUNT This count determines the number of bits of the 16-bit ECMP hash value to use as an input the the modulo function.This provides flixibility to obtain a 10_mod_10 to 16_mod_10. Values are:0: Use the lowest 10-bits of the 16-bit hash value and perform 10_mod_101: Use the lowest 11-bits of the 16-bit hash value and perform 11_mod_102: Use the lowest 12-bits of the 16-bit hash value and perform 12_mod_103: Use the lowest 13-bits of the 16-bit hash value and perform 13_mod_104: Use the lowest 14-bits of the 16-bit hash value and perform 14_mod_105: Use the lowest 15-bits of the 16-bit hash value and perform 15_mod_106: Use the lowest 16-bits of the 16-bit hash value and perform 16_mod_107: Reserved
 */
#define HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program HASH_CONTROL.
 */
typedef union HASH_CONTROLr_s {
	uint32 v[1];
	uint32 hash_control[1];
	uint32 _hash_control;
} HASH_CONTROLr_t;

#define HASH_CONTROLr_CLR(r) (r).hash_control[0] = 0
#define HASH_CONTROLr_SET(r,d) (r).hash_control[0] = d
#define HASH_CONTROLr_GET(r) (r).hash_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET(r) (((r).hash_control[0]) & 0x1)
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET(r) ((((r).hash_control[0]) >> 1) & 0x1)
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET(r) ((((r).hash_control[0]) >> 2) & 0x1)
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET(r) ((((r).hash_control[0]) >> 3) & 0x1)
#define HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define HASH_CONTROLr_ECMP_HASH_UDFf_GET(r) ((((r).hash_control[0]) >> 4) & 0xff)
#define HASH_CONTROLr_ECMP_HASH_UDFf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0xff << 4)) | ((((uint32)f) & 0xff) << 4))
#define HASH_CONTROLr_ECMP_HASH_USE_DIPf_GET(r) ((((r).hash_control[0]) >> 12) & 0x1)
#define HASH_CONTROLr_ECMP_HASH_USE_DIPf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define HASH_CONTROLr_ECMP_HASH_SELf_GET(r) ((((r).hash_control[0]) >> 13) & 0x3)
#define HASH_CONTROLr_ECMP_HASH_SELf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET(r) ((((r).hash_control[0]) >> 15) & 0x7)
#define HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define HASH_CONTROLr_L3_HASH_SELECTf_GET(r) ((((r).hash_control[0]) >> 18) & 0x7)
#define HASH_CONTROLr_L3_HASH_SELECTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET(r) ((((r).hash_control[0]) >> 21) & 0x1)
#define HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET(r) ((((r).hash_control[0]) >> 22) & 0x1)
#define HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define HASH_CONTROLr_ECMP_HASH_USE_RTAG7f_GET(r) ((((r).hash_control[0]) >> 23) & 0x1)
#define HASH_CONTROLr_ECMP_HASH_USE_RTAG7f_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_USE_RTAG7f_GET(r) ((((r).hash_control[0]) >> 24) & 0x1)
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_USE_RTAG7f_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define HASH_CONTROLr_ECMP_HASH_FIELD_UPPER_BITS_COUNTf_GET(r) ((((r).hash_control[0]) >> 25) & 0x7)
#define HASH_CONTROLr_ECMP_HASH_FIELD_UPPER_BITS_COUNTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x7 << 25)) | ((((uint32)f) & 0x7) << 25))

/*
 * These macros can be used to access HASH_CONTROL.
 */
#define WRITE_HASH_CONTROLr(u,r) bcm5607x_reg_set(u,R_HASH_CONTROL,(r._hash_control))
#define READ_HASH_CONTROLr(u,r) bcm5607x_reg_get(u,R_HASH_CONTROL,&(r._hash_control))

/*******************************************************************************
 * End of 'HASH_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  HOLCOSCELLMAXLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLMAXLIMIT     CELL THD.A queue can be put into HOL drop state when the HOL cell count reaches(>=)  the value set in this register.
 *     CELLMAXRESUMELIMIT CELL THD.A queue can be brought out of HOL drop state due to reaching the max cell limit, when the HOL cell count goes below (<) the value set in this register.
 */
#define HOLCOSCELLMAXLIMITr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSCELLMAXLIMIT.
 */
typedef union HOLCOSCELLMAXLIMITr_s {
	uint32 v[1];
	uint32 holcoscellmaxlimit[1];
	uint32 _holcoscellmaxlimit;
} HOLCOSCELLMAXLIMITr_t;

#define HOLCOSCELLMAXLIMITr_CLR(r) (r).holcoscellmaxlimit[0] = 0
#define HOLCOSCELLMAXLIMITr_SET(r,d) (r).holcoscellmaxlimit[0] = d
#define HOLCOSCELLMAXLIMITr_GET(r) (r).holcoscellmaxlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSCELLMAXLIMITr_CELLMAXLIMITf_GET(r) (((r).holcoscellmaxlimit[0]) & 0x3fff)
#define HOLCOSCELLMAXLIMITr_CELLMAXLIMITf_SET(r,f) (r).holcoscellmaxlimit[0]=(((r).holcoscellmaxlimit[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define HOLCOSCELLMAXLIMITr_CELLMAXRESUMELIMITf_GET(r) ((((r).holcoscellmaxlimit[0]) >> 14) & 0x3fff)
#define HOLCOSCELLMAXLIMITr_CELLMAXRESUMELIMITf_SET(r,f) (r).holcoscellmaxlimit[0]=(((r).holcoscellmaxlimit[0] & ~((uint32)0x3fff << 14)) | ((((uint32)f) & 0x3fff) << 14))

/*
 * These macros can be used to access HOLCOSCELLMAXLIMIT.
 */
#define WRITE_HOLCOSCELLMAXLIMITr(u,p, cos,r) bcm5607x_reg_set(u, R_HOLCOSCELLMAXLIMIT(cos,p), (r._holcoscellmaxlimit))
#define READ_HOLCOSCELLMAXLIMITr(u,p, cos,r) bcm5607x_reg_get(u,R_HOLCOSCELLMAXLIMIT(cos,p),&(r._holcoscellmaxlimit))

/*******************************************************************************
 * End of 'HOLCOSCELLMAXLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  HOLCOSCELLMAXLIMIT_QGROUP
 * BLOCKS:   MMU
 * DESC:     per-QG HOL cell max threshold
 * SIZE:     32
 * FIELDS:
 *     CELLMAXLIMIT     A queue can be put into HOL drop state when the HOL cell count reaches (>=) the value set in this register.
 *     CELLMAXRESUMELIMIT A queue can be brought out of HOL drop state due to reaching the max cell limit, when the HOL cell count goes below (<) the value set in this register.
 */
#define HOLCOSCELLMAXLIMIT_QGROUPr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSCELLMAXLIMIT_QGROUP.
 */
typedef union HOLCOSCELLMAXLIMIT_QGROUPr_s {
	uint32 v[1];
	uint32 holcoscellmaxlimit_qgroup[1];
	uint32 _holcoscellmaxlimit_qgroup;
} HOLCOSCELLMAXLIMIT_QGROUPr_t;

#define HOLCOSCELLMAXLIMIT_QGROUPr_CLR(r) (r).holcoscellmaxlimit_qgroup[0] = 0
#define HOLCOSCELLMAXLIMIT_QGROUPr_SET(r,d) (r).holcoscellmaxlimit_qgroup[0] = d
#define HOLCOSCELLMAXLIMIT_QGROUPr_GET(r) (r).holcoscellmaxlimit_qgroup[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSCELLMAXLIMIT_QGROUPr_CELLMAXLIMITf_GET(r) (((r).holcoscellmaxlimit_qgroup[0]) & 0x3fff)
#define HOLCOSCELLMAXLIMIT_QGROUPr_CELLMAXLIMITf_SET(r,f) (r).holcoscellmaxlimit_qgroup[0]=(((r).holcoscellmaxlimit_qgroup[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define HOLCOSCELLMAXLIMIT_QGROUPr_CELLMAXRESUMELIMITf_GET(r) ((((r).holcoscellmaxlimit_qgroup[0]) >> 14) & 0x3fff)
#define HOLCOSCELLMAXLIMIT_QGROUPr_CELLMAXRESUMELIMITf_SET(r,f) (r).holcoscellmaxlimit_qgroup[0]=(((r).holcoscellmaxlimit_qgroup[0] & ~((uint32)0x3fff << 14)) | ((((uint32)f) & 0x3fff) << 14))

/*
 * These macros can be used to access HOLCOSCELLMAXLIMIT_QGROUP.
 */
#define WRITE_HOLCOSCELLMAXLIMIT_QGROUPr(u,p, i,r) bcm5607x_reg_set(u, R_HOLCOSCELLMAXLIMIT_QGROUP(i,p), (r._holcoscellmaxlimit_qgroup))
#define READ_HOLCOSCELLMAXLIMIT_QGROUPr(u,p, i,r) bcm5607x_reg_get(u,R_HOLCOSCELLMAXLIMIT_QGROUP(i,p),&(r._holcoscellmaxlimit_qgroup))

/*******************************************************************************
 * End of 'HOLCOSCELLMAXLIMIT_QGROUPr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  HOLCOSCELLMAXLIMIT_QLAYER
 * BLOCKS:   MMU
 * DESC:     per-Q HOL cell max threshold
 * SIZE:     32
 * FIELDS:
 *     CELLMAXLIMIT     A queue can be put into HOL drop state when the HOL cell count reaches (>=) the value set in this register.Note:This register only can be changed when frame buffer is empty and all traffic stops.
 *     CELLMAXRESUMELIMIT A queue can be brought out of HOL drop state due to reaching the max cell limit, when the HOL cell count goes below (<) the value set in this register.
 */
#define HOLCOSCELLMAXLIMIT_QLAYERr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSCELLMAXLIMIT_QLAYER.
 */
typedef union HOLCOSCELLMAXLIMIT_QLAYERr_s {
	uint32 v[1];
	uint32 holcoscellmaxlimit_qlayer[1];
	uint32 _holcoscellmaxlimit_qlayer;
} HOLCOSCELLMAXLIMIT_QLAYERr_t;

#define HOLCOSCELLMAXLIMIT_QLAYERr_CLR(r) (r).holcoscellmaxlimit_qlayer[0] = 0
#define HOLCOSCELLMAXLIMIT_QLAYERr_SET(r,d) (r).holcoscellmaxlimit_qlayer[0] = d
#define HOLCOSCELLMAXLIMIT_QLAYERr_GET(r) (r).holcoscellmaxlimit_qlayer[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSCELLMAXLIMIT_QLAYERr_CELLMAXLIMITf_GET(r) (((r).holcoscellmaxlimit_qlayer[0]) & 0x3fff)
#define HOLCOSCELLMAXLIMIT_QLAYERr_CELLMAXLIMITf_SET(r,f) (r).holcoscellmaxlimit_qlayer[0]=(((r).holcoscellmaxlimit_qlayer[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define HOLCOSCELLMAXLIMIT_QLAYERr_CELLMAXRESUMELIMITf_GET(r) ((((r).holcoscellmaxlimit_qlayer[0]) >> 14) & 0x3fff)
#define HOLCOSCELLMAXLIMIT_QLAYERr_CELLMAXRESUMELIMITf_SET(r,f) (r).holcoscellmaxlimit_qlayer[0]=(((r).holcoscellmaxlimit_qlayer[0] & ~((uint32)0x3fff << 14)) | ((((uint32)f) & 0x3fff) << 14))

/*
 * These macros can be used to access HOLCOSCELLMAXLIMIT_QLAYER.
 */
#define WRITE_HOLCOSCELLMAXLIMIT_QLAYERr(u,p, cos,r) bcm5607x_reg_set(u, R_HOLCOSCELLMAXLIMIT_QLAYER(cos,p), (r._holcoscellmaxlimit_qlayer))
#define READ_HOLCOSCELLMAXLIMIT_QLAYERr(u,p, cos,r) bcm5607x_reg_get(u,R_HOLCOSCELLMAXLIMIT_QLAYER(cos,p),&(r._holcoscellmaxlimit_qlayer))

/*******************************************************************************
 * End of 'HOLCOSCELLMAXLIMIT_QLAYERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  HOLCOSMINXQCNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     HOLCOSMINXQCNT   PKT THD.Number of reserved XQ packet pointers for a COS/egress port. This register is required to avoid starvation. If other COS queues have consumed all the dynamic XQ pointers, traffic should keep flowing for this COS.HOLCOSPKTSETLIMIT.PKTSETLIMIT must be greater than the HOLCOSMINXQCNT in order to make use of the dynamic XQ pointers. The value in this register should be greater than the MISCCONFIG.SKIDMARKER.Note:This register only can be changed when frame buffer is empty and all traffic stops.
 */
#define HOLCOSMINXQCNTr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSMINXQCNT.
 */
typedef union HOLCOSMINXQCNTr_s {
	uint32 v[1];
	uint32 holcosminxqcnt[1];
	uint32 _holcosminxqcnt;
} HOLCOSMINXQCNTr_t;

#define HOLCOSMINXQCNTr_CLR(r) (r).holcosminxqcnt[0] = 0
#define HOLCOSMINXQCNTr_SET(r,d) (r).holcosminxqcnt[0] = d
#define HOLCOSMINXQCNTr_GET(r) (r).holcosminxqcnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSMINXQCNTr_HOLCOSMINXQCNTf_GET(r) (((r).holcosminxqcnt[0]) & 0x1fff)
#define HOLCOSMINXQCNTr_HOLCOSMINXQCNTf_SET(r,f) (r).holcosminxqcnt[0]=(((r).holcosminxqcnt[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access HOLCOSMINXQCNT.
 */
#define WRITE_HOLCOSMINXQCNTr(u,p, cos,r) bcm5607x_reg_set(u, R_HOLCOSMINXQCNT(cos,p), (r._holcosminxqcnt))
#define READ_HOLCOSMINXQCNTr(u,p, cos,r) bcm5607x_reg_get(u,R_HOLCOSMINXQCNT(cos,p),&(r._holcosminxqcnt))

/*******************************************************************************
 * End of 'HOLCOSMINXQCNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  HOLCOSMINXQCNT_QLAYER
 * BLOCKS:   MMU
 * DESC:     per-Q HOL packet min guarantee threshold
 * SIZE:     32
 * FIELDS:
 *     HOLCOSMINXQCNT   Number of reserved XQ packet pointers for a COS/egress port. This register is required to avoid starvation. If other COS queues have consumed all the dynamic XQ pointers, traffic should keep flowing for this COS.HOLCOSPKTSETLIMIT.PKTSETLIMIT must be greater than the HOLCOSMINXQCNT in order to make use of the dynamic XQ pointers. The value in this register should be greater than the MISCCONFIG.SKIDMARKER.Note:This register only can be changed when frame buffer is empty and all traffic stops.
 */
#define HOLCOSMINXQCNT_QLAYERr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSMINXQCNT_QLAYER.
 */
typedef union HOLCOSMINXQCNT_QLAYERr_s {
	uint32 v[1];
	uint32 holcosminxqcnt_qlayer[1];
	uint32 _holcosminxqcnt_qlayer;
} HOLCOSMINXQCNT_QLAYERr_t;

#define HOLCOSMINXQCNT_QLAYERr_CLR(r) (r).holcosminxqcnt_qlayer[0] = 0
#define HOLCOSMINXQCNT_QLAYERr_SET(r,d) (r).holcosminxqcnt_qlayer[0] = d
#define HOLCOSMINXQCNT_QLAYERr_GET(r) (r).holcosminxqcnt_qlayer[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSMINXQCNT_QLAYERr_HOLCOSMINXQCNTf_GET(r) (((r).holcosminxqcnt_qlayer[0]) & 0x1fff)
#define HOLCOSMINXQCNT_QLAYERr_HOLCOSMINXQCNTf_SET(r,f) (r).holcosminxqcnt_qlayer[0]=(((r).holcosminxqcnt_qlayer[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access HOLCOSMINXQCNT_QLAYER.
 */
#define WRITE_HOLCOSMINXQCNT_QLAYERr(u,p, cos,r) bcm5607x_reg_set(u, R_HOLCOSMINXQCNT_QLAYER(cos,p), (r._holcosminxqcnt_qlayer))
#define READ_HOLCOSMINXQCNT_QLAYERr(u,p, cos,r) bcm5607x_reg_get(u,R_HOLCOSMINXQCNT_QLAYER(cos,p),&(r._holcosminxqcnt_qlayer))

/*******************************************************************************
 * End of 'HOLCOSMINXQCNT_QLAYERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  HOLCOSPKTRESETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTRESETLIMIT    PKT THD.HOL for a COSn will be de-activated when packet count for COSn is smallerthan value in this register. Default value is half of packet set limit
 */
#define HOLCOSPKTRESETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSPKTRESETLIMIT.
 */
typedef union HOLCOSPKTRESETLIMITr_s {
	uint32 v[1];
	uint32 holcospktresetlimit[1];
	uint32 _holcospktresetlimit;
} HOLCOSPKTRESETLIMITr_t;

#define HOLCOSPKTRESETLIMITr_CLR(r) (r).holcospktresetlimit[0] = 0
#define HOLCOSPKTRESETLIMITr_SET(r,d) (r).holcospktresetlimit[0] = d
#define HOLCOSPKTRESETLIMITr_GET(r) (r).holcospktresetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSPKTRESETLIMITr_PKTRESETLIMITf_GET(r) (((r).holcospktresetlimit[0]) & 0x1fff)
#define HOLCOSPKTRESETLIMITr_PKTRESETLIMITf_SET(r,f) (r).holcospktresetlimit[0]=(((r).holcospktresetlimit[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access HOLCOSPKTRESETLIMIT.
 */
#define WRITE_HOLCOSPKTRESETLIMITr(u,p, cos,r) bcm5607x_reg_set(u, R_HOLCOSPKTRESETLIMIT(cos,p), (r._holcospktresetlimit))
#define READ_HOLCOSPKTRESETLIMITr(u,p, cos,r) bcm5607x_reg_get(u,R_HOLCOSPKTRESETLIMIT(cos,p),&(r._holcospktresetlimit))

/*******************************************************************************
 * End of 'HOLCOSPKTRESETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  HOLCOSPKTRESETLIMIT_QGROUP
 * BLOCKS:   MMU
 * DESC:     per-QG HOL packet reset threshold
 * SIZE:     32
 * FIELDS:
 *     PKTRESETLIMIT    HOL for a COSn will be de-activated when packet count for COSn is smallerthan value in this register. Default value is half of packet set limit
 */
#define HOLCOSPKTRESETLIMIT_QGROUPr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSPKTRESETLIMIT_QGROUP.
 */
typedef union HOLCOSPKTRESETLIMIT_QGROUPr_s {
	uint32 v[1];
	uint32 holcospktresetlimit_qgroup[1];
	uint32 _holcospktresetlimit_qgroup;
} HOLCOSPKTRESETLIMIT_QGROUPr_t;

#define HOLCOSPKTRESETLIMIT_QGROUPr_CLR(r) (r).holcospktresetlimit_qgroup[0] = 0
#define HOLCOSPKTRESETLIMIT_QGROUPr_SET(r,d) (r).holcospktresetlimit_qgroup[0] = d
#define HOLCOSPKTRESETLIMIT_QGROUPr_GET(r) (r).holcospktresetlimit_qgroup[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSPKTRESETLIMIT_QGROUPr_PKTRESETLIMITf_GET(r) (((r).holcospktresetlimit_qgroup[0]) & 0x1fff)
#define HOLCOSPKTRESETLIMIT_QGROUPr_PKTRESETLIMITf_SET(r,f) (r).holcospktresetlimit_qgroup[0]=(((r).holcospktresetlimit_qgroup[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access HOLCOSPKTRESETLIMIT_QGROUP.
 */
#define WRITE_HOLCOSPKTRESETLIMIT_QGROUPr(u,p, i,r) bcm5607x_reg_set(u, R_HOLCOSPKTRESETLIMIT_QGROUP(i,p), (r._holcospktresetlimit_qgroup))
#define READ_HOLCOSPKTRESETLIMIT_QGROUPr(u,p, i,r) bcm5607x_reg_get(u,R_HOLCOSPKTRESETLIMIT_QGROUP(i,p),&(r._holcospktresetlimit_qgroup))

/*******************************************************************************
 * End of 'HOLCOSPKTRESETLIMIT_QGROUPr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  HOLCOSPKTRESETLIMIT_QLAYER
 * BLOCKS:   MMU
 * DESC:     per-Q HOL packet reset threshold
 * SIZE:     32
 * FIELDS:
 *     PKTRESETLIMIT    HOL for a COSn will be de-activated when packet count for COSn is smallerthan value in this register. Default value is half of packet set limit
 */
#define HOLCOSPKTRESETLIMIT_QLAYERr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSPKTRESETLIMIT_QLAYER.
 */
typedef union HOLCOSPKTRESETLIMIT_QLAYERr_s {
	uint32 v[1];
	uint32 holcospktresetlimit_qlayer[1];
	uint32 _holcospktresetlimit_qlayer;
} HOLCOSPKTRESETLIMIT_QLAYERr_t;

#define HOLCOSPKTRESETLIMIT_QLAYERr_CLR(r) (r).holcospktresetlimit_qlayer[0] = 0
#define HOLCOSPKTRESETLIMIT_QLAYERr_SET(r,d) (r).holcospktresetlimit_qlayer[0] = d
#define HOLCOSPKTRESETLIMIT_QLAYERr_GET(r) (r).holcospktresetlimit_qlayer[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSPKTRESETLIMIT_QLAYERr_PKTRESETLIMITf_GET(r) (((r).holcospktresetlimit_qlayer[0]) & 0x1fff)
#define HOLCOSPKTRESETLIMIT_QLAYERr_PKTRESETLIMITf_SET(r,f) (r).holcospktresetlimit_qlayer[0]=(((r).holcospktresetlimit_qlayer[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access HOLCOSPKTRESETLIMIT_QLAYER.
 */
#define WRITE_HOLCOSPKTRESETLIMIT_QLAYERr(u,p, cos,r) bcm5607x_reg_set(u, R_HOLCOSPKTRESETLIMIT_QLAYER(cos,p), (r._holcospktresetlimit_qlayer))
#define READ_HOLCOSPKTRESETLIMIT_QLAYERr(u,p, cos,r) bcm5607x_reg_get(u,R_HOLCOSPKTRESETLIMIT_QLAYER(cos,p),&(r._holcospktresetlimit_qlayer))

/*******************************************************************************
 * End of 'HOLCOSPKTRESETLIMIT_QLAYERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  HOLCOSPKTSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      PKT THD.HOL for a COSn will be activated when packet count for COSn is greater than or equal to the value in this register. Note: Do not modify this register when traffic is active 
 */
#define HOLCOSPKTSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSPKTSETLIMIT.
 */
typedef union HOLCOSPKTSETLIMITr_s {
	uint32 v[1];
	uint32 holcospktsetlimit[1];
	uint32 _holcospktsetlimit;
} HOLCOSPKTSETLIMITr_t;

#define HOLCOSPKTSETLIMITr_CLR(r) (r).holcospktsetlimit[0] = 0
#define HOLCOSPKTSETLIMITr_SET(r,d) (r).holcospktsetlimit[0] = d
#define HOLCOSPKTSETLIMITr_GET(r) (r).holcospktsetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSPKTSETLIMITr_PKTSETLIMITf_GET(r) (((r).holcospktsetlimit[0]) & 0x1fff)
#define HOLCOSPKTSETLIMITr_PKTSETLIMITf_SET(r,f) (r).holcospktsetlimit[0]=(((r).holcospktsetlimit[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access HOLCOSPKTSETLIMIT.
 */
#define WRITE_HOLCOSPKTSETLIMITr(u,p, cos,r) bcm5607x_reg_set(u, R_HOLCOSPKTSETLIMIT(cos,p), (r._holcospktsetlimit))
#define READ_HOLCOSPKTSETLIMITr(u,p, cos,r) bcm5607x_reg_get(u,R_HOLCOSPKTSETLIMIT(cos,p),&(r._holcospktsetlimit))

/*******************************************************************************
 * End of 'HOLCOSPKTSETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  HOLCOSPKTSETLIMIT_QGROUP
 * BLOCKS:   MMU
 * DESC:     per-QG HOL packet set threshold
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      HOL for a COSn will be activated when packet count for COSn is greater than or equal to the value in this register. Note: Do not modify this register when traffic is active 
 */
#define HOLCOSPKTSETLIMIT_QGROUPr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSPKTSETLIMIT_QGROUP.
 */
typedef union HOLCOSPKTSETLIMIT_QGROUPr_s {
	uint32 v[1];
	uint32 holcospktsetlimit_qgroup[1];
	uint32 _holcospktsetlimit_qgroup;
} HOLCOSPKTSETLIMIT_QGROUPr_t;

#define HOLCOSPKTSETLIMIT_QGROUPr_CLR(r) (r).holcospktsetlimit_qgroup[0] = 0
#define HOLCOSPKTSETLIMIT_QGROUPr_SET(r,d) (r).holcospktsetlimit_qgroup[0] = d
#define HOLCOSPKTSETLIMIT_QGROUPr_GET(r) (r).holcospktsetlimit_qgroup[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSPKTSETLIMIT_QGROUPr_PKTSETLIMITf_GET(r) (((r).holcospktsetlimit_qgroup[0]) & 0x1fff)
#define HOLCOSPKTSETLIMIT_QGROUPr_PKTSETLIMITf_SET(r,f) (r).holcospktsetlimit_qgroup[0]=(((r).holcospktsetlimit_qgroup[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access HOLCOSPKTSETLIMIT_QGROUP.
 */
#define WRITE_HOLCOSPKTSETLIMIT_QGROUPr(u,p, i,r) bcm5607x_reg_set(u, R_HOLCOSPKTSETLIMIT_QGROUP(i,p), (r._holcospktsetlimit_qgroup))
#define READ_HOLCOSPKTSETLIMIT_QGROUPr(u,p, i,r) bcm5607x_reg_get(u,R_HOLCOSPKTSETLIMIT_QGROUP(i,p),&(r._holcospktsetlimit_qgroup))

/*******************************************************************************
 * End of 'HOLCOSPKTSETLIMIT_QGROUPr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  HOLCOSPKTSETLIMIT_QLAYER
 * BLOCKS:   MMU
 * DESC:     per-Q HOL packet set threshold
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      HOL for a COSn will be activated when packet count for COSn is greater than or equal to the value in this register. Note: Do not modify this register when traffic is active 
 */
#define HOLCOSPKTSETLIMIT_QLAYERr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSPKTSETLIMIT_QLAYER.
 */
typedef union HOLCOSPKTSETLIMIT_QLAYERr_s {
	uint32 v[1];
	uint32 holcospktsetlimit_qlayer[1];
	uint32 _holcospktsetlimit_qlayer;
} HOLCOSPKTSETLIMIT_QLAYERr_t;

#define HOLCOSPKTSETLIMIT_QLAYERr_CLR(r) (r).holcospktsetlimit_qlayer[0] = 0
#define HOLCOSPKTSETLIMIT_QLAYERr_SET(r,d) (r).holcospktsetlimit_qlayer[0] = d
#define HOLCOSPKTSETLIMIT_QLAYERr_GET(r) (r).holcospktsetlimit_qlayer[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSPKTSETLIMIT_QLAYERr_PKTSETLIMITf_GET(r) (((r).holcospktsetlimit_qlayer[0]) & 0x1fff)
#define HOLCOSPKTSETLIMIT_QLAYERr_PKTSETLIMITf_SET(r,f) (r).holcospktsetlimit_qlayer[0]=(((r).holcospktsetlimit_qlayer[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))

/*
 * These macros can be used to access HOLCOSPKTSETLIMIT_QLAYER.
 */
#define WRITE_HOLCOSPKTSETLIMIT_QLAYERr(u,p, cos,r) bcm5607x_reg_set(u, R_HOLCOSPKTSETLIMIT_QLAYER(cos,p), (r._holcospktsetlimit_qlayer))
#define READ_HOLCOSPKTSETLIMIT_QLAYERr(u,p, cos,r) bcm5607x_reg_get(u,R_HOLCOSPKTSETLIMIT_QLAYER(cos,p),&(r._holcospktsetlimit_qlayer))

/*******************************************************************************
 * End of 'HOLCOSPKTSETLIMIT_QLAYERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IARB_TDM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     TDM TABLE configuration
 * SIZE:     32
 * FIELDS:
 *     DISABLE          Disable TDM, set to 1 when changing tdm_mode or slot mapping
 *     TDM_WRAP_PTR     Indicates max valid entry in the TDM TABLE
 *     IDLE_PORT_NUM_SEL If 1, drives logic port 127 as IDLE port number on ipad bus, else drives logic port 127.
 */
#define IARB_TDM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IARB_TDM_CONTROL.
 */
typedef union IARB_TDM_CONTROLr_s {
	uint32 v[1];
	uint32 iarb_tdm_control[1];
	uint32 _iarb_tdm_control;
} IARB_TDM_CONTROLr_t;

#define IARB_TDM_CONTROLr_CLR(r) (r).iarb_tdm_control[0] = 0
#define IARB_TDM_CONTROLr_SET(r,d) (r).iarb_tdm_control[0] = d
#define IARB_TDM_CONTROLr_GET(r) (r).iarb_tdm_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define IARB_TDM_CONTROLr_DISABLEf_GET(r) (((r).iarb_tdm_control[0]) & 0x1)
#define IARB_TDM_CONTROLr_DISABLEf_SET(r,f) (r).iarb_tdm_control[0]=(((r).iarb_tdm_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define IARB_TDM_CONTROLr_TDM_WRAP_PTRf_GET(r) ((((r).iarb_tdm_control[0]) >> 1) & 0x1ff)
#define IARB_TDM_CONTROLr_TDM_WRAP_PTRf_SET(r,f) (r).iarb_tdm_control[0]=(((r).iarb_tdm_control[0] & ~((uint32)0x1ff << 1)) | ((((uint32)f) & 0x1ff) << 1))
#define IARB_TDM_CONTROLr_IDLE_PORT_NUM_SELf_GET(r) ((((r).iarb_tdm_control[0]) >> 10) & 0x1)
#define IARB_TDM_CONTROLr_IDLE_PORT_NUM_SELf_SET(r,f) (r).iarb_tdm_control[0]=(((r).iarb_tdm_control[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))

/*
 * These macros can be used to access IARB_TDM_CONTROL.
 */
#define WRITE_IARB_TDM_CONTROLr(u,r) bcm5607x_reg_set(u,R_IARB_TDM_CONTROL,(r._iarb_tdm_control))
#define READ_IARB_TDM_CONTROLr(u,r) bcm5607x_reg_get(u,R_IARB_TDM_CONTROL,&(r._iarb_tdm_control))

/*******************************************************************************
 * End of 'IARB_TDM_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  IARB_TDM_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Arbiter TDM Table. Must be programmed with the values specified in SDK per index as part of initialization before traffic is enabled 
 * SIZE:     7
 * FIELDS:
 *     PORT_NUM         Indicates port number id. Valid values are 0-101. Value 127 means IDLE slot. Value as programmed in SDK.
 */
#define IARB_TDM_TABLEm_MIN 0
#define IARB_TDM_TABLEm_MAX 511
#define IARB_TDM_TABLEm_CMAX(u) 511
#define IARB_TDM_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program IARB_TDM_TABLE.
 */
typedef union IARB_TDM_TABLEm_s {
	uint32 v[1];
	uint32 iarb_tdm_table[1];
	uint32 _iarb_tdm_table;
} IARB_TDM_TABLEm_t;

#define IARB_TDM_TABLEm_CLR(r) (r).iarb_tdm_table[0] = 0
#define IARB_TDM_TABLEm_SET(r,d) (r).iarb_tdm_table[0] = d
#define IARB_TDM_TABLEm_GET(r) (r).iarb_tdm_table[0]

/*
 * These macros can be used to access individual fields.
 */
#define IARB_TDM_TABLEm_PORT_NUMf_GET(r) (((r).iarb_tdm_table[0]) & 0x7f)
#define IARB_TDM_TABLEm_PORT_NUMf_SET(r,f) (r).iarb_tdm_table[0]=(((r).iarb_tdm_table[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))

/*
 * These macros can be used to access IARB_TDM_TABLE.
 */
#define WRITE_IARB_TDM_TABLEm(u,i,r) bcm5607x_mem_set(u, M_IARB_TDM_TABLE(i), &(r._iarb_tdm_table), 1)
#define READ_IARB_TDM_TABLEm(u,i,r) bcm5607x_mem_get(u, M_IARB_TDM_TABLE(i), &(r._iarb_tdm_table), 1)

/*******************************************************************************
 * End of 'IARB_TDM_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IBPPKTSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      PKT THD.Ingress Back Pressure thresholdThis is the number of packets an ingress port (IBPPKTCOUNT) may have in the system before entering Back Pressure state.(criterion: IBPPKTCOUNT>=PKTSETLIMIT)This will work at both PAUSE mode and PFC mode.Note: Do not modify this register when traffic is active 
 *     RESETLIMITSEL    PKT THD.IBP Packet Reset Threshold SelectWhen Back pressure status is set, packet counts have to fall below Reset Threshold in order to clear BKP status. (criterion: IBPPKTCOUNT<selected threshold))0: 75.0% of IBP Packet Set Limit.1: 50.0% of IBP Packet Set Limit.  2: 25.0% of IBP Packet Set Limit.  3: 100% of IBP Packet Set Limit.  This will work at both PAUSE mode and PFC mode.Note: Do not modify this register when traffic is active 
 */
#define IBPPKTSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program IBPPKTSETLIMIT.
 */
typedef union IBPPKTSETLIMITr_s {
	uint32 v[1];
	uint32 ibppktsetlimit[1];
	uint32 _ibppktsetlimit;
} IBPPKTSETLIMITr_t;

#define IBPPKTSETLIMITr_CLR(r) (r).ibppktsetlimit[0] = 0
#define IBPPKTSETLIMITr_SET(r,d) (r).ibppktsetlimit[0] = d
#define IBPPKTSETLIMITr_GET(r) (r).ibppktsetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define IBPPKTSETLIMITr_PKTSETLIMITf_GET(r) (((r).ibppktsetlimit[0]) & 0x3fff)
#define IBPPKTSETLIMITr_PKTSETLIMITf_SET(r,f) (r).ibppktsetlimit[0]=(((r).ibppktsetlimit[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define IBPPKTSETLIMITr_RESETLIMITSELf_GET(r) ((((r).ibppktsetlimit[0]) >> 14) & 0x3)
#define IBPPKTSETLIMITr_RESETLIMITSELf_SET(r,f) (r).ibppktsetlimit[0]=(((r).ibppktsetlimit[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))

/*
 * These macros can be used to access IBPPKTSETLIMIT.
 */
#define WRITE_IBPPKTSETLIMITr(u,p,r) bcm5607x_reg_set(u,R_IBPPKTSETLIMIT(p),(r._ibppktsetlimit))
#define READ_IBPPKTSETLIMITr(u,p,r) bcm5607x_reg_get(u,R_IBPPKTSETLIMIT(p),&(r._ibppktsetlimit))

/*******************************************************************************
 * End of 'IBPPKTSETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  IFP_REDIRECTION_PROFILE
 * BLOCKS:   IPIPE
 * DESC:     This table is used to specify redirect information for a redirect action that came from the IFP. The index to this table is specified by the FP_POLICY_TABLE.REDIRECTION field
 * SIZE:     74
 * FIELDS:
 *     BITMAP           ContentAware Engine redirection port bitmap. May be used for either port_bitmap or l3_bitmap, depending on the ContentAware Engine action.
 *     BITMAP_LO        Overlay bitmap for ports
 *     HIGIG_TRUNK_OVERRIDE When ContentAware Engine redirection is to a broadcast outgoing VLAN, then this field gives the HiGig trunk override value.
 */
#define IFP_REDIRECTION_PROFILEm_MIN 0
#define IFP_REDIRECTION_PROFILEm_MAX 255
#define IFP_REDIRECTION_PROFILEm_CMAX(u) 255
#define IFP_REDIRECTION_PROFILEm_SIZE 10

/*
 * This structure should be used to declare and program IFP_REDIRECTION_PROFILE.
 */
typedef union IFP_REDIRECTION_PROFILEm_s {
	uint32 v[3];
	uint32 ifp_redirection_profile[3];
	uint32 _ifp_redirection_profile;
} IFP_REDIRECTION_PROFILEm_t;

#define IFP_REDIRECTION_PROFILEm_CLR(r) sal_memset(&((r)._ifp_redirection_profile), 0, sizeof(IFP_REDIRECTION_PROFILEm_t))
#define IFP_REDIRECTION_PROFILEm_SET(r,i,d) (r).ifp_redirection_profile[i] = d
#define IFP_REDIRECTION_PROFILEm_GET(r,i) (r).ifp_redirection_profile[i]

/*
 * These macros can be used to access individual fields.
 */
#define IFP_REDIRECTION_PROFILEm_BITMAPf_GET(r,a) field_get((r).ifp_redirection_profile,0,65,a)
#define IFP_REDIRECTION_PROFILEm_BITMAPf_SET(r,a) field_set((r).ifp_redirection_profile,0,65,a)
#define IFP_REDIRECTION_PROFILEm_BITMAP_LOf_GET(r,a) field_get((r).ifp_redirection_profile,0,65,a)
#define IFP_REDIRECTION_PROFILEm_BITMAP_LOf_SET(r,a) field_set((r).ifp_redirection_profile,0,65,a)
#define IFP_REDIRECTION_PROFILEm_HIGIG_TRUNK_OVERRIDEf_GET(r) ((((r).ifp_redirection_profile[2]) >> 2) & 0xff)
#define IFP_REDIRECTION_PROFILEm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).ifp_redirection_profile[2]=(((r).ifp_redirection_profile[2] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))

/*
 * These macros can be used to access IFP_REDIRECTION_PROFILE.
 */
#define WRITE_IFP_REDIRECTION_PROFILEm(u,i,r) bcm5607x_mem_set(u, M_IFP_REDIRECTION_PROFILE(i), &(r._ifp_redirection_profile), 3)
#define READ_IFP_REDIRECTION_PROFILEm(u,i,r) bcm5607x_mem_get(u, M_IFP_REDIRECTION_PROFILE(i), &(r._ifp_redirection_profile), 3)

/*******************************************************************************
 * End of 'IFP_REDIRECTION_PROFILEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IGMP_MLD_PKT_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     IGMP/MLD Control Register
 * SIZE:     32
 * FIELDS:
 *     IPV6_MC_ROUTER_ADV_PKT_TO_CPU Copy Multicast Router Advertisement/Solicitation/Termination packets (ICMP types 151, 152, 153) to CPU if set to 1.
 *     IPV6_MC_ROUTER_ADV_PKT_FWD_ACTION Forwarding of Multicast Router Advertisement/Solicitation/Termination  packets (ICMP types 151, 152, 153) as below:        00 - Forward based on MAC-DA01 - Drop the packet10 - Flood the packet to the VLAN members11 - Reserved
 *     IPV4_MC_ROUTER_ADV_PKT_TO_CPU Copy Multicast Router Advertisement/Solicitation/Termination packets (ICMP types 151, 152, 153) to CPU if set to 1
 *     IPV4_MC_ROUTER_ADV_PKT_FWD_ACTION Forwarding of Multicast Router Advertisement/Solicitation/Termination  packets (ICMP types 151, 152, 153):        00 - Forward based on MAC-DA01 - Drop the packet10 - Flood the packet to the VLAN members11 - Reserved.
 *     IPV6_RESVD_MC_PKT_TO_CPU Copy IPv6 reserved multicast packets (DIP = ff0X:0:0:0:0:0:0:0) to CPU if set to 1
 *     IPV6_RESVD_MC_PKT_FWD_ACTION Forwarding of IPv6 reserved multicast packets (DIP = ff0X:0:0:0:0:0:0:0) as shown below:       00 - Forward based on MAC-DA       01 - Drop the packet       10 - Flood the packet to the VLAN members       11 - Reserved.
 *     IPV4_RESVD_MC_PKT_TO_CPU Copy IPv4 reserved multicast packets (DIP = 224.0.0.X) to CPU if set to 1.
 *     IPV4_RESVD_MC_PKT_FWD_ACTION Forwarding of IPv4 reserved multicast packets (DIP = 224.0.0.X) as shown below:00 - Forward based on MAC-DA01 - Drop the packet10 - Flood the packet to the VLAN members11 - Reserved.
 *     MLD_QUERY_TO_CPU Copy MLD Queries to the CPU if set to 1.
 *     MLD_QUERY_FWD_ACTION Forwarding of MLD Query messages as shown below:       00 - Forward based on MAC-DA01 - Drop the packet10 - Flood the packet to the VLAN members11 - Reserved
 *     MLD_REP_DONE_TO_CPU Copy MLD Report (v1, v2,)/Done (v1) msgs to the CPU if set to 1.
 *     MLD_REP_DONE_FWD_ACTION Forwarding of MLD Report(v1,v2,)/Done(v1) messages as shown below: 00 - Forward based on MAC-DA01 - Drop the packet10 - Flood the packet to the VLAN members11 - Reserved
 *     IGMP_UNKNOWN_MSG_TO_CPU Copy the unknown IGMP msg to CPU if set to 1.
 *     IGMP_UNKNOWN_MSG_FWD_ACTION Forwarding of unknown IGMP messages (messages that are not recognized as Query/Report/Leave messages) as shown below:       00 - Forward based on MAC-DA       01 - Drop the packet       10 - Flood the packet to the VLAN members       11 - Reserved
 *     IGMP_QUERY_TO_CPU Copy IGMP Query to the CPU if set to 1
 *     IGMP_QUERY_FWD_ACTION Forwarding of IGMP Query messages as shown below:       00 - Forward based on MAC-DA01 - Drop the packet.10 - Flood the packet to the VLAN members11 - Reserved.
 *     IGMP_REP_LEAVE_TO_CPU Copy IGMP Report (v1, v2, v3)/Leave (v2) msgs to the CPU if set to 1.
 *     IGMP_REP_LEAVE_FWD_ACTION Forwarding of IGMP Report(v1,v2,v3)/Leave(v2) messages as shown below:       00 - Forward based on MAC-DA01 - Drop the packet.10 - Flood the packet to the VLAN members11 - Reserved.
 *     PFM_RULE_APPLY   When set to 1, PFM rules are applied to IGMP/MLD/RESERVED_MC packets when flooded to VLAN
 */
#define IGMP_MLD_PKT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IGMP_MLD_PKT_CONTROL.
 */
typedef union IGMP_MLD_PKT_CONTROLr_s {
	uint32 v[1];
	uint32 igmp_mld_pkt_control[1];
	uint32 _igmp_mld_pkt_control;
} IGMP_MLD_PKT_CONTROLr_t;

#define IGMP_MLD_PKT_CONTROLr_CLR(r) (r).igmp_mld_pkt_control[0] = 0
#define IGMP_MLD_PKT_CONTROLr_SET(r,d) (r).igmp_mld_pkt_control[0] = d
#define IGMP_MLD_PKT_CONTROLr_GET(r) (r).igmp_mld_pkt_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_GET(r) (((r).igmp_mld_pkt_control[0]) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 1) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 1)) | ((((uint32)f) & 0x3) << 1))
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 3) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 4) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 6) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 7) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 9) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 10) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 12) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 13) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 15) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 16) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 18) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 19) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 21) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 22) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 24) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 25) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 25)) | ((((uint32)f) & 0x3) << 25))
#define IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 27) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))

/*
 * These macros can be used to access IGMP_MLD_PKT_CONTROL.
 */
#define WRITE_IGMP_MLD_PKT_CONTROLr(u,p,r) bcm5607x_reg_set(u,R_IGMP_MLD_PKT_CONTROL(p),(r._igmp_mld_pkt_control))
#define READ_IGMP_MLD_PKT_CONTROLr(u,p,r) bcm5607x_reg_get(u,R_IGMP_MLD_PKT_CONTROL(p),&(r._igmp_mld_pkt_control))

/*******************************************************************************
 * End of 'IGMP_MLD_PKT_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IING_EGRMSKBMAP_HI
 * BLOCKS:   IPIPE
 * DESC:     Ingress Block Mask, FeatureSpecific-Ethernet: HIGH BITs
 * SIZE:     64
 * FIELDS:
 *     OVER_LO          Used for whole regsiter default value
 *     BITMAP           Bitmap of ports to be blocked. 0=allow-through, 1=block. Note: If any bit in this register belongs to a member of a trunk group (either GE/HIGIG), then in order to function correctly, all bits of that trunk group should be disabled here as well.
 *     BITMAP_LO        Overlay bitmap
 *     BLK_BITMAP       Overlay bitmap
 *     RESERVED         Reserved.
 *     OVER_HI          Used for whole regsiter default value
 */
#define IING_EGRMSKBMAP_HIr_SIZE 8

/*
 * This structure should be used to declare and program IING_EGRMSKBMAP_HI.
 */
typedef union IING_EGRMSKBMAP_HIr_s {
	uint32 v[2];
	uint32 iing_egrmskbmap_hi[2];
	uint32 _iing_egrmskbmap_hi;
} IING_EGRMSKBMAP_HIr_t;

#define IING_EGRMSKBMAP_HIr_CLR(r) sal_memset(&((r)._iing_egrmskbmap_hi), 0, sizeof(IING_EGRMSKBMAP_HIr_t))
#define IING_EGRMSKBMAP_HIr_SET(r,i,d) (r).iing_egrmskbmap_hi[i] = d
#define IING_EGRMSKBMAP_HIr_GET(r,i) (r).iing_egrmskbmap_hi[i]

/*
 * These macros can be used to access individual fields.
 */
#define IING_EGRMSKBMAP_HIr_OVER_LOf_GET(r) ((r).iing_egrmskbmap_hi[0])
#define IING_EGRMSKBMAP_HIr_OVER_LOf_SET(r,f) (r).iing_egrmskbmap_hi[0]=((uint32)f)
#define IING_EGRMSKBMAP_HIr_BITMAPf_GET(r) (((r).iing_egrmskbmap_hi[0]) & 0x3)
#define IING_EGRMSKBMAP_HIr_BITMAPf_SET(r,f) (r).iing_egrmskbmap_hi[0]=(((r).iing_egrmskbmap_hi[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define IING_EGRMSKBMAP_HIr_BITMAP_LOf_GET(r) (((r).iing_egrmskbmap_hi[0]) & 0x3)
#define IING_EGRMSKBMAP_HIr_BITMAP_LOf_SET(r,f) (r).iing_egrmskbmap_hi[0]=(((r).iing_egrmskbmap_hi[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define IING_EGRMSKBMAP_HIr_BLK_BITMAPf_GET(r) (((r).iing_egrmskbmap_hi[0]) & 0x3)
#define IING_EGRMSKBMAP_HIr_BLK_BITMAPf_SET(r,f) (r).iing_egrmskbmap_hi[0]=(((r).iing_egrmskbmap_hi[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define IING_EGRMSKBMAP_HIr_RESERVEDf_GET(r,a) field_get((r).iing_egrmskbmap_hi,2,63,a)
#define IING_EGRMSKBMAP_HIr_RESERVEDf_SET(r,a) field_set((r).iing_egrmskbmap_hi,2,63,a)
#define IING_EGRMSKBMAP_HIr_OVER_HIf_GET(r) ((r).iing_egrmskbmap_hi[1])
#define IING_EGRMSKBMAP_HIr_OVER_HIf_SET(r,f) (r).iing_egrmskbmap_hi[1]=((uint32)f)

/*
 * These macros can be used to access IING_EGRMSKBMAP_HI.
 */
#define WRITE_IING_EGRMSKBMAP_HIr(u,p,r) bcm5607x_reg64_set(u,R_IING_EGRMSKBMAP_HI(p),&(r._iing_egrmskbmap_hi),2)
#define READ_IING_EGRMSKBMAP_HIr(u,p,r) bcm5607x_reg64_get(u,R_IING_EGRMSKBMAP_HI(p),&(r._iing_egrmskbmap_hi),2)

/*******************************************************************************
 * End of 'IING_EGRMSKBMAP_HIr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IING_EGRMSKBMAP_LO
 * BLOCKS:   IPIPE
 * DESC:     Ingress Block Mask, FeatureSpecific-Ethernet: LOW BITs
 * SIZE:     64
 * FIELDS:
 *     BITMAP           Bitmap of ports to be blocked. 0=allow-through, 1=block. Note: If any bit in this register belongs to a member of a trunk group (either GE/HIGIG), then in order to function correctly, all bits of that trunk group should be disabled here as well.
 *     BITMAP_LO        Overlay bitmap
 *     BLK_BITMAP       Overlay bitmap
 *     OVER_LO          Used for whole regsiter default value
 *     OVER_HI          Used for whole regsiter default value
 */
#define IING_EGRMSKBMAP_LOr_SIZE 8

/*
 * This structure should be used to declare and program IING_EGRMSKBMAP_LO.
 */
typedef union IING_EGRMSKBMAP_LOr_s {
	uint32 v[2];
	uint32 iing_egrmskbmap_lo[2];
	uint32 _iing_egrmskbmap_lo;
} IING_EGRMSKBMAP_LOr_t;

#define IING_EGRMSKBMAP_LOr_CLR(r) sal_memset(&((r)._iing_egrmskbmap_lo), 0, sizeof(IING_EGRMSKBMAP_LOr_t))
#define IING_EGRMSKBMAP_LOr_SET(r,i,d) (r).iing_egrmskbmap_lo[i] = d
#define IING_EGRMSKBMAP_LOr_GET(r,i) (r).iing_egrmskbmap_lo[i]

/*
 * These macros can be used to access individual fields.
 */
#define IING_EGRMSKBMAP_LOr_BITMAPf_GET(r,a) field_get((r).iing_egrmskbmap_lo,0,63,a)
#define IING_EGRMSKBMAP_LOr_BITMAPf_SET(r,a) field_set((r).iing_egrmskbmap_lo,0,63,a)
#define IING_EGRMSKBMAP_LOr_BITMAP_LOf_GET(r,a) field_get((r).iing_egrmskbmap_lo,0,63,a)
#define IING_EGRMSKBMAP_LOr_BITMAP_LOf_SET(r,a) field_set((r).iing_egrmskbmap_lo,0,63,a)
#define IING_EGRMSKBMAP_LOr_BLK_BITMAPf_GET(r,a) field_get((r).iing_egrmskbmap_lo,0,63,a)
#define IING_EGRMSKBMAP_LOr_BLK_BITMAPf_SET(r,a) field_set((r).iing_egrmskbmap_lo,0,63,a)
#define IING_EGRMSKBMAP_LOr_OVER_LOf_GET(r) ((r).iing_egrmskbmap_lo[0])
#define IING_EGRMSKBMAP_LOr_OVER_LOf_SET(r,f) (r).iing_egrmskbmap_lo[0]=((uint32)f)
#define IING_EGRMSKBMAP_LOr_OVER_HIf_GET(r) ((r).iing_egrmskbmap_lo[1])
#define IING_EGRMSKBMAP_LOr_OVER_HIf_SET(r,f) (r).iing_egrmskbmap_lo[1]=((uint32)f)

/*
 * These macros can be used to access IING_EGRMSKBMAP_LO.
 */
#define WRITE_IING_EGRMSKBMAP_LOr(u,p,r) bcm5607x_reg64_set(u,R_IING_EGRMSKBMAP_LO(p),&(r._iing_egrmskbmap_lo),2)
#define READ_IING_EGRMSKBMAP_LOr(u,p,r) bcm5607x_reg64_get(u,R_IING_EGRMSKBMAP_LO(p),&(r._iing_egrmskbmap_lo),2)

/*******************************************************************************
 * End of 'IING_EGRMSKBMAP_LOr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  IM_MTP_INDEX
 * BLOCKS:   IPIPE
 * DESC:     Ingress Mirror to Port Table
The index to this table is obtained from MIRROR_CONTROL.IM_MTP_INDEX. The fields specify 1 of 4 mirror to ports
 * SIZE:     16
 * FIELDS:
 *     PORT_NUM         Port if T==0
 *     TGID             Trunk ID value if T==1
 *     MODULE_ID        Module ID if T==0. 
 *     T                Trunked port (LAG) indication
 */
#define IM_MTP_INDEXm_MIN 0
#define IM_MTP_INDEXm_MAX 3
#define IM_MTP_INDEXm_CMAX(u) 3
#define IM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program IM_MTP_INDEX.
 */
typedef union IM_MTP_INDEXm_s {
	uint32 v[1];
	uint32 im_mtp_index[1];
	uint32 _im_mtp_index;
} IM_MTP_INDEXm_t;

#define IM_MTP_INDEXm_CLR(r) (r).im_mtp_index[0] = 0
#define IM_MTP_INDEXm_SET(r,d) (r).im_mtp_index[0] = d
#define IM_MTP_INDEXm_GET(r) (r).im_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 */
#define IM_MTP_INDEXm_PORT_NUMf_GET(r) (((r).im_mtp_index[0]) & 0x7f)
#define IM_MTP_INDEXm_PORT_NUMf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define IM_MTP_INDEXm_TGIDf_GET(r) (((r).im_mtp_index[0]) & 0x7f)
#define IM_MTP_INDEXm_TGIDf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define IM_MTP_INDEXm_MODULE_IDf_GET(r) ((((r).im_mtp_index[0]) >> 7) & 0xff)
#define IM_MTP_INDEXm_MODULE_IDf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define IM_MTP_INDEXm_Tf_GET(r) ((((r).im_mtp_index[0]) >> 15) & 0x1)
#define IM_MTP_INDEXm_Tf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))

/*
 * These macros can be used to access IM_MTP_INDEX.
 */
#define WRITE_IM_MTP_INDEXm(u,i,r) bcm5607x_mem_set(u, M_IM_MTP_INDEX(i), &(r._im_mtp_index), 1)
#define READ_IM_MTP_INDEXm(u,i,r) bcm5607x_mem_get(u, M_IM_MTP_INDEX(i), &(r._im_mtp_index), 1)

/*******************************************************************************
 * End of 'IM_MTP_INDEXm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  ING_CONFIG_64
 * BLOCKS:   IPIPE
 * DESC:     Switch configuration register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0       Reserved.
 *     TRUNKS128        If set to 1, 128 trunk groups are supported
 *     L2DH_EN          L2 destination hit bit enable       0 = Do not update hit bit on destination match       1 = Update the L2 table hit bit on a destination match
 *     L2DST_HIT_ENABLE If set to 1, L2 table will update its HIT bit on destination lookup
 *     L3SH_EN          If set to 1, controls the update of the HIT bit in the L3 table upon an IP source address match.       0 = Do not update L3 table hit bit.       1 = Update the L3 table hit bit.       Hit bit in the L3 table is always updated upon a destination IPmatch.
 *     L3SRC_HIT_ENABLE If set to 1, L3 table will update its HIT bit on source lookup. Only apply to Unicast packets.
 *     CFI_AS_CNG       If set to 1, for tagged packets, use VLAN's CFI field to map to an internal CNG value (for double tagging)
 *     SNAP_OTHER_DECODE_ENABLE If set to 1, decode SNAP packets with non-zero OUI for protocol-based VLAN
 *     STNMOVE_ON_L2SRC_DISC If set to 1, perform station movement on L2 source discard packets
 *     FB_A0_COMPATIBLE If set to 1, disable source MOD_ID checks for mirror packets on HiGig when in XGS-3 style of mirroring. Used when compatibility with BCM56504 A0 devices is required.
 *     STACK_MODE       Stacking Mode.
 *     CVLAN_CFI_AS_CNG If set to 1, treat CFI bit in customer VLAN tag as CNG
 *     APPLY_EGR_MASK_ON_L2 If set to 1, apply Egress mask for L2 switched packets
 *     APPLY_EGR_MASK_ON_L3 If set to 1, apply Egress mask for L3 switched packets
 *     SVL_ENABLE       If set to 1, enable Shared VLAN Learning
 *     LOOKUP_L2MC_WITH_FID_ID  If set to 1, enable L2MC lookups to occur with MAC_DA + FID in Shared VLAN learning mode. 
 *     MAP_FID_ID_TO_OUTER_TAG If set to 1, copy FID-ID as VLAN-ID in outer VLAN tag for FP classification only
 *     MAP_FID_ID_TO_INNER_TAG If set to 1, copy FID-ID as VLAN-ID in inner VLAN tag for FP classification only
 *     DISABLE_E2E_HOL_CHECK Disable E2E HOL checking
 *     LBID_RTAG        If set to 1, RTAG selects how LBID is computed
 *     APPLY_MTU_CHECK_ON_HIGIG_IPMC If set to 1, L3 MTU check is applied to HiGig IPMC packets.
 *     IGNORE_HG_HDR_LAG_FAILOVER If set to 1, HiGig headers LAG_FAILOVER bit will be ignored and will be treated as reserved bit.
 *     IGNORE_HG_HDR_DONOT_LEARN If set to 1, HiGig headers DONOT_LEARN bit will be ignored and will be treated as reserved bit.
 *     IGNORE_HG_HDR_HDR_EXT_LEN If set to 1, HiGig+ headers HDR_EXT_LEN bits will be ignored and will be treated as reserved bit.
 *     IGNORE_MY_MODID  If set to 1, the MY_MODID from the PORT TABLE will be ignored. The chip will not have a module ID (this is the case when the chip is used as a fabric device).
 *     IGMP_PKTS_UNICAST_IGNORE If set to 1, unicast packets with IGMP payload (i.e. IP PROTOCOL = 2) will not be treated as IGMP packets
 *     MLD_PKTS_UNICAST_IGNORE If set to 1, unicast packets with MLD payload will not be treated as MLD packets
 *     ARP_VALIDATION_EN If set to 1, enables the sender Ethernet address to be sent to the VFP. Use in conjunction with the ARP_RARP_TO_FP bit. 
 *     MLD_CHECKS_ENABLE If set to 1, stricter checks for MLD packets are enabled. The packet is checked for TTL=1 and SIP is LINK_LOCAL. 
 *     IPV4_RESERVED_MC_ADDR_IGMP_ENABLE If set to 1, treat the IGMP packets with a IPv4 reserved multicast destination address as IGMP packets. (not as IPv4 reserved multicast packets)
 *     IPV6_RESERVED_MC_ADDR_MLD_ENABLE If set to 1, treat the MLD packets with a IPv6 reserved multicast destination address as MLD packets (not as IPv6 reserved multicast packets)
 *     IPV4_MC_MACDA_CHECK_ENABLE If set to 1, check MACDA and IPV4 DIP address match for IPv4 multicast packets
 *     IPV6_MC_MACDA_CHECK_ENABLE If set to 1, check MACDA and IPV6 DIP address match for IPv6 multicast packets
 *     ARP_RARP_TO_FP   This field controls the encodings of the ARP/RARP packet type into the VFP and IFP keys. If bit[0] is set, then ARP packets are included. If bit[1] is set, then RARP packets are included. It is also used in conjunction with ARP_VALIDATION_EN to validate these packets in the VFP.
 *     RESERVED_40      Reserved bit
 *     VFP_PRI_ACTION_FB2_MODE FB2 backward compatibility mode for L2/L3 lookup/DSCP priority override
 *     L3IIF_URPF_SELECT When set to 1, the uRPF controls are defined per L3_IIF.  When set to 0, the uRPF controls are per physical port.
 *     IGNORE_PPD0_PRESERVE_QOS If set, then the parser will not interpret the PPD0 bits as preserve QOS bits and instead will treat them as reserved and will be transited.
 *     IGNORE_PPD2_PRESERVE_QOS If set, then the parser will not interpret the PPD2 bits as preserve QOS bits and instead will treat them as reserved and will be transited.
 *     USE_PPD_SOURCE   If set to 1, the PPD overlay contains the system source port for packet processing.  If set to 0, the FRC source will be used as the system source port for packet processing.
 *     TREAT_PKTPRI_AS_DOT1P If set, then the packet priority which is derived from VLAN assignment will be treated as dot1p priority (instead of ING_PRI_CNG_MAP.PRI.)
 *     IPHDR_ERROR_L3_LOOKUP_ENABLE .
 *     ENABLE_MAC_IP_BINDING_FOR_ARP_PKTS Enable the MAC_IP_BINDING support for ARP packets
 *     HIGIG2_ECN_IN_CC_ENABLE Backward compatibility mode. 0: Backward compatible 1: Higig Congestion class valid.
 *     L2_128_OVF_DISABLE Disable new 128 L2_ENTRY_OVERFLOW feature.
 */
#define ING_CONFIG_64r_SIZE 8

/*
 * This structure should be used to declare and program ING_CONFIG_64.
 */
typedef union ING_CONFIG_64r_s {
	uint32 v[2];
	uint32 ing_config_64[2];
	uint32 _ing_config_64;
} ING_CONFIG_64r_t;

#define ING_CONFIG_64r_CLR(r) sal_memset(&((r)._ing_config_64), 0, sizeof(ING_CONFIG_64r_t))
#define ING_CONFIG_64r_SET(r,i,d) (r).ing_config_64[i] = d
#define ING_CONFIG_64r_GET(r,i) (r).ing_config_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define ING_CONFIG_64r_RESERVED_0f_GET(r) (((r).ing_config_64[0]) & 0x1)
#define ING_CONFIG_64r_RESERVED_0f_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define ING_CONFIG_64r_TRUNKS128f_GET(r) ((((r).ing_config_64[0]) >> 1) & 0x1)
#define ING_CONFIG_64r_TRUNKS128f_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define ING_CONFIG_64r_L2DH_ENf_GET(r) ((((r).ing_config_64[0]) >> 2) & 0x1)
#define ING_CONFIG_64r_L2DH_ENf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define ING_CONFIG_64r_L2DST_HIT_ENABLEf_GET(r) ((((r).ing_config_64[0]) >> 2) & 0x1)
#define ING_CONFIG_64r_L2DST_HIT_ENABLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define ING_CONFIG_64r_L3SH_ENf_GET(r) ((((r).ing_config_64[0]) >> 3) & 0x1)
#define ING_CONFIG_64r_L3SH_ENf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define ING_CONFIG_64r_L3SRC_HIT_ENABLEf_GET(r) ((((r).ing_config_64[0]) >> 3) & 0x1)
#define ING_CONFIG_64r_L3SRC_HIT_ENABLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define ING_CONFIG_64r_CFI_AS_CNGf_GET(r) ((((r).ing_config_64[0]) >> 5) & 0x1)
#define ING_CONFIG_64r_CFI_AS_CNGf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define ING_CONFIG_64r_SNAP_OTHER_DECODE_ENABLEf_GET(r) ((((r).ing_config_64[0]) >> 6) & 0x1)
#define ING_CONFIG_64r_SNAP_OTHER_DECODE_ENABLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define ING_CONFIG_64r_STNMOVE_ON_L2SRC_DISCf_GET(r) ((((r).ing_config_64[0]) >> 7) & 0x1)
#define ING_CONFIG_64r_STNMOVE_ON_L2SRC_DISCf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define ING_CONFIG_64r_FB_A0_COMPATIBLEf_GET(r) ((((r).ing_config_64[0]) >> 8) & 0x1)
#define ING_CONFIG_64r_FB_A0_COMPATIBLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define ING_CONFIG_64r_STACK_MODEf_GET(r) ((((r).ing_config_64[0]) >> 9) & 0x3)
#define ING_CONFIG_64r_STACK_MODEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define ING_CONFIG_64r_CVLAN_CFI_AS_CNGf_GET(r) ((((r).ing_config_64[0]) >> 11) & 0x1)
#define ING_CONFIG_64r_CVLAN_CFI_AS_CNGf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define ING_CONFIG_64r_APPLY_EGR_MASK_ON_L2f_GET(r) ((((r).ing_config_64[0]) >> 12) & 0x1)
#define ING_CONFIG_64r_APPLY_EGR_MASK_ON_L2f_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define ING_CONFIG_64r_APPLY_EGR_MASK_ON_L3f_GET(r) ((((r).ing_config_64[0]) >> 13) & 0x1)
#define ING_CONFIG_64r_APPLY_EGR_MASK_ON_L3f_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define ING_CONFIG_64r_SVL_ENABLEf_GET(r) ((((r).ing_config_64[0]) >> 14) & 0x1)
#define ING_CONFIG_64r_SVL_ENABLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define ING_CONFIG_64r_LOOKUP_L2MC_WITH_FID_IDf_GET(r) ((((r).ing_config_64[0]) >> 15) & 0x1)
#define ING_CONFIG_64r_LOOKUP_L2MC_WITH_FID_IDf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define ING_CONFIG_64r_MAP_FID_ID_TO_OUTER_TAGf_GET(r) ((((r).ing_config_64[0]) >> 16) & 0x1)
#define ING_CONFIG_64r_MAP_FID_ID_TO_OUTER_TAGf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define ING_CONFIG_64r_MAP_FID_ID_TO_INNER_TAGf_GET(r) ((((r).ing_config_64[0]) >> 17) & 0x1)
#define ING_CONFIG_64r_MAP_FID_ID_TO_INNER_TAGf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define ING_CONFIG_64r_DISABLE_E2E_HOL_CHECKf_GET(r) ((((r).ing_config_64[0]) >> 18) & 0x1)
#define ING_CONFIG_64r_DISABLE_E2E_HOL_CHECKf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define ING_CONFIG_64r_LBID_RTAGf_GET(r) ((((r).ing_config_64[0]) >> 19) & 0x7)
#define ING_CONFIG_64r_LBID_RTAGf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define ING_CONFIG_64r_APPLY_MTU_CHECK_ON_HIGIG_IPMCf_GET(r) ((((r).ing_config_64[0]) >> 22) & 0x1)
#define ING_CONFIG_64r_APPLY_MTU_CHECK_ON_HIGIG_IPMCf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define ING_CONFIG_64r_IGNORE_HG_HDR_LAG_FAILOVERf_GET(r) ((((r).ing_config_64[0]) >> 23) & 0x1)
#define ING_CONFIG_64r_IGNORE_HG_HDR_LAG_FAILOVERf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define ING_CONFIG_64r_IGNORE_HG_HDR_DONOT_LEARNf_GET(r) ((((r).ing_config_64[0]) >> 24) & 0x1)
#define ING_CONFIG_64r_IGNORE_HG_HDR_DONOT_LEARNf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define ING_CONFIG_64r_IGNORE_HG_HDR_HDR_EXT_LENf_GET(r) ((((r).ing_config_64[0]) >> 25) & 0x1)
#define ING_CONFIG_64r_IGNORE_HG_HDR_HDR_EXT_LENf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define ING_CONFIG_64r_IGNORE_MY_MODIDf_GET(r) ((((r).ing_config_64[0]) >> 26) & 0x1)
#define ING_CONFIG_64r_IGNORE_MY_MODIDf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define ING_CONFIG_64r_IGMP_PKTS_UNICAST_IGNOREf_GET(r) ((((r).ing_config_64[0]) >> 27) & 0x1)
#define ING_CONFIG_64r_IGMP_PKTS_UNICAST_IGNOREf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define ING_CONFIG_64r_MLD_PKTS_UNICAST_IGNOREf_GET(r) ((((r).ing_config_64[0]) >> 28) & 0x1)
#define ING_CONFIG_64r_MLD_PKTS_UNICAST_IGNOREf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define ING_CONFIG_64r_ARP_VALIDATION_ENf_GET(r) ((((r).ing_config_64[0]) >> 29) & 0x1)
#define ING_CONFIG_64r_ARP_VALIDATION_ENf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define ING_CONFIG_64r_MLD_CHECKS_ENABLEf_GET(r) ((((r).ing_config_64[0]) >> 30) & 0x1)
#define ING_CONFIG_64r_MLD_CHECKS_ENABLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define ING_CONFIG_64r_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_GET(r) ((((r).ing_config_64[0]) >> 31) & 0x1)
#define ING_CONFIG_64r_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define ING_CONFIG_64r_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_GET(r) (((r).ing_config_64[1]) & 0x1)
#define ING_CONFIG_64r_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define ING_CONFIG_64r_IPV4_MC_MACDA_CHECK_ENABLEf_GET(r) ((((r).ing_config_64[1]) >> 1) & 0x1)
#define ING_CONFIG_64r_IPV4_MC_MACDA_CHECK_ENABLEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define ING_CONFIG_64r_IPV6_MC_MACDA_CHECK_ENABLEf_GET(r) ((((r).ing_config_64[1]) >> 2) & 0x1)
#define ING_CONFIG_64r_IPV6_MC_MACDA_CHECK_ENABLEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define ING_CONFIG_64r_ARP_RARP_TO_FPf_GET(r) ((((r).ing_config_64[1]) >> 6) & 0x3)
#define ING_CONFIG_64r_ARP_RARP_TO_FPf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define ING_CONFIG_64r_RESERVED_40f_GET(r) ((((r).ing_config_64[1]) >> 8) & 0x1)
#define ING_CONFIG_64r_RESERVED_40f_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define ING_CONFIG_64r_VFP_PRI_ACTION_FB2_MODEf_GET(r) ((((r).ing_config_64[1]) >> 9) & 0x1)
#define ING_CONFIG_64r_VFP_PRI_ACTION_FB2_MODEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define ING_CONFIG_64r_L3IIF_URPF_SELECTf_GET(r) ((((r).ing_config_64[1]) >> 10) & 0x1)
#define ING_CONFIG_64r_L3IIF_URPF_SELECTf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define ING_CONFIG_64r_IGNORE_PPD0_PRESERVE_QOSf_GET(r) ((((r).ing_config_64[1]) >> 11) & 0x1)
#define ING_CONFIG_64r_IGNORE_PPD0_PRESERVE_QOSf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define ING_CONFIG_64r_IGNORE_PPD2_PRESERVE_QOSf_GET(r) ((((r).ing_config_64[1]) >> 12) & 0x1)
#define ING_CONFIG_64r_IGNORE_PPD2_PRESERVE_QOSf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define ING_CONFIG_64r_USE_PPD_SOURCEf_GET(r) ((((r).ing_config_64[1]) >> 13) & 0x1)
#define ING_CONFIG_64r_USE_PPD_SOURCEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define ING_CONFIG_64r_TREAT_PKTPRI_AS_DOT1Pf_GET(r) ((((r).ing_config_64[1]) >> 14) & 0x1)
#define ING_CONFIG_64r_TREAT_PKTPRI_AS_DOT1Pf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define ING_CONFIG_64r_IPHDR_ERROR_L3_LOOKUP_ENABLEf_GET(r) ((((r).ing_config_64[1]) >> 16) & 0x1)
#define ING_CONFIG_64r_IPHDR_ERROR_L3_LOOKUP_ENABLEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define ING_CONFIG_64r_ENABLE_MAC_IP_BINDING_FOR_ARP_PKTSf_GET(r) ((((r).ing_config_64[1]) >> 17) & 0x1)
#define ING_CONFIG_64r_ENABLE_MAC_IP_BINDING_FOR_ARP_PKTSf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define ING_CONFIG_64r_HIGIG2_ECN_IN_CC_ENABLEf_GET(r) ((((r).ing_config_64[1]) >> 18) & 0x1)
#define ING_CONFIG_64r_HIGIG2_ECN_IN_CC_ENABLEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define ING_CONFIG_64r_L2_128_OVF_DISABLEf_GET(r) ((((r).ing_config_64[1]) >> 19) & 0x1)
#define ING_CONFIG_64r_L2_128_OVF_DISABLEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))

/*
 * These macros can be used to access ING_CONFIG_64.
 */
#define WRITE_ING_CONFIG_64r(u,r) bcm5607x_reg64_set(u,R_ING_CONFIG_64,&(r._ing_config_64),2)
#define READ_ING_CONFIG_64r(u,r) bcm5607x_reg64_get(u,R_ING_CONFIG_64,&(r._ing_config_64),2)

/*******************************************************************************
 * End of 'ING_CONFIG_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  ING_EGRMSKBMAP_HI
 * BLOCKS:   IPIPE
 * DESC:     Ingress Block Mask, FeatureSpecific-Ethernet: HIGH BITs
 * SIZE:     64
 * FIELDS:
 *     OVER_LO          Used for whole regsiter default value
 *     BITMAP           Bitmap of ports to be blocked. 0=allow-through, 1=block. Note: If any bit in this register belongs to a member of a trunk group (either GE/HIGIG), then in order to function correctly, all bits of that trunk group should be disabled here as well.
 *     BITMAP_LO        Overlay bitmap
 *     BLK_BITMAP       Overlay bitmap
 *     RESERVED         Reserved.
 *     OVER_HI          Used for whole regsiter default value
 */
#define ING_EGRMSKBMAP_HIr_SIZE 8

/*
 * This structure should be used to declare and program ING_EGRMSKBMAP_HI.
 */
typedef union ING_EGRMSKBMAP_HIr_s {
	uint32 v[2];
	uint32 ing_egrmskbmap_hi[2];
	uint32 _ing_egrmskbmap_hi;
} ING_EGRMSKBMAP_HIr_t;

#define ING_EGRMSKBMAP_HIr_CLR(r) sal_memset(&((r)._ing_egrmskbmap_hi), 0, sizeof(ING_EGRMSKBMAP_HIr_t))
#define ING_EGRMSKBMAP_HIr_SET(r,i,d) (r).ing_egrmskbmap_hi[i] = d
#define ING_EGRMSKBMAP_HIr_GET(r,i) (r).ing_egrmskbmap_hi[i]

/*
 * These macros can be used to access individual fields.
 */
#define ING_EGRMSKBMAP_HIr_OVER_LOf_GET(r) ((r).ing_egrmskbmap_hi[0])
#define ING_EGRMSKBMAP_HIr_OVER_LOf_SET(r,f) (r).ing_egrmskbmap_hi[0]=((uint32)f)
#define ING_EGRMSKBMAP_HIr_BITMAPf_GET(r) (((r).ing_egrmskbmap_hi[0]) & 0x3)
#define ING_EGRMSKBMAP_HIr_BITMAPf_SET(r,f) (r).ing_egrmskbmap_hi[0]=(((r).ing_egrmskbmap_hi[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define ING_EGRMSKBMAP_HIr_BITMAP_LOf_GET(r) (((r).ing_egrmskbmap_hi[0]) & 0x3)
#define ING_EGRMSKBMAP_HIr_BITMAP_LOf_SET(r,f) (r).ing_egrmskbmap_hi[0]=(((r).ing_egrmskbmap_hi[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define ING_EGRMSKBMAP_HIr_BLK_BITMAPf_GET(r) (((r).ing_egrmskbmap_hi[0]) & 0x3)
#define ING_EGRMSKBMAP_HIr_BLK_BITMAPf_SET(r,f) (r).ing_egrmskbmap_hi[0]=(((r).ing_egrmskbmap_hi[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define ING_EGRMSKBMAP_HIr_RESERVEDf_GET(r,a) field_get((r).ing_egrmskbmap_hi,2,63,a)
#define ING_EGRMSKBMAP_HIr_RESERVEDf_SET(r,a) field_set((r).ing_egrmskbmap_hi,2,63,a)
#define ING_EGRMSKBMAP_HIr_OVER_HIf_GET(r) ((r).ing_egrmskbmap_hi[1])
#define ING_EGRMSKBMAP_HIr_OVER_HIf_SET(r,f) (r).ing_egrmskbmap_hi[1]=((uint32)f)

/*
 * These macros can be used to access ING_EGRMSKBMAP_HI.
 */
#define WRITE_ING_EGRMSKBMAP_HIr(u,p,r) bcm5607x_reg64_set(u,R_ING_EGRMSKBMAP_HI(p),&(r._ing_egrmskbmap_hi),2)
#define READ_ING_EGRMSKBMAP_HIr(u,p,r) bcm5607x_reg64_get(u,R_ING_EGRMSKBMAP_HI(p),&(r._ing_egrmskbmap_hi),2)

/*******************************************************************************
 * End of 'ING_EGRMSKBMAP_HIr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  ING_EGRMSKBMAP_LO
 * BLOCKS:   IPIPE
 * DESC:     Ingress Block Mask, FeatureSpecific-Ethernet: LOW BITs
 * SIZE:     64
 * FIELDS:
 *     BITMAP           Bitmap of ports to be blocked. 0=allow-through, 1=block. Note: If any bit in this register belongs to a member of a trunk group (either GE/HIGIG), then in order to function correctly, all bits of that trunk group should be disabled here as well.
 *     BITMAP_LO        Overlay bitmap
 *     BLK_BITMAP       Overlay bitmap
 *     OVER_LO          Used for whole regsiter default value
 *     OVER_HI          Used for whole regsiter default value
 */
#define ING_EGRMSKBMAP_LOr_SIZE 8

/*
 * This structure should be used to declare and program ING_EGRMSKBMAP_LO.
 */
typedef union ING_EGRMSKBMAP_LOr_s {
	uint32 v[2];
	uint32 ing_egrmskbmap_lo[2];
	uint32 _ing_egrmskbmap_lo;
} ING_EGRMSKBMAP_LOr_t;

#define ING_EGRMSKBMAP_LOr_CLR(r) sal_memset(&((r)._ing_egrmskbmap_lo), 0, sizeof(ING_EGRMSKBMAP_LOr_t))
#define ING_EGRMSKBMAP_LOr_SET(r,i,d) (r).ing_egrmskbmap_lo[i] = d
#define ING_EGRMSKBMAP_LOr_GET(r,i) (r).ing_egrmskbmap_lo[i]

/*
 * These macros can be used to access individual fields.
 */
#define ING_EGRMSKBMAP_LOr_BITMAPf_GET(r,a) field_get((r).ing_egrmskbmap_lo,0,63,a)
#define ING_EGRMSKBMAP_LOr_BITMAPf_SET(r,a) field_set((r).ing_egrmskbmap_lo,0,63,a)
#define ING_EGRMSKBMAP_LOr_BITMAP_LOf_GET(r,a) field_get((r).ing_egrmskbmap_lo,0,63,a)
#define ING_EGRMSKBMAP_LOr_BITMAP_LOf_SET(r,a) field_set((r).ing_egrmskbmap_lo,0,63,a)
#define ING_EGRMSKBMAP_LOr_BLK_BITMAPf_GET(r,a) field_get((r).ing_egrmskbmap_lo,0,63,a)
#define ING_EGRMSKBMAP_LOr_BLK_BITMAPf_SET(r,a) field_set((r).ing_egrmskbmap_lo,0,63,a)
#define ING_EGRMSKBMAP_LOr_OVER_LOf_GET(r) ((r).ing_egrmskbmap_lo[0])
#define ING_EGRMSKBMAP_LOr_OVER_LOf_SET(r,f) (r).ing_egrmskbmap_lo[0]=((uint32)f)
#define ING_EGRMSKBMAP_LOr_OVER_HIf_GET(r) ((r).ing_egrmskbmap_lo[1])
#define ING_EGRMSKBMAP_LOr_OVER_HIf_SET(r,f) (r).ing_egrmskbmap_lo[1]=((uint32)f)

/*
 * These macros can be used to access ING_EGRMSKBMAP_LO.
 */
#define WRITE_ING_EGRMSKBMAP_LOr(u,p,r) bcm5607x_reg64_set(u,R_ING_EGRMSKBMAP_LO(p),&(r._ing_egrmskbmap_lo),2)
#define READ_ING_EGRMSKBMAP_LOr(u,p,r) bcm5607x_reg64_get(u,R_ING_EGRMSKBMAP_LO(p),&(r._ing_egrmskbmap_lo),2)

/*******************************************************************************
 * End of 'ING_EGRMSKBMAP_LOr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  ING_HW_RESET_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register 1. ING_HW_RESET_CONTROL_1 and ING_HW_RESET_CONTROL_2 can be used in conjunction to clear memory tables that reside in the ingress pipeline in hardware.
 * SIZE:     32
 * FIELDS:
 *     OFFSET           18-bit starting offset of table for memory
 *     MEMORY_NUMBER    Memory Select
 *     STAGE_NUMBER     IP stage for the memory table
 */
#define ING_HW_RESET_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_1.
 */
typedef union ING_HW_RESET_CONTROL_1r_s {
	uint32 v[1];
	uint32 ing_hw_reset_control_1[1];
	uint32 _ing_hw_reset_control_1;
} ING_HW_RESET_CONTROL_1r_t;

#define ING_HW_RESET_CONTROL_1r_CLR(r) (r).ing_hw_reset_control_1[0] = 0
#define ING_HW_RESET_CONTROL_1r_SET(r,d) (r).ing_hw_reset_control_1[0] = d
#define ING_HW_RESET_CONTROL_1r_GET(r) (r).ing_hw_reset_control_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_HW_RESET_CONTROL_1r_OFFSETf_GET(r) (((r).ing_hw_reset_control_1[0]) & 0x3ffff)
#define ING_HW_RESET_CONTROL_1r_OFFSETf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32)0x3ffff)) | (((uint32)f) & 0x3ffff))
#define ING_HW_RESET_CONTROL_1r_MEMORY_NUMBERf_GET(r) ((((r).ing_hw_reset_control_1[0]) >> 18) & 0xff)
#define ING_HW_RESET_CONTROL_1r_MEMORY_NUMBERf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32)0xff << 18)) | ((((uint32)f) & 0xff) << 18))
#define ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET(r) ((((r).ing_hw_reset_control_1[0]) >> 26) & 0x3f)
#define ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_1.
 */
#define WRITE_ING_HW_RESET_CONTROL_1r(u,r) bcm5607x_reg_set(u,R_ING_HW_RESET_CONTROL_1,(r._ing_hw_reset_control_1))
#define READ_ING_HW_RESET_CONTROL_1r(u,r) bcm5607x_reg_get(u,R_ING_HW_RESET_CONTROL_1,&(r._ing_hw_reset_control_1))

/*******************************************************************************
 * End of 'ING_HW_RESET_CONTROL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  ING_HW_RESET_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register 2
 * SIZE:     32
 * FIELDS:
 *     COUNT            Number of entries of memory to initialize. Note that the number mentioned here should be one more than the entries to be intialized.
 *     RESET_ALL        Indicates all memories in all stages should be initialized (independent of stage or table number)				0 = Clear memory table specified in ING_HW_RESET_CONTROL_1				1 = Clear all memory tables in the ingress pipeline
 *     VALID            Set by software to trigger memory initialization				0 = Normal oparation				1 = Begin  initialization
 *     DONE             Set by hardware to indicate memory table writes have completed on pipeline				0 = Not complete				1 = Completed
 */
#define ING_HW_RESET_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_2.
 */
typedef union ING_HW_RESET_CONTROL_2r_s {
	uint32 v[1];
	uint32 ing_hw_reset_control_2[1];
	uint32 _ing_hw_reset_control_2;
} ING_HW_RESET_CONTROL_2r_t;

#define ING_HW_RESET_CONTROL_2r_CLR(r) (r).ing_hw_reset_control_2[0] = 0
#define ING_HW_RESET_CONTROL_2r_SET(r,d) (r).ing_hw_reset_control_2[0] = d
#define ING_HW_RESET_CONTROL_2r_GET(r) (r).ing_hw_reset_control_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_HW_RESET_CONTROL_2r_COUNTf_GET(r) (((r).ing_hw_reset_control_2[0]) & 0xffff)
#define ING_HW_RESET_CONTROL_2r_COUNTf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 16) & 0x1)
#define ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define ING_HW_RESET_CONTROL_2r_VALIDf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 17) & 0x1)
#define ING_HW_RESET_CONTROL_2r_VALIDf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define ING_HW_RESET_CONTROL_2r_DONEf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 18) & 0x1)
#define ING_HW_RESET_CONTROL_2r_DONEf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_2.
 */
#define WRITE_ING_HW_RESET_CONTROL_2r(u,r) bcm5607x_reg_set(u,R_ING_HW_RESET_CONTROL_2,(r._ing_hw_reset_control_2))
#define READ_ING_HW_RESET_CONTROL_2r(u,r) bcm5607x_reg_get(u,R_ING_HW_RESET_CONTROL_2,&(r._ing_hw_reset_control_2))

/*******************************************************************************
 * End of 'ING_HW_RESET_CONTROL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  ING_MISC_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Additional configuration bits
 * SIZE:     32
 * FIELDS:
 *     APPLY_EGR_MASK_ON_UC_ONLY If set, apply egress mask on unicast packets only.
 *     APPLY_SRCMOD_BLOCK_ON_UC_ONLY If set, apply source modid block on unicast packets only.
 *     DO_NOT_APPLY_SRCMOD_BLOCK_ON_SC If set, do not apply source modid block on system control packets.
 *     DO_NOT_COPY_FROM_CPU_TO_CPU If set, packets originating from the CPU port will not not be copied packet CPU.
 *     LOCAL_SW_DISABLE_HGTRUNK_RES_EN Enables Higig Trunk resolution when chip is in local switch disable mode. GNATS(8815, 8962)
 *     STG_CHECK_ENABLE If set, apply egress port's spanning tree check before enqueuing to the MMU for L2 forwarding.
 *     USE_DEST_PORT    USE_DEST_PORT.
 *     INPUT_PRI_TAGGED 0 - incoming_vlan_tag[15:13]; 1 - int_pri[3:0].
 *     INPUT_PRI_UNTAGGED 0 - learn_and_fwd_vlan_tag[15:13]; 1 - int_pri[3:0].
 */
#define ING_MISC_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program ING_MISC_CONFIG.
 */
typedef union ING_MISC_CONFIGr_s {
	uint32 v[1];
	uint32 ing_misc_config[1];
	uint32 _ing_misc_config;
} ING_MISC_CONFIGr_t;

#define ING_MISC_CONFIGr_CLR(r) (r).ing_misc_config[0] = 0
#define ING_MISC_CONFIGr_SET(r,d) (r).ing_misc_config[0] = d
#define ING_MISC_CONFIGr_GET(r) (r).ing_misc_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_GET(r) (((r).ing_misc_config[0]) & 0x1)
#define ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_GET(r) ((((r).ing_misc_config[0]) >> 1) & 0x1)
#define ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_GET(r) ((((r).ing_misc_config[0]) >> 2) & 0x1)
#define ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define ING_MISC_CONFIGr_DO_NOT_COPY_FROM_CPU_TO_CPUf_GET(r) ((((r).ing_misc_config[0]) >> 3) & 0x1)
#define ING_MISC_CONFIGr_DO_NOT_COPY_FROM_CPU_TO_CPUf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define ING_MISC_CONFIGr_LOCAL_SW_DISABLE_HGTRUNK_RES_ENf_GET(r) ((((r).ing_misc_config[0]) >> 4) & 0x1)
#define ING_MISC_CONFIGr_LOCAL_SW_DISABLE_HGTRUNK_RES_ENf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define ING_MISC_CONFIGr_STG_CHECK_ENABLEf_GET(r) ((((r).ing_misc_config[0]) >> 17) & 0x1)
#define ING_MISC_CONFIGr_STG_CHECK_ENABLEf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define ING_MISC_CONFIGr_USE_DEST_PORTf_GET(r) ((((r).ing_misc_config[0]) >> 19) & 0x1)
#define ING_MISC_CONFIGr_USE_DEST_PORTf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define ING_MISC_CONFIGr_INPUT_PRI_TAGGEDf_GET(r) ((((r).ing_misc_config[0]) >> 20) & 0x1)
#define ING_MISC_CONFIGr_INPUT_PRI_TAGGEDf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define ING_MISC_CONFIGr_INPUT_PRI_UNTAGGEDf_GET(r) ((((r).ing_misc_config[0]) >> 21) & 0x1)
#define ING_MISC_CONFIGr_INPUT_PRI_UNTAGGEDf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))

/*
 * These macros can be used to access ING_MISC_CONFIG.
 */
#define WRITE_ING_MISC_CONFIGr(u,r) bcm5607x_reg_set(u,R_ING_MISC_CONFIG,(r._ing_misc_config))
#define READ_ING_MISC_CONFIGr(u,r) bcm5607x_reg_get(u,R_ING_MISC_CONFIG,&(r._ing_misc_config))

/*******************************************************************************
 * End of 'ING_MISC_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Ingress Physical to Logical Port Number Mapping Table. Indexed by the Physical port number, and provides the corresponding logical port number.
 * SIZE:     7
 * FIELDS:
 *     LOGICAL_PORT_NUMBER Logical Port Number.
 */
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_MIN 0
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_MAX 77
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_CMAX(u) 77
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLE.
 */
typedef union ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_s {
	uint32 v[1];
	uint32 ing_physical_to_logical_port_number_mapping_table[1];
	uint32 _ing_physical_to_logical_port_number_mapping_table;
} ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_t;

#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_CLR(r) (r).ing_physical_to_logical_port_number_mapping_table[0] = 0
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_SET(r,d) (r).ing_physical_to_logical_port_number_mapping_table[0] = d
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_GET(r) (r).ing_physical_to_logical_port_number_mapping_table[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_LOGICAL_PORT_NUMBERf_GET(r) (((r).ing_physical_to_logical_port_number_mapping_table[0]) & 0x7f)
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_LOGICAL_PORT_NUMBERf_SET(r,f) (r).ing_physical_to_logical_port_number_mapping_table[0]=(((r).ing_physical_to_logical_port_number_mapping_table[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))

/*
 * These macros can be used to access ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLE.
 */
#define WRITE_ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm(u,i,r) bcm5607x_mem_set(u, M_ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLE(i), &(r._ing_physical_to_logical_port_number_mapping_table), 1)
#define READ_ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm(u,i,r) bcm5607x_mem_get(u, M_ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLE(i), &(r._ing_physical_to_logical_port_number_mapping_table), 1)

/*******************************************************************************
 * End of 'ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  ING_PRI_CNG_MAP
 * BLOCKS:   IPIPE
 * DESC:     Per port ingress priority/CFI mapping table. The ING_PRI_CNG_MAP table is used to lookup the (.1p, CFI) bits of incoming VLAN tag to generate (int_pri, CNG). This is done only if the 802.1p bits are trusted on the incoming L2 interface. The index into this table is composed of 10 bits: 6 bits of ingress port, 3 bits for priority, and 1 bit for CFI. The priority and CFI will be taken from the outer tag or inner tag depending on whether USE_INNER_PRI is set.
 * SIZE:     5
 * FIELDS:
 *     CNG              CNG mapped from incoming packet priority and CFG
 *     PRI              Priority mapped from incoming packet priority and CFI
 */
#define ING_PRI_CNG_MAPm_MIN 0
#define ING_PRI_CNG_MAPm_MAX 1070
#define ING_PRI_CNG_MAPm_CMAX(u) 1070
#define ING_PRI_CNG_MAPm_SIZE 1

/*
 * This structure should be used to declare and program ING_PRI_CNG_MAP.
 */
typedef union ING_PRI_CNG_MAPm_s {
	uint32 v[1];
	uint32 ing_pri_cng_map[1];
	uint32 _ing_pri_cng_map;
} ING_PRI_CNG_MAPm_t;

#define ING_PRI_CNG_MAPm_CLR(r) (r).ing_pri_cng_map[0] = 0
#define ING_PRI_CNG_MAPm_SET(r,d) (r).ing_pri_cng_map[0] = d
#define ING_PRI_CNG_MAPm_GET(r) (r).ing_pri_cng_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_PRI_CNG_MAPm_CNGf_GET(r) (((r).ing_pri_cng_map[0]) & 0x3)
#define ING_PRI_CNG_MAPm_CNGf_SET(r,f) (r).ing_pri_cng_map[0]=(((r).ing_pri_cng_map[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define ING_PRI_CNG_MAPm_PRIf_GET(r) ((((r).ing_pri_cng_map[0]) >> 2) & 0x7)
#define ING_PRI_CNG_MAPm_PRIf_SET(r,f) (r).ing_pri_cng_map[0]=(((r).ing_pri_cng_map[0] & ~((uint32)0x7 << 2)) | ((((uint32)f) & 0x7) << 2))

/*
 * These macros can be used to access ING_PRI_CNG_MAP.
 */
#define WRITE_ING_PRI_CNG_MAPm(u,i,r) bcm5607x_mem_set(u, M_ING_PRI_CNG_MAP(i), &(r._ing_pri_cng_map), 1)
#define READ_ING_PRI_CNG_MAPm(u,i,r) bcm5607x_mem_get(u, M_ING_PRI_CNG_MAP(i), &(r._ing_pri_cng_map), 1)

/*******************************************************************************
 * End of 'ING_PRI_CNG_MAPm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  ING_VLAN_TAG_ACTION_PROFILE
 * BLOCKS:   IPIPE
 * DESC:      Actions for the VLAN translation.
The index into this table is supplied from the TAG_ACTION_PROFILE_PTR field in PORT, IPORT, LPORT, VLAN_SUBNET, VLAN_PROTOCOL, VLAN_XLATE, or VLAN_MAC table
 * SIZE:     24
 * FIELDS:
 *     UT_ITAG_ACTION   Specifies the inner VLAN tag action if incoming packet is untagged:0 = do not modify1 = add internal IVID2 = reserved3 = reserved
 *     UT_OTAG_ACTION   Specifies the outer VLAN tag action if incoming packet untagged:0 = do not modify1 = add internal OVID2 = reserved3 = reserved
 *     SIT_PITAG_ACTION Specifies the inner VLAN tag action if incoming packet is single inner-tagged and priority-tagged:0 = do not modify1 = reserved2 = replace incoming IVID with internal IVID3 = delete incoming IVID
 *     SIT_ITAG_ACTION  Specifies the inner VLAN tag action if incoming packet is single inner-tagged and not priority-tagged:0 = do not modify1 = reserved2 = replace incoming IVID with internal IVID3 = delete incoming IVID
 *     SIT_OTAG_ACTION  Specifies the inner VLAN tag action if incoming packet is single inner-tagged and not priority-tagged:0 = do not modify1 = add internal OVID2 = reserved3 = reserved
 *     SOT_ITAG_ACTION  Specifies the inner VLAN tag action if incoming packet is single outer-tagged:0 = do not modify1 = add internal IVID2 = reserved3 = reserved
 *     SOT_POTAG_ACTION Specifies the outer VLAN tag action if incoming packet is single outer-tagged and priority-tagged:0 = do not modify1 = add internal OVID2 = replace incoming OVID with internal OVID3 = delete incoming OVID
 *     SOT_OTAG_ACTION  Specifies the outer VLAN tag action if incoming packet is single outer-tagged:0 = do not modify1 = add internal OVID2 = replace incoming OVID with internal OVID3 = delete incoming OVID
 *     DT_PITAG_ACTION  Specifies the inner VLAN tag action if incoming packet is double tagged and inner tag is a priority tag:0 = do not modify1 = reserved2 = replace incoming IVID with internal IVID3 = delete incoming IVID
 *     DT_ITAG_ACTION   Specifies the inner VLAN tag action if incoming packet is double tagged:0 = do not modify1 = reserved2 = replace incoming IVID with internal IVID3 = delete incoming IVID
 *     DT_POTAG_ACTION  Specifies the outer VLAN tag action if incoming packet is double tagged and priority-tagged:0 = do not modify1 = add internal OVID2 = replace incoming OVID with internal OVID3 = delete incoming OVID
 *     DT_OTAG_ACTION   Specifies the outer VLAN tag action if incoming packet is double tagged:0 = do not modify1 = add internal OVID2 = replace incoming OVID with internal OVID3 = delete incoming OVID
 */
#define ING_VLAN_TAG_ACTION_PROFILEm_MIN 0
#define ING_VLAN_TAG_ACTION_PROFILEm_MAX 63
#define ING_VLAN_TAG_ACTION_PROFILEm_CMAX(u) 63
#define ING_VLAN_TAG_ACTION_PROFILEm_SIZE 3

/*
 * This structure should be used to declare and program ING_VLAN_TAG_ACTION_PROFILE.
 */
typedef union ING_VLAN_TAG_ACTION_PROFILEm_s {
	uint32 v[1];
	uint32 ing_vlan_tag_action_profile[1];
	uint32 _ing_vlan_tag_action_profile;
} ING_VLAN_TAG_ACTION_PROFILEm_t;

#define ING_VLAN_TAG_ACTION_PROFILEm_CLR(r) (r).ing_vlan_tag_action_profile[0] = 0
#define ING_VLAN_TAG_ACTION_PROFILEm_SET(r,d) (r).ing_vlan_tag_action_profile[0] = d
#define ING_VLAN_TAG_ACTION_PROFILEm_GET(r) (r).ing_vlan_tag_action_profile[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_VLAN_TAG_ACTION_PROFILEm_UT_ITAG_ACTIONf_GET(r) (((r).ing_vlan_tag_action_profile[0]) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_UT_ITAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define ING_VLAN_TAG_ACTION_PROFILEm_UT_OTAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 2) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_UT_OTAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define ING_VLAN_TAG_ACTION_PROFILEm_SIT_PITAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 4) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_SIT_PITAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define ING_VLAN_TAG_ACTION_PROFILEm_SIT_ITAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 6) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_SIT_ITAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define ING_VLAN_TAG_ACTION_PROFILEm_SIT_OTAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 8) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_SIT_OTAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define ING_VLAN_TAG_ACTION_PROFILEm_SOT_ITAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 10) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_SOT_ITAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define ING_VLAN_TAG_ACTION_PROFILEm_SOT_POTAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 12) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_SOT_POTAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define ING_VLAN_TAG_ACTION_PROFILEm_SOT_OTAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 14) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_SOT_OTAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_PITAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 16) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_PITAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_ITAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 18) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_ITAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_POTAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 20) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_POTAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_OTAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 22) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_OTAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))

/*
 * These macros can be used to access ING_VLAN_TAG_ACTION_PROFILE.
 */
#define WRITE_ING_VLAN_TAG_ACTION_PROFILEm(u,i,r) bcm5607x_mem_set(u, M_ING_VLAN_TAG_ACTION_PROFILE(i), &(r._ing_vlan_tag_action_profile), 1)
#define READ_ING_VLAN_TAG_ACTION_PROFILEm(u,i,r) bcm5607x_mem_get(u, M_ING_VLAN_TAG_ACTION_PROFILE(i), &(r._ing_vlan_tag_action_profile), 1)

/*******************************************************************************
 * End of 'ING_VLAN_TAG_ACTION_PROFILEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPG_HD_BKP_CNTL
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     The control register for HD-BackPressure.
 * SIZE:     32
 * FIELDS:
 *     HD_FC_ENA        When set, enables back-pressure in half-duplex mode.
 *     HD_FC_BKOFF_OK   Register Bit 1 refers to the application of backoff algorithm during HD backpressure.
 *     IPG_CONFIG_RX    The programmable Rx IPG below which the packets received are dropped graciously. The value is in Bytes for 1/2.5G and Nibbles for 10/100M.
 */
#define IPG_HD_BKP_CNTLr_SIZE 4

/*
 * This structure should be used to declare and program IPG_HD_BKP_CNTL.
 */
typedef union IPG_HD_BKP_CNTLr_s {
	uint32 v[1];
	uint32 ipg_hd_bkp_cntl[1];
	uint32 _ipg_hd_bkp_cntl;
} IPG_HD_BKP_CNTLr_t;

#define IPG_HD_BKP_CNTLr_CLR(r) (r).ipg_hd_bkp_cntl[0] = 0
#define IPG_HD_BKP_CNTLr_SET(r,d) (r).ipg_hd_bkp_cntl[0] = d
#define IPG_HD_BKP_CNTLr_GET(r) (r).ipg_hd_bkp_cntl[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPG_HD_BKP_CNTLr_HD_FC_ENAf_GET(r) (((r).ipg_hd_bkp_cntl[0]) & 0x1)
#define IPG_HD_BKP_CNTLr_HD_FC_ENAf_SET(r,f) (r).ipg_hd_bkp_cntl[0]=(((r).ipg_hd_bkp_cntl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define IPG_HD_BKP_CNTLr_HD_FC_BKOFF_OKf_GET(r) ((((r).ipg_hd_bkp_cntl[0]) >> 1) & 0x1)
#define IPG_HD_BKP_CNTLr_HD_FC_BKOFF_OKf_SET(r,f) (r).ipg_hd_bkp_cntl[0]=(((r).ipg_hd_bkp_cntl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define IPG_HD_BKP_CNTLr_IPG_CONFIG_RXf_GET(r) ((((r).ipg_hd_bkp_cntl[0]) >> 2) & 0x1f)
#define IPG_HD_BKP_CNTLr_IPG_CONFIG_RXf_SET(r,f) (r).ipg_hd_bkp_cntl[0]=(((r).ipg_hd_bkp_cntl[0] & ~((uint32)0x1f << 2)) | ((((uint32)f) & 0x1f) << 2))

/*
 * These macros can be used to access IPG_HD_BKP_CNTL.
 */
#define WRITE_IPG_HD_BKP_CNTLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_IPG_HD_BKP_CNTL(bcm5607x_gport_lport_to_index_in_block[p]), (r._ipg_hd_bkp_cntl))
#define READ_IPG_HD_BKP_CNTLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_IPG_HD_BKP_CNTL(bcm5607x_gport_lport_to_index_in_block[p]), &(r._ipg_hd_bkp_cntl))

/*******************************************************************************
 * End of 'IPG_HD_BKP_CNTLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROCPERIPH_UART0_UART_RBR_THR_DLL
 * BLOCKS:   IPROC
 * DESC:     1)Receive Buffer Register
2)Transmit Holding Register
3)Divisor Latch (Low)


 * SIZE:     32
 * FIELDS:
 *     RBR_THR_DLL      1) RBR: Receive Buffer RegisterRead OnlyReset Value: 0x0Dependencies: LCR[7] bit = 0                2) THR: Transmit Holding RegisterWrite OnlyReset Value: 0x0Dependencies: LCR[7] bit = 03) DLL: Divisor Latch (Low)Read WriteReset Value: 0x0Dependencies: LCR[7] bit = 1
 */
#define IPROCPERIPH_UART0_UART_RBR_THR_DLLr_SIZE 4

/*
 * This structure should be used to declare and program IPROCPERIPH_UART0_UART_RBR_THR_DLL.
 */
typedef union IPROCPERIPH_UART0_UART_RBR_THR_DLLr_s {
	uint32 v[1];
	uint32 iprocperiph_uart0_uart_rbr_thr_dll[1];
	uint32 _iprocperiph_uart0_uart_rbr_thr_dll;
} IPROCPERIPH_UART0_UART_RBR_THR_DLLr_t;

#define IPROCPERIPH_UART0_UART_RBR_THR_DLLr_CLR(r) (r).iprocperiph_uart0_uart_rbr_thr_dll[0] = 0
#define IPROCPERIPH_UART0_UART_RBR_THR_DLLr_SET(r,d) (r).iprocperiph_uart0_uart_rbr_thr_dll[0] = d
#define IPROCPERIPH_UART0_UART_RBR_THR_DLLr_GET(r) (r).iprocperiph_uart0_uart_rbr_thr_dll[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROCPERIPH_UART0_UART_RBR_THR_DLLr_RBR_THR_DLLf_GET(r) (((r).iprocperiph_uart0_uart_rbr_thr_dll[0]) & 0xff)
#define IPROCPERIPH_UART0_UART_RBR_THR_DLLr_RBR_THR_DLLf_SET(r,f) (r).iprocperiph_uart0_uart_rbr_thr_dll[0]=(((r).iprocperiph_uart0_uart_rbr_thr_dll[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))

/*
 * These macros can be used to access IPROCPERIPH_UART0_UART_RBR_THR_DLL.
 */
#define READ_IPROCPERIPH_UART0_UART_RBR_THR_DLLr(u,r) bcm5607x_read32(u, R_IPROCPERIPH_UART0_UART_RBR_THR_DLL, &(r._iprocperiph_uart0_uart_rbr_thr_dll))
#define WRITE_IPROCPERIPH_UART0_UART_RBR_THR_DLLr(u,r) bcm5607x_write32(u, R_IPROCPERIPH_UART0_UART_RBR_THR_DLL, (r._iprocperiph_uart0_uart_rbr_thr_dll))

/*******************************************************************************
 * End of 'IPROCPERIPH_UART0_UART_RBR_THR_DLLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROCPERIPH_UART1_UART_RBR_THR_DLL
 * BLOCKS:   IPROC
 * DESC:     1)Receive Buffer Register
2)Transmit Holding Register
3)Divisor Latch (Low)


 * SIZE:     32
 * FIELDS:
 *     RBR_THR_DLL      1) RBR: Receive Buffer RegisterRead OnlyReset Value: 0x0Dependencies: LCR[7] bit = 0                2) THR: Transmit Holding RegisterWrite OnlyReset Value: 0x0Dependencies: LCR[7] bit = 03) DLL: Divisor Latch (Low)Read WriteReset Value: 0x0Dependencies: LCR[7] bit = 1
 */
#define IPROCPERIPH_UART1_UART_RBR_THR_DLLr_SIZE 4

/*
 * This structure should be used to declare and program IPROCPERIPH_UART1_UART_RBR_THR_DLL.
 */
typedef union IPROCPERIPH_UART1_UART_RBR_THR_DLLr_s {
	uint32 v[1];
	uint32 iprocperiph_uart1_uart_rbr_thr_dll[1];
	uint32 _iprocperiph_uart1_uart_rbr_thr_dll;
} IPROCPERIPH_UART1_UART_RBR_THR_DLLr_t;

#define IPROCPERIPH_UART1_UART_RBR_THR_DLLr_CLR(r) (r).iprocperiph_uart1_uart_rbr_thr_dll[0] = 0
#define IPROCPERIPH_UART1_UART_RBR_THR_DLLr_SET(r,d) (r).iprocperiph_uart1_uart_rbr_thr_dll[0] = d
#define IPROCPERIPH_UART1_UART_RBR_THR_DLLr_GET(r) (r).iprocperiph_uart1_uart_rbr_thr_dll[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROCPERIPH_UART1_UART_RBR_THR_DLLr_RBR_THR_DLLf_GET(r) (((r).iprocperiph_uart1_uart_rbr_thr_dll[0]) & 0xff)
#define IPROCPERIPH_UART1_UART_RBR_THR_DLLr_RBR_THR_DLLf_SET(r,f) (r).iprocperiph_uart1_uart_rbr_thr_dll[0]=(((r).iprocperiph_uart1_uart_rbr_thr_dll[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))

/*
 * These macros can be used to access IPROCPERIPH_UART1_UART_RBR_THR_DLL.
 */
#define READ_IPROCPERIPH_UART1_UART_RBR_THR_DLLr(u,r) bcm5607x_read32(u, R_IPROCPERIPH_UART1_UART_RBR_THR_DLL, &(r._iprocperiph_uart1_uart_rbr_thr_dll))
#define WRITE_IPROCPERIPH_UART1_UART_RBR_THR_DLLr(u,r) bcm5607x_write32(u, R_IPROCPERIPH_UART1_UART_RBR_THR_DLL, (r._iprocperiph_uart1_uart_rbr_thr_dll))

/*******************************************************************************
 * End of 'IPROCPERIPH_UART1_UART_RBR_THR_DLLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_0_127_96
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_0_127_96
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_0_127_96 CHIP_OTP_STATUS_0_127_96
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_0_127_96r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_0_127_96r is element of IPROC_WRAP_CHIP_OTP_STATUS_0 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_0_127_96.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_0_127_96r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_0_127_96[1];
	uint32 _iproc_wrap_chip_otp_status_0_127_96;
} IPROC_WRAP_CHIP_OTP_STATUS_0_127_96r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_0_127_96r_CLR(r) (r).iproc_wrap_chip_otp_status_0_127_96[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_0_127_96r_SET(r,d) (r).iproc_wrap_chip_otp_status_0_127_96[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_0_127_96r_GET(r) (r).iproc_wrap_chip_otp_status_0_127_96[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_0_127_96r_CHIP_OTP_STATUS_0_127_96f_GET(r) ((r).iproc_wrap_chip_otp_status_0_127_96[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_0_127_96r_CHIP_OTP_STATUS_0_127_96f_SET(r,f) (r).iproc_wrap_chip_otp_status_0_127_96[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_0_127_96.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_0_127_96r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_0_127_96, &(r._iproc_wrap_chip_otp_status_0_127_96))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_0_127_96r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_0_127_96, (r._iproc_wrap_chip_otp_status_0_127_96))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_0_127_96r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_0_31_0
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_0_31_0
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_0_31_0 CHIP_OTP_STATUS_0_31_0
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_0_31_0r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_0_31_0r is element of IPROC_WRAP_CHIP_OTP_STATUS_0 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_0_31_0.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_0_31_0r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_0_31_0[1];
	uint32 _iproc_wrap_chip_otp_status_0_31_0;
} IPROC_WRAP_CHIP_OTP_STATUS_0_31_0r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_0_31_0r_CLR(r) (r).iproc_wrap_chip_otp_status_0_31_0[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_0_31_0r_SET(r,d) (r).iproc_wrap_chip_otp_status_0_31_0[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_0_31_0r_GET(r) (r).iproc_wrap_chip_otp_status_0_31_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_0_31_0r_CHIP_OTP_STATUS_0_31_0f_GET(r) ((r).iproc_wrap_chip_otp_status_0_31_0[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_0_31_0r_CHIP_OTP_STATUS_0_31_0f_SET(r,f) (r).iproc_wrap_chip_otp_status_0_31_0[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_0_31_0.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_0_31_0r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_0_31_0, &(r._iproc_wrap_chip_otp_status_0_31_0))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_0_31_0r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_0_31_0, (r._iproc_wrap_chip_otp_status_0_31_0))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_0_31_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_0_63_32
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_0_63_32
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_0_63_32 CHIP_OTP_STATUS_0_63_32
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_0_63_32r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_0_63_32r is element of IPROC_WRAP_CHIP_OTP_STATUS_0 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_0_63_32.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_0_63_32r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_0_63_32[1];
	uint32 _iproc_wrap_chip_otp_status_0_63_32;
} IPROC_WRAP_CHIP_OTP_STATUS_0_63_32r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_0_63_32r_CLR(r) (r).iproc_wrap_chip_otp_status_0_63_32[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_0_63_32r_SET(r,d) (r).iproc_wrap_chip_otp_status_0_63_32[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_0_63_32r_GET(r) (r).iproc_wrap_chip_otp_status_0_63_32[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_0_63_32r_CHIP_OTP_STATUS_0_63_32f_GET(r) ((r).iproc_wrap_chip_otp_status_0_63_32[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_0_63_32r_CHIP_OTP_STATUS_0_63_32f_SET(r,f) (r).iproc_wrap_chip_otp_status_0_63_32[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_0_63_32.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_0_63_32r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_0_63_32, &(r._iproc_wrap_chip_otp_status_0_63_32))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_0_63_32r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_0_63_32, (r._iproc_wrap_chip_otp_status_0_63_32))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_0_63_32r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_0_95_64
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_0_95_64
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_0_95_64 CHIP_OTP_STATUS_0_95_64
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_0_95_64r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_0_95_64r is element of IPROC_WRAP_CHIP_OTP_STATUS_0 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_0_95_64.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_0_95_64r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_0_95_64[1];
	uint32 _iproc_wrap_chip_otp_status_0_95_64;
} IPROC_WRAP_CHIP_OTP_STATUS_0_95_64r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_0_95_64r_CLR(r) (r).iproc_wrap_chip_otp_status_0_95_64[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_0_95_64r_SET(r,d) (r).iproc_wrap_chip_otp_status_0_95_64[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_0_95_64r_GET(r) (r).iproc_wrap_chip_otp_status_0_95_64[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_0_95_64r_CHIP_OTP_STATUS_0_95_64f_GET(r) ((r).iproc_wrap_chip_otp_status_0_95_64[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_0_95_64r_CHIP_OTP_STATUS_0_95_64f_SET(r,f) (r).iproc_wrap_chip_otp_status_0_95_64[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_0_95_64.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_0_95_64r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_0_95_64, &(r._iproc_wrap_chip_otp_status_0_95_64))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_0_95_64r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_0_95_64, (r._iproc_wrap_chip_otp_status_0_95_64))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_0_95_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_1_127_96
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_1_127_96
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_1_127_96 CHIP_OTP_STATUS_1_127_96
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_1_127_96r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_1_127_96r is element of IPROC_WRAP_CHIP_OTP_STATUS_1 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_1_127_96.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_1_127_96r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_1_127_96[1];
	uint32 _iproc_wrap_chip_otp_status_1_127_96;
} IPROC_WRAP_CHIP_OTP_STATUS_1_127_96r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_1_127_96r_CLR(r) (r).iproc_wrap_chip_otp_status_1_127_96[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_1_127_96r_SET(r,d) (r).iproc_wrap_chip_otp_status_1_127_96[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_1_127_96r_GET(r) (r).iproc_wrap_chip_otp_status_1_127_96[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_1_127_96r_CHIP_OTP_STATUS_1_127_96f_GET(r) ((r).iproc_wrap_chip_otp_status_1_127_96[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_1_127_96r_CHIP_OTP_STATUS_1_127_96f_SET(r,f) (r).iproc_wrap_chip_otp_status_1_127_96[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_1_127_96.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_1_127_96r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_1_127_96, &(r._iproc_wrap_chip_otp_status_1_127_96))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_1_127_96r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_1_127_96, (r._iproc_wrap_chip_otp_status_1_127_96))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_1_127_96r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_1_31_0
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_1_31_0
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_1_31_0 CHIP_OTP_STATUS_1_31_0
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_1_31_0r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_1_31_0r is element of IPROC_WRAP_CHIP_OTP_STATUS_1 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_1_31_0.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_1_31_0r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_1_31_0[1];
	uint32 _iproc_wrap_chip_otp_status_1_31_0;
} IPROC_WRAP_CHIP_OTP_STATUS_1_31_0r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_1_31_0r_CLR(r) (r).iproc_wrap_chip_otp_status_1_31_0[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_1_31_0r_SET(r,d) (r).iproc_wrap_chip_otp_status_1_31_0[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_1_31_0r_GET(r) (r).iproc_wrap_chip_otp_status_1_31_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_1_31_0r_CHIP_OTP_STATUS_1_31_0f_GET(r) ((r).iproc_wrap_chip_otp_status_1_31_0[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_1_31_0r_CHIP_OTP_STATUS_1_31_0f_SET(r,f) (r).iproc_wrap_chip_otp_status_1_31_0[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_1_31_0.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_1_31_0r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_1_31_0, &(r._iproc_wrap_chip_otp_status_1_31_0))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_1_31_0r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_1_31_0, (r._iproc_wrap_chip_otp_status_1_31_0))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_1_31_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_1_63_32
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_1_63_32
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_1_63_32 CHIP_OTP_STATUS_1_63_32
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_1_63_32r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_1_63_32r is element of IPROC_WRAP_CHIP_OTP_STATUS_1 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_1_63_32.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_1_63_32r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_1_63_32[1];
	uint32 _iproc_wrap_chip_otp_status_1_63_32;
} IPROC_WRAP_CHIP_OTP_STATUS_1_63_32r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_1_63_32r_CLR(r) (r).iproc_wrap_chip_otp_status_1_63_32[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_1_63_32r_SET(r,d) (r).iproc_wrap_chip_otp_status_1_63_32[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_1_63_32r_GET(r) (r).iproc_wrap_chip_otp_status_1_63_32[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_1_63_32r_CHIP_OTP_STATUS_1_63_32f_GET(r) ((r).iproc_wrap_chip_otp_status_1_63_32[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_1_63_32r_CHIP_OTP_STATUS_1_63_32f_SET(r,f) (r).iproc_wrap_chip_otp_status_1_63_32[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_1_63_32.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_1_63_32r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_1_63_32, &(r._iproc_wrap_chip_otp_status_1_63_32))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_1_63_32r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_1_63_32, (r._iproc_wrap_chip_otp_status_1_63_32))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_1_63_32r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_1_95_64
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_1_95_64
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_1_95_64 CHIP_OTP_STATUS_1_95_64
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_1_95_64r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_1_95_64r is element of IPROC_WRAP_CHIP_OTP_STATUS_1 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_1_95_64.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_1_95_64r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_1_95_64[1];
	uint32 _iproc_wrap_chip_otp_status_1_95_64;
} IPROC_WRAP_CHIP_OTP_STATUS_1_95_64r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_1_95_64r_CLR(r) (r).iproc_wrap_chip_otp_status_1_95_64[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_1_95_64r_SET(r,d) (r).iproc_wrap_chip_otp_status_1_95_64[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_1_95_64r_GET(r) (r).iproc_wrap_chip_otp_status_1_95_64[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_1_95_64r_CHIP_OTP_STATUS_1_95_64f_GET(r) ((r).iproc_wrap_chip_otp_status_1_95_64[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_1_95_64r_CHIP_OTP_STATUS_1_95_64f_SET(r,f) (r).iproc_wrap_chip_otp_status_1_95_64[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_1_95_64.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_1_95_64r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_1_95_64, &(r._iproc_wrap_chip_otp_status_1_95_64))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_1_95_64r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_1_95_64, (r._iproc_wrap_chip_otp_status_1_95_64))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_1_95_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_2_127_96
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_2_127_96
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_2_127_96 CHIP_OTP_STATUS_2_127_96
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_2_127_96r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_2_127_96r is element of IPROC_WRAP_CHIP_OTP_STATUS_2 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_2_127_96.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_2_127_96r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_2_127_96[1];
	uint32 _iproc_wrap_chip_otp_status_2_127_96;
} IPROC_WRAP_CHIP_OTP_STATUS_2_127_96r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_2_127_96r_CLR(r) (r).iproc_wrap_chip_otp_status_2_127_96[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_2_127_96r_SET(r,d) (r).iproc_wrap_chip_otp_status_2_127_96[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_2_127_96r_GET(r) (r).iproc_wrap_chip_otp_status_2_127_96[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_2_127_96r_CHIP_OTP_STATUS_2_127_96f_GET(r) ((r).iproc_wrap_chip_otp_status_2_127_96[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_2_127_96r_CHIP_OTP_STATUS_2_127_96f_SET(r,f) (r).iproc_wrap_chip_otp_status_2_127_96[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_2_127_96.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_2_127_96r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_2_127_96, &(r._iproc_wrap_chip_otp_status_2_127_96))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_2_127_96r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_2_127_96, (r._iproc_wrap_chip_otp_status_2_127_96))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_2_127_96r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_2_31_0
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_2_31_0
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_2_31_0 CHIP_OTP_STATUS_2_31_0
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_2_31_0r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_2_31_0r is element of IPROC_WRAP_CHIP_OTP_STATUS_2 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_2_31_0.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_2_31_0r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_2_31_0[1];
	uint32 _iproc_wrap_chip_otp_status_2_31_0;
} IPROC_WRAP_CHIP_OTP_STATUS_2_31_0r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_2_31_0r_CLR(r) (r).iproc_wrap_chip_otp_status_2_31_0[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_2_31_0r_SET(r,d) (r).iproc_wrap_chip_otp_status_2_31_0[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_2_31_0r_GET(r) (r).iproc_wrap_chip_otp_status_2_31_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_2_31_0r_CHIP_OTP_STATUS_2_31_0f_GET(r) ((r).iproc_wrap_chip_otp_status_2_31_0[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_2_31_0r_CHIP_OTP_STATUS_2_31_0f_SET(r,f) (r).iproc_wrap_chip_otp_status_2_31_0[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_2_31_0.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_2_31_0r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_2_31_0, &(r._iproc_wrap_chip_otp_status_2_31_0))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_2_31_0r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_2_31_0, (r._iproc_wrap_chip_otp_status_2_31_0))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_2_31_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_2_63_32
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_2_63_32
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_2_63_32 CHIP_OTP_STATUS_2_63_32
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_2_63_32r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_2_63_32r is element of IPROC_WRAP_CHIP_OTP_STATUS_2 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_2_63_32.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_2_63_32r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_2_63_32[1];
	uint32 _iproc_wrap_chip_otp_status_2_63_32;
} IPROC_WRAP_CHIP_OTP_STATUS_2_63_32r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_2_63_32r_CLR(r) (r).iproc_wrap_chip_otp_status_2_63_32[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_2_63_32r_SET(r,d) (r).iproc_wrap_chip_otp_status_2_63_32[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_2_63_32r_GET(r) (r).iproc_wrap_chip_otp_status_2_63_32[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_2_63_32r_CHIP_OTP_STATUS_2_63_32f_GET(r) ((r).iproc_wrap_chip_otp_status_2_63_32[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_2_63_32r_CHIP_OTP_STATUS_2_63_32f_SET(r,f) (r).iproc_wrap_chip_otp_status_2_63_32[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_2_63_32.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_2_63_32r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_2_63_32, &(r._iproc_wrap_chip_otp_status_2_63_32))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_2_63_32r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_2_63_32, (r._iproc_wrap_chip_otp_status_2_63_32))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_2_63_32r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_2_95_64
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_2_95_64
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_2_95_64 CHIP_OTP_STATUS_2_95_64
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_2_95_64r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_2_95_64r is element of IPROC_WRAP_CHIP_OTP_STATUS_2 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_2_95_64.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_2_95_64r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_2_95_64[1];
	uint32 _iproc_wrap_chip_otp_status_2_95_64;
} IPROC_WRAP_CHIP_OTP_STATUS_2_95_64r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_2_95_64r_CLR(r) (r).iproc_wrap_chip_otp_status_2_95_64[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_2_95_64r_SET(r,d) (r).iproc_wrap_chip_otp_status_2_95_64[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_2_95_64r_GET(r) (r).iproc_wrap_chip_otp_status_2_95_64[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_2_95_64r_CHIP_OTP_STATUS_2_95_64f_GET(r) ((r).iproc_wrap_chip_otp_status_2_95_64[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_2_95_64r_CHIP_OTP_STATUS_2_95_64f_SET(r,f) (r).iproc_wrap_chip_otp_status_2_95_64[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_2_95_64.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_2_95_64r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_2_95_64, &(r._iproc_wrap_chip_otp_status_2_95_64))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_2_95_64r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_2_95_64, (r._iproc_wrap_chip_otp_status_2_95_64))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_2_95_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_3_127_96
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_3_127_96
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_3_127_96 CHIP_OTP_STATUS_3_127_96
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_3_127_96r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_3_127_96r is element of IPROC_WRAP_CHIP_OTP_STATUS_3 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_3_127_96.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_3_127_96r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_3_127_96[1];
	uint32 _iproc_wrap_chip_otp_status_3_127_96;
} IPROC_WRAP_CHIP_OTP_STATUS_3_127_96r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_3_127_96r_CLR(r) (r).iproc_wrap_chip_otp_status_3_127_96[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_3_127_96r_SET(r,d) (r).iproc_wrap_chip_otp_status_3_127_96[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_3_127_96r_GET(r) (r).iproc_wrap_chip_otp_status_3_127_96[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_3_127_96r_CHIP_OTP_STATUS_3_127_96f_GET(r) ((r).iproc_wrap_chip_otp_status_3_127_96[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_3_127_96r_CHIP_OTP_STATUS_3_127_96f_SET(r,f) (r).iproc_wrap_chip_otp_status_3_127_96[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_3_127_96.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_3_127_96r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_3_127_96, &(r._iproc_wrap_chip_otp_status_3_127_96))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_3_127_96r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_3_127_96, (r._iproc_wrap_chip_otp_status_3_127_96))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_3_127_96r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_3_31_0
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_3_31_0
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_3_31_0 CHIP_OTP_STATUS_3_31_0
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_3_31_0r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_3_31_0r is element of IPROC_WRAP_CHIP_OTP_STATUS_3 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_3_31_0.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_3_31_0r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_3_31_0[1];
	uint32 _iproc_wrap_chip_otp_status_3_31_0;
} IPROC_WRAP_CHIP_OTP_STATUS_3_31_0r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_3_31_0r_CLR(r) (r).iproc_wrap_chip_otp_status_3_31_0[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_3_31_0r_SET(r,d) (r).iproc_wrap_chip_otp_status_3_31_0[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_3_31_0r_GET(r) (r).iproc_wrap_chip_otp_status_3_31_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_3_31_0r_CHIP_OTP_STATUS_3_31_0f_GET(r) ((r).iproc_wrap_chip_otp_status_3_31_0[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_3_31_0r_CHIP_OTP_STATUS_3_31_0f_SET(r,f) (r).iproc_wrap_chip_otp_status_3_31_0[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_3_31_0.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_3_31_0r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_3_31_0, &(r._iproc_wrap_chip_otp_status_3_31_0))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_3_31_0r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_3_31_0, (r._iproc_wrap_chip_otp_status_3_31_0))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_3_31_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_3_63_32
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_3_63_32
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_3_63_32 CHIP_OTP_STATUS_3_63_32
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_3_63_32r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_3_63_32r is element of IPROC_WRAP_CHIP_OTP_STATUS_3 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_3_63_32.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_3_63_32r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_3_63_32[1];
	uint32 _iproc_wrap_chip_otp_status_3_63_32;
} IPROC_WRAP_CHIP_OTP_STATUS_3_63_32r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_3_63_32r_CLR(r) (r).iproc_wrap_chip_otp_status_3_63_32[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_3_63_32r_SET(r,d) (r).iproc_wrap_chip_otp_status_3_63_32[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_3_63_32r_GET(r) (r).iproc_wrap_chip_otp_status_3_63_32[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_3_63_32r_CHIP_OTP_STATUS_3_63_32f_GET(r) ((r).iproc_wrap_chip_otp_status_3_63_32[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_3_63_32r_CHIP_OTP_STATUS_3_63_32f_SET(r,f) (r).iproc_wrap_chip_otp_status_3_63_32[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_3_63_32.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_3_63_32r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_3_63_32, &(r._iproc_wrap_chip_otp_status_3_63_32))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_3_63_32r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_3_63_32, (r._iproc_wrap_chip_otp_status_3_63_32))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_3_63_32r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IPROC_WRAP_CHIP_OTP_STATUS_3_95_64
 * BLOCKS:   IPROC
 * DESC:     CHIP_OTP_STATUS_3_95_64
 * SIZE:     32
 * FIELDS:
 *     CHIP_OTP_STATUS_3_95_64 CHIP_OTP_STATUS_3_95_64
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_3_95_64r_SIZE 4

/* IPROC_WRAP_CHIP_OTP_STATUS_3_95_64r is element of IPROC_WRAP_CHIP_OTP_STATUS_3 */

/*
 * This structure should be used to declare and program IPROC_WRAP_CHIP_OTP_STATUS_3_95_64.
 */
typedef union IPROC_WRAP_CHIP_OTP_STATUS_3_95_64r_s {
	uint32 v[1];
	uint32 iproc_wrap_chip_otp_status_3_95_64[1];
	uint32 _iproc_wrap_chip_otp_status_3_95_64;
} IPROC_WRAP_CHIP_OTP_STATUS_3_95_64r_t;

#define IPROC_WRAP_CHIP_OTP_STATUS_3_95_64r_CLR(r) (r).iproc_wrap_chip_otp_status_3_95_64[0] = 0
#define IPROC_WRAP_CHIP_OTP_STATUS_3_95_64r_SET(r,d) (r).iproc_wrap_chip_otp_status_3_95_64[0] = d
#define IPROC_WRAP_CHIP_OTP_STATUS_3_95_64r_GET(r) (r).iproc_wrap_chip_otp_status_3_95_64[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_CHIP_OTP_STATUS_3_95_64r_CHIP_OTP_STATUS_3_95_64f_GET(r) ((r).iproc_wrap_chip_otp_status_3_95_64[0])
#define IPROC_WRAP_CHIP_OTP_STATUS_3_95_64r_CHIP_OTP_STATUS_3_95_64f_SET(r,f) (r).iproc_wrap_chip_otp_status_3_95_64[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_CHIP_OTP_STATUS_3_95_64.
 */
#define READ_IPROC_WRAP_CHIP_OTP_STATUS_3_95_64r(u,r) bcm5607x_read32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_3_95_64, &(r._iproc_wrap_chip_otp_status_3_95_64))
#define WRITE_IPROC_WRAP_CHIP_OTP_STATUS_3_95_64r(u,r) bcm5607x_write32(u, R_IPROC_WRAP_CHIP_OTP_STATUS_3_95_64, (r._iproc_wrap_chip_otp_status_3_95_64))

/*******************************************************************************
 * End of 'IPROC_WRAP_CHIP_OTP_STATUS_3_95_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IP_TO_CMICM_CREDIT_TRANSFER
 * BLOCKS:   IPIPE
 * DESC:     Controls the number of credits transferred from IP to CMICM for data transfer purposes.
 * SIZE:     32
 * FIELDS:
 *     NUM_OF_CREDITS   Number of 8 byte credits available for CMIC.
 *     TRANSFER_ENABLE  Enable the transfer of credits from IP to CMIC
 */
#define IP_TO_CMICM_CREDIT_TRANSFERr_SIZE 4

/*
 * This structure should be used to declare and program IP_TO_CMICM_CREDIT_TRANSFER.
 */
typedef union IP_TO_CMICM_CREDIT_TRANSFERr_s {
	uint32 v[1];
	uint32 ip_to_cmicm_credit_transfer[1];
	uint32 _ip_to_cmicm_credit_transfer;
} IP_TO_CMICM_CREDIT_TRANSFERr_t;

#define IP_TO_CMICM_CREDIT_TRANSFERr_CLR(r) (r).ip_to_cmicm_credit_transfer[0] = 0
#define IP_TO_CMICM_CREDIT_TRANSFERr_SET(r,d) (r).ip_to_cmicm_credit_transfer[0] = d
#define IP_TO_CMICM_CREDIT_TRANSFERr_GET(r) (r).ip_to_cmicm_credit_transfer[0]

/*
 * These macros can be used to access individual fields.
 */
#define IP_TO_CMICM_CREDIT_TRANSFERr_NUM_OF_CREDITSf_GET(r) (((r).ip_to_cmicm_credit_transfer[0]) & 0x3f)
#define IP_TO_CMICM_CREDIT_TRANSFERr_NUM_OF_CREDITSf_SET(r,f) (r).ip_to_cmicm_credit_transfer[0]=(((r).ip_to_cmicm_credit_transfer[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define IP_TO_CMICM_CREDIT_TRANSFERr_TRANSFER_ENABLEf_GET(r) ((((r).ip_to_cmicm_credit_transfer[0]) >> 6) & 0x1)
#define IP_TO_CMICM_CREDIT_TRANSFERr_TRANSFER_ENABLEf_SET(r,f) (r).ip_to_cmicm_credit_transfer[0]=(((r).ip_to_cmicm_credit_transfer[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))

/*
 * These macros can be used to access IP_TO_CMICM_CREDIT_TRANSFER.
 */
#define WRITE_IP_TO_CMICM_CREDIT_TRANSFERr(u,r) bcm5607x_reg_set(u,R_IP_TO_CMICM_CREDIT_TRANSFER,(r._ip_to_cmicm_credit_transfer))
#define READ_IP_TO_CMICM_CREDIT_TRANSFERr(u,r) bcm5607x_reg_get(u,R_IP_TO_CMICM_CREDIT_TRANSFER,&(r._ip_to_cmicm_credit_transfer))

/*******************************************************************************
 * End of 'IP_TO_CMICM_CREDIT_TRANSFERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IUNKNOWN_MCAST_BLOCK_MASK_HI_64
 * BLOCKS:   IPIPE
 * DESC:     Unknown Multicast Block Mask HIGH BITs
 * SIZE:     64
 * FIELDS:
 *     OVER_LO          Used for whole regsiter default value
 *     BLK_BITMAP       Bitmap of ports to be blocked. 1=Block, 0=Allow
 *     BLK_BITMAP_0     Overlay bitmap for ports. 1=Block, 0=Allow
 *     RESERVED         Reserved.
 *     OVER_HI          Used for whole regsiter default value
 */
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_SIZE 8

/*
 * This structure should be used to declare and program IUNKNOWN_MCAST_BLOCK_MASK_HI_64.
 */
typedef union IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_s {
	uint32 v[2];
	uint32 iunknown_mcast_block_mask_hi_64[2];
	uint32 _iunknown_mcast_block_mask_hi_64;
} IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_t;

#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_CLR(r) sal_memset(&((r)._iunknown_mcast_block_mask_hi_64), 0, sizeof(IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_t))
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_SET(r,i,d) (r).iunknown_mcast_block_mask_hi_64[i] = d
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_GET(r,i) (r).iunknown_mcast_block_mask_hi_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_OVER_LOf_GET(r) ((r).iunknown_mcast_block_mask_hi_64[0])
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_OVER_LOf_SET(r,f) (r).iunknown_mcast_block_mask_hi_64[0]=((uint32)f)
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_BLK_BITMAPf_GET(r) (((r).iunknown_mcast_block_mask_hi_64[0]) & 0x3)
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_BLK_BITMAPf_SET(r,f) (r).iunknown_mcast_block_mask_hi_64[0]=(((r).iunknown_mcast_block_mask_hi_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_BLK_BITMAP_0f_GET(r) (((r).iunknown_mcast_block_mask_hi_64[0]) & 0x3)
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_BLK_BITMAP_0f_SET(r,f) (r).iunknown_mcast_block_mask_hi_64[0]=(((r).iunknown_mcast_block_mask_hi_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_RESERVEDf_GET(r,a) field_get((r).iunknown_mcast_block_mask_hi_64,2,63,a)
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_RESERVEDf_SET(r,a) field_set((r).iunknown_mcast_block_mask_hi_64,2,63,a)
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_OVER_HIf_GET(r) ((r).iunknown_mcast_block_mask_hi_64[1])
#define IUNKNOWN_MCAST_BLOCK_MASK_HI_64r_OVER_HIf_SET(r,f) (r).iunknown_mcast_block_mask_hi_64[1]=((uint32)f)

/*
 * These macros can be used to access IUNKNOWN_MCAST_BLOCK_MASK_HI_64.
 */
#define WRITE_IUNKNOWN_MCAST_BLOCK_MASK_HI_64r(u,p,r) bcm5607x_reg64_set(u,R_IUNKNOWN_MCAST_BLOCK_MASK_HI_64(p),&(r._iunknown_mcast_block_mask_hi_64),2)
#define READ_IUNKNOWN_MCAST_BLOCK_MASK_HI_64r(u,p,r) bcm5607x_reg64_get(u,R_IUNKNOWN_MCAST_BLOCK_MASK_HI_64(p),&(r._iunknown_mcast_block_mask_hi_64),2)

/*******************************************************************************
 * End of 'IUNKNOWN_MCAST_BLOCK_MASK_HI_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IUNKNOWN_MCAST_BLOCK_MASK_LO_64
 * BLOCKS:   IPIPE
 * DESC:     Unknown Multicast Block Mask LOW BITs
 * SIZE:     64
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked. 1=Block, 0=Allow
 *     BLK_BITMAP_0     Overlay bitmap for ports. 1=Block, 0=Allow
 *     OVER_LO          Used for whole regsiter default value
 *     OVER_HI          Used for whole regsiter default value
 */
#define IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_SIZE 8

/*
 * This structure should be used to declare and program IUNKNOWN_MCAST_BLOCK_MASK_LO_64.
 */
typedef union IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_s {
	uint32 v[2];
	uint32 iunknown_mcast_block_mask_lo_64[2];
	uint32 _iunknown_mcast_block_mask_lo_64;
} IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_t;

#define IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_CLR(r) sal_memset(&((r)._iunknown_mcast_block_mask_lo_64), 0, sizeof(IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_t))
#define IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_SET(r,i,d) (r).iunknown_mcast_block_mask_lo_64[i] = d
#define IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_GET(r,i) (r).iunknown_mcast_block_mask_lo_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_BLK_BITMAPf_GET(r,a) field_get((r).iunknown_mcast_block_mask_lo_64,0,63,a)
#define IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_BLK_BITMAPf_SET(r,a) field_set((r).iunknown_mcast_block_mask_lo_64,0,63,a)
#define IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_BLK_BITMAP_0f_GET(r,a) field_get((r).iunknown_mcast_block_mask_lo_64,0,63,a)
#define IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_BLK_BITMAP_0f_SET(r,a) field_set((r).iunknown_mcast_block_mask_lo_64,0,63,a)
#define IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_OVER_LOf_GET(r) ((r).iunknown_mcast_block_mask_lo_64[0])
#define IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_OVER_LOf_SET(r,f) (r).iunknown_mcast_block_mask_lo_64[0]=((uint32)f)
#define IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_OVER_HIf_GET(r) ((r).iunknown_mcast_block_mask_lo_64[1])
#define IUNKNOWN_MCAST_BLOCK_MASK_LO_64r_OVER_HIf_SET(r,f) (r).iunknown_mcast_block_mask_lo_64[1]=((uint32)f)

/*
 * These macros can be used to access IUNKNOWN_MCAST_BLOCK_MASK_LO_64.
 */
#define WRITE_IUNKNOWN_MCAST_BLOCK_MASK_LO_64r(u,p,r) bcm5607x_reg64_set(u,R_IUNKNOWN_MCAST_BLOCK_MASK_LO_64(p),&(r._iunknown_mcast_block_mask_lo_64),2)
#define READ_IUNKNOWN_MCAST_BLOCK_MASK_LO_64r(u,p,r) bcm5607x_reg64_get(u,R_IUNKNOWN_MCAST_BLOCK_MASK_LO_64(p),&(r._iunknown_mcast_block_mask_lo_64),2)

/*******************************************************************************
 * End of 'IUNKNOWN_MCAST_BLOCK_MASK_LO_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IUNKNOWN_UCAST_BLOCK_MASK_HI_64
 * BLOCKS:   IPIPE
 * DESC:     Unknown Unicast Block Mask HIGH BITs
 * SIZE:     64
 * FIELDS:
 *     OVER_LO          Used for whole regsiter default value
 *     BLK_BITMAP       Bitmap of ports to be blocked. 1=Block, 0=Allow
 *     BLK_BITMAP_0     Overlay bitmap for ports. 1=Block, 0=Allow
 *     RESERVED         Reserved.
 *     OVER_HI          Used for whole regsiter default value
 */
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_SIZE 8

/*
 * This structure should be used to declare and program IUNKNOWN_UCAST_BLOCK_MASK_HI_64.
 */
typedef union IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_s {
	uint32 v[2];
	uint32 iunknown_ucast_block_mask_hi_64[2];
	uint32 _iunknown_ucast_block_mask_hi_64;
} IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_t;

#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_CLR(r) sal_memset(&((r)._iunknown_ucast_block_mask_hi_64), 0, sizeof(IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_t))
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_SET(r,i,d) (r).iunknown_ucast_block_mask_hi_64[i] = d
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_GET(r,i) (r).iunknown_ucast_block_mask_hi_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_OVER_LOf_GET(r) ((r).iunknown_ucast_block_mask_hi_64[0])
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_OVER_LOf_SET(r,f) (r).iunknown_ucast_block_mask_hi_64[0]=((uint32)f)
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_BLK_BITMAPf_GET(r) (((r).iunknown_ucast_block_mask_hi_64[0]) & 0x3)
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_BLK_BITMAPf_SET(r,f) (r).iunknown_ucast_block_mask_hi_64[0]=(((r).iunknown_ucast_block_mask_hi_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_BLK_BITMAP_0f_GET(r) (((r).iunknown_ucast_block_mask_hi_64[0]) & 0x3)
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_BLK_BITMAP_0f_SET(r,f) (r).iunknown_ucast_block_mask_hi_64[0]=(((r).iunknown_ucast_block_mask_hi_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_RESERVEDf_GET(r,a) field_get((r).iunknown_ucast_block_mask_hi_64,2,63,a)
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_RESERVEDf_SET(r,a) field_set((r).iunknown_ucast_block_mask_hi_64,2,63,a)
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_OVER_HIf_GET(r) ((r).iunknown_ucast_block_mask_hi_64[1])
#define IUNKNOWN_UCAST_BLOCK_MASK_HI_64r_OVER_HIf_SET(r,f) (r).iunknown_ucast_block_mask_hi_64[1]=((uint32)f)

/*
 * These macros can be used to access IUNKNOWN_UCAST_BLOCK_MASK_HI_64.
 */
#define WRITE_IUNKNOWN_UCAST_BLOCK_MASK_HI_64r(u,p,r) bcm5607x_reg64_set(u,R_IUNKNOWN_UCAST_BLOCK_MASK_HI_64(p),&(r._iunknown_ucast_block_mask_hi_64),2)
#define READ_IUNKNOWN_UCAST_BLOCK_MASK_HI_64r(u,p,r) bcm5607x_reg64_get(u,R_IUNKNOWN_UCAST_BLOCK_MASK_HI_64(p),&(r._iunknown_ucast_block_mask_hi_64),2)

/*******************************************************************************
 * End of 'IUNKNOWN_UCAST_BLOCK_MASK_HI_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  IUNKNOWN_UCAST_BLOCK_MASK_LO_64
 * BLOCKS:   IPIPE
 * DESC:     Unknown Unicast Block Mask LOW BITs
 * SIZE:     64
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked. 1=Block, 0=Allow
 *     BLK_BITMAP_0     Overlay bitmap for ports. 1=Block, 0=Allow
 *     OVER_LO          Used for whole regsiter default value
 *     OVER_HI          Used for whole regsiter default value
 */
#define IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_SIZE 8

/*
 * This structure should be used to declare and program IUNKNOWN_UCAST_BLOCK_MASK_LO_64.
 */
typedef union IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_s {
	uint32 v[2];
	uint32 iunknown_ucast_block_mask_lo_64[2];
	uint32 _iunknown_ucast_block_mask_lo_64;
} IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_t;

#define IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_CLR(r) sal_memset(&((r)._iunknown_ucast_block_mask_lo_64), 0, sizeof(IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_t))
#define IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_SET(r,i,d) (r).iunknown_ucast_block_mask_lo_64[i] = d
#define IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_GET(r,i) (r).iunknown_ucast_block_mask_lo_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_BLK_BITMAPf_GET(r,a) field_get((r).iunknown_ucast_block_mask_lo_64,0,63,a)
#define IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_BLK_BITMAPf_SET(r,a) field_set((r).iunknown_ucast_block_mask_lo_64,0,63,a)
#define IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_BLK_BITMAP_0f_GET(r,a) field_get((r).iunknown_ucast_block_mask_lo_64,0,63,a)
#define IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_BLK_BITMAP_0f_SET(r,a) field_set((r).iunknown_ucast_block_mask_lo_64,0,63,a)
#define IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_OVER_LOf_GET(r) ((r).iunknown_ucast_block_mask_lo_64[0])
#define IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_OVER_LOf_SET(r,f) (r).iunknown_ucast_block_mask_lo_64[0]=((uint32)f)
#define IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_OVER_HIf_GET(r) ((r).iunknown_ucast_block_mask_lo_64[1])
#define IUNKNOWN_UCAST_BLOCK_MASK_LO_64r_OVER_HIf_SET(r,f) (r).iunknown_ucast_block_mask_lo_64[1]=((uint32)f)

/*
 * These macros can be used to access IUNKNOWN_UCAST_BLOCK_MASK_LO_64.
 */
#define WRITE_IUNKNOWN_UCAST_BLOCK_MASK_LO_64r(u,p,r) bcm5607x_reg64_set(u,R_IUNKNOWN_UCAST_BLOCK_MASK_LO_64(p),&(r._iunknown_ucast_block_mask_lo_64),2)
#define READ_IUNKNOWN_UCAST_BLOCK_MASK_LO_64r(u,p,r) bcm5607x_reg64_get(u,R_IUNKNOWN_UCAST_BLOCK_MASK_LO_64(p),&(r._iunknown_ucast_block_mask_lo_64),2)

/*******************************************************************************
 * End of 'IUNKNOWN_UCAST_BLOCK_MASK_LO_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  L2MC
 * BLOCKS:   IPIPE
 * DESC:     L2 Multicast table
The multicast table is 1024 entries deep and 76 bits wide. If the destination MAC address is a multicast address, then the result of the destination lookup is a 10-bit index (L2MC_PTR) into this table. The result of the direct index into the L2 multicast table is a bitmap that indicates which ports on the local switch should receive the packet. The MC Port Bitmap is qualified with the VLAN bitmap. The MC Port bitmap is picked up from the L2MC table
 * SIZE:     76
 * FIELDS:
 *     HIGIG_TRUNK_OVERRIDE Higig Trunk Override indicationWhen set, indicates the HiGig port bitmap cannot be modified by HiGig trunking logic
 *     PORT_BITMAP      Multicast port membership bitmap
 *     PORT_BITMAP_LO   Multicast port membership
 *     VALID            Indicates that the entry is valid
 *     EVEN_PARITY      Even parity bit
 */
#define L2MCm_MIN 0
#define L2MCm_MAX 1023
#define L2MCm_CMAX(u) 1023
#define L2MCm_SIZE 10

/*
 * This structure should be used to declare and program L2MC.
 */
typedef union L2MCm_s {
	uint32 v[3];
	uint32 l2mc[3];
	uint32 _l2mc;
} L2MCm_t;

#define L2MCm_CLR(r) sal_memset(&((r)._l2mc), 0, sizeof(L2MCm_t))
#define L2MCm_SET(r,i,d) (r).l2mc[i] = d
#define L2MCm_GET(r,i) (r).l2mc[i]

/*
 * These macros can be used to access individual fields.
 */
#define L2MCm_HIGIG_TRUNK_OVERRIDEf_GET(r) (((r).l2mc[0]) & 0xff)
#define L2MCm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define L2MCm_PORT_BITMAPf_GET(r,a) field_get((r).l2mc,8,73,a)
#define L2MCm_PORT_BITMAPf_SET(r,a) field_set((r).l2mc,8,73,a)
#define L2MCm_PORT_BITMAP_LOf_GET(r,a) field_get((r).l2mc,8,73,a)
#define L2MCm_PORT_BITMAP_LOf_SET(r,a) field_set((r).l2mc,8,73,a)
#define L2MCm_VALIDf_GET(r) ((((r).l2mc[2]) >> 10) & 0x1)
#define L2MCm_VALIDf_SET(r,f) (r).l2mc[2]=(((r).l2mc[2] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define L2MCm_EVEN_PARITYf_GET(r) ((((r).l2mc[2]) >> 11) & 0x1)
#define L2MCm_EVEN_PARITYf_SET(r,f) (r).l2mc[2]=(((r).l2mc[2] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))

/*
 * These macros can be used to access L2MC.
 */
#define WRITE_L2MCm(u,i,r) bcm5607x_mem_set(u, M_L2MC(i), &(r._l2mc), 3)
#define READ_L2MCm(u,i,r) bcm5607x_mem_get(u, M_L2MC(i), &(r._l2mc), 3)

/*******************************************************************************
 * End of 'L2MCm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  L2_AGE_TIMER
 * BLOCKS:   IPIPE
 * DESC:     Age Timer Register
 * SIZE:     32
 * FIELDS:
 *     AGE_VAL          Age Limit. Value is the age timer in units of 1 second to age dynamic entries. Default is 300 seconds. When aging is first enabled, it may take up to three times the AGE_VAL for aging to occur because AGE_ENA is asynchronous to the internal timers. Note: IEEE 802.1d specification range is 10 to 1,000,000 seconds.
 *     AGE_ENA          Age Enable
 */
#define L2_AGE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program L2_AGE_TIMER.
 */
typedef union L2_AGE_TIMERr_s {
	uint32 v[1];
	uint32 l2_age_timer[1];
	uint32 _l2_age_timer;
} L2_AGE_TIMERr_t;

#define L2_AGE_TIMERr_CLR(r) (r).l2_age_timer[0] = 0
#define L2_AGE_TIMERr_SET(r,d) (r).l2_age_timer[0] = d
#define L2_AGE_TIMERr_GET(r) (r).l2_age_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define L2_AGE_TIMERr_AGE_VALf_GET(r) (((r).l2_age_timer[0]) & 0xfffff)
#define L2_AGE_TIMERr_AGE_VALf_SET(r,f) (r).l2_age_timer[0]=(((r).l2_age_timer[0] & ~((uint32)0xfffff)) | (((uint32)f) & 0xfffff))
#define L2_AGE_TIMERr_AGE_ENAf_GET(r) ((((r).l2_age_timer[0]) >> 20) & 0x1)
#define L2_AGE_TIMERr_AGE_ENAf_SET(r,f) (r).l2_age_timer[0]=(((r).l2_age_timer[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))

/*
 * These macros can be used to access L2_AGE_TIMER.
 */
#define WRITE_L2_AGE_TIMERr(u,r) bcm5607x_reg_set(u,R_L2_AGE_TIMER,(r._l2_age_timer))
#define READ_L2_AGE_TIMERr(u,r) bcm5607x_reg_get(u,R_L2_AGE_TIMER,&(r._l2_age_timer))

/*******************************************************************************
 * End of 'L2_AGE_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  L2_AUX_HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2_AUX_HASH_CONTROL Register. Enable dual hashing mode for the L2 table. The hashing mode in this register is for the second group of L2 tables. The hashing mode for first group of L2 tables is controlled via the HASH_SELECT register. 
 * SIZE:     32
 * FIELDS:
 *     INSERT_LEAST_FULL_HALF If set to 1, insert entry into the least full half of the hash location.
 *     HASH_SELECT      Select hashing modes for the L2 table second group lookup.
 *     ENABLE           If set, enables the dual hashing feature. This is to improve the first miss utilization.
 */
#define L2_AUX_HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2_AUX_HASH_CONTROL.
 */
typedef union L2_AUX_HASH_CONTROLr_s {
	uint32 v[1];
	uint32 l2_aux_hash_control[1];
	uint32 _l2_aux_hash_control;
} L2_AUX_HASH_CONTROLr_t;

#define L2_AUX_HASH_CONTROLr_CLR(r) (r).l2_aux_hash_control[0] = 0
#define L2_AUX_HASH_CONTROLr_SET(r,d) (r).l2_aux_hash_control[0] = d
#define L2_AUX_HASH_CONTROLr_GET(r) (r).l2_aux_hash_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define L2_AUX_HASH_CONTROLr_INSERT_LEAST_FULL_HALFf_GET(r) (((r).l2_aux_hash_control[0]) & 0x1)
#define L2_AUX_HASH_CONTROLr_INSERT_LEAST_FULL_HALFf_SET(r,f) (r).l2_aux_hash_control[0]=(((r).l2_aux_hash_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_AUX_HASH_CONTROLr_HASH_SELECTf_GET(r) ((((r).l2_aux_hash_control[0]) >> 1) & 0x7)
#define L2_AUX_HASH_CONTROLr_HASH_SELECTf_SET(r,f) (r).l2_aux_hash_control[0]=(((r).l2_aux_hash_control[0] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define L2_AUX_HASH_CONTROLr_ENABLEf_GET(r) ((((r).l2_aux_hash_control[0]) >> 4) & 0x1)
#define L2_AUX_HASH_CONTROLr_ENABLEf_SET(r,f) (r).l2_aux_hash_control[0]=(((r).l2_aux_hash_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))

/*
 * These macros can be used to access L2_AUX_HASH_CONTROL.
 */
#define WRITE_L2_AUX_HASH_CONTROLr(u,r) bcm5607x_reg_set(u,R_L2_AUX_HASH_CONTROL,(r._l2_aux_hash_control))
#define READ_L2_AUX_HASH_CONTROLr(u,r) bcm5607x_reg_get(u,R_L2_AUX_HASH_CONTROL,&(r._l2_aux_hash_control))

/*******************************************************************************
 * End of 'L2_AUX_HASH_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  L2_ENTRY
 * BLOCKS:   IPIPE
 * DESC:     Combined HW-managed L2 entry table. Includes L2_ENTRY, SR_L2_ENTRY, L2_HITDA, and L2_HITSA. This table and the four tables it includes are hashed tables. The fields used for the hash depends on the definition specified in KEY_TYPE. To manipulate and look up entries in the table, please use S-channel Message OPCODES TBL_INS, TBL_DEL and TBL_LKUP.
 * SIZE:     173
 * FIELDS:
 *     KEY_TYPE         KEY: Key type
 *     LEGACY:OVID      KEY TYPE 1 or 2: OVID
 *     LEGACY:VLAN_ID   KEY TYPE 0: VLAN ID
 *     LEGACY:VFI       Virtual Forwarding Index. Valid values are 0 to 1K-1.
 *     LEGACY:RESERVED_VFI Reserved field due to VFI width reduction.
 *     LEGACY:MAC_ADDR  KEY TYPE 0: MAC address
 *     LEGACY:IVID      KEY TYPE 2: IVID
 *     LEGACY:DESTINATION_1 Destination fields for KEY_TYPE = 1 and 2
 *     LEGACY:PORT_NUM_1 Port if T_1==0
 *     LEGACY:TGID_1    Trunk ID value if T_1==1
 *     LEGACY:MODULE_ID_1 Module ID if T_1==0
 *     LEGACY:REMOTE_TRUNK_1 When T_1==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     LEGACY:T_1       Indicates destination is a LAG
 *     LEGACY:ASSOCIATED_DATA Entire associated data for KEY_TYPE = 0
 *     LEGACY:DESTINATION Destination fields for KEY_TYPE = 0, 1 and 2
 *     LEGACY:VPG       Reserved
 *     LEGACY:L2MC_PTR  L2MC pointer if MAC_ADDR[40]==1
 *     LEGACY:NHI_ECMP  NHI/ ECMP pointer.
 *     LEGACY:PORT_NUM  Port if T==0
 *     LEGACY:TGID      Trunk ID value if T==1
 *     LEGACY:MODULE_ID Module ID if T==0
 *     LEGACY:RESERVED_L2MC_PTR Reserved field due to L2MC PTR width reduction.
 *     LEGACY:REMOTE_TRUNK When T==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     LEGACY:DEST_TYPE Indicates destination type.		    For VLAN-based keys:		    00 = {MODID, PORT} or L2MC_index		    01 = {'0', TGID} or L2MC_index		    #10 = GPON DVPG		    11 = GPON Multicast (L3MC_index)		    		    #For VFI-based keys:		    #10 = VPLS DVP		    #11 = VPLS Multicast (L3MC_index)		    For VXLAN-based keys:		    100 = NHI		    101 = ECMP		    110 = IPMC 
 *     LEGACY:T         Trunk bit(overlay)Indicates destination is a LAG
 *     LEGACY:CLASS_ID  L2 Classification ID used for ingress ContentAware engine
 *     LEGACY:MAC_BLOCK_INDEX This field indicates the index into the PORT_MAC Block Index
 *     LEGACY:DUMMY_INDEX Reserved when using CLASS_ID overlay
 *     LEGACY:RPE       Remap Priority Enable bit0 = Do not use the IEEE 802.1p priority from L2_ENTRY.PRI. Recommended setting when the priority is to be obtained from the VLAN tables or the PORT table for untagged packets.1 = Use the IEEE 802.1p priority from the L2_ENTRY.PRI field. This overwrites any priority obtained from the VLAN tables or the default priority from the PORT table. This is applicable for untagged packets and for tagged packets when PORT.MAP_TAG_PACKET_PRIORITYT=1.
 *     LEGACY:MIRROR    Mirror bit
 *     LEGACY:MIRROR0   Mirror container bitmap to enable egress mirroring Egress mirror port bitmaps are defined in EMIRROR_CONTROL table
 *     LEGACY:PRI       Identifies the priority of the packet. Used when L2_ENTRY.RPE=1
 *     LEGACY:CPU       Sends the packet to the CPU when set
 *     LEGACY:DST_DISCARD Destination DiscardThis bit identifies whether the packet should be discarded based on the the destination address. Set to discard
 *     LEGACY:SRC_DISCARD Source DiscardThis bit identifies whether the packet should be discarded based on the the source address. Set to discard
 *     LEGACY:SCP       Source CoS PriorityIf this bit is set in the matched source entry, the source CoS has priority over destination CoS
 *     LEGACY:LIMIT_COUNTED Indicates if entry is counted for MAC limits.  CPU INSERT can set/reset for new entry as needed/  HW LEARNs always set this bit.
 *     LEGACY:REMOTE    Indicates if entry is learned from a local port (0) or a remote port (1).  Note: CPU must set this field correctly for CPU INSERT commands.
 *     LEGACY:STATIC_BIT Indicates entry is software programmed and static
 *     LEGACY:PENDING   Indicates that the entry is pending validation from software
 *     LEGACY:TAF_GATE_ID_PROFILE Gate ID Profile used to lookup GATE_ID.
 *     LEGACY:RESERVED_108 Reserved.
 *     L2:VLAN_ID       KEY TYPE 0: VLAN ID
 *     L2:VFI           Virtual Forwarding Index. Valid values are 0 to 1K-1.
 *     L2:MAC_ADDR      KEY TYPE 0: MAC address
 *     L2:ASSOCIATED_DATA Entire associated data for KEY_TYPE = 0
 *     L2:DESTINATION   Destination fields for KEY_TYPE = 0, 1 and 2
 *     L2:L2MC_PTR      L2MC pointer if MAC_ADDR[40]==1
 *     L2:NHI_ECMP      NHI/ ECMP pointer.
 *     L2:PORT_NUM      Port if T==0
 *     L2:TGID          Trunk ID value if T==1
 *     L2:MODULE_ID     Module ID if T==0
 *     L2:REMOTE_TRUNK  When T==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     L2:DEST_TYPE     Indicates destination type.		    For VLAN-based keys:		    00 = {MODID, PORT} or L2MC_index		    01 = {'0', TGID} or L2MC_index		    #10 = GPON DVPG		    11 = GPON Multicast (L3MC_index)		    		    #For VFI-based keys:		    #10 = VPLS DVP		    #11 = VPLS Multicast (L3MC_index)		    For VXLAN-based keys:		    100 = NHI		    101 = ECMP		    110 = IPMC 
 *     L2:T             Trunk bit(overlay)Indicates destination is a LAG
 *     L2:CLASS_ID      L2 Classification ID used for ingress ContentAware engine
 *     L2:MAC_BLOCK_INDEX This field indicates the index into the PORT_MAC_BLOCK table
 *     L2:DUMMY_INDEX   Reserved when using CLASS_ID overlay
 *     L2:RPE           Remap Priority Enable bit 0 = Do not use the IEEE 802.1p priority from L2_ENTRY.PRI. Recommended setting when the priority is to be obtained from the VLAN tables or the PORT table for untagged packets. 1 = Use the IEEE 802.1p priority from the L2_ENTRY.PRI field. This overwrites any priority obtained from the VLAN tables or the default priority from the PORT table. This is applicable for untagged packets and for tagged packets when PORT.MAP_TAG_PACKET_PRIORITYT=1.
 *     L2:MIRROR        Mirror container bitmap to enable egress mirroring Egress mirror port bitmaps are defined in EMIRROR_CONTROL table 
 *     L2:MIRROR0       Mirror bit
 *     L2:PRI           PRI Identifies the priority of the packet. Used when L2_ENTRY.RPE=1
 *     L2:CPU           Sends the packet to CPU when set
 *     L2:DST_DISCARD   Destination DiscardThis bit identifies whether the packet should be discarded based on the the destination address. Set to discard
 *     L2:SRC_DISCARD   Source DiscardThis bit identifies whether the packet should be discarded based on the the source address. Set to discard
 *     L2:SCP           Source CoS PriorityIf this bit is set in the matched source entry, the source CoS has priority over destination CoS 
 *     L2:LIMIT_COUNTED Indicates if entry is counted for MAC limits.  CPU INSERT can set/reset for new entry as needed/  HW LEARNs always set this bit.
 *     L2:REMOTE        Indicates if entry is learned from a local port (0) or a remote port (1).  Note: CPU must set this field correctly for CPU INSERT commands.
 *     L2:STATIC_BIT    Indicates entry is SW programmed and static
 *     L2:PENDING       Indicates that the entry is pending validation from software
 *     L2:TAF_GATE_ID_PROFILE Gate ID Profile used to lookup GATE_ID.
 *     L2:RESERVED_108  Reserved.
 *     VLAN:OVID        KEY TYPE 1 or 2: OVID
 *     VLAN:IVID        KEY TYPE 2: IVID
 *     VLAN:DESTINATION_1 Destination fields for KEY_TYPE = 1 and 2
 *     VLAN:PORT_NUM_1  Port if T_1==0
 *     VLAN:TGID_1      Trunk ID value if T_1==1
 *     VLAN:MODULE_ID_1 Module ID if T_1==0
 *     VLAN:REMOTE_TRUNK_1 When T_1==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     VLAN:T_1         Indicates destination is a LAG
 *     VLAN:DESTINATION Destination fields for KEY_TYPE = 0, 1 and 2
 *     VLAN:PORT_NUM    Port if T==0
 *     VLAN:TGID        Trunk ID value if T==1
 *     VLAN:MODULE_ID   Module ID if T==0
 *     VLAN:REMOTE_TRUNK When T==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     VLAN:DEST_TYPE   Indicates destination type.		    For VLAN-based keys:		    00 = {MODID, PORT} or L2MC_index		    01 = {'0', TGID} or L2MC_index		    #10 = GPON DVPG		    11 = GPON Multicast (L3MC_index)		    		    #For VFI-based keys:		    #10 = VPLS DVP		    #11 = VPLS Multicast (L3MC_index)
 *     VLAN:T           Trunk bit(overlay)Indicates destination is a LAG
 *     VLAN:CLASS_ID    L2 Classification ID used for ingress ContentAware egnine
 *     VLAN:MAC_BLOCK_INDEX This field indicates the index into the PORT_MAC_BLOCK table
 *     VLAN:DUMMY_INDEX Reserved when using CLASS_ID overlay
 *     VLAN:RPE         Remap Priority Enable bit0 = Do not use the IEEE 802.1p priority from L2_ENTRY.PRI. Recommended setting when the priority is to be obtained from the VLAN tables or the PORT table for untagged packets.1 = Use the IEEE 802.1p priority from the L2_ENTRY.PRI field. This overwrites any priority obtained from the VLAN tables or the default priority from the PORT table. This is applicable for untagged packets and for tagged packets when PORT.MAP_TAG_PACKET_PRIORITYT=1.
 *     VLAN:MIRROR      MIRROR Mirror container bitmap to enable egress mirroring Egress mirror port bitmaps are defined in EMIRROR_CONTROL table
 *     VLAN:MIRROR0     Mirror bit
 *     VLAN:PRI         Identifies the priority of the packet. Used when L2_ENTRY.RPE=1
 *     VLAN:CPU         Sends the packet to the CPU when set
 *     VLAN:DST_DISCARD DISCARD Destination Discard This bit identifies whether the packet should be discarded based on the the destination address. Set to discard
 *     VLAN:SRC_DISCARD DISCARD Source Discard This bit identifies whether the packet should be discarded based on the the source address. Set to discard
 *     VLAN:SCP         Source CoS PriorityIf this bit is set in the matched source entry, the source CoS has priority over destination CoS
 *     VLAN:LIMIT_COUNTED Indicates if entry is counted for MAC limits.  CPU INSERT can set/reset for new entry as needed/  HW LEARNs always set this bit.
 *     VLAN:REMOTE      Indicates if entry is learned from a local port (0) or a remote port (1).  Note: CPU must set this field correctly for CPU INSERT commands.
 *     VLAN:STATIC_BIT  Indicates entry is software programmed and static
 *     VLAN:PENDING     Indicates that the entry is pending validation from software
 *     VLAN:TAF_GATE_ID_PROFILE Gate ID Profile used to lookup GATE_ID.
 *     VLAN:RESERVED_108 Reserved.
 *     VFI:KEY          Key for KEY_TYPE = VFI.
 *     VFI:VLAN_ID      KEY TYPE 0: VLAN ID
 *     VFI:VFI          Virtual Forwarding Index. Valid values are 0 to 1K-1.
 *     VFI:MAC_ADDR     KEY TYPE 0: MAC address
 *     VFI:ASSOCIATED_DATA Entire associated data for KEY_TYPE = 0
 *     VFI:DESTINATION  Destination fields for KEY_TYPE = 0, 1 and 2
 *     VFI:L2MC_PTR     L2MC pointer if MAC_ADDR[40]==1
 *     VFI:NHI_ECMP     NHI/ ECMP pointer.
 *     VFI:PORT_NUM     Port if T==0
 *     VFI:TGID         Trunk ID value if T==1
 *     VFI:MODULE_ID    Module ID if T==0
 *     VFI:REMOTE_TRUNK When T==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     VFI:DEST_TYPE    Indicates destination type.		    For VLAN-based keys:		    00 = {MODID, PORT} or L2MC_index		    01 = {'0', TGID} or L2MC_index		    #10 = GPON DVPG		    11 = GPON Multicast (L3MC_index)		    		    #For VFI-based keys:		    #10 = VPLS DVP		    #11 = VPLS Multicast (L3MC_index)		    For VXLAN-based keys:		    100 = NHI		    101 = ECMP		    110 = IPMC 
 *     VFI:T            Trunk bit(overlay)Indicates destination is a LAG
 *     VFI:CLASS_ID     L2 Classification ID used for ingress ContentAware engine
 *     VFI:MAC_BLOCK_INDEX This field indicates the index into the PORT_MAC_BLOCK table
 *     VFI:DUMMY_INDEX  Reserved when using CLASS_ID overlay
 *     VFI:RPE          Remap Priority Enable bit 0 = Do not use the IEEE 802.1p priority from L2_ENTRY.PRI. Recommended setting when the priority is to be obtained from the VLAN tables or the PORT table for untagged packets. 1 = Use the IEEE 802.1p priority from the L2_ENTRY.PRI field. This overwrites any priority obtained from the VLAN tables or the default priority from the PORT table. This is applicable for untagged packets and for tagged packets when PORT.MAP_TAG_PACKET_PRIORITYT=1.
 *     VFI:MIRROR       Mirror container bitmap to enable egress mirroring Egress mirror port bitmaps are defined in EMIRROR_CONTROL table 
 *     VFI:MIRROR0      Mirror bit
 *     VFI:PRI          PRI Identifies the priority of the packet. Used when L2_ENTRY.RPE=1
 *     VFI:CPU          Sends the packet to CPU when set
 *     VFI:DST_DISCARD  Destination DiscardThis bit identifies whether the packet should be discarded based on the the destination address. Set to discard
 *     VFI:SRC_DISCARD  Source DiscardThis bit identifies whether the packet should be discarded based on the the source address. Set to discard
 *     VFI:SCP          Source CoS PriorityIf this bit is set in the matched source entry, the source CoS has priority over destination CoS 
 *     VFI:LIMIT_COUNTED Indicates if entry is counted for MAC limits.  CPU INSERT can set/reset for new entry as needed/  HW LEARNs always set this bit.
 *     VFI:REMOTE       Indicates if entry is learned from a local port (0) or a remote port (1).  Note: CPU must set this field correctly for CPU INSERT commands.
 *     VFI:STATIC_BIT   Indicates entry is SW programmed and static
 *     VFI:PENDING      Indicates that the entry is pending validation from software
 *     VFI:TAF_GATE_ID_PROFILE Gate ID Profile used to lookup GATE_ID.
 *     VFI:RESERVED_108 Reserved.
 *     VIF:KEY          Key for KEY_TYPE = VIF.
 *     VIF:NAMESPACE    KEY TYPE VIF: Ingress Ports associated Namespace from PORT_TABLE.
 *     VIF:DST_VIF      KEY TYPE VIF: The dst_vif field of the incoming packet's VNTAG.
 *     VIF:P            KEY TYPE VIF: The p field of the incoming packet's VNTAG.
 *     VIF:ASSOCIATED_DATA Entire associated data for KEY_TYPE = VIF
 *     VIF:DESTINATION  Destination fields for KEY_TYPE = 0, 1 and 2
 *     VIF:L2MC_PTR     L2MC pointer if MAC_ADDR[40]==1
 *     VIF:NHI_ECMP     NHI/ ECMP pointer.
 *     VIF:PORT_NUM     Port if T==0 and VPG_TYPE==0
 *     VIF:TGID         Trunk ID value if T==1
 *     VIF:MODULE_ID    Module ID if T==0 and VPG_TYPE==0
 *     VIF:REMOTE_TRUNK When T==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     VIF:DEST_TYPE    Indicates destination type.		    For VIF-based keys:		    00 = {MODID, PORT} or L2MC_index		    01 = {'0', TGID} or L2MC_index
 *     VIF:T            Indicates destination is a LAG
 *     VIF:RESERVED_78  RESERVED.
 *     VIF:CLASS_ID     L2 Classification ID used for ingress FP
 *     VIF:MAC_BLOCK_INDEX MAC Block Index
 *     VIF:DUMMY_INDEX  Dummy base field to line up with CLASS_ID overlay
 *     VIF:RPE          RPE bit
 *     VIF:RESERVED_89  RESERVED.
 *     VIF:PRI          Priority
 *     VIF:CPU          CPU bit
 *     VIF:DST_DISCARD  Dst Discard
 *     VIF:SRC_DISCARD  Src Discard
 *     VIF:SCP          SCP bit
 *     VIF:RESERVED_96  RESERVED.
 *     VIF:REMOTE       Indicates if entry is learned from a local port (0) or a remote port (1).  Note: CPU must set this field correctly for CPU INSERT commands.
 *     VIF:STATIC_BIT   Indicates entry is SW programmed and static
 *     VIF:PENDING      Indicates that the entry is pending validation from software
 *     VIF:TAF_GATE_ID_PROFILE Gate ID Profile used to lookup GATE_ID.
 *     VIF:RESERVED_108 Reserved.
 *     PE_VID:KEY       Key for KEY_TYPE = VIF.
 *     PE_VID:NAMESPACE KEY TYPE PE_VID: Ingress Ports associated Namespace from PORT_TABLE.
 *     PE_VID:ETAG_VID  KEY TYPE PE_VID: The VID field of the incoming packet's ETAG.
 *     PE_VID:ASSOCIATED_DATA Entire associated data for KEY_TYPE = VIF
 *     PE_VID:DESTINATION Destination fields for KEY_TYPE = 0, 1 and 2
 *     PE_VID:L2MC_PTR  L2MC pointer if MAC_ADDR[40]==1
 *     PE_VID:NHI_ECMP  NHI/ ECMP pointer.
 *     PE_VID:PORT_NUM  Port if T==0 and VPG_TYPE==0
 *     PE_VID:TGID      Trunk ID value if T==1
 *     PE_VID:MODULE_ID Module ID if T==0 and VPG_TYPE==0
 *     PE_VID:REMOTE_TRUNK When T==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     PE_VID:DEST_TYPE Indicates destination type.		    For PE_VID-based keys:		    00 = {MODID, PORT} or L2MC_index		    01 = {'0', TGID} or L2MC_index
 *     PE_VID:T         Indicates destination is a LAG
 *     PE_VID:RESERVED_80 RESERVED.
 *     PE_VID:CLASS_ID  L2 Classification ID used for ingress FP
 *     PE_VID:MAC_BLOCK_INDEX MAC Block Index
 *     PE_VID:DUMMY_INDEX Dummy base field to line up with CLASS_ID overlay
 *     PE_VID:RPE       RPE bit
 *     PE_VID:RESERVED_89 RESERVED.
 *     PE_VID:PRI       Priority
 *     PE_VID:CPU       CPU bit
 *     PE_VID:DST_DISCARD Dst Discard
 *     PE_VID:SRC_DISCARD Src Discard
 *     PE_VID:SCP       SCP bit
 *     PE_VID:RESERVED_98 RESERVED.
 *     PE_VID:REMOTE    Indicates if entry is learned from a local port (0) or a remote port (1).  Note: CPU must set this field correctly for CPU INSERT commands.
 *     PE_VID:STATIC_BIT Indicates entry is SW programmed and static
 *     PE_VID:PENDING   Indicates that the entry is pending validation from software
 *     PE_VID:TAF_GATE_ID_PROFILE Gate ID Profile used to lookup GATE_ID.
 *     PE_VID:RESERVED_108 Reserved.
 *     VALID            Indicates that the entry is valid
 *     RESERVED_110     Reserved Bit. Use to align even boundary for PPD memory.
 *     EVEN_PARITY      Even parity bit (i.e. excludes HIT bits)
 *     ASSOCIATED_DATA_TYPE Specifies the Associated Data type
 *     SR_ASSOCIATED_DATA Entire associated data for SR
 *     SGLP             SOURCE  PORT.
 *     SR_DUPLICATE_FORWARDING Indicates that the destination is a Seamless Redundancy Duplicate port and Unicast packets must be forwarded as Multicast (DEST_TYPE=L2MC).
 *     SVC_METER_OFFSET_MODE Provides the OFFSET_MODE for metering.
 *     SVC_METER_INDEX  Provides the Service Meter Index. SVC_METER_INDEX = 0 indicates metering function is disabled
 *     RESERVED_13      RESERVED.
 *     SR_MAC_PROXY_PROFILE_PTR Provides index to SR_MAC_PROXY_PROFILE table that stores the port bitmap, where each bit indicates the ports that this MAC-SA is considered to be a proxy for them. Valid only for MAC-SA lookup.
 *     TSN_PRI_OFFSET_PROFILE Provides a profile index to TSN_PRI_OFFSET table
 *     TSN_CIRCUIT_ID   Provides TSN circuit ID for this packet. 0 = Invalid TSN_CIRCUIT_ID, Valid only for MAC-DA lookup
 *     RESERVED_35      Reserved bits due to width reduction of TSN_CIRCUIT_ID.
 *     SR_PRI_OFFSET_PROFILE Provides a profile index to SR_PRI_OFFSET table
 *     SR_FLOW_ID       Provides the Flow ID for Seamless Redundancy. SR_Flow_ID=0 is not valid. Valid for DA or SA lookup depending on PORT.SR_FLOW_ID_SOURCE_PRIORITY.
 *     RESERVED_51      Reserved bits due to bit width reduction of SR_FLOW_ID.
 *     SAN              Indicates this MAC address belongs to SAN. 0: DAN, 1: SAN.
 *     PARITY           Memory Parity bit for 2-bit error detection.
 *     HITDA            Dst hit update bitThis bit is set if there is a match with the destination address. It is used in aging mechanism. If the AGE TIME duration is expired and this bit is not set, then this entry is purged out by the aging process, provided that the STATIC_BIT is not set.
 *     HITSA            Src hit update bitThis bit is set if there is a match with the source address. It is used in hardware aging mechanism. If the AGE TIME duration is expired and this bit is not set, then this entry is purged out by the aging process, provided that the STATIC_BIT is not set.
 *     LOCAL_SA         Src local update bitLOCAL_SA starts out as the inverse of REMOTE, but LOCAL_SA is a dynamic value that is updated on a per packet basis.
 */
#define L2_ENTRYm_MIN 0
#define L2_ENTRYm_MAX 16383
#define L2_ENTRYm_CMAX(u) 16383
#define L2_ENTRYm_SIZE 22

/*
 * This structure should be used to declare and program L2_ENTRY.
 */
typedef union L2_ENTRYm_s {
	uint32 v[6];
	uint32 l2_entry[6];
	uint32 _l2_entry;
} L2_ENTRYm_t;

#define L2_ENTRYm_CLR(r) sal_memset(&((r)._l2_entry), 0, sizeof(L2_ENTRYm_t))
#define L2_ENTRYm_SET(r,i,d) (r).l2_entry[i] = d
#define L2_ENTRYm_GET(r,i) (r).l2_entry[i]

/*
 * These macros can be used to access individual fields.
 */
#define L2_ENTRYm_KEY_TYPEf_GET(r) (((r).l2_entry[0]) & 0x7)
#define L2_ENTRYm_KEY_TYPEf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define L2_ENTRYm_LEGACY_OVIDf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_LEGACY_OVIDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_LEGACY_VLAN_IDf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_LEGACY_VLAN_IDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_LEGACY_VFIf_GET(r) ((((r).l2_entry[0]) >> 3) & 0x3ff)
#define L2_ENTRYm_LEGACY_VFIf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0x3ff << 3)) | ((((uint32)f) & 0x3ff) << 3))
#define L2_ENTRYm_LEGACY_RESERVED_VFIf_GET(r) ((((r).l2_entry[0]) >> 13) & 0x3)
#define L2_ENTRYm_LEGACY_RESERVED_VFIf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define L2_ENTRYm_LEGACY_MAC_ADDRf_GET(r,a) field_get((r).l2_entry,15,62,a)
#define L2_ENTRYm_LEGACY_MAC_ADDRf_SET(r,a) field_set((r).l2_entry,15,62,a)
#define L2_ENTRYm_LEGACY_IVIDf_GET(r) ((((r).l2_entry[0]) >> 15) & 0xfff)
#define L2_ENTRYm_LEGACY_IVIDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 15)) | ((((uint32)f) & 0xfff) << 15))
#define L2_ENTRYm_LEGACY_DESTINATION_1f_GET(r) (((r).l2_entry[1]) & 0x7fff)
#define L2_ENTRYm_LEGACY_DESTINATION_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x7fff)) | (((uint32)f) & 0x7fff))
#define L2_ENTRYm_LEGACY_PORT_NUM_1f_GET(r) (((r).l2_entry[1]) & 0x7f)
#define L2_ENTRYm_LEGACY_PORT_NUM_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define L2_ENTRYm_LEGACY_TGID_1f_GET(r) (((r).l2_entry[1]) & 0x7f)
#define L2_ENTRYm_LEGACY_TGID_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define L2_ENTRYm_LEGACY_MODULE_ID_1f_GET(r) ((((r).l2_entry[1]) >> 7) & 0xff)
#define L2_ENTRYm_LEGACY_MODULE_ID_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define L2_ENTRYm_LEGACY_REMOTE_TRUNK_1f_GET(r) ((((r).l2_entry[1]) >> 14) & 0x1)
#define L2_ENTRYm_LEGACY_REMOTE_TRUNK_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_LEGACY_T_1f_GET(r) ((((r).l2_entry[1]) >> 15) & 0x1)
#define L2_ENTRYm_LEGACY_T_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define L2_ENTRYm_LEGACY_ASSOCIATED_DATAf_GET(r,a) field_get((r).l2_entry,63,108,a)
#define L2_ENTRYm_LEGACY_ASSOCIATED_DATAf_SET(r,a) field_set((r).l2_entry,63,108,a)
#define L2_ENTRYm_LEGACY_DESTINATIONf_GET(r) field32_get((r).l2_entry,63,77)
#define L2_ENTRYm_LEGACY_DESTINATIONf_SET(r,f) field32_set((r).l2_entry,63,77,f)
#define L2_ENTRYm_LEGACY_VPGf_GET(r) field32_get((r).l2_entry,63,77)
#define L2_ENTRYm_LEGACY_VPGf_SET(r,f) field32_set((r).l2_entry,63,77,f)
#define L2_ENTRYm_LEGACY_L2MC_PTRf_GET(r) field32_get((r).l2_entry,63,72)
#define L2_ENTRYm_LEGACY_L2MC_PTRf_SET(r,f) field32_set((r).l2_entry,63,72,f)
#define L2_ENTRYm_LEGACY_NHI_ECMPf_GET(r) field32_get((r).l2_entry,63,71)
#define L2_ENTRYm_LEGACY_NHI_ECMPf_SET(r,f) field32_set((r).l2_entry,63,71,f)
#define L2_ENTRYm_LEGACY_PORT_NUMf_GET(r) field32_get((r).l2_entry,63,69)
#define L2_ENTRYm_LEGACY_PORT_NUMf_SET(r,f) field32_set((r).l2_entry,63,69,f)
#define L2_ENTRYm_LEGACY_TGIDf_GET(r) field32_get((r).l2_entry,63,69)
#define L2_ENTRYm_LEGACY_TGIDf_SET(r,f) field32_set((r).l2_entry,63,69,f)
#define L2_ENTRYm_LEGACY_MODULE_IDf_GET(r) ((((r).l2_entry[2]) >> 6) & 0xff)
#define L2_ENTRYm_LEGACY_MODULE_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define L2_ENTRYm_LEGACY_RESERVED_L2MC_PTRf_GET(r) ((((r).l2_entry[2]) >> 9) & 0x3)
#define L2_ENTRYm_LEGACY_RESERVED_L2MC_PTRf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define L2_ENTRYm_LEGACY_REMOTE_TRUNKf_GET(r) ((((r).l2_entry[2]) >> 13) & 0x1)
#define L2_ENTRYm_LEGACY_REMOTE_TRUNKf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define L2_ENTRYm_LEGACY_DEST_TYPEf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x7)
#define L2_ENTRYm_LEGACY_DEST_TYPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define L2_ENTRYm_LEGACY_Tf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x1)
#define L2_ENTRYm_LEGACY_Tf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_LEGACY_CLASS_IDf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x3f)
#define L2_ENTRYm_LEGACY_CLASS_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define L2_ENTRYm_LEGACY_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x1f)
#define L2_ENTRYm_LEGACY_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define L2_ENTRYm_LEGACY_DUMMY_INDEXf_GET(r) ((((r).l2_entry[2]) >> 22) & 0x1)
#define L2_ENTRYm_LEGACY_DUMMY_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define L2_ENTRYm_LEGACY_RPEf_GET(r) ((((r).l2_entry[2]) >> 24) & 0x1)
#define L2_ENTRYm_LEGACY_RPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define L2_ENTRYm_LEGACY_MIRRORf_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_LEGACY_MIRRORf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_LEGACY_MIRROR0f_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_LEGACY_MIRROR0f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_LEGACY_PRIf_GET(r) ((((r).l2_entry[2]) >> 27) & 0x7)
#define L2_ENTRYm_LEGACY_PRIf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define L2_ENTRYm_LEGACY_CPUf_GET(r) ((((r).l2_entry[2]) >> 30) & 0x1)
#define L2_ENTRYm_LEGACY_CPUf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_LEGACY_DST_DISCARDf_GET(r) ((((r).l2_entry[2]) >> 31) & 0x1)
#define L2_ENTRYm_LEGACY_DST_DISCARDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define L2_ENTRYm_LEGACY_SRC_DISCARDf_GET(r) (((r).l2_entry[3]) & 0x1)
#define L2_ENTRYm_LEGACY_SRC_DISCARDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_ENTRYm_LEGACY_SCPf_GET(r) ((((r).l2_entry[3]) >> 1) & 0x1)
#define L2_ENTRYm_LEGACY_SCPf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define L2_ENTRYm_LEGACY_LIMIT_COUNTEDf_GET(r) ((((r).l2_entry[3]) >> 2) & 0x1)
#define L2_ENTRYm_LEGACY_LIMIT_COUNTEDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_ENTRYm_LEGACY_REMOTEf_GET(r) ((((r).l2_entry[3]) >> 3) & 0x1)
#define L2_ENTRYm_LEGACY_REMOTEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_ENTRYm_LEGACY_STATIC_BITf_GET(r) ((((r).l2_entry[3]) >> 4) & 0x1)
#define L2_ENTRYm_LEGACY_STATIC_BITf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_ENTRYm_LEGACY_PENDINGf_GET(r) ((((r).l2_entry[3]) >> 5) & 0x1)
#define L2_ENTRYm_LEGACY_PENDINGf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define L2_ENTRYm_LEGACY_TAF_GATE_ID_PROFILEf_GET(r) ((((r).l2_entry[3]) >> 6) & 0x3f)
#define L2_ENTRYm_LEGACY_TAF_GATE_ID_PROFILEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define L2_ENTRYm_LEGACY_RESERVED_108f_GET(r) ((((r).l2_entry[3]) >> 12) & 0x1)
#define L2_ENTRYm_LEGACY_RESERVED_108f_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define L2_ENTRYm_L2_VLAN_IDf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_L2_VLAN_IDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_L2_VFIf_GET(r) ((((r).l2_entry[0]) >> 3) & 0x3ff)
#define L2_ENTRYm_L2_VFIf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0x3ff << 3)) | ((((uint32)f) & 0x3ff) << 3))
#define L2_ENTRYm_L2_MAC_ADDRf_GET(r,a) field_get((r).l2_entry,15,62,a)
#define L2_ENTRYm_L2_MAC_ADDRf_SET(r,a) field_set((r).l2_entry,15,62,a)
#define L2_ENTRYm_L2_ASSOCIATED_DATAf_GET(r,a) field_get((r).l2_entry,63,108,a)
#define L2_ENTRYm_L2_ASSOCIATED_DATAf_SET(r,a) field_set((r).l2_entry,63,108,a)
#define L2_ENTRYm_L2_DESTINATIONf_GET(r) field32_get((r).l2_entry,63,77)
#define L2_ENTRYm_L2_DESTINATIONf_SET(r,f) field32_set((r).l2_entry,63,77,f)
#define L2_ENTRYm_L2_L2MC_PTRf_GET(r) field32_get((r).l2_entry,63,72)
#define L2_ENTRYm_L2_L2MC_PTRf_SET(r,f) field32_set((r).l2_entry,63,72,f)
#define L2_ENTRYm_L2_NHI_ECMPf_GET(r) field32_get((r).l2_entry,63,71)
#define L2_ENTRYm_L2_NHI_ECMPf_SET(r,f) field32_set((r).l2_entry,63,71,f)
#define L2_ENTRYm_L2_PORT_NUMf_GET(r) field32_get((r).l2_entry,63,69)
#define L2_ENTRYm_L2_PORT_NUMf_SET(r,f) field32_set((r).l2_entry,63,69,f)
#define L2_ENTRYm_L2_TGIDf_GET(r) field32_get((r).l2_entry,63,69)
#define L2_ENTRYm_L2_TGIDf_SET(r,f) field32_set((r).l2_entry,63,69,f)
#define L2_ENTRYm_L2_MODULE_IDf_GET(r) ((((r).l2_entry[2]) >> 6) & 0xff)
#define L2_ENTRYm_L2_MODULE_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define L2_ENTRYm_L2_REMOTE_TRUNKf_GET(r) ((((r).l2_entry[2]) >> 13) & 0x1)
#define L2_ENTRYm_L2_REMOTE_TRUNKf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define L2_ENTRYm_L2_DEST_TYPEf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x7)
#define L2_ENTRYm_L2_DEST_TYPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define L2_ENTRYm_L2_Tf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x1)
#define L2_ENTRYm_L2_Tf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_L2_CLASS_IDf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x3f)
#define L2_ENTRYm_L2_CLASS_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define L2_ENTRYm_L2_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x1f)
#define L2_ENTRYm_L2_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define L2_ENTRYm_L2_DUMMY_INDEXf_GET(r) ((((r).l2_entry[2]) >> 22) & 0x1)
#define L2_ENTRYm_L2_DUMMY_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define L2_ENTRYm_L2_RPEf_GET(r) ((((r).l2_entry[2]) >> 24) & 0x1)
#define L2_ENTRYm_L2_RPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define L2_ENTRYm_L2_MIRRORf_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_L2_MIRRORf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_L2_MIRROR0f_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_L2_MIRROR0f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_L2_PRIf_GET(r) ((((r).l2_entry[2]) >> 27) & 0x7)
#define L2_ENTRYm_L2_PRIf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define L2_ENTRYm_L2_CPUf_GET(r) ((((r).l2_entry[2]) >> 30) & 0x1)
#define L2_ENTRYm_L2_CPUf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_L2_DST_DISCARDf_GET(r) ((((r).l2_entry[2]) >> 31) & 0x1)
#define L2_ENTRYm_L2_DST_DISCARDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define L2_ENTRYm_L2_SRC_DISCARDf_GET(r) (((r).l2_entry[3]) & 0x1)
#define L2_ENTRYm_L2_SRC_DISCARDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_ENTRYm_L2_SCPf_GET(r) ((((r).l2_entry[3]) >> 1) & 0x1)
#define L2_ENTRYm_L2_SCPf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define L2_ENTRYm_L2_LIMIT_COUNTEDf_GET(r) ((((r).l2_entry[3]) >> 2) & 0x1)
#define L2_ENTRYm_L2_LIMIT_COUNTEDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_ENTRYm_L2_REMOTEf_GET(r) ((((r).l2_entry[3]) >> 3) & 0x1)
#define L2_ENTRYm_L2_REMOTEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_ENTRYm_L2_STATIC_BITf_GET(r) ((((r).l2_entry[3]) >> 4) & 0x1)
#define L2_ENTRYm_L2_STATIC_BITf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_ENTRYm_L2_PENDINGf_GET(r) ((((r).l2_entry[3]) >> 5) & 0x1)
#define L2_ENTRYm_L2_PENDINGf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define L2_ENTRYm_L2_TAF_GATE_ID_PROFILEf_GET(r) ((((r).l2_entry[3]) >> 6) & 0x3f)
#define L2_ENTRYm_L2_TAF_GATE_ID_PROFILEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define L2_ENTRYm_L2_RESERVED_108f_GET(r) ((((r).l2_entry[3]) >> 12) & 0x1)
#define L2_ENTRYm_L2_RESERVED_108f_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define L2_ENTRYm_VLAN_OVIDf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_VLAN_OVIDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_VLAN_IVIDf_GET(r) ((((r).l2_entry[0]) >> 15) & 0xfff)
#define L2_ENTRYm_VLAN_IVIDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 15)) | ((((uint32)f) & 0xfff) << 15))
#define L2_ENTRYm_VLAN_DESTINATION_1f_GET(r) (((r).l2_entry[1]) & 0x7fff)
#define L2_ENTRYm_VLAN_DESTINATION_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x7fff)) | (((uint32)f) & 0x7fff))
#define L2_ENTRYm_VLAN_PORT_NUM_1f_GET(r) (((r).l2_entry[1]) & 0x7f)
#define L2_ENTRYm_VLAN_PORT_NUM_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define L2_ENTRYm_VLAN_TGID_1f_GET(r) (((r).l2_entry[1]) & 0x7f)
#define L2_ENTRYm_VLAN_TGID_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define L2_ENTRYm_VLAN_MODULE_ID_1f_GET(r) ((((r).l2_entry[1]) >> 7) & 0xff)
#define L2_ENTRYm_VLAN_MODULE_ID_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define L2_ENTRYm_VLAN_REMOTE_TRUNK_1f_GET(r) ((((r).l2_entry[1]) >> 14) & 0x1)
#define L2_ENTRYm_VLAN_REMOTE_TRUNK_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_VLAN_T_1f_GET(r) ((((r).l2_entry[1]) >> 15) & 0x1)
#define L2_ENTRYm_VLAN_T_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define L2_ENTRYm_VLAN_DESTINATIONf_GET(r) field32_get((r).l2_entry,63,77)
#define L2_ENTRYm_VLAN_DESTINATIONf_SET(r,f) field32_set((r).l2_entry,63,77,f)
#define L2_ENTRYm_VLAN_PORT_NUMf_GET(r) field32_get((r).l2_entry,63,69)
#define L2_ENTRYm_VLAN_PORT_NUMf_SET(r,f) field32_set((r).l2_entry,63,69,f)
#define L2_ENTRYm_VLAN_TGIDf_GET(r) field32_get((r).l2_entry,63,69)
#define L2_ENTRYm_VLAN_TGIDf_SET(r,f) field32_set((r).l2_entry,63,69,f)
#define L2_ENTRYm_VLAN_MODULE_IDf_GET(r) ((((r).l2_entry[2]) >> 6) & 0xff)
#define L2_ENTRYm_VLAN_MODULE_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define L2_ENTRYm_VLAN_REMOTE_TRUNKf_GET(r) ((((r).l2_entry[2]) >> 13) & 0x1)
#define L2_ENTRYm_VLAN_REMOTE_TRUNKf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define L2_ENTRYm_VLAN_DEST_TYPEf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x7)
#define L2_ENTRYm_VLAN_DEST_TYPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define L2_ENTRYm_VLAN_Tf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x1)
#define L2_ENTRYm_VLAN_Tf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_VLAN_CLASS_IDf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x3f)
#define L2_ENTRYm_VLAN_CLASS_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define L2_ENTRYm_VLAN_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x1f)
#define L2_ENTRYm_VLAN_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define L2_ENTRYm_VLAN_DUMMY_INDEXf_GET(r) ((((r).l2_entry[2]) >> 22) & 0x1)
#define L2_ENTRYm_VLAN_DUMMY_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define L2_ENTRYm_VLAN_RPEf_GET(r) ((((r).l2_entry[2]) >> 24) & 0x1)
#define L2_ENTRYm_VLAN_RPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define L2_ENTRYm_VLAN_MIRRORf_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_VLAN_MIRRORf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_VLAN_MIRROR0f_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_VLAN_MIRROR0f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_VLAN_PRIf_GET(r) ((((r).l2_entry[2]) >> 27) & 0x7)
#define L2_ENTRYm_VLAN_PRIf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define L2_ENTRYm_VLAN_CPUf_GET(r) ((((r).l2_entry[2]) >> 30) & 0x1)
#define L2_ENTRYm_VLAN_CPUf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_VLAN_DST_DISCARDf_GET(r) ((((r).l2_entry[2]) >> 31) & 0x1)
#define L2_ENTRYm_VLAN_DST_DISCARDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define L2_ENTRYm_VLAN_SRC_DISCARDf_GET(r) (((r).l2_entry[3]) & 0x1)
#define L2_ENTRYm_VLAN_SRC_DISCARDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_ENTRYm_VLAN_SCPf_GET(r) ((((r).l2_entry[3]) >> 1) & 0x1)
#define L2_ENTRYm_VLAN_SCPf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define L2_ENTRYm_VLAN_LIMIT_COUNTEDf_GET(r) ((((r).l2_entry[3]) >> 2) & 0x1)
#define L2_ENTRYm_VLAN_LIMIT_COUNTEDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_ENTRYm_VLAN_REMOTEf_GET(r) ((((r).l2_entry[3]) >> 3) & 0x1)
#define L2_ENTRYm_VLAN_REMOTEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_ENTRYm_VLAN_STATIC_BITf_GET(r) ((((r).l2_entry[3]) >> 4) & 0x1)
#define L2_ENTRYm_VLAN_STATIC_BITf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_ENTRYm_VLAN_PENDINGf_GET(r) ((((r).l2_entry[3]) >> 5) & 0x1)
#define L2_ENTRYm_VLAN_PENDINGf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define L2_ENTRYm_VLAN_TAF_GATE_ID_PROFILEf_GET(r) ((((r).l2_entry[3]) >> 6) & 0x3f)
#define L2_ENTRYm_VLAN_TAF_GATE_ID_PROFILEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define L2_ENTRYm_VLAN_RESERVED_108f_GET(r) ((((r).l2_entry[3]) >> 12) & 0x1)
#define L2_ENTRYm_VLAN_RESERVED_108f_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define L2_ENTRYm_VFI_KEYf_GET(r,a) field_get((r).l2_entry,0,62,a)
#define L2_ENTRYm_VFI_KEYf_SET(r,a) field_set((r).l2_entry,0,62,a)
#define L2_ENTRYm_VFI_VLAN_IDf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_VFI_VLAN_IDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_VFI_VFIf_GET(r) ((((r).l2_entry[0]) >> 3) & 0x3ff)
#define L2_ENTRYm_VFI_VFIf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0x3ff << 3)) | ((((uint32)f) & 0x3ff) << 3))
#define L2_ENTRYm_VFI_MAC_ADDRf_GET(r,a) field_get((r).l2_entry,15,62,a)
#define L2_ENTRYm_VFI_MAC_ADDRf_SET(r,a) field_set((r).l2_entry,15,62,a)
#define L2_ENTRYm_VFI_ASSOCIATED_DATAf_GET(r,a) field_get((r).l2_entry,63,108,a)
#define L2_ENTRYm_VFI_ASSOCIATED_DATAf_SET(r,a) field_set((r).l2_entry,63,108,a)
#define L2_ENTRYm_VFI_DESTINATIONf_GET(r) field32_get((r).l2_entry,63,77)
#define L2_ENTRYm_VFI_DESTINATIONf_SET(r,f) field32_set((r).l2_entry,63,77,f)
#define L2_ENTRYm_VFI_L2MC_PTRf_GET(r) field32_get((r).l2_entry,63,72)
#define L2_ENTRYm_VFI_L2MC_PTRf_SET(r,f) field32_set((r).l2_entry,63,72,f)
#define L2_ENTRYm_VFI_NHI_ECMPf_GET(r) field32_get((r).l2_entry,63,71)
#define L2_ENTRYm_VFI_NHI_ECMPf_SET(r,f) field32_set((r).l2_entry,63,71,f)
#define L2_ENTRYm_VFI_PORT_NUMf_GET(r) field32_get((r).l2_entry,63,69)
#define L2_ENTRYm_VFI_PORT_NUMf_SET(r,f) field32_set((r).l2_entry,63,69,f)
#define L2_ENTRYm_VFI_TGIDf_GET(r) field32_get((r).l2_entry,63,69)
#define L2_ENTRYm_VFI_TGIDf_SET(r,f) field32_set((r).l2_entry,63,69,f)
#define L2_ENTRYm_VFI_MODULE_IDf_GET(r) ((((r).l2_entry[2]) >> 6) & 0xff)
#define L2_ENTRYm_VFI_MODULE_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define L2_ENTRYm_VFI_REMOTE_TRUNKf_GET(r) ((((r).l2_entry[2]) >> 13) & 0x1)
#define L2_ENTRYm_VFI_REMOTE_TRUNKf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define L2_ENTRYm_VFI_DEST_TYPEf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x7)
#define L2_ENTRYm_VFI_DEST_TYPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define L2_ENTRYm_VFI_Tf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x1)
#define L2_ENTRYm_VFI_Tf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_VFI_CLASS_IDf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x3f)
#define L2_ENTRYm_VFI_CLASS_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define L2_ENTRYm_VFI_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x1f)
#define L2_ENTRYm_VFI_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define L2_ENTRYm_VFI_DUMMY_INDEXf_GET(r) ((((r).l2_entry[2]) >> 22) & 0x1)
#define L2_ENTRYm_VFI_DUMMY_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define L2_ENTRYm_VFI_RPEf_GET(r) ((((r).l2_entry[2]) >> 24) & 0x1)
#define L2_ENTRYm_VFI_RPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define L2_ENTRYm_VFI_MIRRORf_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_VFI_MIRRORf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_VFI_MIRROR0f_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_VFI_MIRROR0f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_VFI_PRIf_GET(r) ((((r).l2_entry[2]) >> 27) & 0x7)
#define L2_ENTRYm_VFI_PRIf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define L2_ENTRYm_VFI_CPUf_GET(r) ((((r).l2_entry[2]) >> 30) & 0x1)
#define L2_ENTRYm_VFI_CPUf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_VFI_DST_DISCARDf_GET(r) ((((r).l2_entry[2]) >> 31) & 0x1)
#define L2_ENTRYm_VFI_DST_DISCARDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define L2_ENTRYm_VFI_SRC_DISCARDf_GET(r) (((r).l2_entry[3]) & 0x1)
#define L2_ENTRYm_VFI_SRC_DISCARDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_ENTRYm_VFI_SCPf_GET(r) ((((r).l2_entry[3]) >> 1) & 0x1)
#define L2_ENTRYm_VFI_SCPf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define L2_ENTRYm_VFI_LIMIT_COUNTEDf_GET(r) ((((r).l2_entry[3]) >> 2) & 0x1)
#define L2_ENTRYm_VFI_LIMIT_COUNTEDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_ENTRYm_VFI_REMOTEf_GET(r) ((((r).l2_entry[3]) >> 3) & 0x1)
#define L2_ENTRYm_VFI_REMOTEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_ENTRYm_VFI_STATIC_BITf_GET(r) ((((r).l2_entry[3]) >> 4) & 0x1)
#define L2_ENTRYm_VFI_STATIC_BITf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_ENTRYm_VFI_PENDINGf_GET(r) ((((r).l2_entry[3]) >> 5) & 0x1)
#define L2_ENTRYm_VFI_PENDINGf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define L2_ENTRYm_VFI_TAF_GATE_ID_PROFILEf_GET(r) ((((r).l2_entry[3]) >> 6) & 0x3f)
#define L2_ENTRYm_VFI_TAF_GATE_ID_PROFILEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define L2_ENTRYm_VFI_RESERVED_108f_GET(r) ((((r).l2_entry[3]) >> 12) & 0x1)
#define L2_ENTRYm_VFI_RESERVED_108f_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define L2_ENTRYm_VIF_KEYf_GET(r,a) field_get((r).l2_entry,0,62,a)
#define L2_ENTRYm_VIF_KEYf_SET(r,a) field_set((r).l2_entry,0,62,a)
#define L2_ENTRYm_VIF_NAMESPACEf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_VIF_NAMESPACEf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_VIF_DST_VIFf_GET(r) ((((r).l2_entry[0]) >> 15) & 0x3fff)
#define L2_ENTRYm_VIF_DST_VIFf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0x3fff << 15)) | ((((uint32)f) & 0x3fff) << 15))
#define L2_ENTRYm_VIF_Pf_GET(r) ((((r).l2_entry[0]) >> 29) & 0x1)
#define L2_ENTRYm_VIF_Pf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define L2_ENTRYm_VIF_ASSOCIATED_DATAf_GET(r,a) field_get((r).l2_entry,63,108,a)
#define L2_ENTRYm_VIF_ASSOCIATED_DATAf_SET(r,a) field_set((r).l2_entry,63,108,a)
#define L2_ENTRYm_VIF_DESTINATIONf_GET(r) field32_get((r).l2_entry,63,77)
#define L2_ENTRYm_VIF_DESTINATIONf_SET(r,f) field32_set((r).l2_entry,63,77,f)
#define L2_ENTRYm_VIF_L2MC_PTRf_GET(r) field32_get((r).l2_entry,63,72)
#define L2_ENTRYm_VIF_L2MC_PTRf_SET(r,f) field32_set((r).l2_entry,63,72,f)
#define L2_ENTRYm_VIF_NHI_ECMPf_GET(r) field32_get((r).l2_entry,63,71)
#define L2_ENTRYm_VIF_NHI_ECMPf_SET(r,f) field32_set((r).l2_entry,63,71,f)
#define L2_ENTRYm_VIF_PORT_NUMf_GET(r) field32_get((r).l2_entry,63,69)
#define L2_ENTRYm_VIF_PORT_NUMf_SET(r,f) field32_set((r).l2_entry,63,69,f)
#define L2_ENTRYm_VIF_TGIDf_GET(r) field32_get((r).l2_entry,63,69)
#define L2_ENTRYm_VIF_TGIDf_SET(r,f) field32_set((r).l2_entry,63,69,f)
#define L2_ENTRYm_VIF_MODULE_IDf_GET(r) ((((r).l2_entry[2]) >> 6) & 0xff)
#define L2_ENTRYm_VIF_MODULE_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define L2_ENTRYm_VIF_REMOTE_TRUNKf_GET(r) ((((r).l2_entry[2]) >> 13) & 0x1)
#define L2_ENTRYm_VIF_REMOTE_TRUNKf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define L2_ENTRYm_VIF_DEST_TYPEf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x7)
#define L2_ENTRYm_VIF_DEST_TYPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define L2_ENTRYm_VIF_Tf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x1)
#define L2_ENTRYm_VIF_Tf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_VIF_RESERVED_78f_GET(r) ((((r).l2_entry[2]) >> 16) & 0x1)
#define L2_ENTRYm_VIF_RESERVED_78f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define L2_ENTRYm_VIF_CLASS_IDf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x3f)
#define L2_ENTRYm_VIF_CLASS_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define L2_ENTRYm_VIF_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x1f)
#define L2_ENTRYm_VIF_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define L2_ENTRYm_VIF_DUMMY_INDEXf_GET(r) ((((r).l2_entry[2]) >> 22) & 0x1)
#define L2_ENTRYm_VIF_DUMMY_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define L2_ENTRYm_VIF_RPEf_GET(r) ((((r).l2_entry[2]) >> 24) & 0x1)
#define L2_ENTRYm_VIF_RPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define L2_ENTRYm_VIF_RESERVED_89f_GET(r) ((((r).l2_entry[2]) >> 25) & 0x3)
#define L2_ENTRYm_VIF_RESERVED_89f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3 << 25)) | ((((uint32)f) & 0x3) << 25))
#define L2_ENTRYm_VIF_PRIf_GET(r) ((((r).l2_entry[2]) >> 27) & 0x7)
#define L2_ENTRYm_VIF_PRIf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define L2_ENTRYm_VIF_CPUf_GET(r) ((((r).l2_entry[2]) >> 30) & 0x1)
#define L2_ENTRYm_VIF_CPUf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_VIF_DST_DISCARDf_GET(r) ((((r).l2_entry[2]) >> 31) & 0x1)
#define L2_ENTRYm_VIF_DST_DISCARDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define L2_ENTRYm_VIF_SRC_DISCARDf_GET(r) (((r).l2_entry[3]) & 0x1)
#define L2_ENTRYm_VIF_SRC_DISCARDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_ENTRYm_VIF_SCPf_GET(r) ((((r).l2_entry[3]) >> 1) & 0x1)
#define L2_ENTRYm_VIF_SCPf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define L2_ENTRYm_VIF_RESERVED_96f_GET(r) ((((r).l2_entry[3]) >> 2) & 0x1)
#define L2_ENTRYm_VIF_RESERVED_96f_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_ENTRYm_VIF_REMOTEf_GET(r) ((((r).l2_entry[3]) >> 3) & 0x1)
#define L2_ENTRYm_VIF_REMOTEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_ENTRYm_VIF_STATIC_BITf_GET(r) ((((r).l2_entry[3]) >> 4) & 0x1)
#define L2_ENTRYm_VIF_STATIC_BITf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_ENTRYm_VIF_PENDINGf_GET(r) ((((r).l2_entry[3]) >> 5) & 0x1)
#define L2_ENTRYm_VIF_PENDINGf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define L2_ENTRYm_VIF_TAF_GATE_ID_PROFILEf_GET(r) ((((r).l2_entry[3]) >> 6) & 0x3f)
#define L2_ENTRYm_VIF_TAF_GATE_ID_PROFILEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define L2_ENTRYm_VIF_RESERVED_108f_GET(r) ((((r).l2_entry[3]) >> 12) & 0x1)
#define L2_ENTRYm_VIF_RESERVED_108f_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define L2_ENTRYm_PE_VID_KEYf_GET(r,a) field_get((r).l2_entry,0,62,a)
#define L2_ENTRYm_PE_VID_KEYf_SET(r,a) field_set((r).l2_entry,0,62,a)
#define L2_ENTRYm_PE_VID_NAMESPACEf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_PE_VID_NAMESPACEf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_PE_VID_ETAG_VIDf_GET(r) ((((r).l2_entry[0]) >> 15) & 0x3fff)
#define L2_ENTRYm_PE_VID_ETAG_VIDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0x3fff << 15)) | ((((uint32)f) & 0x3fff) << 15))
#define L2_ENTRYm_PE_VID_ASSOCIATED_DATAf_GET(r,a) field_get((r).l2_entry,63,108,a)
#define L2_ENTRYm_PE_VID_ASSOCIATED_DATAf_SET(r,a) field_set((r).l2_entry,63,108,a)
#define L2_ENTRYm_PE_VID_DESTINATIONf_GET(r) field32_get((r).l2_entry,63,77)
#define L2_ENTRYm_PE_VID_DESTINATIONf_SET(r,f) field32_set((r).l2_entry,63,77,f)
#define L2_ENTRYm_PE_VID_L2MC_PTRf_GET(r) field32_get((r).l2_entry,63,72)
#define L2_ENTRYm_PE_VID_L2MC_PTRf_SET(r,f) field32_set((r).l2_entry,63,72,f)
#define L2_ENTRYm_PE_VID_NHI_ECMPf_GET(r) field32_get((r).l2_entry,63,71)
#define L2_ENTRYm_PE_VID_NHI_ECMPf_SET(r,f) field32_set((r).l2_entry,63,71,f)
#define L2_ENTRYm_PE_VID_PORT_NUMf_GET(r) field32_get((r).l2_entry,63,69)
#define L2_ENTRYm_PE_VID_PORT_NUMf_SET(r,f) field32_set((r).l2_entry,63,69,f)
#define L2_ENTRYm_PE_VID_TGIDf_GET(r) field32_get((r).l2_entry,63,69)
#define L2_ENTRYm_PE_VID_TGIDf_SET(r,f) field32_set((r).l2_entry,63,69,f)
#define L2_ENTRYm_PE_VID_MODULE_IDf_GET(r) ((((r).l2_entry[2]) >> 6) & 0xff)
#define L2_ENTRYm_PE_VID_MODULE_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define L2_ENTRYm_PE_VID_REMOTE_TRUNKf_GET(r) ((((r).l2_entry[2]) >> 13) & 0x1)
#define L2_ENTRYm_PE_VID_REMOTE_TRUNKf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define L2_ENTRYm_PE_VID_DEST_TYPEf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x7)
#define L2_ENTRYm_PE_VID_DEST_TYPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define L2_ENTRYm_PE_VID_Tf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x1)
#define L2_ENTRYm_PE_VID_Tf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_PE_VID_RESERVED_80f_GET(r) ((((r).l2_entry[2]) >> 16) & 0x1)
#define L2_ENTRYm_PE_VID_RESERVED_80f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define L2_ENTRYm_PE_VID_CLASS_IDf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x3f)
#define L2_ENTRYm_PE_VID_CLASS_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define L2_ENTRYm_PE_VID_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x1f)
#define L2_ENTRYm_PE_VID_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define L2_ENTRYm_PE_VID_DUMMY_INDEXf_GET(r) ((((r).l2_entry[2]) >> 22) & 0x1)
#define L2_ENTRYm_PE_VID_DUMMY_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define L2_ENTRYm_PE_VID_RPEf_GET(r) ((((r).l2_entry[2]) >> 24) & 0x1)
#define L2_ENTRYm_PE_VID_RPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define L2_ENTRYm_PE_VID_RESERVED_89f_GET(r) ((((r).l2_entry[2]) >> 25) & 0x3)
#define L2_ENTRYm_PE_VID_RESERVED_89f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3 << 25)) | ((((uint32)f) & 0x3) << 25))
#define L2_ENTRYm_PE_VID_PRIf_GET(r) ((((r).l2_entry[2]) >> 27) & 0x7)
#define L2_ENTRYm_PE_VID_PRIf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define L2_ENTRYm_PE_VID_CPUf_GET(r) ((((r).l2_entry[2]) >> 30) & 0x1)
#define L2_ENTRYm_PE_VID_CPUf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_PE_VID_DST_DISCARDf_GET(r) ((((r).l2_entry[2]) >> 31) & 0x1)
#define L2_ENTRYm_PE_VID_DST_DISCARDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define L2_ENTRYm_PE_VID_SRC_DISCARDf_GET(r) (((r).l2_entry[3]) & 0x1)
#define L2_ENTRYm_PE_VID_SRC_DISCARDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_ENTRYm_PE_VID_SCPf_GET(r) ((((r).l2_entry[3]) >> 1) & 0x1)
#define L2_ENTRYm_PE_VID_SCPf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define L2_ENTRYm_PE_VID_RESERVED_98f_GET(r) ((((r).l2_entry[3]) >> 2) & 0x1)
#define L2_ENTRYm_PE_VID_RESERVED_98f_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_ENTRYm_PE_VID_REMOTEf_GET(r) ((((r).l2_entry[3]) >> 3) & 0x1)
#define L2_ENTRYm_PE_VID_REMOTEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_ENTRYm_PE_VID_STATIC_BITf_GET(r) ((((r).l2_entry[3]) >> 4) & 0x1)
#define L2_ENTRYm_PE_VID_STATIC_BITf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_ENTRYm_PE_VID_PENDINGf_GET(r) ((((r).l2_entry[3]) >> 5) & 0x1)
#define L2_ENTRYm_PE_VID_PENDINGf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define L2_ENTRYm_PE_VID_TAF_GATE_ID_PROFILEf_GET(r) ((((r).l2_entry[3]) >> 6) & 0x3f)
#define L2_ENTRYm_PE_VID_TAF_GATE_ID_PROFILEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define L2_ENTRYm_PE_VID_RESERVED_108f_GET(r) ((((r).l2_entry[3]) >> 12) & 0x1)
#define L2_ENTRYm_PE_VID_RESERVED_108f_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define L2_ENTRYm_VALIDf_GET(r) ((((r).l2_entry[3]) >> 13) & 0x1)
#define L2_ENTRYm_VALIDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define L2_ENTRYm_RESERVED_110f_GET(r) ((((r).l2_entry[3]) >> 14) & 0x1)
#define L2_ENTRYm_RESERVED_110f_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_EVEN_PARITYf_GET(r) ((((r).l2_entry[3]) >> 15) & 0x1)
#define L2_ENTRYm_EVEN_PARITYf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define L2_ENTRYm_ASSOCIATED_DATA_TYPEf_GET(r) ((((r).l2_entry[3]) >> 16) & 0x3)
#define L2_ENTRYm_ASSOCIATED_DATA_TYPEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define L2_ENTRYm_SR_ASSOCIATED_DATAf_GET(r,a) field_get((r).l2_entry,114,168,a)
#define L2_ENTRYm_SR_ASSOCIATED_DATAf_SET(r,a) field_set((r).l2_entry,114,168,a)
#define L2_ENTRYm_SGLPf_GET(r) field32_get((r).l2_entry,114,129)
#define L2_ENTRYm_SGLPf_SET(r,f) field32_set((r).l2_entry,114,129,f)
#define L2_ENTRYm_SR_DUPLICATE_FORWARDINGf_GET(r) ((((r).l2_entry[3]) >> 18) & 0x1)
#define L2_ENTRYm_SR_DUPLICATE_FORWARDINGf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define L2_ENTRYm_SVC_METER_OFFSET_MODEf_GET(r) ((((r).l2_entry[3]) >> 19) & 0x3)
#define L2_ENTRYm_SVC_METER_OFFSET_MODEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define L2_ENTRYm_SVC_METER_INDEXf_GET(r) ((((r).l2_entry[3]) >> 21) & 0xff)
#define L2_ENTRYm_SVC_METER_INDEXf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0xff << 21)) | ((((uint32)f) & 0xff) << 21))
#define L2_ENTRYm_RESERVED_13f_GET(r) field32_get((r).l2_entry,125,129)
#define L2_ENTRYm_RESERVED_13f_SET(r,f) field32_set((r).l2_entry,125,129,f)
#define L2_ENTRYm_SR_MAC_PROXY_PROFILE_PTRf_GET(r) ((((r).l2_entry[4]) >> 2) & 0x3f)
#define L2_ENTRYm_SR_MAC_PROXY_PROFILE_PTRf_SET(r,f) (r).l2_entry[4]=(((r).l2_entry[4] & ~((uint32)0x3f << 2)) | ((((uint32)f) & 0x3f) << 2))
#define L2_ENTRYm_TSN_PRI_OFFSET_PROFILEf_GET(r) ((((r).l2_entry[4]) >> 8) & 0x7)
#define L2_ENTRYm_TSN_PRI_OFFSET_PROFILEf_SET(r,f) (r).l2_entry[4]=(((r).l2_entry[4] & ~((uint32)0x7 << 8)) | ((((uint32)f) & 0x7) << 8))
#define L2_ENTRYm_TSN_CIRCUIT_IDf_GET(r) ((((r).l2_entry[4]) >> 11) & 0xff)
#define L2_ENTRYm_TSN_CIRCUIT_IDf_SET(r,f) (r).l2_entry[4]=(((r).l2_entry[4] & ~((uint32)0xff << 11)) | ((((uint32)f) & 0xff) << 11))
#define L2_ENTRYm_RESERVED_35f_GET(r) ((((r).l2_entry[4]) >> 19) & 0xf)
#define L2_ENTRYm_RESERVED_35f_SET(r,f) (r).l2_entry[4]=(((r).l2_entry[4] & ~((uint32)0xf << 19)) | ((((uint32)f) & 0xf) << 19))
#define L2_ENTRYm_SR_PRI_OFFSET_PROFILEf_GET(r) ((((r).l2_entry[4]) >> 23) & 0x7)
#define L2_ENTRYm_SR_PRI_OFFSET_PROFILEf_SET(r,f) (r).l2_entry[4]=(((r).l2_entry[4] & ~((uint32)0x7 << 23)) | ((((uint32)f) & 0x7) << 23))
#define L2_ENTRYm_SR_FLOW_IDf_GET(r) field32_get((r).l2_entry,154,162)
#define L2_ENTRYm_SR_FLOW_IDf_SET(r,f) field32_set((r).l2_entry,154,162,f)
#define L2_ENTRYm_RESERVED_51f_GET(r) ((((r).l2_entry[5]) >> 3) & 0xf)
#define L2_ENTRYm_RESERVED_51f_SET(r,f) (r).l2_entry[5]=(((r).l2_entry[5] & ~((uint32)0xf << 3)) | ((((uint32)f) & 0xf) << 3))
#define L2_ENTRYm_SANf_GET(r) ((((r).l2_entry[5]) >> 8) & 0x1)
#define L2_ENTRYm_SANf_SET(r,f) (r).l2_entry[5]=(((r).l2_entry[5] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define L2_ENTRYm_PARITYf_GET(r) ((((r).l2_entry[5]) >> 9) & 0x1)
#define L2_ENTRYm_PARITYf_SET(r,f) (r).l2_entry[5]=(((r).l2_entry[5] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define L2_ENTRYm_HITDAf_GET(r) ((((r).l2_entry[5]) >> 10) & 0x1)
#define L2_ENTRYm_HITDAf_SET(r,f) (r).l2_entry[5]=(((r).l2_entry[5] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define L2_ENTRYm_HITSAf_GET(r) ((((r).l2_entry[5]) >> 11) & 0x1)
#define L2_ENTRYm_HITSAf_SET(r,f) (r).l2_entry[5]=(((r).l2_entry[5] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define L2_ENTRYm_LOCAL_SAf_GET(r) ((((r).l2_entry[5]) >> 12) & 0x1)
#define L2_ENTRYm_LOCAL_SAf_SET(r,f) (r).l2_entry[5]=(((r).l2_entry[5] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))

/*
 * These macros can be used to access L2_ENTRY.
 */
#define WRITE_L2_ENTRYm(u,i,r) bcm5607x_mem_set(u, M_L2_ENTRY(i), &(r._l2_entry), 6)
#define READ_L2_ENTRYm(u,i,r) bcm5607x_mem_get(u, M_L2_ENTRY(i), &(r._l2_entry), 6)

/*******************************************************************************
 * End of 'L2_ENTRYm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  L2_USER_ENTRY
 * BLOCKS:   IPIPE
 * DESC:     Combined L2_ENTRY TCAM/Data RAM for guaranteed L2 entries and BPDUs. FeatureSpecific-Ethernet
 * SIZE:     181
 * FIELDS:
 *     VALID            Indicates that the entry is valid
 *     KEY              The entire Key.
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     VFI              Virtual Forwarding Index.
 *     KEY_TYPE         Key Type - VLAN-based(0)
 *     RESERVED         RESERVED.
 *     MASK             Mask for the entire Key.
 *     MAC_ADDR_MASK    MASK of MAC_ADDR
 *     VLAN_ID_MASK     MASK of VLAN_ID
 *     VFI_MASK         MASK of VFI
 *     RESERVED_VFI_MASK MASK of RESERVED_VFI
 *     KEY_TYPE_MASK    MASK of KEY_TYPE
 *     RESERVED_MASK    MASK of RESERVED
 *     PRI              Priority
 *     CPU              CPU bit
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     MIRROR0          Mirror bit
 *     PORT_NUM         Port if T==0
 *     TGID             TGID value if T==1
 *     MODULE_ID        Module ID if T==0
 *     T                Trunk (LAG) indication
 *     BPDU             Indicates entry is a BPDU
 *     DO_NOT_LEARN_MACSA If set to 1, destination hits in the L2_USER_ENTRY will not learn their MACSA
 *     CLASS_ID         L2 Destination Class ID for IFP keys.
 *     L2_PROTOCOL_PKT  When configured as a per-VFI L2_USER_ENTRY TCAM entry, this bit indicates the packet that matched L2 protocol packet
 *     DST_DISCARD      Dst Discard
 *     TAF_GATE_ID_PROFILE Gate ID Profile used to lookup GATE_ID.
 *     RESERVED_179     Reserved.
 *     EVEN_PARITY      Even parity for the  L2_USER_ENTRY_DATA RAM.
 */
#define L2_USER_ENTRYm_MIN 0
#define L2_USER_ENTRYm_MAX 63
#define L2_USER_ENTRYm_CMAX(u) 63
#define L2_USER_ENTRYm_SIZE 23

/*
 * This structure should be used to declare and program L2_USER_ENTRY.
 */
typedef union L2_USER_ENTRYm_s {
	uint32 v[6];
	uint32 l2_user_entry[6];
	uint32 _l2_user_entry;
} L2_USER_ENTRYm_t;

#define L2_USER_ENTRYm_CLR(r) sal_memset(&((r)._l2_user_entry), 0, sizeof(L2_USER_ENTRYm_t))
#define L2_USER_ENTRYm_SET(r,i,d) (r).l2_user_entry[i] = d
#define L2_USER_ENTRYm_GET(r,i) (r).l2_user_entry[i]

/*
 * These macros can be used to access individual fields.
 */
#define L2_USER_ENTRYm_VALIDf_GET(r) (((r).l2_user_entry[0]) & 0x1)
#define L2_USER_ENTRYm_VALIDf_SET(r,f) (r).l2_user_entry[0]=(((r).l2_user_entry[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_USER_ENTRYm_KEYf_GET(r,a) field_get((r).l2_user_entry,1,69,a)
#define L2_USER_ENTRYm_KEYf_SET(r,a) field_set((r).l2_user_entry,1,69,a)
#define L2_USER_ENTRYm_MAC_ADDRf_GET(r,a) field_get((r).l2_user_entry,1,48,a)
#define L2_USER_ENTRYm_MAC_ADDRf_SET(r,a) field_set((r).l2_user_entry,1,48,a)
#define L2_USER_ENTRYm_VLAN_IDf_GET(r) ((((r).l2_user_entry[1]) >> 17) & 0xfff)
#define L2_USER_ENTRYm_VLAN_IDf_SET(r,f) (r).l2_user_entry[1]=(((r).l2_user_entry[1] & ~((uint32)0xfff << 17)) | ((((uint32)f) & 0xfff) << 17))
#define L2_USER_ENTRYm_VFIf_GET(r) ((((r).l2_user_entry[1]) >> 17) & 0x3ff)
#define L2_USER_ENTRYm_VFIf_SET(r,f) (r).l2_user_entry[1]=(((r).l2_user_entry[1] & ~((uint32)0x3ff << 17)) | ((((uint32)f) & 0x3ff) << 17))
#define L2_USER_ENTRYm_KEY_TYPEf_GET(r) ((((r).l2_user_entry[1]) >> 29) & 0x1)
#define L2_USER_ENTRYm_KEY_TYPEf_SET(r,f) (r).l2_user_entry[1]=(((r).l2_user_entry[1] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define L2_USER_ENTRYm_RESERVEDf_GET(r) field32_get((r).l2_user_entry,62,69)
#define L2_USER_ENTRYm_RESERVEDf_SET(r,f) field32_set((r).l2_user_entry,62,69,f)
#define L2_USER_ENTRYm_MASKf_GET(r,a) field_get((r).l2_user_entry,70,138,a)
#define L2_USER_ENTRYm_MASKf_SET(r,a) field_set((r).l2_user_entry,70,138,a)
#define L2_USER_ENTRYm_MAC_ADDR_MASKf_GET(r,a) field_get((r).l2_user_entry,70,117,a)
#define L2_USER_ENTRYm_MAC_ADDR_MASKf_SET(r,a) field_set((r).l2_user_entry,70,117,a)
#define L2_USER_ENTRYm_VLAN_ID_MASKf_GET(r) field32_get((r).l2_user_entry,118,129)
#define L2_USER_ENTRYm_VLAN_ID_MASKf_SET(r,f) field32_set((r).l2_user_entry,118,129,f)
#define L2_USER_ENTRYm_VFI_MASKf_GET(r) ((((r).l2_user_entry[3]) >> 22) & 0x3ff)
#define L2_USER_ENTRYm_VFI_MASKf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32)0x3ff << 22)) | ((((uint32)f) & 0x3ff) << 22))
#define L2_USER_ENTRYm_RESERVED_VFI_MASKf_GET(r) (((r).l2_user_entry[4]) & 0x3)
#define L2_USER_ENTRYm_RESERVED_VFI_MASKf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define L2_USER_ENTRYm_KEY_TYPE_MASKf_GET(r) ((((r).l2_user_entry[4]) >> 2) & 0x1)
#define L2_USER_ENTRYm_KEY_TYPE_MASKf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_USER_ENTRYm_RESERVED_MASKf_GET(r) ((((r).l2_user_entry[4]) >> 3) & 0xff)
#define L2_USER_ENTRYm_RESERVED_MASKf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define L2_USER_ENTRYm_PRIf_GET(r) ((((r).l2_user_entry[4]) >> 11) & 0x7)
#define L2_USER_ENTRYm_PRIf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x7 << 11)) | ((((uint32)f) & 0x7) << 11))
#define L2_USER_ENTRYm_CPUf_GET(r) ((((r).l2_user_entry[4]) >> 14) & 0x1)
#define L2_USER_ENTRYm_CPUf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_USER_ENTRYm_RPEf_GET(r) ((((r).l2_user_entry[4]) >> 16) & 0x1)
#define L2_USER_ENTRYm_RPEf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define L2_USER_ENTRYm_MIRRORf_GET(r) ((((r).l2_user_entry[4]) >> 17) & 0x1)
#define L2_USER_ENTRYm_MIRRORf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define L2_USER_ENTRYm_MIRROR0f_GET(r) ((((r).l2_user_entry[4]) >> 17) & 0x1)
#define L2_USER_ENTRYm_MIRROR0f_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define L2_USER_ENTRYm_PORT_NUMf_GET(r) ((((r).l2_user_entry[4]) >> 19) & 0x7f)
#define L2_USER_ENTRYm_PORT_NUMf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x7f << 19)) | ((((uint32)f) & 0x7f) << 19))
#define L2_USER_ENTRYm_TGIDf_GET(r) ((((r).l2_user_entry[4]) >> 19) & 0x7f)
#define L2_USER_ENTRYm_TGIDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x7f << 19)) | ((((uint32)f) & 0x7f) << 19))
#define L2_USER_ENTRYm_MODULE_IDf_GET(r) field32_get((r).l2_user_entry,154,161)
#define L2_USER_ENTRYm_MODULE_IDf_SET(r,f) field32_set((r).l2_user_entry,154,161,f)
#define L2_USER_ENTRYm_Tf_GET(r) ((((r).l2_user_entry[5]) >> 2) & 0x1)
#define L2_USER_ENTRYm_Tf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_USER_ENTRYm_BPDUf_GET(r) ((((r).l2_user_entry[5]) >> 3) & 0x1)
#define L2_USER_ENTRYm_BPDUf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_USER_ENTRYm_DO_NOT_LEARN_MACSAf_GET(r) ((((r).l2_user_entry[5]) >> 4) & 0x1)
#define L2_USER_ENTRYm_DO_NOT_LEARN_MACSAf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_USER_ENTRYm_CLASS_IDf_GET(r) ((((r).l2_user_entry[5]) >> 5) & 0x3f)
#define L2_USER_ENTRYm_CLASS_IDf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x3f << 5)) | ((((uint32)f) & 0x3f) << 5))
#define L2_USER_ENTRYm_L2_PROTOCOL_PKTf_GET(r) ((((r).l2_user_entry[5]) >> 11) & 0x1)
#define L2_USER_ENTRYm_L2_PROTOCOL_PKTf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define L2_USER_ENTRYm_DST_DISCARDf_GET(r) ((((r).l2_user_entry[5]) >> 12) & 0x1)
#define L2_USER_ENTRYm_DST_DISCARDf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define L2_USER_ENTRYm_TAF_GATE_ID_PROFILEf_GET(r) ((((r).l2_user_entry[5]) >> 13) & 0x3f)
#define L2_USER_ENTRYm_TAF_GATE_ID_PROFILEf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x3f << 13)) | ((((uint32)f) & 0x3f) << 13))
#define L2_USER_ENTRYm_RESERVED_179f_GET(r) ((((r).l2_user_entry[5]) >> 19) & 0x1)
#define L2_USER_ENTRYm_RESERVED_179f_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define L2_USER_ENTRYm_EVEN_PARITYf_GET(r) ((((r).l2_user_entry[5]) >> 20) & 0x1)
#define L2_USER_ENTRYm_EVEN_PARITYf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))

/*
 * These macros can be used to access L2_USER_ENTRY.
 */
#define WRITE_L2_USER_ENTRYm(u,i,r) bcm5607x_tcam_mem_set(u, M_L2_USER_ENTRY(i), &(r._l2_user_entry), 6, 1, 70, 69)
#define READ_L2_USER_ENTRYm(u,i,r) bcm5607x_tcam_mem_get(u, M_L2_USER_ENTRY(i), &(r._l2_user_entry), 6, 1, 70, 69)

/*******************************************************************************
 * End of 'L2_USER_ENTRYm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  L2_USER_ENTRY_CAM_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_CONTROL 
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *     RESERVED_19_16   Reserved bits
 *     BLKSEL           BLKSEL bits
 */
#define L2_USER_ENTRY_CAM_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_DBGCTRL.
 */
typedef union L2_USER_ENTRY_CAM_DBGCTRLr_s {
	uint32 v[1];
	uint32 l2_user_entry_cam_dbgctrl[1];
	uint32 _l2_user_entry_cam_dbgctrl;
} L2_USER_ENTRY_CAM_DBGCTRLr_t;

#define L2_USER_ENTRY_CAM_DBGCTRLr_CLR(r) (r).l2_user_entry_cam_dbgctrl[0] = 0
#define L2_USER_ENTRY_CAM_DBGCTRLr_SET(r,d) (r).l2_user_entry_cam_dbgctrl[0] = d
#define L2_USER_ENTRY_CAM_DBGCTRLr_GET(r) (r).l2_user_entry_cam_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define L2_USER_ENTRY_CAM_DBGCTRLr_TMf_GET(r) (((r).l2_user_entry_cam_dbgctrl[0]) & 0xffff)
#define L2_USER_ENTRY_CAM_DBGCTRLr_TMf_SET(r,f) (r).l2_user_entry_cam_dbgctrl[0]=(((r).l2_user_entry_cam_dbgctrl[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define L2_USER_ENTRY_CAM_DBGCTRLr_RESERVED_19_16f_GET(r) ((((r).l2_user_entry_cam_dbgctrl[0]) >> 16) & 0xf)
#define L2_USER_ENTRY_CAM_DBGCTRLr_RESERVED_19_16f_SET(r,f) (r).l2_user_entry_cam_dbgctrl[0]=(((r).l2_user_entry_cam_dbgctrl[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define L2_USER_ENTRY_CAM_DBGCTRLr_BLKSELf_GET(r) ((((r).l2_user_entry_cam_dbgctrl[0]) >> 20) & 0xf)
#define L2_USER_ENTRY_CAM_DBGCTRLr_BLKSELf_SET(r,f) (r).l2_user_entry_cam_dbgctrl[0]=(((r).l2_user_entry_cam_dbgctrl[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_DBGCTRL.
 */
#define WRITE_L2_USER_ENTRY_CAM_DBGCTRLr(u,r) bcm5607x_reg_set(u,R_L2_USER_ENTRY_CAM_DBGCTRL,(r._l2_user_entry_cam_dbgctrl))
#define READ_L2_USER_ENTRY_CAM_DBGCTRLr(u,r) bcm5607x_reg_get(u,R_L2_USER_ENTRY_CAM_DBGCTRL,&(r._l2_user_entry_cam_dbgctrl))

/*******************************************************************************
 * End of 'L2_USER_ENTRY_CAM_DBGCTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  L3_AUX_HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L3_AUX_HASH_CONTROL. Enable dual hashing mode for L3 table. The hashing mode in this register is for the second group of L3 tables. Hashing mode for first group of L3 tables is controlled via the HASH_SELECT register.
 * SIZE:     32
 * FIELDS:
 *     INSERT_LEAST_FULL_HALF If set to 1, insert entry into the least full half of the hash location.
 *     HASH_SELECT      Selects one of the standard hashing modes.
 *     ENABLE           Set to enable dual hashing feature. This is to improve the first miss utilization.
 */
#define L3_AUX_HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L3_AUX_HASH_CONTROL.
 */
typedef union L3_AUX_HASH_CONTROLr_s {
	uint32 v[1];
	uint32 l3_aux_hash_control[1];
	uint32 _l3_aux_hash_control;
} L3_AUX_HASH_CONTROLr_t;

#define L3_AUX_HASH_CONTROLr_CLR(r) (r).l3_aux_hash_control[0] = 0
#define L3_AUX_HASH_CONTROLr_SET(r,d) (r).l3_aux_hash_control[0] = d
#define L3_AUX_HASH_CONTROLr_GET(r) (r).l3_aux_hash_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define L3_AUX_HASH_CONTROLr_INSERT_LEAST_FULL_HALFf_GET(r) (((r).l3_aux_hash_control[0]) & 0x1)
#define L3_AUX_HASH_CONTROLr_INSERT_LEAST_FULL_HALFf_SET(r,f) (r).l3_aux_hash_control[0]=(((r).l3_aux_hash_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L3_AUX_HASH_CONTROLr_HASH_SELECTf_GET(r) ((((r).l3_aux_hash_control[0]) >> 1) & 0x7)
#define L3_AUX_HASH_CONTROLr_HASH_SELECTf_SET(r,f) (r).l3_aux_hash_control[0]=(((r).l3_aux_hash_control[0] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define L3_AUX_HASH_CONTROLr_ENABLEf_GET(r) ((((r).l3_aux_hash_control[0]) >> 4) & 0x1)
#define L3_AUX_HASH_CONTROLr_ENABLEf_SET(r,f) (r).l3_aux_hash_control[0]=(((r).l3_aux_hash_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))

/*
 * These macros can be used to access L3_AUX_HASH_CONTROL.
 */
#define WRITE_L3_AUX_HASH_CONTROLr(u,r) bcm5607x_reg_set(u,R_L3_AUX_HASH_CONTROL,(r._l3_aux_hash_control))
#define READ_L3_AUX_HASH_CONTROLr(u,r) bcm5607x_reg_get(u,R_L3_AUX_HASH_CONTROL,&(r._l3_aux_hash_control))

/*******************************************************************************
 * End of 'L3_AUX_HASH_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  LWMCOSCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLSETLIMIT     CELL THD.This field indicates the threshold at which packet drops will begin in terms of buffer utilization in the units of cells, setting the HOL blocking state for this queue/port.In Dynamic Memory mode:This LWMCOSCELLSETLIMIT.CELLSETLIMIT register allocates the guaranteed cells for one port's COSx queue. After cell count over this limit, it will start using dynamic cells in port dynamic space.When the following conditions are met, it will set this queue's HOL status and stop admitting any new coming cell. ( ( DYNCELLCOUNT(port) >=DYNCELLLIMIT.DYNCELLLIMIT(port) ) OR ( TOTALDYNCELLUSED >=TOTALDYNCELLLIMIT.SETLIMIT ) ) AND ( COSLCCOUNT(port, cos) >=LWMCOSCELLSETLIMIT.CELLSETLIMIT(port, cos) )When not in Dynamic Memory Mode, This is COSx queue HOL Cell high limit.When the following condition is met, it will set this queue's HOL status and stop admitting any new coming cell. ( COSLCCOUNT(port, cos) >=LWMCOSCELLSETLIMIT.CELLSETLIMIT(port, cos) ) Note:This register only can be changed when frame buffer is empty. 
 *     CELLRESETLIMIT   CELL THD.This field indicates the level at which buffer utilization in terms of cells must drop below before traffic is allowed to resume from HOL blocking state.When in Dynamic Memory mode:To reset a cos queue's HOL status, it needs to meet following conditions ( ( DYNCELLCOUNT(port) <DYNCELLLIMIT.RESETLIMIT(port) ) AND ( TOTALDYNCELLUSED <TOTALDYNCELLRESETLIMIT.RESETLIMIT ) ) OR ( COSLCCOUNT(port, cos) <LWMCOSCELLSETLIMIT.RESETLIMIT(port, cos) )When not in Dynamic Memory Mode:To reset a cos queue's HOL status, it needs to meet following condition ( COSLCCOUNT(port, cos) <LWMCOSCELLSETLIMIT.RESETLIMIT(port, cos) ) Note:This register only can be changed when frame buffer is empty. 
 */
#define LWMCOSCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program LWMCOSCELLSETLIMIT.
 */
typedef union LWMCOSCELLSETLIMITr_s {
	uint32 v[1];
	uint32 lwmcoscellsetlimit[1];
	uint32 _lwmcoscellsetlimit;
} LWMCOSCELLSETLIMITr_t;

#define LWMCOSCELLSETLIMITr_CLR(r) (r).lwmcoscellsetlimit[0] = 0
#define LWMCOSCELLSETLIMITr_SET(r,d) (r).lwmcoscellsetlimit[0] = d
#define LWMCOSCELLSETLIMITr_GET(r) (r).lwmcoscellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define LWMCOSCELLSETLIMITr_CELLSETLIMITf_GET(r) (((r).lwmcoscellsetlimit[0]) & 0x3fff)
#define LWMCOSCELLSETLIMITr_CELLSETLIMITf_SET(r,f) (r).lwmcoscellsetlimit[0]=(((r).lwmcoscellsetlimit[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define LWMCOSCELLSETLIMITr_CELLRESETLIMITf_GET(r) ((((r).lwmcoscellsetlimit[0]) >> 14) & 0x3fff)
#define LWMCOSCELLSETLIMITr_CELLRESETLIMITf_SET(r,f) (r).lwmcoscellsetlimit[0]=(((r).lwmcoscellsetlimit[0] & ~((uint32)0x3fff << 14)) | ((((uint32)f) & 0x3fff) << 14))

/*
 * These macros can be used to access LWMCOSCELLSETLIMIT.
 */
#define WRITE_LWMCOSCELLSETLIMITr(u,p, cos,r) bcm5607x_reg_set(u, R_LWMCOSCELLSETLIMIT(cos,p), (r._lwmcoscellsetlimit))
#define READ_LWMCOSCELLSETLIMITr(u,p, cos,r) bcm5607x_reg_get(u,R_LWMCOSCELLSETLIMIT(cos,p),&(r._lwmcoscellsetlimit))

/*******************************************************************************
 * End of 'LWMCOSCELLSETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  LWMCOSCELLSETLIMIT_QLAYER
 * BLOCKS:   MMU
 * DESC:     per-Q HOL cell min guarantee threshold
 * SIZE:     32
 * FIELDS:
 *     CELLSETLIMIT     This field indicates the threshold at which packet drops will begin in terms of buffer utilization in the units of cells, setting the HOL blocking state for this queue/port.In Dynamic Memory mode:This LWMCOSCELLSETLIMIT.CELLSETLIMIT register allocates the guaranteed cells for one port's COSx queue. After cell count over this limit, it will start using dynamic cells in port dynamic space.When the following conditions are met, it will set this queue's HOL status and stop admitting any new coming cell. ( ( DYNCELLCOUNT(port) >=DYNCELLLIMIT.DYNCELLLIMIT(port) ) OR ( TOTALDYNCELLUSED >=TOTALDYNCELLLIMIT.SETLIMIT ) ) AND ( COSLCCOUNT(port, cos) >=LWMCOSCELLSETLIMIT.CELLSETLIMIT(port, cos) )When not in Dynamic Memory Mode, This is COSx queue HOL Cell high limit.When the following condition is met, it will set this queue's HOL status and stop admitting any new coming cell. ( COSLCCOUNT(port, cos) >=LWMCOSCELLSETLIMIT.CELLSETLIMIT(port, cos) ) Note:This register only can be changed when frame buffer is empty and all traffic stops.
 *     CELLRESETLIMIT   This field indicates the level at which buffer utilization in terms of cells must drop below before traffic is allowed to resume from HOL blocking state.When in Dynamic Memory mode:To reset a cos queue's HOL status, it needs to meet following conditions ( ( DYNCELLCOUNT(port) <DYNCELLLIMIT.RESETLIMIT(port) ) AND ( TOTALDYNCELLUSED <TOTALDYNCELLRESETLIMIT.RESETLIMIT ) ) OR ( COSLCCOUNT(port, cos) <LWMCOSCELLSETLIMIT.RESETLIMIT(port, cos) )When not in Dynamic Memory Mode:To reset a cos queue's HOL status, it needs to meet following condition ( COSLCCOUNT(port, cos) <LWMCOSCELLSETLIMIT.RESETLIMIT(port, cos) ) 
 */
#define LWMCOSCELLSETLIMIT_QLAYERr_SIZE 4

/*
 * This structure should be used to declare and program LWMCOSCELLSETLIMIT_QLAYER.
 */
typedef union LWMCOSCELLSETLIMIT_QLAYERr_s {
	uint32 v[1];
	uint32 lwmcoscellsetlimit_qlayer[1];
	uint32 _lwmcoscellsetlimit_qlayer;
} LWMCOSCELLSETLIMIT_QLAYERr_t;

#define LWMCOSCELLSETLIMIT_QLAYERr_CLR(r) (r).lwmcoscellsetlimit_qlayer[0] = 0
#define LWMCOSCELLSETLIMIT_QLAYERr_SET(r,d) (r).lwmcoscellsetlimit_qlayer[0] = d
#define LWMCOSCELLSETLIMIT_QLAYERr_GET(r) (r).lwmcoscellsetlimit_qlayer[0]

/*
 * These macros can be used to access individual fields.
 */
#define LWMCOSCELLSETLIMIT_QLAYERr_CELLSETLIMITf_GET(r) (((r).lwmcoscellsetlimit_qlayer[0]) & 0x3fff)
#define LWMCOSCELLSETLIMIT_QLAYERr_CELLSETLIMITf_SET(r,f) (r).lwmcoscellsetlimit_qlayer[0]=(((r).lwmcoscellsetlimit_qlayer[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define LWMCOSCELLSETLIMIT_QLAYERr_CELLRESETLIMITf_GET(r) ((((r).lwmcoscellsetlimit_qlayer[0]) >> 14) & 0x3fff)
#define LWMCOSCELLSETLIMIT_QLAYERr_CELLRESETLIMITf_SET(r,f) (r).lwmcoscellsetlimit_qlayer[0]=(((r).lwmcoscellsetlimit_qlayer[0] & ~((uint32)0x3fff << 14)) | ((((uint32)f) & 0x3fff) << 14))

/*
 * These macros can be used to access LWMCOSCELLSETLIMIT_QLAYER.
 */
#define WRITE_LWMCOSCELLSETLIMIT_QLAYERr(u,p, cos,r) bcm5607x_reg_set(u, R_LWMCOSCELLSETLIMIT_QLAYER(cos,p), (r._lwmcoscellsetlimit_qlayer))
#define READ_LWMCOSCELLSETLIMIT_QLAYERr(u,p, cos,r) bcm5607x_reg_get(u,R_LWMCOSCELLSETLIMIT_QLAYER(cos,p),&(r._lwmcoscellsetlimit_qlayer))

/*******************************************************************************
 * End of 'LWMCOSCELLSETLIMIT_QLAYERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MAC_0
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     MAC Address 32-Bit Word 0. Core MAC address bit 47 to 16.
 * SIZE:     32
 * FIELDS:
 *     MAC_ADDR0        Register Bit 0 refers to Bit 16 of the MAC address, Bit 1 refers to bit 17 of the MAC address etc.
 */
#define MAC_0r_SIZE 4

/* MAC_0r is element of MAC */

/*
 * This structure should be used to declare and program MAC_0.
 */
typedef union MAC_0r_s {
	uint32 v[1];
	uint32 mac_0[1];
	uint32 _mac_0;
} MAC_0r_t;

#define MAC_0r_CLR(r) (r).mac_0[0] = 0
#define MAC_0r_SET(r,d) (r).mac_0[0] = d
#define MAC_0r_GET(r) (r).mac_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_0r_MAC_ADDR0f_GET(r) ((r).mac_0[0])
#define MAC_0r_MAC_ADDR0f_SET(r,f) (r).mac_0[0]=((uint32)f)

/*
 * These macros can be used to access MAC_0.
 */
#define WRITE_MAC_0r(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_0(bcm5607x_gport_lport_to_index_in_block[p]), (r._mac_0))
#define READ_MAC_0r(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_0(bcm5607x_gport_lport_to_index_in_block[p]), &(r._mac_0))

/*******************************************************************************
 * End of 'MAC_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MAC_1
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     MAC Address 32-Bit Word 1. Core MAC address bit 15 to 0.
 * SIZE:     32
 * FIELDS:
 *     MAC_ADDR1        Register Bit 0 refers to Bit 0 of the MAC address, Register Bit 1 refers to Bit 1 of the MAC address etc.Bits 16 to 31 are reserved.
 */
#define MAC_1r_SIZE 4

/* MAC_1r is element of MAC */

/*
 * This structure should be used to declare and program MAC_1.
 */
typedef union MAC_1r_s {
	uint32 v[1];
	uint32 mac_1[1];
	uint32 _mac_1;
} MAC_1r_t;

#define MAC_1r_CLR(r) (r).mac_1[0] = 0
#define MAC_1r_SET(r,d) (r).mac_1[0] = d
#define MAC_1r_GET(r) (r).mac_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_1r_MAC_ADDR1f_GET(r) (((r).mac_1[0]) & 0xffff)
#define MAC_1r_MAC_ADDR1f_SET(r,f) (r).mac_1[0]=(((r).mac_1[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access MAC_1.
 */
#define WRITE_MAC_1r(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_1(bcm5607x_gport_lport_to_index_in_block[p]), (r._mac_1))
#define READ_MAC_1r(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_1(bcm5607x_gport_lport_to_index_in_block[p]), &(r._mac_1))

/*******************************************************************************
 * End of 'MAC_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MAC_PFC_CTRL
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     PPP control register
 * SIZE:     32
 * FIELDS:
 *     PFC_TX_ENBL      Enables the PPP-Tx functionality.
 *     PFC_RX_ENBL      Enables the PPP-Rx functionality.
 *     FORCE_PFC_XON    Instructs MAC to send Xon message to all classes of service.
 *     RX_PASS_PFC_FRM  When set, MAC pass PFC frame to the system. Otherwise, PFC frame is discarded.
 *     PFC_STATS_EN     When clear, none of PFC related counters should increment. 			       Otherwise, PFC counters is in full function.                                Note: it is programming requirement to set this bit when PFC function is enable.
 */
#define MAC_PFC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MAC_PFC_CTRL.
 */
typedef union MAC_PFC_CTRLr_s {
	uint32 v[1];
	uint32 mac_pfc_ctrl[1];
	uint32 _mac_pfc_ctrl;
} MAC_PFC_CTRLr_t;

#define MAC_PFC_CTRLr_CLR(r) (r).mac_pfc_ctrl[0] = 0
#define MAC_PFC_CTRLr_SET(r,d) (r).mac_pfc_ctrl[0] = d
#define MAC_PFC_CTRLr_GET(r) (r).mac_pfc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_PFC_CTRLr_PFC_TX_ENBLf_GET(r) (((r).mac_pfc_ctrl[0]) & 0x1)
#define MAC_PFC_CTRLr_PFC_TX_ENBLf_SET(r,f) (r).mac_pfc_ctrl[0]=(((r).mac_pfc_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define MAC_PFC_CTRLr_PFC_RX_ENBLf_GET(r) ((((r).mac_pfc_ctrl[0]) >> 1) & 0x1)
#define MAC_PFC_CTRLr_PFC_RX_ENBLf_SET(r,f) (r).mac_pfc_ctrl[0]=(((r).mac_pfc_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define MAC_PFC_CTRLr_FORCE_PFC_XONf_GET(r) ((((r).mac_pfc_ctrl[0]) >> 2) & 0x1)
#define MAC_PFC_CTRLr_FORCE_PFC_XONf_SET(r,f) (r).mac_pfc_ctrl[0]=(((r).mac_pfc_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define MAC_PFC_CTRLr_RX_PASS_PFC_FRMf_GET(r) ((((r).mac_pfc_ctrl[0]) >> 4) & 0x1)
#define MAC_PFC_CTRLr_RX_PASS_PFC_FRMf_SET(r,f) (r).mac_pfc_ctrl[0]=(((r).mac_pfc_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define MAC_PFC_CTRLr_PFC_STATS_ENf_GET(r) ((((r).mac_pfc_ctrl[0]) >> 5) & 0x1)
#define MAC_PFC_CTRLr_PFC_STATS_ENf_SET(r,f) (r).mac_pfc_ctrl[0]=(((r).mac_pfc_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))

/*
 * These macros can be used to access MAC_PFC_CTRL.
 */
#define WRITE_MAC_PFC_CTRLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_PFC_CTRL(bcm5607x_gport_lport_to_index_in_block[p]), (r._mac_pfc_ctrl))
#define READ_MAC_PFC_CTRLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_PFC_CTRL(bcm5607x_gport_lport_to_index_in_block[p]), &(r._mac_pfc_ctrl))

/*******************************************************************************
 * End of 'MAC_PFC_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MAC_PFC_DA_0
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     lower 32 bits of programmable DA for PPP (GNAT 13897)
 * SIZE:     32
 * FIELDS:
 *     PFC_MACDA_0      Lower 32 bits of programmable DA for PPP. Since PPP is not standardized yet, the DA must be programmable to make sure that when it gets standardized, we can be standards compliant. 
 */
#define MAC_PFC_DA_0r_SIZE 4

/* MAC_PFC_DA_0r is element of MAC_PFC_DA */

/*
 * This structure should be used to declare and program MAC_PFC_DA_0.
 */
typedef union MAC_PFC_DA_0r_s {
	uint32 v[1];
	uint32 mac_pfc_da_0[1];
	uint32 _mac_pfc_da_0;
} MAC_PFC_DA_0r_t;

#define MAC_PFC_DA_0r_CLR(r) (r).mac_pfc_da_0[0] = 0
#define MAC_PFC_DA_0r_SET(r,d) (r).mac_pfc_da_0[0] = d
#define MAC_PFC_DA_0r_GET(r) (r).mac_pfc_da_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_PFC_DA_0r_PFC_MACDA_0f_GET(r) ((r).mac_pfc_da_0[0])
#define MAC_PFC_DA_0r_PFC_MACDA_0f_SET(r,f) (r).mac_pfc_da_0[0]=((uint32)f)

/*
 * These macros can be used to access MAC_PFC_DA_0.
 */
#define WRITE_MAC_PFC_DA_0r(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_PFC_DA_0(bcm5607x_gport_lport_to_index_in_block[p]), (r._mac_pfc_da_0))
#define READ_MAC_PFC_DA_0r(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_PFC_DA_0(bcm5607x_gport_lport_to_index_in_block[p]), &(r._mac_pfc_da_0))

/*******************************************************************************
 * End of 'MAC_PFC_DA_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MAC_PFC_DA_1
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     upper 16 bits of programmable DA for PPP (GNAT 13897)
 * SIZE:     32
 * FIELDS:
 *     PFC_MACDA_1      Upper 16 bits of programmable DA for PPP. Since PPP is not standardized yet, the DA must be programmable to make sure that when it gets standardized, we can be standards compliant. 
 */
#define MAC_PFC_DA_1r_SIZE 4

/* MAC_PFC_DA_1r is element of MAC_PFC_DA */

/*
 * This structure should be used to declare and program MAC_PFC_DA_1.
 */
typedef union MAC_PFC_DA_1r_s {
	uint32 v[1];
	uint32 mac_pfc_da_1[1];
	uint32 _mac_pfc_da_1;
} MAC_PFC_DA_1r_t;

#define MAC_PFC_DA_1r_CLR(r) (r).mac_pfc_da_1[0] = 0
#define MAC_PFC_DA_1r_SET(r,d) (r).mac_pfc_da_1[0] = d
#define MAC_PFC_DA_1r_GET(r) (r).mac_pfc_da_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_PFC_DA_1r_PFC_MACDA_1f_GET(r) (((r).mac_pfc_da_1[0]) & 0xffff)
#define MAC_PFC_DA_1r_PFC_MACDA_1f_SET(r,f) (r).mac_pfc_da_1[0]=(((r).mac_pfc_da_1[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access MAC_PFC_DA_1.
 */
#define WRITE_MAC_PFC_DA_1r(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_PFC_DA_1(bcm5607x_gport_lport_to_index_in_block[p]), (r._mac_pfc_da_1))
#define READ_MAC_PFC_DA_1r(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_PFC_DA_1(bcm5607x_gport_lport_to_index_in_block[p]), &(r._mac_pfc_da_1))

/*******************************************************************************
 * End of 'MAC_PFC_DA_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MAC_PFC_OPCODE
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Programmable opcode (GNAT 13440)
 * SIZE:     32
 * FIELDS:
 *     PFC_OPCODE       These 16 bits are for opcode. Since PFC is not standardized yet, the opcode must be programmable to make sure that when it gets standardized, we can be standards compliant. 
 */
#define MAC_PFC_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program MAC_PFC_OPCODE.
 */
typedef union MAC_PFC_OPCODEr_s {
	uint32 v[1];
	uint32 mac_pfc_opcode[1];
	uint32 _mac_pfc_opcode;
} MAC_PFC_OPCODEr_t;

#define MAC_PFC_OPCODEr_CLR(r) (r).mac_pfc_opcode[0] = 0
#define MAC_PFC_OPCODEr_SET(r,d) (r).mac_pfc_opcode[0] = d
#define MAC_PFC_OPCODEr_GET(r) (r).mac_pfc_opcode[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_PFC_OPCODEr_PFC_OPCODEf_GET(r) (((r).mac_pfc_opcode[0]) & 0xffff)
#define MAC_PFC_OPCODEr_PFC_OPCODEf_SET(r,f) (r).mac_pfc_opcode[0]=(((r).mac_pfc_opcode[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access MAC_PFC_OPCODE.
 */
#define WRITE_MAC_PFC_OPCODEr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_PFC_OPCODE(bcm5607x_gport_lport_to_index_in_block[p]), (r._mac_pfc_opcode))
#define READ_MAC_PFC_OPCODEr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_PFC_OPCODE(bcm5607x_gport_lport_to_index_in_block[p]), &(r._mac_pfc_opcode))

/*******************************************************************************
 * End of 'MAC_PFC_OPCODEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MAC_PFC_REFRESH_CTRL
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     PPP refresh control register
 * SIZE:     32
 * FIELDS:
 *     PFC_REFRESH_EN   Enables the PPP refresh functionality on the Tx side. When enabled, the MAC sends Xoff message on refresh counter becoming 0
 *     PFC_REFRESH_TIMER PPP refresh counter value.
 */
#define MAC_PFC_REFRESH_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MAC_PFC_REFRESH_CTRL.
 */
typedef union MAC_PFC_REFRESH_CTRLr_s {
	uint32 v[1];
	uint32 mac_pfc_refresh_ctrl[1];
	uint32 _mac_pfc_refresh_ctrl;
} MAC_PFC_REFRESH_CTRLr_t;

#define MAC_PFC_REFRESH_CTRLr_CLR(r) (r).mac_pfc_refresh_ctrl[0] = 0
#define MAC_PFC_REFRESH_CTRLr_SET(r,d) (r).mac_pfc_refresh_ctrl[0] = d
#define MAC_PFC_REFRESH_CTRLr_GET(r) (r).mac_pfc_refresh_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_PFC_REFRESH_CTRLr_PFC_REFRESH_ENf_GET(r) (((r).mac_pfc_refresh_ctrl[0]) & 0x1)
#define MAC_PFC_REFRESH_CTRLr_PFC_REFRESH_ENf_SET(r,f) (r).mac_pfc_refresh_ctrl[0]=(((r).mac_pfc_refresh_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define MAC_PFC_REFRESH_CTRLr_PFC_REFRESH_TIMERf_GET(r) ((((r).mac_pfc_refresh_ctrl[0]) >> 16) & 0xffff)
#define MAC_PFC_REFRESH_CTRLr_PFC_REFRESH_TIMERf_SET(r,f) (r).mac_pfc_refresh_ctrl[0]=(((r).mac_pfc_refresh_ctrl[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access MAC_PFC_REFRESH_CTRL.
 */
#define WRITE_MAC_PFC_REFRESH_CTRLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_PFC_REFRESH_CTRL(bcm5607x_gport_lport_to_index_in_block[p]), (r._mac_pfc_refresh_ctrl))
#define READ_MAC_PFC_REFRESH_CTRLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_PFC_REFRESH_CTRL(bcm5607x_gport_lport_to_index_in_block[p]), &(r._mac_pfc_refresh_ctrl))

/*******************************************************************************
 * End of 'MAC_PFC_REFRESH_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MAC_PFC_TYPE
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Programmable ethertype (GNAT 13440)
 * SIZE:     32
 * FIELDS:
 *     PFC_ETH_TYPE     These 16 bits are for programmable ethertype in PFC. Since PFC is not standardized yet, the ethertype must be programmable to make sure that when it gets standardized, we can be standards compliant. 
 */
#define MAC_PFC_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program MAC_PFC_TYPE.
 */
typedef union MAC_PFC_TYPEr_s {
	uint32 v[1];
	uint32 mac_pfc_type[1];
	uint32 _mac_pfc_type;
} MAC_PFC_TYPEr_t;

#define MAC_PFC_TYPEr_CLR(r) (r).mac_pfc_type[0] = 0
#define MAC_PFC_TYPEr_SET(r,d) (r).mac_pfc_type[0] = d
#define MAC_PFC_TYPEr_GET(r) (r).mac_pfc_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_PFC_TYPEr_PFC_ETH_TYPEf_GET(r) (((r).mac_pfc_type[0]) & 0xffff)
#define MAC_PFC_TYPEr_PFC_ETH_TYPEf_SET(r,f) (r).mac_pfc_type[0]=(((r).mac_pfc_type[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access MAC_PFC_TYPE.
 */
#define WRITE_MAC_PFC_TYPEr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_PFC_TYPE(bcm5607x_gport_lport_to_index_in_block[p]), (r._mac_pfc_type))
#define READ_MAC_PFC_TYPEr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_MAC_PFC_TYPE(bcm5607x_gport_lport_to_index_in_block[p]), &(r._mac_pfc_type))

/*******************************************************************************
 * End of 'MAC_PFC_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MII_EEE_DELAY_ENTRY_TIMER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     MII_EEE LPI timer
 * SIZE:     32
 * FIELDS:
 *     MII_EEE_LPI_TIMER This is the duration for which condition to move to LPI state must be satisfied, at the end of which MAC transitions to LPI State. The decrement unit is 1 micro-second.This register is meant for 10/100 Mbps speed.
 */
#define MII_EEE_DELAY_ENTRY_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program MII_EEE_DELAY_ENTRY_TIMER.
 */
typedef union MII_EEE_DELAY_ENTRY_TIMERr_s {
	uint32 v[1];
	uint32 mii_eee_delay_entry_timer[1];
	uint32 _mii_eee_delay_entry_timer;
} MII_EEE_DELAY_ENTRY_TIMERr_t;

#define MII_EEE_DELAY_ENTRY_TIMERr_CLR(r) (r).mii_eee_delay_entry_timer[0] = 0
#define MII_EEE_DELAY_ENTRY_TIMERr_SET(r,d) (r).mii_eee_delay_entry_timer[0] = d
#define MII_EEE_DELAY_ENTRY_TIMERr_GET(r) (r).mii_eee_delay_entry_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define MII_EEE_DELAY_ENTRY_TIMERr_MII_EEE_LPI_TIMERf_GET(r) ((r).mii_eee_delay_entry_timer[0])
#define MII_EEE_DELAY_ENTRY_TIMERr_MII_EEE_LPI_TIMERf_SET(r,f) (r).mii_eee_delay_entry_timer[0]=((uint32)f)

/*
 * These macros can be used to access MII_EEE_DELAY_ENTRY_TIMER.
 */
#define WRITE_MII_EEE_DELAY_ENTRY_TIMERr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_MII_EEE_DELAY_ENTRY_TIMER(bcm5607x_gport_lport_to_index_in_block[p]), (r._mii_eee_delay_entry_timer))
#define READ_MII_EEE_DELAY_ENTRY_TIMERr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_MII_EEE_DELAY_ENTRY_TIMER(bcm5607x_gport_lport_to_index_in_block[p]), &(r._mii_eee_delay_entry_timer))

/*******************************************************************************
 * End of 'MII_EEE_DELAY_ENTRY_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MII_EEE_WAKE_TIMER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     MII_EEE Wake timer
 * SIZE:     32
 * FIELDS:
 *     MII_EEE_WAKE_TIMER_FLD This is the duration for which MAC must wait to go back to ACTIVE state from LPI state when it receives packet for transmission. The decrement unit is 1 micro-second.This register is meant for 10/100 Mbps speed.
 */
#define MII_EEE_WAKE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program MII_EEE_WAKE_TIMER.
 */
typedef union MII_EEE_WAKE_TIMERr_s {
	uint32 v[1];
	uint32 mii_eee_wake_timer[1];
	uint32 _mii_eee_wake_timer;
} MII_EEE_WAKE_TIMERr_t;

#define MII_EEE_WAKE_TIMERr_CLR(r) (r).mii_eee_wake_timer[0] = 0
#define MII_EEE_WAKE_TIMERr_SET(r,d) (r).mii_eee_wake_timer[0] = d
#define MII_EEE_WAKE_TIMERr_GET(r) (r).mii_eee_wake_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define MII_EEE_WAKE_TIMERr_MII_EEE_WAKE_TIMER_FLDf_GET(r) (((r).mii_eee_wake_timer[0]) & 0xffff)
#define MII_EEE_WAKE_TIMERr_MII_EEE_WAKE_TIMER_FLDf_SET(r,f) (r).mii_eee_wake_timer[0]=(((r).mii_eee_wake_timer[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access MII_EEE_WAKE_TIMER.
 */
#define WRITE_MII_EEE_WAKE_TIMERr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_MII_EEE_WAKE_TIMER(bcm5607x_gport_lport_to_index_in_block[p]), (r._mii_eee_wake_timer))
#define READ_MII_EEE_WAKE_TIMERr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_MII_EEE_WAKE_TIMER(bcm5607x_gport_lport_to_index_in_block[p]), &(r._mii_eee_wake_timer))

/*******************************************************************************
 * End of 'MII_EEE_WAKE_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MIRROR_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Mirror control register 
 * SIZE:     32
 * FIELDS:
 *     M_ENABLE         Enable mirroring
 *     IM_MTP_INDEX     Ingress MTP index
 *     IM_MTP_INDEX0    Ingress MTP index
 *     EM_MTP_INDEX     Egress MTP index
 *     EM_MTP_INDEX0    Egress MTP index
 *     NON_UC_EM_MTP_INDEX Non-unicast egress MTP index
 *     NON_UC_EM_MTP_INDEX0 Non-unicast egress MTP index
 *     SRC_MODID_BLOCK_MIRROR_ONLY_PKT Apply the source MODID block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig packets with MH.M=1, MH.MO=1, MH.MD=0 ports
 *     SRC_MODID_BLOCK_MIRROR_COPY Apply the source MODID block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig packets with MH.M=1, MH.MO=0, MH.MD=0 ports
 */
#define MIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MIRROR_CONTROL.
 */
typedef union MIRROR_CONTROLr_s {
	uint32 v[1];
	uint32 mirror_control[1];
	uint32 _mirror_control;
} MIRROR_CONTROLr_t;

#define MIRROR_CONTROLr_CLR(r) (r).mirror_control[0] = 0
#define MIRROR_CONTROLr_SET(r,d) (r).mirror_control[0] = d
#define MIRROR_CONTROLr_GET(r) (r).mirror_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIRROR_CONTROLr_M_ENABLEf_GET(r) (((r).mirror_control[0]) & 0x1)
#define MIRROR_CONTROLr_M_ENABLEf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define MIRROR_CONTROLr_IM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 1) & 0x3)
#define MIRROR_CONTROLr_IM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x3 << 1)) | ((((uint32)f) & 0x3) << 1))
#define MIRROR_CONTROLr_IM_MTP_INDEX0f_GET(r) ((((r).mirror_control[0]) >> 1) & 0x3)
#define MIRROR_CONTROLr_IM_MTP_INDEX0f_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x3 << 1)) | ((((uint32)f) & 0x3) << 1))
#define MIRROR_CONTROLr_EM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 3) & 0x3)
#define MIRROR_CONTROLr_EM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x3 << 3)) | ((((uint32)f) & 0x3) << 3))
#define MIRROR_CONTROLr_EM_MTP_INDEX0f_GET(r) ((((r).mirror_control[0]) >> 3) & 0x3)
#define MIRROR_CONTROLr_EM_MTP_INDEX0f_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x3 << 3)) | ((((uint32)f) & 0x3) << 3))
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 5) & 0x3)
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x3 << 5)) | ((((uint32)f) & 0x3) << 5))
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEX0f_GET(r) ((((r).mirror_control[0]) >> 5) & 0x3)
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEX0f_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x3 << 5)) | ((((uint32)f) & 0x3) << 5))
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET(r) ((((r).mirror_control[0]) >> 13) & 0x1)
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET(r) ((((r).mirror_control[0]) >> 14) & 0x1)
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))

/*
 * These macros can be used to access MIRROR_CONTROL.
 */
#define WRITE_MIRROR_CONTROLr(u,p,r) bcm5607x_reg_set(u,R_MIRROR_CONTROL(p),(r._mirror_control))
#define READ_MIRROR_CONTROLr(u,p,r) bcm5607x_reg_get(u,R_MIRROR_CONTROL(p),&(r._mirror_control))

/*******************************************************************************
 * End of 'MIRROR_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MISCCONFIG
 * BLOCKS:   MMU
 * DESC:     Controls various functions in the MMU
 * SIZE:     32
 * FIELDS:
 *     DYNAMIC_MEMORY_EN Dynamic Memory Mode EnableHOL cell limit behavior (dynamic sharing of CBP):1: Dynamic Memory mode is enabled,0: Dynamic Memory mode is disabled.
 *     CLRDROPCTR       Clear All Drop Packet CountersWhen set to 1, MMU will clear all port counters of the followings:DROPPEDPKTCOUNT, CNGDROPCOUNT0, CNGDROPCOUNT1.Reading this bit will always return 0.
 *     SKIDMARKER       SkidMarker for each HOL Packet Counter, reserved value for the packets already in the transition to be accepted by MMU XQ. The values of SkidMarker are:0: 4 packets,1: 5 packets, 2: 6 packets,3: 7 packets.
 *     SLAM_MEM         Write 1 into this register will interrupt CFAP & CCP power-on initialization.After write 1 into this register, users will be able to slam cfap and ccp memories with desired value. When memory slamming is done, users need to wirte 1 into CFAPCONFIG.CFAPINIT register to complete CFAP & CCP initialzation.This regsiter should not be programmed while the tarffic is on. It may generate unexpected result.
 *     METERING_CLK_EN  METERING_CLK_EN will enable metering 3.90625us refresh tick to flow into egress port metering, min/max bucket and ingress back pressure metering function.0: Disable refresh tick,1: Enable refresh tick.
 *     PARITY_CHECK_EN  PARITY_CHECK_EN enable MMU hardware to 1. generate parity/ECC for memory write data2. check the parity protection memory read out data, report parity error3. check the ECC protection memory read out data,report ECC error and repair 1 bit error.4. "0": Disable memory parity/ECC "1": Enable  memory parity/ECC
 *     HOL_CELL_SOP_DROP_EN Only do HOL cell drop on sop cell to help TCP performance. This bit is also used to drop packets                               on SOP cell for BKP discard. 0X0 = DISABLE - Disable hol cell drop on sop cell 0x1 = ENABLE - Enable hol cell drop on sop cell 
 *     DYN_XQ_EN        Dynamic sharing of descriptor queue (XQ) among COSn for a port 0x0 = DISABLE - Disable dyn_xq_en 0x1 = ENABLE - Enable dyn_xq_en 
 *     IPMC_IND_MODE    IPMC_IND_MODE will enable egress port's ppp send out one extra l2 packet with L3IPMC packets when a packet is tagged as both l2 and l3 switching 0: disable sending extra l2 packet,1: enable sending extra l2 packet.
 *     CNG_DROP_EN      Set this bit will enable CNG colored packet drop function 0x0 = DISABLE - Disable CNG packet drop function 0x1 = ENABLE - Enable CNG packet drop function
 *     MULTIPLE_ACCOUNTING_FIX_EN Set to enable the fix for the accounting logic of the global dynamic space, for a multicast cell 0x0 = DISABLE - Disable MC accounting fix 0x1 = ENABLE - Enable MC accounting fix
 *     RESERVED         Reserved
 *     RESERVED_1       Reserved
 *     MEM_CORRUPT_CTL  This is purely for debug purpose.MMU memory feature wrapper has 2 corrupt control bits . Software/DV/DVT can inject memory error by setting these 2 bits.For parity only wrapper:bit 14: set 1 to inject parity error when write, hardware will write error parity/ECC into memory.bit 15: set 1 to inject parity error when read.For ECC wrapper:2'b01: inject 2bit ECC error when write 2'b10: inject 1bit ECC error when read2'b11: inject 2bit ECC error when read
 *     ECC_ONE_BIT_ERROR_INT_EN This is purely for debug purpose.set 1: to enable 1-bit ECC error trigger the interrupt and record the error pointer 
 */
#define MISCCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MISCCONFIG.
 */
typedef union MISCCONFIGr_s {
	uint32 v[1];
	uint32 miscconfig[1];
	uint32 _miscconfig;
} MISCCONFIGr_t;

#define MISCCONFIGr_CLR(r) (r).miscconfig[0] = 0
#define MISCCONFIGr_SET(r,d) (r).miscconfig[0] = d
#define MISCCONFIGr_GET(r) (r).miscconfig[0]

/*
 * These macros can be used to access individual fields.
 */
#define MISCCONFIGr_DYNAMIC_MEMORY_ENf_GET(r) (((r).miscconfig[0]) & 0x1)
#define MISCCONFIGr_DYNAMIC_MEMORY_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define MISCCONFIGr_CLRDROPCTRf_GET(r) ((((r).miscconfig[0]) >> 1) & 0x1)
#define MISCCONFIGr_CLRDROPCTRf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define MISCCONFIGr_SKIDMARKERf_GET(r) ((((r).miscconfig[0]) >> 2) & 0x3)
#define MISCCONFIGr_SKIDMARKERf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define MISCCONFIGr_SLAM_MEMf_GET(r) ((((r).miscconfig[0]) >> 4) & 0x1)
#define MISCCONFIGr_SLAM_MEMf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define MISCCONFIGr_METERING_CLK_ENf_GET(r) ((((r).miscconfig[0]) >> 5) & 0x1)
#define MISCCONFIGr_METERING_CLK_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define MISCCONFIGr_PARITY_CHECK_ENf_GET(r) ((((r).miscconfig[0]) >> 6) & 0x1)
#define MISCCONFIGr_PARITY_CHECK_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_GET(r) ((((r).miscconfig[0]) >> 7) & 0x1)
#define MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define MISCCONFIGr_DYN_XQ_ENf_GET(r) ((((r).miscconfig[0]) >> 8) & 0x1)
#define MISCCONFIGr_DYN_XQ_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define MISCCONFIGr_IPMC_IND_MODEf_GET(r) ((((r).miscconfig[0]) >> 9) & 0x1)
#define MISCCONFIGr_IPMC_IND_MODEf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define MISCCONFIGr_CNG_DROP_ENf_GET(r) ((((r).miscconfig[0]) >> 10) & 0x1)
#define MISCCONFIGr_CNG_DROP_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define MISCCONFIGr_MULTIPLE_ACCOUNTING_FIX_ENf_GET(r) ((((r).miscconfig[0]) >> 11) & 0x1)
#define MISCCONFIGr_MULTIPLE_ACCOUNTING_FIX_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define MISCCONFIGr_RESERVEDf_GET(r) ((((r).miscconfig[0]) >> 12) & 0x1)
#define MISCCONFIGr_RESERVEDf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define MISCCONFIGr_RESERVED_1f_GET(r) ((((r).miscconfig[0]) >> 13) & 0x1)
#define MISCCONFIGr_RESERVED_1f_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define MISCCONFIGr_MEM_CORRUPT_CTLf_GET(r) ((((r).miscconfig[0]) >> 14) & 0x3)
#define MISCCONFIGr_MEM_CORRUPT_CTLf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define MISCCONFIGr_ECC_ONE_BIT_ERROR_INT_ENf_GET(r) ((((r).miscconfig[0]) >> 16) & 0x1)
#define MISCCONFIGr_ECC_ONE_BIT_ERROR_INT_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))

/*
 * These macros can be used to access MISCCONFIG.
 */
#define WRITE_MISCCONFIGr(u,r) bcm5607x_reg_set(u,R_MISCCONFIG,(r._miscconfig))
#define READ_MISCCONFIGr(u,r) bcm5607x_reg_get(u,R_MISCCONFIG,&(r._miscconfig))

/*******************************************************************************
 * End of 'MISCCONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMUFLUSHCONTROL
 * BLOCKS:   MMU
 * DESC:     Port MMU XQ Flush
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Each control bit when asserted, puts the corresponding port in the flush state. When a particular port is in flush state, the packets from the XQ of the port are purged after dequeue. It is expected that once a port is in flush state, there will be no more packets queued so that the queues become empty for that port. Once the port is empty, flush control bit can be deasserted. 
 */
#define MMUFLUSHCONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MMUFLUSHCONTROL.
 */
typedef union MMUFLUSHCONTROLr_s {
	uint32 v[1];
	uint32 mmuflushcontrol[1];
	uint32 _mmuflushcontrol;
} MMUFLUSHCONTROLr_t;

#define MMUFLUSHCONTROLr_CLR(r) (r).mmuflushcontrol[0] = 0
#define MMUFLUSHCONTROLr_SET(r,d) (r).mmuflushcontrol[0] = d
#define MMUFLUSHCONTROLr_GET(r) (r).mmuflushcontrol[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUFLUSHCONTROLr_FLUSHf_GET(r) ((r).mmuflushcontrol[0])
#define MMUFLUSHCONTROLr_FLUSHf_SET(r,f) (r).mmuflushcontrol[0]=((uint32)f)

/*
 * These macros can be used to access MMUFLUSHCONTROL.
 */
#define WRITE_MMUFLUSHCONTROLr(u,i,r) bcm5607x_reg_set(u,R_MMUFLUSHCONTROL(i),(r._mmuflushcontrol))
#define READ_MMUFLUSHCONTROLr(u,i,r) bcm5607x_reg_get(u,R_MMUFLUSHCONTROL(i),&(r._mmuflushcontrol))

/*******************************************************************************
 * End of 'MMUFLUSHCONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMUFLUSHCONTROL_0
 * BLOCKS:   MMU
 * DESC:     Port MMU XQ Flush
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Each control bit when asserted, puts the corresponding port in the flush state. When a particular port is in flush state, the packets from the XQ of the port are purged after dequeue. It is expected that once a port is in flush state, there will be no more packets queued so that the queues become empty for that port. Once the port is empty, flush control bit can be deasserted. 
 */
#define MMUFLUSHCONTROL_0r_SIZE 4

/* MMUFLUSHCONTROL_0r is element of MMUFLUSHCONTROL */

/*
 * This structure should be used to declare and program MMUFLUSHCONTROL_0.
 */
typedef union MMUFLUSHCONTROL_0r_s {
	uint32 v[1];
	uint32 mmuflushcontrol_0[1];
	uint32 _mmuflushcontrol_0;
} MMUFLUSHCONTROL_0r_t;

#define MMUFLUSHCONTROL_0r_CLR(r) (r).mmuflushcontrol_0[0] = 0
#define MMUFLUSHCONTROL_0r_SET(r,d) (r).mmuflushcontrol_0[0] = d
#define MMUFLUSHCONTROL_0r_GET(r) (r).mmuflushcontrol_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUFLUSHCONTROL_0r_FLUSHf_GET(r) ((r).mmuflushcontrol_0[0])
#define MMUFLUSHCONTROL_0r_FLUSHf_SET(r,f) (r).mmuflushcontrol_0[0]=((uint32)f)

/*
 * These macros can be used to access MMUFLUSHCONTROL_0.
 */
#define WRITE_MMUFLUSHCONTROL_0r(u,r) bcm5607x_reg_set(u,R_MMUFLUSHCONTROL_0,(r._mmuflushcontrol_0))
#define READ_MMUFLUSHCONTROL_0r(u,r) bcm5607x_reg_get(u,R_MMUFLUSHCONTROL_0,&(r._mmuflushcontrol_0))

/*******************************************************************************
 * End of 'MMUFLUSHCONTROL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMUFLUSHCONTROL_1
 * BLOCKS:   MMU
 * DESC:     Port MMU XQ Flush
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Each control bit when asserted, puts the corresponding port in the flush state. When a particular port is in flush state, the packets from the XQ of the port are purged after dequeue. It is expected that once a port is in flush state, there will be no more packets queued so that the queues become empty for that port. Once the port is empty, flush control bit can be deasserted. 
 */
#define MMUFLUSHCONTROL_1r_SIZE 4

/* MMUFLUSHCONTROL_1r is element of MMUFLUSHCONTROL */

/*
 * This structure should be used to declare and program MMUFLUSHCONTROL_1.
 */
typedef union MMUFLUSHCONTROL_1r_s {
	uint32 v[1];
	uint32 mmuflushcontrol_1[1];
	uint32 _mmuflushcontrol_1;
} MMUFLUSHCONTROL_1r_t;

#define MMUFLUSHCONTROL_1r_CLR(r) (r).mmuflushcontrol_1[0] = 0
#define MMUFLUSHCONTROL_1r_SET(r,d) (r).mmuflushcontrol_1[0] = d
#define MMUFLUSHCONTROL_1r_GET(r) (r).mmuflushcontrol_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUFLUSHCONTROL_1r_FLUSHf_GET(r) ((r).mmuflushcontrol_1[0])
#define MMUFLUSHCONTROL_1r_FLUSHf_SET(r,f) (r).mmuflushcontrol_1[0]=((uint32)f)

/*
 * These macros can be used to access MMUFLUSHCONTROL_1.
 */
#define WRITE_MMUFLUSHCONTROL_1r(u,r) bcm5607x_reg_set(u,R_MMUFLUSHCONTROL_1,(r._mmuflushcontrol_1))
#define READ_MMUFLUSHCONTROL_1r(u,r) bcm5607x_reg_get(u,R_MMUFLUSHCONTROL_1,&(r._mmuflushcontrol_1))

/*******************************************************************************
 * End of 'MMUFLUSHCONTROL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMUFLUSHCONTROL_2
 * BLOCKS:   MMU
 * DESC:     Port MMU XQ Flush
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Each control bit when asserted, puts the corresponding port in the flush state. When a particular port is in flush state, the packets from the XQ of the port are purged after dequeue. It is expected that once a port is in flush state, there will be no more packets queued so that the queues become empty for that port. Once the port is empty, flush control bit can be deasserted. 
 */
#define MMUFLUSHCONTROL_2r_SIZE 4

/* MMUFLUSHCONTROL_2r is element of MMUFLUSHCONTROL */

/*
 * This structure should be used to declare and program MMUFLUSHCONTROL_2.
 */
typedef union MMUFLUSHCONTROL_2r_s {
	uint32 v[1];
	uint32 mmuflushcontrol_2[1];
	uint32 _mmuflushcontrol_2;
} MMUFLUSHCONTROL_2r_t;

#define MMUFLUSHCONTROL_2r_CLR(r) (r).mmuflushcontrol_2[0] = 0
#define MMUFLUSHCONTROL_2r_SET(r,d) (r).mmuflushcontrol_2[0] = d
#define MMUFLUSHCONTROL_2r_GET(r) (r).mmuflushcontrol_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUFLUSHCONTROL_2r_FLUSHf_GET(r) (((r).mmuflushcontrol_2[0]) & 0x3)
#define MMUFLUSHCONTROL_2r_FLUSHf_SET(r,f) (r).mmuflushcontrol_2[0]=(((r).mmuflushcontrol_2[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))

/*
 * These macros can be used to access MMUFLUSHCONTROL_2.
 */
#define WRITE_MMUFLUSHCONTROL_2r(u,r) bcm5607x_reg_set(u,R_MMUFLUSHCONTROL_2,(r._mmuflushcontrol_2))
#define READ_MMUFLUSHCONTROL_2r(u,r) bcm5607x_reg_get(u,R_MMUFLUSHCONTROL_2,&(r._mmuflushcontrol_2))

/*******************************************************************************
 * End of 'MMUFLUSHCONTROL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMUPORTENABLE
 * BLOCKS:   MMU
 * DESC:     Port to memory buffer enable configuration 
 * SIZE:     32
 * FIELDS:
 *     MMUPORTENABLE    This bitmap specifies which egress ports are allowed to buffer packets. 
 */
#define MMUPORTENABLEr_SIZE 4

/*
 * This structure should be used to declare and program MMUPORTENABLE.
 */
typedef union MMUPORTENABLEr_s {
	uint32 v[1];
	uint32 mmuportenable[1];
	uint32 _mmuportenable;
} MMUPORTENABLEr_t;

#define MMUPORTENABLEr_CLR(r) (r).mmuportenable[0] = 0
#define MMUPORTENABLEr_SET(r,d) (r).mmuportenable[0] = d
#define MMUPORTENABLEr_GET(r) (r).mmuportenable[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUPORTENABLEr_MMUPORTENABLEf_GET(r) ((r).mmuportenable[0])
#define MMUPORTENABLEr_MMUPORTENABLEf_SET(r,f) (r).mmuportenable[0]=((uint32)f)

/*
 * These macros can be used to access MMUPORTENABLE.
 */
#define WRITE_MMUPORTENABLEr(u,i,r) bcm5607x_reg_set(u,R_MMUPORTENABLE(i),(r._mmuportenable))
#define READ_MMUPORTENABLEr(u,i,r) bcm5607x_reg_get(u,R_MMUPORTENABLE(i),&(r._mmuportenable))

/*******************************************************************************
 * End of 'MMUPORTENABLEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMUPORTENABLE_0
 * BLOCKS:   MMU
 * DESC:     Port to memory buffer enable configuration 
 * SIZE:     32
 * FIELDS:
 *     MMUPORTENABLE    This bitmap specifies which egress ports are allowed to buffer packets. 
 */
#define MMUPORTENABLE_0r_SIZE 4

/* MMUPORTENABLE_0r is element of MMUPORTENABLE */

/*
 * This structure should be used to declare and program MMUPORTENABLE_0.
 */
typedef union MMUPORTENABLE_0r_s {
	uint32 v[1];
	uint32 mmuportenable_0[1];
	uint32 _mmuportenable_0;
} MMUPORTENABLE_0r_t;

#define MMUPORTENABLE_0r_CLR(r) (r).mmuportenable_0[0] = 0
#define MMUPORTENABLE_0r_SET(r,d) (r).mmuportenable_0[0] = d
#define MMUPORTENABLE_0r_GET(r) (r).mmuportenable_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUPORTENABLE_0r_MMUPORTENABLEf_GET(r) ((r).mmuportenable_0[0])
#define MMUPORTENABLE_0r_MMUPORTENABLEf_SET(r,f) (r).mmuportenable_0[0]=((uint32)f)

/*
 * These macros can be used to access MMUPORTENABLE_0.
 */
#define WRITE_MMUPORTENABLE_0r(u,r) bcm5607x_reg_set(u,R_MMUPORTENABLE_0,(r._mmuportenable_0))
#define READ_MMUPORTENABLE_0r(u,r) bcm5607x_reg_get(u,R_MMUPORTENABLE_0,&(r._mmuportenable_0))

/*******************************************************************************
 * End of 'MMUPORTENABLE_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMUPORTENABLE_1
 * BLOCKS:   MMU
 * DESC:     Port to memory buffer enable configuration 
 * SIZE:     32
 * FIELDS:
 *     MMUPORTENABLE    This bitmap specifies which egress ports are allowed to buffer packets. 
 */
#define MMUPORTENABLE_1r_SIZE 4

/* MMUPORTENABLE_1r is element of MMUPORTENABLE */

/*
 * This structure should be used to declare and program MMUPORTENABLE_1.
 */
typedef union MMUPORTENABLE_1r_s {
	uint32 v[1];
	uint32 mmuportenable_1[1];
	uint32 _mmuportenable_1;
} MMUPORTENABLE_1r_t;

#define MMUPORTENABLE_1r_CLR(r) (r).mmuportenable_1[0] = 0
#define MMUPORTENABLE_1r_SET(r,d) (r).mmuportenable_1[0] = d
#define MMUPORTENABLE_1r_GET(r) (r).mmuportenable_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUPORTENABLE_1r_MMUPORTENABLEf_GET(r) ((r).mmuportenable_1[0])
#define MMUPORTENABLE_1r_MMUPORTENABLEf_SET(r,f) (r).mmuportenable_1[0]=((uint32)f)

/*
 * These macros can be used to access MMUPORTENABLE_1.
 */
#define WRITE_MMUPORTENABLE_1r(u,r) bcm5607x_reg_set(u,R_MMUPORTENABLE_1,(r._mmuportenable_1))
#define READ_MMUPORTENABLE_1r(u,r) bcm5607x_reg_get(u,R_MMUPORTENABLE_1,&(r._mmuportenable_1))

/*******************************************************************************
 * End of 'MMUPORTENABLE_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMUPORTENABLE_2
 * BLOCKS:   MMU
 * DESC:     Port to memory buffer enable configuration 
 * SIZE:     32
 * FIELDS:
 *     MMUPORTENABLE    This bitmap specifies which egress ports are allowed to buffer packets. 
 */
#define MMUPORTENABLE_2r_SIZE 4

/* MMUPORTENABLE_2r is element of MMUPORTENABLE */

/*
 * This structure should be used to declare and program MMUPORTENABLE_2.
 */
typedef union MMUPORTENABLE_2r_s {
	uint32 v[1];
	uint32 mmuportenable_2[1];
	uint32 _mmuportenable_2;
} MMUPORTENABLE_2r_t;

#define MMUPORTENABLE_2r_CLR(r) (r).mmuportenable_2[0] = 0
#define MMUPORTENABLE_2r_SET(r,d) (r).mmuportenable_2[0] = d
#define MMUPORTENABLE_2r_GET(r) (r).mmuportenable_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUPORTENABLE_2r_MMUPORTENABLEf_GET(r) (((r).mmuportenable_2[0]) & 0x3)
#define MMUPORTENABLE_2r_MMUPORTENABLEf_SET(r,f) (r).mmuportenable_2[0]=(((r).mmuportenable_2[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))

/*
 * These macros can be used to access MMUPORTENABLE_2.
 */
#define WRITE_MMUPORTENABLE_2r(u,r) bcm5607x_reg_set(u,R_MMUPORTENABLE_2,(r._mmuportenable_2))
#define READ_MMUPORTENABLE_2r(u,r) bcm5607x_reg_get(u,R_MMUPORTENABLE_2,&(r._mmuportenable_2))

/*******************************************************************************
 * End of 'MMUPORTENABLE_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMUPORTTXENABLE_0
 * BLOCKS:   MMU
 * DESC:     Memory buffer to port enable configuration. This is so software can turn off any port's transmission on a packet boundary, without truncating or fragmenting any packets. 

 * SIZE:     32
 * FIELDS:
 *     MMUPORTTXENABLE  This bitmap specifies which ports the memory buffer can transmit packets to. 
 */
#define MMUPORTTXENABLE_0r_SIZE 4

/* MMUPORTTXENABLE_0r is element of MMUPORTTXENABLE */

/*
 * This structure should be used to declare and program MMUPORTTXENABLE_0.
 */
typedef union MMUPORTTXENABLE_0r_s {
	uint32 v[1];
	uint32 mmuporttxenable_0[1];
	uint32 _mmuporttxenable_0;
} MMUPORTTXENABLE_0r_t;

#define MMUPORTTXENABLE_0r_CLR(r) (r).mmuporttxenable_0[0] = 0
#define MMUPORTTXENABLE_0r_SET(r,d) (r).mmuporttxenable_0[0] = d
#define MMUPORTTXENABLE_0r_GET(r) (r).mmuporttxenable_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUPORTTXENABLE_0r_MMUPORTTXENABLEf_GET(r) ((r).mmuporttxenable_0[0])
#define MMUPORTTXENABLE_0r_MMUPORTTXENABLEf_SET(r,f) (r).mmuporttxenable_0[0]=((uint32)f)

/*
 * These macros can be used to access MMUPORTTXENABLE_0.
 */
#define WRITE_MMUPORTTXENABLE_0r(u,r) bcm5607x_reg_set(u,R_MMUPORTTXENABLE_0,(r._mmuporttxenable_0))
#define READ_MMUPORTTXENABLE_0r(u,r) bcm5607x_reg_get(u,R_MMUPORTTXENABLE_0,&(r._mmuporttxenable_0))

/*******************************************************************************
 * End of 'MMUPORTTXENABLE_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMUPORTTXENABLE_1
 * BLOCKS:   MMU
 * DESC:     Memory buffer to port enable configuration. This is so software can turn off any port's transmission on a packet boundary, without truncating or fragmenting any packets. 

 * SIZE:     32
 * FIELDS:
 *     MMUPORTTXENABLE  This bitmap specifies which ports the memory buffer can transmit packets to. 
 */
#define MMUPORTTXENABLE_1r_SIZE 4

/* MMUPORTTXENABLE_1r is element of MMUPORTTXENABLE */

/*
 * This structure should be used to declare and program MMUPORTTXENABLE_1.
 */
typedef union MMUPORTTXENABLE_1r_s {
	uint32 v[1];
	uint32 mmuporttxenable_1[1];
	uint32 _mmuporttxenable_1;
} MMUPORTTXENABLE_1r_t;

#define MMUPORTTXENABLE_1r_CLR(r) (r).mmuporttxenable_1[0] = 0
#define MMUPORTTXENABLE_1r_SET(r,d) (r).mmuporttxenable_1[0] = d
#define MMUPORTTXENABLE_1r_GET(r) (r).mmuporttxenable_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUPORTTXENABLE_1r_MMUPORTTXENABLEf_GET(r) ((r).mmuporttxenable_1[0])
#define MMUPORTTXENABLE_1r_MMUPORTTXENABLEf_SET(r,f) (r).mmuporttxenable_1[0]=((uint32)f)

/*
 * These macros can be used to access MMUPORTTXENABLE_1.
 */
#define WRITE_MMUPORTTXENABLE_1r(u,r) bcm5607x_reg_set(u,R_MMUPORTTXENABLE_1,(r._mmuporttxenable_1))
#define READ_MMUPORTTXENABLE_1r(u,r) bcm5607x_reg_get(u,R_MMUPORTTXENABLE_1,&(r._mmuporttxenable_1))

/*******************************************************************************
 * End of 'MMUPORTTXENABLE_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMUPORTTXENABLE_2
 * BLOCKS:   MMU
 * DESC:     Memory buffer to port enable configuration. This is so software can turn off any port's transmission on a packet boundary, without truncating or fragmenting any packets. 

 * SIZE:     32
 * FIELDS:
 *     MMUPORTTXENABLE  This bitmap specifies which ports the memory buffer can transmit packets to. 
 */
#define MMUPORTTXENABLE_2r_SIZE 4

/* MMUPORTTXENABLE_2r is element of MMUPORTTXENABLE */

/*
 * This structure should be used to declare and program MMUPORTTXENABLE_2.
 */
typedef union MMUPORTTXENABLE_2r_s {
	uint32 v[1];
	uint32 mmuporttxenable_2[1];
	uint32 _mmuporttxenable_2;
} MMUPORTTXENABLE_2r_t;

#define MMUPORTTXENABLE_2r_CLR(r) (r).mmuporttxenable_2[0] = 0
#define MMUPORTTXENABLE_2r_SET(r,d) (r).mmuporttxenable_2[0] = d
#define MMUPORTTXENABLE_2r_GET(r) (r).mmuporttxenable_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUPORTTXENABLE_2r_MMUPORTTXENABLEf_GET(r) (((r).mmuporttxenable_2[0]) & 0x3)
#define MMUPORTTXENABLE_2r_MMUPORTTXENABLEf_SET(r,f) (r).mmuporttxenable_2[0]=(((r).mmuporttxenable_2[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))

/*
 * These macros can be used to access MMUPORTTXENABLE_2.
 */
#define WRITE_MMUPORTTXENABLE_2r(u,r) bcm5607x_reg_set(u,R_MMUPORTTXENABLE_2,(r._mmuporttxenable_2))
#define READ_MMUPORTTXENABLE_2r(u,r) bcm5607x_reg_get(u,R_MMUPORTTXENABLE_2,&(r._mmuporttxenable_2))

/*******************************************************************************
 * End of 'MMUPORTTXENABLE_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  MMU_ARB_TDM_TABLE
 * BLOCKS:   MMU
 * DESC:     MMU to EPIPE Arbiter TDM Table
Must be programmed with the values specified in SDK per index as part of initialization before traffic is enabled.
 * SIZE:     8
 * FIELDS:
 *     PORT_NUM         Indicates destination port ID.Value as programmed in SDK.
 *     WRAP_EN          MMU to EPIPE TDM Table Read Wrap around Enable.Value as programmed in SDK.
 */
#define MMU_ARB_TDM_TABLEm_MIN 0
#define MMU_ARB_TDM_TABLEm_MAX 511
#define MMU_ARB_TDM_TABLEm_CMAX(u) 511
#define MMU_ARB_TDM_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program MMU_ARB_TDM_TABLE.
 */
typedef union MMU_ARB_TDM_TABLEm_s {
	uint32 v[1];
	uint32 mmu_arb_tdm_table[1];
	uint32 _mmu_arb_tdm_table;
} MMU_ARB_TDM_TABLEm_t;

#define MMU_ARB_TDM_TABLEm_CLR(r) (r).mmu_arb_tdm_table[0] = 0
#define MMU_ARB_TDM_TABLEm_SET(r,d) (r).mmu_arb_tdm_table[0] = d
#define MMU_ARB_TDM_TABLEm_GET(r) (r).mmu_arb_tdm_table[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_ARB_TDM_TABLEm_PORT_NUMf_GET(r) (((r).mmu_arb_tdm_table[0]) & 0x7f)
#define MMU_ARB_TDM_TABLEm_PORT_NUMf_SET(r,f) (r).mmu_arb_tdm_table[0]=(((r).mmu_arb_tdm_table[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define MMU_ARB_TDM_TABLEm_WRAP_ENf_GET(r) ((((r).mmu_arb_tdm_table[0]) >> 7) & 0x1)
#define MMU_ARB_TDM_TABLEm_WRAP_ENf_SET(r,f) (r).mmu_arb_tdm_table[0]=(((r).mmu_arb_tdm_table[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access MMU_ARB_TDM_TABLE.
 */
#define WRITE_MMU_ARB_TDM_TABLEm(u,i,r) bcm5607x_mem_set(u, M_MMU_ARB_TDM_TABLE(i), &(r._mmu_arb_tdm_table), 1)
#define READ_MMU_ARB_TDM_TABLEm(u,i,r) bcm5607x_mem_get(u, M_MMU_ARB_TDM_TABLE(i), &(r._mmu_arb_tdm_table), 1)

/*******************************************************************************
 * End of 'MMU_ARB_TDM_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  MMU_CFAP
 * BLOCKS:   MMU
 * DESC:     CBP Free Address Pool RAM
 * SIZE:     28
 * FIELDS:
 *     FREE_PTR0        CBP Free Address
 *     FREE_PTR1        CBP Free Address
 *     ECC              ECC for FREE_PTR fields 
 *     PARITY           Parity for FREE_PTR+ECC fields including ecc
 */
#define MMU_CFAPm_MIN 0
#define MMU_CFAPm_MAX 8191
#define MMU_CFAPm_CMAX(u) 8191
#define MMU_CFAPm_SIZE 4

/*
 * This structure should be used to declare and program MMU_CFAP.
 */
typedef union MMU_CFAPm_s {
	uint32 v[1];
	uint32 mmu_cfap[1];
	uint32 _mmu_cfap;
} MMU_CFAPm_t;

#define MMU_CFAPm_CLR(r) (r).mmu_cfap[0] = 0
#define MMU_CFAPm_SET(r,d) (r).mmu_cfap[0] = d
#define MMU_CFAPm_GET(r) (r).mmu_cfap[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_CFAPm_FREE_PTR0f_GET(r) (((r).mmu_cfap[0]) & 0x7ff)
#define MMU_CFAPm_FREE_PTR0f_SET(r,f) (r).mmu_cfap[0]=(((r).mmu_cfap[0] & ~((uint32)0x7ff)) | (((uint32)f) & 0x7ff))
#define MMU_CFAPm_FREE_PTR1f_GET(r) ((((r).mmu_cfap[0]) >> 11) & 0x7ff)
#define MMU_CFAPm_FREE_PTR1f_SET(r,f) (r).mmu_cfap[0]=(((r).mmu_cfap[0] & ~((uint32)0x7ff << 11)) | ((((uint32)f) & 0x7ff) << 11))
#define MMU_CFAPm_ECCf_GET(r) ((((r).mmu_cfap[0]) >> 22) & 0x1f)
#define MMU_CFAPm_ECCf_SET(r,f) (r).mmu_cfap[0]=(((r).mmu_cfap[0] & ~((uint32)0x1f << 22)) | ((((uint32)f) & 0x1f) << 22))
#define MMU_CFAPm_PARITYf_GET(r) ((((r).mmu_cfap[0]) >> 27) & 0x1)
#define MMU_CFAPm_PARITYf_SET(r,f) (r).mmu_cfap[0]=(((r).mmu_cfap[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))

/*
 * These macros can be used to access MMU_CFAP.
 */
#define WRITE_MMU_CFAPm(u,i,r) bcm5607x_mem_set(u, M_MMU_CFAP(i), &(r._mmu_cfap), 1)
#define READ_MMU_CFAPm(u,i,r) bcm5607x_mem_get(u, M_MMU_CFAP(i), &(r._mmu_cfap), 1)

/*******************************************************************************
 * End of 'MMU_CFAPm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMU_FC_RX_EN
 * BLOCKS:   MMU
 * DESC:     MMU PFC/SAFC RX enable register
 * SIZE:     32
 * FIELDS:
 *     MMU_FC_RX_ENABLE RX enable bitmap. Each bit represents a Tx COS in that port that can be backpressured by PFC/LLFC messages received from the link partner. Bit 7: COS7....Bit 0: COS01: Enable backpressure for the Tx COS0: Ignore backpressure for the Tx COS 
 */
#define MMU_FC_RX_ENr_SIZE 4

/*
 * This structure should be used to declare and program MMU_FC_RX_EN.
 */
typedef union MMU_FC_RX_ENr_s {
	uint32 v[1];
	uint32 mmu_fc_rx_en[1];
	uint32 _mmu_fc_rx_en;
} MMU_FC_RX_ENr_t;

#define MMU_FC_RX_ENr_CLR(r) (r).mmu_fc_rx_en[0] = 0
#define MMU_FC_RX_ENr_SET(r,d) (r).mmu_fc_rx_en[0] = d
#define MMU_FC_RX_ENr_GET(r) (r).mmu_fc_rx_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_FC_RX_ENr_MMU_FC_RX_ENABLEf_GET(r) (((r).mmu_fc_rx_en[0]) & 0xff)
#define MMU_FC_RX_ENr_MMU_FC_RX_ENABLEf_SET(r,f) (r).mmu_fc_rx_en[0]=(((r).mmu_fc_rx_en[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))

/*
 * These macros can be used to access MMU_FC_RX_EN.
 */
#define WRITE_MMU_FC_RX_ENr(u,p,r) bcm5607x_reg_set(u,R_MMU_FC_RX_EN(p),(r._mmu_fc_rx_en))
#define READ_MMU_FC_RX_ENr(u,p,r) bcm5607x_reg_get(u,R_MMU_FC_RX_EN(p),&(r._mmu_fc_rx_en))

/*******************************************************************************
 * End of 'MMU_FC_RX_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMU_FC_TX_EN
 * BLOCKS:   MMU
 * DESC:     MMU PFC/SAFC RX enable register
 * SIZE:     32
 * FIELDS:
 *     MMU_FC_TX_ENABLE Each bit corresponding to a "priority enable vector" bit."0": MMU will reset the corresponding "priority enable vector" bit no matter its original XOFF status set by any of MMU flow control schemes"1": MMU will honor its original XOFF status set by any of MMU flow control schemesFor PFC, [7:0] is used.For SAFC, [15:0] is used.
 */
#define MMU_FC_TX_ENr_SIZE 4

/*
 * This structure should be used to declare and program MMU_FC_TX_EN.
 */
typedef union MMU_FC_TX_ENr_s {
	uint32 v[1];
	uint32 mmu_fc_tx_en[1];
	uint32 _mmu_fc_tx_en;
} MMU_FC_TX_ENr_t;

#define MMU_FC_TX_ENr_CLR(r) (r).mmu_fc_tx_en[0] = 0
#define MMU_FC_TX_ENr_SET(r,d) (r).mmu_fc_tx_en[0] = d
#define MMU_FC_TX_ENr_GET(r) (r).mmu_fc_tx_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_FC_TX_ENr_MMU_FC_TX_ENABLEf_GET(r) (((r).mmu_fc_tx_en[0]) & 0xffff)
#define MMU_FC_TX_ENr_MMU_FC_TX_ENABLEf_SET(r,f) (r).mmu_fc_tx_en[0]=(((r).mmu_fc_tx_en[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access MMU_FC_TX_EN.
 */
#define WRITE_MMU_FC_TX_ENr(u,p,r) bcm5607x_reg_set(u,R_MMU_FC_TX_EN(p),(r._mmu_fc_tx_en))
#define READ_MMU_FC_TX_ENr(u,p,r) bcm5607x_reg_get(u,R_MMU_FC_TX_EN(p),&(r._mmu_fc_tx_en))

/*******************************************************************************
 * End of 'MMU_FC_TX_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  MMU_IPMC_GROUP_TBL
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 
 * SIZE:     63
 * FIELDS:
 *     PORT_1STPTR      All pointers field.
 *     PORT_1STPTR_0    first pointer to LSB VLAN Bitmap for Port 2. In GH2, put multiple pointers in one entry. This is the 1st pointer.
 *     PORT_1STPTR_1    first pointer to LSB VLAN Bitmap for Port 2.In GH2, put multiple pointers in one entry. This is the 2nd pointer.
 *     PORT_1STPTR_2    first pointer to LSB VLAN Bitmap for Port 2.In GH2, put multiple pointers in one entry. This is the 3rd pointer.
 *     PORT_1STPTR_3    first pointer to LSB VLAN Bitmap for Port 2. In GH2, put multiple pointers in one entry. This is the 4th pointer.
 *     PORT_1STPTR_4    first pointer to LSB VLAN Bitmap for Port 2.In GH2, put multiple pointers in one entry. This is the 5rd pointer.
 *     PORT_1STPTR_5    first pointer to LSB VLAN Bitmap for Port 2. In GH2, put multiple pointers in one entry. This is the 6th pointer.
 *     PORT_1STPTR_6    first pointer to LSB VLAN Bitmap for Port 2.In GH2, put multiple pointers in one entry. This is the 7rd pointer.
 *     PORT_1STPTR_7    first pointer to LSB VLAN Bitmap for Port 2. In GH2, put multiple pointers in one entry. This is the 8th pointer.
 *     ECCP             ECC and Parity  of the IPMC group table.
 *     ECC              ECC of the IPMC group table.
 *     PARITY           Parity  of the IPMC group table.
 */
#define MMU_IPMC_GROUP_TBLm_MIN 0
#define MMU_IPMC_GROUP_TBLm_MAX 15
#define MMU_IPMC_GROUP_TBLm_CMAX(u) 15
#define MMU_IPMC_GROUP_TBLm_SIZE 8

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL.
 */
typedef union MMU_IPMC_GROUP_TBLm_s {
	uint32 v[2];
	uint32 mmu_ipmc_group_tbl[2];
	uint32 _mmu_ipmc_group_tbl;
} MMU_IPMC_GROUP_TBLm_t;

#define MMU_IPMC_GROUP_TBLm_CLR(r) sal_memset(&((r)._mmu_ipmc_group_tbl), 0, sizeof(MMU_IPMC_GROUP_TBLm_t))
#define MMU_IPMC_GROUP_TBLm_SET(r,i,d) (r).mmu_ipmc_group_tbl[i] = d
#define MMU_IPMC_GROUP_TBLm_GET(r,i) (r).mmu_ipmc_group_tbl[i]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTRf_GET(r,a) field_get((r).mmu_ipmc_group_tbl,0,55,a)
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTRf_SET(r,a) field_set((r).mmu_ipmc_group_tbl,0,55,a)
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_0f_GET(r) (((r).mmu_ipmc_group_tbl[0]) & 0x7f)
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_0f_SET(r,f) (r).mmu_ipmc_group_tbl[0]=(((r).mmu_ipmc_group_tbl[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_1f_GET(r) ((((r).mmu_ipmc_group_tbl[0]) >> 7) & 0x7f)
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_1f_SET(r,f) (r).mmu_ipmc_group_tbl[0]=(((r).mmu_ipmc_group_tbl[0] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_2f_GET(r) ((((r).mmu_ipmc_group_tbl[0]) >> 14) & 0x7f)
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_2f_SET(r,f) (r).mmu_ipmc_group_tbl[0]=(((r).mmu_ipmc_group_tbl[0] & ~((uint32)0x7f << 14)) | ((((uint32)f) & 0x7f) << 14))
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_3f_GET(r) ((((r).mmu_ipmc_group_tbl[0]) >> 21) & 0x7f)
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_3f_SET(r,f) (r).mmu_ipmc_group_tbl[0]=(((r).mmu_ipmc_group_tbl[0] & ~((uint32)0x7f << 21)) | ((((uint32)f) & 0x7f) << 21))
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_4f_GET(r) field32_get((r).mmu_ipmc_group_tbl,28,34)
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_4f_SET(r,f) field32_set((r).mmu_ipmc_group_tbl,28,34,f)
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_5f_GET(r) ((((r).mmu_ipmc_group_tbl[1]) >> 3) & 0x7f)
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_5f_SET(r,f) (r).mmu_ipmc_group_tbl[1]=(((r).mmu_ipmc_group_tbl[1] & ~((uint32)0x7f << 3)) | ((((uint32)f) & 0x7f) << 3))
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_6f_GET(r) ((((r).mmu_ipmc_group_tbl[1]) >> 10) & 0x7f)
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_6f_SET(r,f) (r).mmu_ipmc_group_tbl[1]=(((r).mmu_ipmc_group_tbl[1] & ~((uint32)0x7f << 10)) | ((((uint32)f) & 0x7f) << 10))
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_7f_GET(r) ((((r).mmu_ipmc_group_tbl[1]) >> 17) & 0x7f)
#define MMU_IPMC_GROUP_TBLm_PORT_1STPTR_7f_SET(r,f) (r).mmu_ipmc_group_tbl[1]=(((r).mmu_ipmc_group_tbl[1] & ~((uint32)0x7f << 17)) | ((((uint32)f) & 0x7f) << 17))
#define MMU_IPMC_GROUP_TBLm_ECCPf_GET(r) ((((r).mmu_ipmc_group_tbl[1]) >> 24) & 0x7f)
#define MMU_IPMC_GROUP_TBLm_ECCPf_SET(r,f) (r).mmu_ipmc_group_tbl[1]=(((r).mmu_ipmc_group_tbl[1] & ~((uint32)0x7f << 24)) | ((((uint32)f) & 0x7f) << 24))
#define MMU_IPMC_GROUP_TBLm_ECCf_GET(r) ((((r).mmu_ipmc_group_tbl[1]) >> 24) & 0x3f)
#define MMU_IPMC_GROUP_TBLm_ECCf_SET(r,f) (r).mmu_ipmc_group_tbl[1]=(((r).mmu_ipmc_group_tbl[1] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))
#define MMU_IPMC_GROUP_TBLm_PARITYf_GET(r) ((((r).mmu_ipmc_group_tbl[1]) >> 30) & 0x1)
#define MMU_IPMC_GROUP_TBLm_PARITYf_SET(r,f) (r).mmu_ipmc_group_tbl[1]=(((r).mmu_ipmc_group_tbl[1] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL.
 */
#define WRITE_MMU_IPMC_GROUP_TBLm(u,aidx,idx, r) bcm5607x_mem_set(u, M_MMU_IPMC_GROUP_TBL(aidx,idx), &(r._mmu_ipmc_group_tbl), 2)
#define READ_MMU_IPMC_GROUP_TBLm(u,aidx,idx, r) bcm5607x_mem_get(u, M_MMU_IPMC_GROUP_TBL(aidx,idx), &(r._mmu_ipmc_group_tbl), 2)

/*******************************************************************************
 * End of 'MMU_IPMC_GROUP_TBLm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  MMU_MAX_BUCKET_QGROUP
 * BLOCKS:   MMU
 * DESC:     port/QG to MEM idx mapping:  only for(port >= 58) idx = {port-58, QG[2:0]} 

 * SIZE:     61
 * FIELDS:
 *     THD_SEL          MAX Shaping Bucket Size.
 *     REFRESH          MAX Shaping Bucket Refresh Count.
 *     EAV_MODE         Enable EAV Shaper2'b00: MAX shaping2'b01: EAV shaping. Token count is set to MAX_THRD when it is empty2'b10: EAV shaping. Token count is set to MAX_THRD when it is empty or Gate state is closeBit 1 is no used in QGROUP and must be set to 0.
 *     BUCKET           MAX Shaping Bucket.
 */
#define MMU_MAX_BUCKET_QGROUPm_MIN 0
#define MMU_MAX_BUCKET_QGROUPm_MAX 63
#define MMU_MAX_BUCKET_QGROUPm_CMAX(u) 63
#define MMU_MAX_BUCKET_QGROUPm_SIZE 8

/*
 * This structure should be used to declare and program MMU_MAX_BUCKET_QGROUP.
 */
typedef union MMU_MAX_BUCKET_QGROUPm_s {
	uint32 v[2];
	uint32 mmu_max_bucket_qgroup[2];
	uint32 _mmu_max_bucket_qgroup;
} MMU_MAX_BUCKET_QGROUPm_t;

#define MMU_MAX_BUCKET_QGROUPm_CLR(r) sal_memset(&((r)._mmu_max_bucket_qgroup), 0, sizeof(MMU_MAX_BUCKET_QGROUPm_t))
#define MMU_MAX_BUCKET_QGROUPm_SET(r,i,d) (r).mmu_max_bucket_qgroup[i] = d
#define MMU_MAX_BUCKET_QGROUPm_GET(r,i) (r).mmu_max_bucket_qgroup[i]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_MAX_BUCKET_QGROUPm_THD_SELf_GET(r) (((r).mmu_max_bucket_qgroup[0]) & 0xfff)
#define MMU_MAX_BUCKET_QGROUPm_THD_SELf_SET(r,f) (r).mmu_max_bucket_qgroup[0]=(((r).mmu_max_bucket_qgroup[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define MMU_MAX_BUCKET_QGROUPm_REFRESHf_GET(r) ((((r).mmu_max_bucket_qgroup[0]) >> 12) & 0x3ffff)
#define MMU_MAX_BUCKET_QGROUPm_REFRESHf_SET(r,f) (r).mmu_max_bucket_qgroup[0]=(((r).mmu_max_bucket_qgroup[0] & ~((uint32)0x3ffff << 12)) | ((((uint32)f) & 0x3ffff) << 12))
#define MMU_MAX_BUCKET_QGROUPm_EAV_MODEf_GET(r) ((((r).mmu_max_bucket_qgroup[0]) >> 30) & 0x3)
#define MMU_MAX_BUCKET_QGROUPm_EAV_MODEf_SET(r,f) (r).mmu_max_bucket_qgroup[0]=(((r).mmu_max_bucket_qgroup[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define MMU_MAX_BUCKET_QGROUPm_BUCKETf_GET(r) (((r).mmu_max_bucket_qgroup[1]) & 0x1fffffff)
#define MMU_MAX_BUCKET_QGROUPm_BUCKETf_SET(r,f) (r).mmu_max_bucket_qgroup[1]=(((r).mmu_max_bucket_qgroup[1] & ~((uint32)0x1fffffff)) | (((uint32)f) & 0x1fffffff))

/*
 * These macros can be used to access MMU_MAX_BUCKET_QGROUP.
 */
#define WRITE_MMU_MAX_BUCKET_QGROUPm(u,i,r) bcm5607x_mem_set(u, M_MMU_MAX_BUCKET_QGROUP(i), &(r._mmu_max_bucket_qgroup), 2)
#define READ_MMU_MAX_BUCKET_QGROUPm(u,i,r) bcm5607x_mem_get(u, M_MMU_MAX_BUCKET_QGROUP(i), &(r._mmu_max_bucket_qgroup), 2)

/*******************************************************************************
 * End of 'MMU_MAX_BUCKET_QGROUPm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  MMU_MAX_BUCKET_QLAYER
 * BLOCKS:   MMU
 * DESC:     port/cos to MEM idx mapping: 
  if(port <=57) idx = {port, cos[2:0]} 
  else          idx = {(port-58), cos[5:0]}+ 58*8

 * SIZE:     61
 * FIELDS:
 *     THD_SEL          MAX Shaping Bucket Size.
 *     REFRESH          MAX Shaping Bucket Refresh Count.
 *     EAV_MODE         Enable EAV Shaper2'b00: MAX shaping2'b01: EAV shaping. Token count is set to MAX_THRD when it is empty2'b10: EAV shaping. Token count is set to MAX_THRD when it is empty or Gate state is closeBit 1 is no used in QGROUP and must be set to 0.
 *     BUCKET           MAX Shaping Bucket.
 */
#define MMU_MAX_BUCKET_QLAYERm_MIN 0
#define MMU_MAX_BUCKET_QLAYERm_MAX 975
#define MMU_MAX_BUCKET_QLAYERm_CMAX(u) 975
#define MMU_MAX_BUCKET_QLAYERm_SIZE 8

/*
 * This structure should be used to declare and program MMU_MAX_BUCKET_QLAYER.
 */
typedef union MMU_MAX_BUCKET_QLAYERm_s {
	uint32 v[2];
	uint32 mmu_max_bucket_qlayer[2];
	uint32 _mmu_max_bucket_qlayer;
} MMU_MAX_BUCKET_QLAYERm_t;

#define MMU_MAX_BUCKET_QLAYERm_CLR(r) sal_memset(&((r)._mmu_max_bucket_qlayer), 0, sizeof(MMU_MAX_BUCKET_QLAYERm_t))
#define MMU_MAX_BUCKET_QLAYERm_SET(r,i,d) (r).mmu_max_bucket_qlayer[i] = d
#define MMU_MAX_BUCKET_QLAYERm_GET(r,i) (r).mmu_max_bucket_qlayer[i]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_MAX_BUCKET_QLAYERm_THD_SELf_GET(r) (((r).mmu_max_bucket_qlayer[0]) & 0xfff)
#define MMU_MAX_BUCKET_QLAYERm_THD_SELf_SET(r,f) (r).mmu_max_bucket_qlayer[0]=(((r).mmu_max_bucket_qlayer[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define MMU_MAX_BUCKET_QLAYERm_REFRESHf_GET(r) ((((r).mmu_max_bucket_qlayer[0]) >> 12) & 0x3ffff)
#define MMU_MAX_BUCKET_QLAYERm_REFRESHf_SET(r,f) (r).mmu_max_bucket_qlayer[0]=(((r).mmu_max_bucket_qlayer[0] & ~((uint32)0x3ffff << 12)) | ((((uint32)f) & 0x3ffff) << 12))
#define MMU_MAX_BUCKET_QLAYERm_EAV_MODEf_GET(r) ((((r).mmu_max_bucket_qlayer[0]) >> 30) & 0x3)
#define MMU_MAX_BUCKET_QLAYERm_EAV_MODEf_SET(r,f) (r).mmu_max_bucket_qlayer[0]=(((r).mmu_max_bucket_qlayer[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define MMU_MAX_BUCKET_QLAYERm_BUCKETf_GET(r) (((r).mmu_max_bucket_qlayer[1]) & 0x1fffffff)
#define MMU_MAX_BUCKET_QLAYERm_BUCKETf_SET(r,f) (r).mmu_max_bucket_qlayer[1]=(((r).mmu_max_bucket_qlayer[1] & ~((uint32)0x1fffffff)) | (((uint32)f) & 0x1fffffff))

/*
 * These macros can be used to access MMU_MAX_BUCKET_QLAYER.
 */
#define WRITE_MMU_MAX_BUCKET_QLAYERm(u,i,r) bcm5607x_mem_set(u, M_MMU_MAX_BUCKET_QLAYER(i), &(r._mmu_max_bucket_qlayer), 2)
#define READ_MMU_MAX_BUCKET_QLAYERm(u,i,r) bcm5607x_mem_get(u, M_MMU_MAX_BUCKET_QLAYER(i), &(r._mmu_max_bucket_qlayer), 2)

/*******************************************************************************
 * End of 'MMU_MAX_BUCKET_QLAYERm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMU_PORT_TO_LOGIC_PORT_MAPPING
 * BLOCKS:   MMU
 * DESC:     MMU port to Logic port number mapping
 * SIZE:     32
 * FIELDS:
 *     LOGIC_PORT       Registers indexed by MMU PORT NUM, Contains are LOGIC port number.
 */
#define MMU_PORT_TO_LOGIC_PORT_MAPPINGr_SIZE 4

/*
 * This structure should be used to declare and program MMU_PORT_TO_LOGIC_PORT_MAPPING.
 */
typedef union MMU_PORT_TO_LOGIC_PORT_MAPPINGr_s {
	uint32 v[1];
	uint32 mmu_port_to_logic_port_mapping[1];
	uint32 _mmu_port_to_logic_port_mapping;
} MMU_PORT_TO_LOGIC_PORT_MAPPINGr_t;

#define MMU_PORT_TO_LOGIC_PORT_MAPPINGr_CLR(r) (r).mmu_port_to_logic_port_mapping[0] = 0
#define MMU_PORT_TO_LOGIC_PORT_MAPPINGr_SET(r,d) (r).mmu_port_to_logic_port_mapping[0] = d
#define MMU_PORT_TO_LOGIC_PORT_MAPPINGr_GET(r) (r).mmu_port_to_logic_port_mapping[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_PORT_TO_LOGIC_PORT_MAPPINGr_LOGIC_PORTf_GET(r) (((r).mmu_port_to_logic_port_mapping[0]) & 0x7f)
#define MMU_PORT_TO_LOGIC_PORT_MAPPINGr_LOGIC_PORTf_SET(r,f) (r).mmu_port_to_logic_port_mapping[0]=(((r).mmu_port_to_logic_port_mapping[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))

/*
 * These macros can be used to access MMU_PORT_TO_LOGIC_PORT_MAPPING.
 */
#define WRITE_MMU_PORT_TO_LOGIC_PORT_MAPPINGr(u,p,r) bcm5607x_reg_set(u,R_MMU_PORT_TO_LOGIC_PORT_MAPPING(p),(r._mmu_port_to_logic_port_mapping))
#define READ_MMU_PORT_TO_LOGIC_PORT_MAPPINGr(u,p,r) bcm5607x_reg_get(u,R_MMU_PORT_TO_LOGIC_PORT_MAPPING(p),&(r._mmu_port_to_logic_port_mapping))

/*******************************************************************************
 * End of 'MMU_PORT_TO_LOGIC_PORT_MAPPINGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  MMU_PORT_TO_PHY_PORT_MAPPING
 * BLOCKS:   MMU
 * DESC:     MMU port to Physical port number mapping
 * SIZE:     32
 * FIELDS:
 *     PHY_PORT         Registers indexed by MMU PORT NUM, Contains are Physical port number.
 */
#define MMU_PORT_TO_PHY_PORT_MAPPINGr_SIZE 4

/*
 * This structure should be used to declare and program MMU_PORT_TO_PHY_PORT_MAPPING.
 */
typedef union MMU_PORT_TO_PHY_PORT_MAPPINGr_s {
	uint32 v[1];
	uint32 mmu_port_to_phy_port_mapping[1];
	uint32 _mmu_port_to_phy_port_mapping;
} MMU_PORT_TO_PHY_PORT_MAPPINGr_t;

#define MMU_PORT_TO_PHY_PORT_MAPPINGr_CLR(r) (r).mmu_port_to_phy_port_mapping[0] = 0
#define MMU_PORT_TO_PHY_PORT_MAPPINGr_SET(r,d) (r).mmu_port_to_phy_port_mapping[0] = d
#define MMU_PORT_TO_PHY_PORT_MAPPINGr_GET(r) (r).mmu_port_to_phy_port_mapping[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_PORT_TO_PHY_PORT_MAPPINGr_PHY_PORTf_GET(r) (((r).mmu_port_to_phy_port_mapping[0]) & 0x7f)
#define MMU_PORT_TO_PHY_PORT_MAPPINGr_PHY_PORTf_SET(r,f) (r).mmu_port_to_phy_port_mapping[0]=(((r).mmu_port_to_phy_port_mapping[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))

/*
 * These macros can be used to access MMU_PORT_TO_PHY_PORT_MAPPING.
 */
#define WRITE_MMU_PORT_TO_PHY_PORT_MAPPINGr(u,p,r) bcm5607x_reg_set(u,R_MMU_PORT_TO_PHY_PORT_MAPPING(p),(r._mmu_port_to_phy_port_mapping))
#define READ_MMU_PORT_TO_PHY_PORT_MAPPINGr(u,p,r) bcm5607x_reg_get(u,R_MMU_PORT_TO_PHY_PORT_MAPPING(p),&(r._mmu_port_to_phy_port_mapping))

/*******************************************************************************
 * End of 'MMU_PORT_TO_PHY_PORT_MAPPINGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  NONUCAST_TRUNK_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Multicast and Broadcast Trunk Block Mask Table
 * SIZE:     67
 * FIELDS:
 *     BLOCK_MASK       Multicast/broadcast trunk block mask
 *     BLOCK_MASK_LO    Multicast/broadcast trunk block mask
 *     EVEN_PARITY      Even parity.
 */
#define NONUCAST_TRUNK_BLOCK_MASKm_MIN 0
#define NONUCAST_TRUNK_BLOCK_MASKm_MAX 63
#define NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u) 63
#define NONUCAST_TRUNK_BLOCK_MASKm_SIZE 9

/*
 * This structure should be used to declare and program NONUCAST_TRUNK_BLOCK_MASK.
 */
typedef union NONUCAST_TRUNK_BLOCK_MASKm_s {
	uint32 v[3];
	uint32 nonucast_trunk_block_mask[3];
	uint32 _nonucast_trunk_block_mask;
} NONUCAST_TRUNK_BLOCK_MASKm_t;

#define NONUCAST_TRUNK_BLOCK_MASKm_CLR(r) sal_memset(&((r)._nonucast_trunk_block_mask), 0, sizeof(NONUCAST_TRUNK_BLOCK_MASKm_t))
#define NONUCAST_TRUNK_BLOCK_MASKm_SET(r,i,d) (r).nonucast_trunk_block_mask[i] = d
#define NONUCAST_TRUNK_BLOCK_MASKm_GET(r,i) (r).nonucast_trunk_block_mask[i]

/*
 * These macros can be used to access individual fields.
 */
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET(r,a) field_get((r).nonucast_trunk_block_mask,0,65,a)
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET(r,a) field_set((r).nonucast_trunk_block_mask,0,65,a)
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_GET(r,a) field_get((r).nonucast_trunk_block_mask,0,65,a)
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_SET(r,a) field_set((r).nonucast_trunk_block_mask,0,65,a)
#define NONUCAST_TRUNK_BLOCK_MASKm_EVEN_PARITYf_GET(r) ((((r).nonucast_trunk_block_mask[2]) >> 2) & 0x1)
#define NONUCAST_TRUNK_BLOCK_MASKm_EVEN_PARITYf_SET(r,f) (r).nonucast_trunk_block_mask[2]=(((r).nonucast_trunk_block_mask[2] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))

/*
 * These macros can be used to access NONUCAST_TRUNK_BLOCK_MASK.
 */
#define WRITE_NONUCAST_TRUNK_BLOCK_MASKm(u,i,r) bcm5607x_mem_set(u, M_NONUCAST_TRUNK_BLOCK_MASK(i), &(r._nonucast_trunk_block_mask), 3)
#define READ_NONUCAST_TRUNK_BLOCK_MASKm(u,i,r) bcm5607x_mem_get(u, M_NONUCAST_TRUNK_BLOCK_MASK(i), &(r._nonucast_trunk_block_mask), 3)

/*******************************************************************************
 * End of 'NONUCAST_TRUNK_BLOCK_MASKm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * SWFORMAT:  PBSMH
 * BLOCKS:  
 * DESC:     PBS MH Header Format.
 * SIZE:     128
 * FIELDS:
 *     SRC_MODID        Source module ID, must be programmed to MY_MODID.
 *     LOCAL_DEST_PORT  Indicates the local port to send a SOBMH packet out.
 *     SET_L2BM         Indicates that PBI.L2_BITMAP should be set (to queue as L2MC packet).
 *     QUEUE_NUM        Queue number to be used for unicast queuing and CPU queue (CPU_COS).
 *     IEEE1588_TIMESTAMP_HDR_OFFSET HDR_OFFSET
 *     SET_L3BM         Indicates that PBI.L3_BITMAP should be set (to queue as IPMC packet).
 *     TX_TS            Indicates for TS packet transmitted from CPU into IP that the outgoing packet needs to have its transmit timestamp captured by the port.
 *     NLF_PORT_NUMBER  Logical Egress port number provided by the EP
 *     IEEE1588_INGRESS_TIMESTAMP_SIGN ITS_SIGN
 *     UNICAST          Indicates that PBI.UNICAST should be set to queue as unicast packet.
 *     SPAP             For PBI.SPAP - Service Pool Priority (color)
 *     IEEE1588_REGEN_UDP_CHECKSUM Regenerate UDP Checksum
 *     IEEE1588_ONE_STEP_ENABLE ONE STEP TIME STAMPING ENABLE
 *     RESERVED_4       Reserved
 *     OAM_REPLACEMENT_TYPE 00:NOP 01:DM 10:NTP 11:LM
 *     SPID             For PBI.SPID - Service Pool ID
 *     CELL_ERROR       CELL_ERROR or PURGE
 *     RESERVED_1       RESERVED
 *     SPID_OVERRIDE    For PBI.SPID_Override
 *     OAM_REPLACEMENT_OFFSET From CPU indicatinf insertion point in packet for LM count or DM Timestamp. Has 14 Byte offset with 2 byte increments
 *     COS              Class of service for MMU queueing for this packet - sets COS values, PBI.UC_COS, PBI.MC_COS1, and PBI.MC_COS2.
 *     INT_PRI          Internal Priority used for CPU_COS_MAP TCAM lookups for EP COPY TO CPU (header type 0) to generate CPU_COS
 *     INPUT_PRI        Traffic priority to be applied to MMU via PBI.INPUT_PRIORITY.
 *     QUEUE_NUM_UPPER  Holds upper 2 bit of the QUEUE_NUM field.
 *     EP_CPU_REASON_CODE EP Copy to CPU Reasons
 *     LM_COUNTER_INDEX From CPU indicating LM Counter Index
 *     CELL_LENGTH      CELL_LENGTH (set by hardware - in Iarb).
 *     EOP              EOP indicator (set by hardware - in Iarb).
 *     SOP              SOP indicator (set by hardware - in Iarb).
 *     PKT_LENGTH       PKT_LENGTH (set by hardware - in Iarb).
 *     RESERVED_3       Reserved
 *     RESERVED_5       Reserved
 *     IPCF_PTR         Pointer to cell buffer of this SOBMH cell. (Set by hardware)
 *     RESERVED_IPCF_PTR Pointer to cell buffer of this SOBMH cell. (Set by hardware)
 *     HEADER_TYPE      64 Header Types Supported
 *     START            Start of frame indicator. 
 */
#define PBSMH_SIZE 16

/*
 * This structure should be used to declare and program PBSMH.
 */
typedef union PBSMH_s {
	uint32 v[4];
	uint32 pbsmh[4];
	uint32 _pbsmh;
} PBSMH_t;

#define PBSMH_CLR(r) sal_memset(&((r)._pbsmh), 0, sizeof(PBSMH_t))
#define PBSMH_SET(r,i,d) (r).pbsmh[i] = d
#define PBSMH_GET(r,i) (r).pbsmh[i]

/*
 * These macros can be used to access individual fields.
 */
#define PBSMH_SRC_MODIDf_GET(r) (((r).pbsmh[1]) & 0xff)
#define PBSMH_SRC_MODIDf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define PBSMH_LOCAL_DEST_PORTf_GET(r) (((r).pbsmh[1]) & 0x7f)
#define PBSMH_LOCAL_DEST_PORTf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define PBSMH_SET_L2BMf_GET(r) ((((r).pbsmh[1]) >> 7) & 0x1)
#define PBSMH_SET_L2BMf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define PBSMH_QUEUE_NUMf_GET(r) ((((r).pbsmh[1]) >> 8) & 0x3ff)
#define PBSMH_QUEUE_NUMf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x3ff << 8)) | ((((uint32)f) & 0x3ff) << 8))
#define PBSMH_IEEE1588_TIMESTAMP_HDR_OFFSETf_GET(r) ((((r).pbsmh[1]) >> 8) & 0xff)
#define PBSMH_IEEE1588_TIMESTAMP_HDR_OFFSETf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define PBSMH_SET_L3BMf_GET(r) ((((r).pbsmh[1]) >> 16) & 0x1)
#define PBSMH_SET_L3BMf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define PBSMH_TX_TSf_GET(r) ((((r).pbsmh[1]) >> 17) & 0x1)
#define PBSMH_TX_TSf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define PBSMH_NLF_PORT_NUMBERf_GET(r) ((((r).pbsmh[1]) >> 18) & 0x3f)
#define PBSMH_NLF_PORT_NUMBERf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))
#define PBSMH_IEEE1588_INGRESS_TIMESTAMP_SIGNf_GET(r) ((((r).pbsmh[1]) >> 18) & 0x1)
#define PBSMH_IEEE1588_INGRESS_TIMESTAMP_SIGNf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define PBSMH_UNICASTf_GET(r) ((((r).pbsmh[1]) >> 18) & 0x1)
#define PBSMH_UNICASTf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define PBSMH_SPAPf_GET(r) ((((r).pbsmh[1]) >> 19) & 0x3)
#define PBSMH_SPAPf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define PBSMH_IEEE1588_REGEN_UDP_CHECKSUMf_GET(r) ((((r).pbsmh[1]) >> 19) & 0x1)
#define PBSMH_IEEE1588_REGEN_UDP_CHECKSUMf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define PBSMH_IEEE1588_ONE_STEP_ENABLEf_GET(r) ((((r).pbsmh[1]) >> 20) & 0x1)
#define PBSMH_IEEE1588_ONE_STEP_ENABLEf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define PBSMH_RESERVED_4f_GET(r) ((((r).pbsmh[1]) >> 21) & 0x7ff)
#define PBSMH_RESERVED_4f_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x7ff << 21)) | ((((uint32)f) & 0x7ff) << 21))
#define PBSMH_OAM_REPLACEMENT_TYPEf_GET(r) ((((r).pbsmh[1]) >> 21) & 0x3)
#define PBSMH_OAM_REPLACEMENT_TYPEf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define PBSMH_SPIDf_GET(r) ((((r).pbsmh[1]) >> 21) & 0x3)
#define PBSMH_SPIDf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define PBSMH_CELL_ERRORf_GET(r) ((((r).pbsmh[1]) >> 23) & 0x1)
#define PBSMH_CELL_ERRORf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define PBSMH_RESERVED_1f_GET(r) ((((r).pbsmh[1]) >> 23) & 0x1)
#define PBSMH_RESERVED_1f_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define PBSMH_SPID_OVERRIDEf_GET(r) ((((r).pbsmh[1]) >> 23) & 0x1)
#define PBSMH_SPID_OVERRIDEf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define PBSMH_OAM_REPLACEMENT_OFFSETf_GET(r) ((((r).pbsmh[1]) >> 24) & 0x3f)
#define PBSMH_OAM_REPLACEMENT_OFFSETf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))
#define PBSMH_COSf_GET(r) ((((r).pbsmh[1]) >> 24) & 0xf)
#define PBSMH_COSf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define PBSMH_INT_PRIf_GET(r) ((((r).pbsmh[1]) >> 24) & 0xf)
#define PBSMH_INT_PRIf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define PBSMH_INPUT_PRIf_GET(r) ((((r).pbsmh[1]) >> 28) & 0xf)
#define PBSMH_INPUT_PRIf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define PBSMH_QUEUE_NUM_UPPERf_GET(r) ((((r).pbsmh[1]) >> 30) & 0x3)
#define PBSMH_QUEUE_NUM_UPPERf_SET(r,f) (r).pbsmh[1]=(((r).pbsmh[1] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define PBSMH_EP_CPU_REASON_CODEf_GET(r) (((r).pbsmh[0]) & 0xfffff)
#define PBSMH_EP_CPU_REASON_CODEf_SET(r,f) (r).pbsmh[0]=(((r).pbsmh[0] & ~((uint32)0xfffff)) | (((uint32)f) & 0xfffff))
#define PBSMH_LM_COUNTER_INDEXf_GET(r) (((r).pbsmh[0]) & 0xffff)
#define PBSMH_LM_COUNTER_INDEXf_SET(r,f) (r).pbsmh[0]=(((r).pbsmh[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define PBSMH_CELL_LENGTHf_GET(r) (((r).pbsmh[0]) & 0xff)
#define PBSMH_CELL_LENGTHf_SET(r,f) (r).pbsmh[0]=(((r).pbsmh[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define PBSMH_EOPf_GET(r) ((((r).pbsmh[0]) >> 8) & 0x1)
#define PBSMH_EOPf_SET(r,f) (r).pbsmh[0]=(((r).pbsmh[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define PBSMH_SOPf_GET(r) ((((r).pbsmh[0]) >> 9) & 0x1)
#define PBSMH_SOPf_SET(r,f) (r).pbsmh[0]=(((r).pbsmh[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define PBSMH_PKT_LENGTHf_GET(r) ((((r).pbsmh[0]) >> 10) & 0x3fff)
#define PBSMH_PKT_LENGTHf_SET(r,f) (r).pbsmh[0]=(((r).pbsmh[0] & ~((uint32)0x3fff << 10)) | ((((uint32)f) & 0x3fff) << 10))
#define PBSMH_RESERVED_3f_GET(r) ((((r).pbsmh[0]) >> 16) & 0xff)
#define PBSMH_RESERVED_3f_SET(r,f) (r).pbsmh[0]=(((r).pbsmh[0] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define PBSMH_RESERVED_5f_GET(r) ((((r).pbsmh[0]) >> 20) & 0xf)
#define PBSMH_RESERVED_5f_SET(r,f) (r).pbsmh[0]=(((r).pbsmh[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define PBSMH_IPCF_PTRf_GET(r) ((((r).pbsmh[0]) >> 24) & 0xff)
#define PBSMH_IPCF_PTRf_SET(r,f) (r).pbsmh[0]=(((r).pbsmh[0] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define PBSMH_RESERVED_IPCF_PTRf_GET(r) ((((r).pbsmh[0]) >> 24) & 0xff)
#define PBSMH_RESERVED_IPCF_PTRf_SET(r,f) (r).pbsmh[0]=(((r).pbsmh[0] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define PBSMH_HEADER_TYPEf_GET(r) ((((r).pbsmh[0]) >> 24) & 0x3f)
#define PBSMH_HEADER_TYPEf_SET(r,f) (r).pbsmh[0]=(((r).pbsmh[0] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))
#define PBSMH_STARTf_GET(r) ((((r).pbsmh[0]) >> 30) & 0x3)
#define PBSMH_STARTf_SET(r,f) (r).pbsmh[0]=(((r).pbsmh[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))

/*******************************************************************************
 * End of 'PBSMH'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PER_PORT_AGE_CONTROL_64
 * BLOCKS:   IPIPE
 * DESC:     Per Port/VLAN Aging Control Register. This register controls software initiated aging, which allows the software to purge all static and dynamic entries for a given VLAN or port from the L2 table. To use this feature hardware (time-based), aging must be disabled by setting L2_AGE_TIMER.AGE_ENA to 0. Hardware aging may be re-enabled after the software initiated aging is complete. Set PPA_MODE to select the fields to match and action taken.
 * SIZE:     64
 * FIELDS:
 *     PORT_NUM         Indicates the Port number to purge if T==0. This field is used with the MODULE_ID field to uniquely identify a module/port to age.
 *     TGID             Trunk ID value if T==1
 *     MODULE_ID        Indicates the module ID to purge if T==0. This field is used with the PORT_NUM field to uniquely identify a module/port to age.
 *     VLAN_ID          Indicates the VLAN ID to purge
 *     PPA_MODE         indicates selection criteria, deletion versus replacement
 *     START            Initiate aging. Software should write this bit to 1 to start software initiated aging. This bit will automatically be cleared when the aging process has completed.				0 = Do not start				1 = Start aging
 *     COMPLETE         Aging complete. Indicates that software initiated aging is complete. Software should clear this bit when START is written to 1. Hardware will set this bit to 1 when the aging process is complete.				0 = Not complete				1 = Complete
 *     DEST_TYPE        Indicates destination type.		    For VLAN-based keys:		    00 = {MODID, PORT} or L2MC_index		    01 = {'0', TGID} or L2MC_index		    #10 = GPON DVPG		    11 = GPON Multicast (L3MC_index)		    		    #For VFI-based keys:		    #10 = VPLS DVP		    #11 = VPLS Multicast (L3MC_index)		    For VXLAN-based keys:		    100 = NHI		    101 = ECMP		    110 = IPMC 		    
 *     T                                                Trunked port (LAG) indication				T == 1, then the trunk group ID, TGID is used				T == 0, then Port_Num and Module_ID are used
 */
#define PER_PORT_AGE_CONTROL_64r_SIZE 8

/*
 * This structure should be used to declare and program PER_PORT_AGE_CONTROL_64.
 */
typedef union PER_PORT_AGE_CONTROL_64r_s {
	uint32 v[2];
	uint32 per_port_age_control_64[2];
	uint32 _per_port_age_control_64;
} PER_PORT_AGE_CONTROL_64r_t;

#define PER_PORT_AGE_CONTROL_64r_CLR(r) sal_memset(&((r)._per_port_age_control_64), 0, sizeof(PER_PORT_AGE_CONTROL_64r_t))
#define PER_PORT_AGE_CONTROL_64r_SET(r,i,d) (r).per_port_age_control_64[i] = d
#define PER_PORT_AGE_CONTROL_64r_GET(r,i) (r).per_port_age_control_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define PER_PORT_AGE_CONTROL_64r_PORT_NUMf_GET(r) (((r).per_port_age_control_64[0]) & 0x7f)
#define PER_PORT_AGE_CONTROL_64r_PORT_NUMf_SET(r,f) (r).per_port_age_control_64[0]=(((r).per_port_age_control_64[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define PER_PORT_AGE_CONTROL_64r_TGIDf_GET(r) (((r).per_port_age_control_64[0]) & 0x7f)
#define PER_PORT_AGE_CONTROL_64r_TGIDf_SET(r,f) (r).per_port_age_control_64[0]=(((r).per_port_age_control_64[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define PER_PORT_AGE_CONTROL_64r_MODULE_IDf_GET(r) ((((r).per_port_age_control_64[0]) >> 7) & 0xff)
#define PER_PORT_AGE_CONTROL_64r_MODULE_IDf_SET(r,f) (r).per_port_age_control_64[0]=(((r).per_port_age_control_64[0] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define PER_PORT_AGE_CONTROL_64r_VLAN_IDf_GET(r) ((((r).per_port_age_control_64[0]) >> 15) & 0xfff)
#define PER_PORT_AGE_CONTROL_64r_VLAN_IDf_SET(r,f) (r).per_port_age_control_64[0]=(((r).per_port_age_control_64[0] & ~((uint32)0xfff << 15)) | ((((uint32)f) & 0xfff) << 15))
#define PER_PORT_AGE_CONTROL_64r_PPA_MODEf_GET(r) ((((r).per_port_age_control_64[0]) >> 27) & 0x7)
#define PER_PORT_AGE_CONTROL_64r_PPA_MODEf_SET(r,f) (r).per_port_age_control_64[0]=(((r).per_port_age_control_64[0] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define PER_PORT_AGE_CONTROL_64r_STARTf_GET(r) ((((r).per_port_age_control_64[0]) >> 30) & 0x1)
#define PER_PORT_AGE_CONTROL_64r_STARTf_SET(r,f) (r).per_port_age_control_64[0]=(((r).per_port_age_control_64[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define PER_PORT_AGE_CONTROL_64r_COMPLETEf_GET(r) ((((r).per_port_age_control_64[0]) >> 31) & 0x1)
#define PER_PORT_AGE_CONTROL_64r_COMPLETEf_SET(r,f) (r).per_port_age_control_64[0]=(((r).per_port_age_control_64[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define PER_PORT_AGE_CONTROL_64r_DEST_TYPEf_GET(r) (((r).per_port_age_control_64[1]) & 0x7)
#define PER_PORT_AGE_CONTROL_64r_DEST_TYPEf_SET(r,f) (r).per_port_age_control_64[1]=(((r).per_port_age_control_64[1] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define PER_PORT_AGE_CONTROL_64r_Tf_GET(r) (((r).per_port_age_control_64[1]) & 0x1)
#define PER_PORT_AGE_CONTROL_64r_Tf_SET(r,f) (r).per_port_age_control_64[1]=(((r).per_port_age_control_64[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access PER_PORT_AGE_CONTROL_64.
 */
#define WRITE_PER_PORT_AGE_CONTROL_64r(u,r) bcm5607x_reg64_set(u,R_PER_PORT_AGE_CONTROL_64,&(r._per_port_age_control_64),2)
#define READ_PER_PORT_AGE_CONTROL_64r(u,r) bcm5607x_reg64_get(u,R_PER_PORT_AGE_CONTROL_64,&(r._per_port_age_control_64),2)

/*******************************************************************************
 * End of 'PER_PORT_AGE_CONTROL_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PFC_XOFF_TIMER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     XOFF Timer value for PFC Tx packet
 * SIZE:     32
 * FIELDS:
 *     PFC_XOFF_TIMER_FLD Time value sent in the Timer Field for classes in XOFF state (Unit is 512 bit-times).
 */
#define PFC_XOFF_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program PFC_XOFF_TIMER.
 */
typedef union PFC_XOFF_TIMERr_s {
	uint32 v[1];
	uint32 pfc_xoff_timer[1];
	uint32 _pfc_xoff_timer;
} PFC_XOFF_TIMERr_t;

#define PFC_XOFF_TIMERr_CLR(r) (r).pfc_xoff_timer[0] = 0
#define PFC_XOFF_TIMERr_SET(r,d) (r).pfc_xoff_timer[0] = d
#define PFC_XOFF_TIMERr_GET(r) (r).pfc_xoff_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define PFC_XOFF_TIMERr_PFC_XOFF_TIMER_FLDf_GET(r) (((r).pfc_xoff_timer[0]) & 0xffff)
#define PFC_XOFF_TIMERr_PFC_XOFF_TIMER_FLDf_SET(r,f) (r).pfc_xoff_timer[0]=(((r).pfc_xoff_timer[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access PFC_XOFF_TIMER.
 */
#define WRITE_PFC_XOFF_TIMERr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_PFC_XOFF_TIMER(bcm5607x_gport_lport_to_index_in_block[p]), (r._pfc_xoff_timer))
#define READ_PFC_XOFF_TIMERr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_PFC_XOFF_TIMER(bcm5607x_gport_lport_to_index_in_block[p]), &(r._pfc_xoff_timer))

/*******************************************************************************
 * End of 'PFC_XOFF_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PG2TC
 * BLOCKS:   MMU
 * DESC:     PG to PRIORITY/TC mapping register
 * SIZE:     32
 * FIELDS:
 *     PG_BMP           The registers are used when the port is configured either as a PFC enabled or a SAFC enabled port. The 16-bit vector PGn_BMP (n=0..7) indicates which bits in the Enable vector in the PFC/SAFC frame transmitted by Greyhound will be set when Priority Group (PG) n needs to be backpressured. Each bit in a PGn_BMP register corresponds to a bit in the Enable vector in the PFC/SAFC frame. For a PFC enabled port, only the lower 8 bits of each of the 8 registers map directly to the PFC Enable Vector and the upper 8 bits are ignored. Instead, on a SAFC enabled port the 16 bits of each of the 8 registers map directly to the 16-bit SAFC Enable Vector.These mapping registers for a PFC/SAFC enabled port in Greyhound are used only when Greyhound transmits a PFC/SAFC frame on that port.For example, if bit 5 in the 16-bit vector PG3_BMP is set for a PFC/SAFC enabled port and PG3 needs to be backpressured on that port, then bit 5 in the Enable vector in the transmitted PFC/SAFC frame will be set by the PFC/SAFC transmit function in Greyhound. 
 */
#define PG2TCr_SIZE 4

/*
 * This structure should be used to declare and program PG2TC.
 */
typedef union PG2TCr_s {
	uint32 v[1];
	uint32 pg2tc[1];
	uint32 _pg2tc;
} PG2TCr_t;

#define PG2TCr_CLR(r) (r).pg2tc[0] = 0
#define PG2TCr_SET(r,d) (r).pg2tc[0] = d
#define PG2TCr_GET(r) (r).pg2tc[0]

/*
 * These macros can be used to access individual fields.
 */
#define PG2TCr_PG_BMPf_GET(r) (((r).pg2tc[0]) & 0xffff)
#define PG2TCr_PG_BMPf_SET(r,f) (r).pg2tc[0]=(((r).pg2tc[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access PG2TC.
 */
#define WRITE_PG2TCr(u,p, i,r) bcm5607x_reg_set(u, R_PG2TC(i,p), (r._pg2tc))
#define READ_PG2TCr(u,p, i,r) bcm5607x_reg_get(u,R_PG2TC(i,p),&(r._pg2tc))

/*******************************************************************************
 * End of 'PG2TCr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PGCELLLIMIT
 * BLOCKS:   MMU
 * DESC:     PG cell set/reset limit
 * SIZE:     32
 * FIELDS:
 *     CELLSETLIMIT     When a PG of an ingress port is not in a backpressure state, the PG's cell counter must rise above this threshold before the backpressure state for the ingress PG is set.(criterion:PGCELLCNT >= CELLSETLIMIT)
 *     CELLRESETLIMIT   When a Priority Group is in the backpressure state, its cell counter must cross this reset limit threshold for the backpressure state of the PG to be reset.(criterion:PGCELLCNT < CELLRESETLIMIT)The CELLRESETLIMIT can be set to the same value or a value lower than the CELLSETLIMIT
 */
#define PGCELLLIMITr_SIZE 4

/*
 * This structure should be used to declare and program PGCELLLIMIT.
 */
typedef union PGCELLLIMITr_s {
	uint32 v[1];
	uint32 pgcelllimit[1];
	uint32 _pgcelllimit;
} PGCELLLIMITr_t;

#define PGCELLLIMITr_CLR(r) (r).pgcelllimit[0] = 0
#define PGCELLLIMITr_SET(r,d) (r).pgcelllimit[0] = d
#define PGCELLLIMITr_GET(r) (r).pgcelllimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGCELLLIMITr_CELLSETLIMITf_GET(r) (((r).pgcelllimit[0]) & 0x3fff)
#define PGCELLLIMITr_CELLSETLIMITf_SET(r,f) (r).pgcelllimit[0]=(((r).pgcelllimit[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define PGCELLLIMITr_CELLRESETLIMITf_GET(r) ((((r).pgcelllimit[0]) >> 14) & 0x3fff)
#define PGCELLLIMITr_CELLRESETLIMITf_SET(r,f) (r).pgcelllimit[0]=(((r).pgcelllimit[0] & ~((uint32)0x3fff << 14)) | ((((uint32)f) & 0x3fff) << 14))

/*
 * These macros can be used to access PGCELLLIMIT.
 */
#define WRITE_PGCELLLIMITr(u,p, i,r) bcm5607x_reg_set(u, R_PGCELLLIMIT(i,p), (r._pgcelllimit))
#define READ_PGCELLLIMITr(u,p, i,r) bcm5607x_reg_get(u,R_PGCELLLIMIT(i,p),&(r._pgcelllimit))

/*******************************************************************************
 * End of 'PGCELLLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PGDISCARDSETLIMIT
 * BLOCKS:   MMU
 * DESC:     PG discard limit
 * SIZE:     32
 * FIELDS:
 *     DISCARDSETLIMIT  If the cell counter of a priority group of an ingress port rises above this threshold, new coming packets are dropped immediately.(criterion:PGCELLCNT >= DISCARDSETLIMIT)
 */
#define PGDISCARDSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program PGDISCARDSETLIMIT.
 */
typedef union PGDISCARDSETLIMITr_s {
	uint32 v[1];
	uint32 pgdiscardsetlimit[1];
	uint32 _pgdiscardsetlimit;
} PGDISCARDSETLIMITr_t;

#define PGDISCARDSETLIMITr_CLR(r) (r).pgdiscardsetlimit[0] = 0
#define PGDISCARDSETLIMITr_SET(r,d) (r).pgdiscardsetlimit[0] = d
#define PGDISCARDSETLIMITr_GET(r) (r).pgdiscardsetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGDISCARDSETLIMITr_DISCARDSETLIMITf_GET(r) (((r).pgdiscardsetlimit[0]) & 0x3fff)
#define PGDISCARDSETLIMITr_DISCARDSETLIMITf_SET(r,f) (r).pgdiscardsetlimit[0]=(((r).pgdiscardsetlimit[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))

/*
 * These macros can be used to access PGDISCARDSETLIMIT.
 */
#define WRITE_PGDISCARDSETLIMITr(u,p, i,r) bcm5607x_reg_set(u, R_PGDISCARDSETLIMIT(i,p), (r._pgdiscardsetlimit))
#define READ_PGDISCARDSETLIMITr(u,p, i,r) bcm5607x_reg_get(u,R_PGDISCARDSETLIMIT(i,p),&(r._pgdiscardsetlimit))

/*******************************************************************************
 * End of 'PGDISCARDSETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PGW_CL_TXFIFO_CTRL
 * BLOCKS:   CLPORT0 CLPORT1 CLPORT2 CLPORT3
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CORE_CLR_COUNT   Software control to clear credit count on core side of async txfifo in PGW_CL (active High).
 *     MAC_CLR_COUNT    Software control to clear credit count on mac side of async txfifo in PGW_CL (active High).
 *     DELAY_PKT        Number of packets to hold in fifo before sending to xlmac for given subport.  default is 1.  Can set to 0 for faster core clock frequencies if 1 cycle latency reduction is desired.
 */
#define PGW_CL_TXFIFO_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program PGW_CL_TXFIFO_CTRL.
 */
typedef union PGW_CL_TXFIFO_CTRLr_s {
	uint32 v[1];
	uint32 pgw_cl_txfifo_ctrl[1];
	uint32 _pgw_cl_txfifo_ctrl;
} PGW_CL_TXFIFO_CTRLr_t;

#define PGW_CL_TXFIFO_CTRLr_CLR(r) (r).pgw_cl_txfifo_ctrl[0] = 0
#define PGW_CL_TXFIFO_CTRLr_SET(r,d) (r).pgw_cl_txfifo_ctrl[0] = d
#define PGW_CL_TXFIFO_CTRLr_GET(r) (r).pgw_cl_txfifo_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGW_CL_TXFIFO_CTRLr_CORE_CLR_COUNTf_GET(r) (((r).pgw_cl_txfifo_ctrl[0]) & 0x1)
#define PGW_CL_TXFIFO_CTRLr_CORE_CLR_COUNTf_SET(r,f) (r).pgw_cl_txfifo_ctrl[0]=(((r).pgw_cl_txfifo_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define PGW_CL_TXFIFO_CTRLr_MAC_CLR_COUNTf_GET(r) ((((r).pgw_cl_txfifo_ctrl[0]) >> 1) & 0x1)
#define PGW_CL_TXFIFO_CTRLr_MAC_CLR_COUNTf_SET(r,f) (r).pgw_cl_txfifo_ctrl[0]=(((r).pgw_cl_txfifo_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define PGW_CL_TXFIFO_CTRLr_DELAY_PKTf_GET(r) ((((r).pgw_cl_txfifo_ctrl[0]) >> 2) & 0x3)
#define PGW_CL_TXFIFO_CTRLr_DELAY_PKTf_SET(r,f) (r).pgw_cl_txfifo_ctrl[0]=(((r).pgw_cl_txfifo_ctrl[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))

/*
 * These macros can be used to access PGW_CL_TXFIFO_CTRL.
 */
#define WRITE_PGW_CL_TXFIFO_CTRLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_clport_lport_to_blockid[p], R_PGW_CL_TXFIFO_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), (r._pgw_cl_txfifo_ctrl))
#define READ_PGW_CL_TXFIFO_CTRLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_clport_lport_to_blockid[p], R_PGW_CL_TXFIFO_CTRL(bcm5607x_clport_lport_to_index_in_block[p]), &(r._pgw_cl_txfifo_ctrl))

/*******************************************************************************
 * End of 'PGW_CL_TXFIFO_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PGW_CTRL_0
 * BLOCKS:   TOP
 * DESC:     PGW Control Register 0
 * SIZE:     32
 * FIELDS:
 *     SW_PM4X10Q_DISABLE When the bit is set, PM4X10Q would be shut off.Bit 0: control PM4X10Q_0.Bit 1: control PM4X10Q_1.Bit 1: control PM4X10Q_2.
 *     SW_PM4X25_DISABLE When the bit is set, PM_4X25 would be shut off.Bit 0: control PM_4X25_0.Bit 1: control PM_4X25_1.Bit 2: control PM_4X25_2.Bit 3: control PM_4X25_3.
 *     RSVD             Reserved
 */
#define PGW_CTRL_0r_SIZE 4

/*
 * This structure should be used to declare and program PGW_CTRL_0.
 */
typedef union PGW_CTRL_0r_s {
	uint32 v[1];
	uint32 pgw_ctrl_0[1];
	uint32 _pgw_ctrl_0;
} PGW_CTRL_0r_t;

#define PGW_CTRL_0r_CLR(r) (r).pgw_ctrl_0[0] = 0
#define PGW_CTRL_0r_SET(r,d) (r).pgw_ctrl_0[0] = d
#define PGW_CTRL_0r_GET(r) (r).pgw_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGW_CTRL_0r_SW_PM4X10Q_DISABLEf_GET(r) (((r).pgw_ctrl_0[0]) & 0x7)
#define PGW_CTRL_0r_SW_PM4X10Q_DISABLEf_SET(r,f) (r).pgw_ctrl_0[0]=(((r).pgw_ctrl_0[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define PGW_CTRL_0r_SW_PM4X25_DISABLEf_GET(r) ((((r).pgw_ctrl_0[0]) >> 3) & 0xf)
#define PGW_CTRL_0r_SW_PM4X25_DISABLEf_SET(r,f) (r).pgw_ctrl_0[0]=(((r).pgw_ctrl_0[0] & ~((uint32)0xf << 3)) | ((((uint32)f) & 0xf) << 3))
#define PGW_CTRL_0r_RSVDf_GET(r) ((((r).pgw_ctrl_0[0]) >> 7) & 0x1ffffff)
#define PGW_CTRL_0r_RSVDf_SET(r,f) (r).pgw_ctrl_0[0]=(((r).pgw_ctrl_0[0] & ~((uint32)0x1ffffff << 7)) | ((((uint32)f) & 0x1ffffff) << 7))

/*
 * These macros can be used to access PGW_CTRL_0.
 */
#define WRITE_PGW_CTRL_0r(u,r) bcm5607x_reg_set(u,R_PGW_CTRL_0,(r._pgw_ctrl_0))
#define READ_PGW_CTRL_0r(u,r) bcm5607x_reg_get(u,R_PGW_CTRL_0,&(r._pgw_ctrl_0))

/*******************************************************************************
 * End of 'PGW_CTRL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PGW_GE_RXFIFO_SOFT_RESET
 * BLOCKS:   PGW_GE0 PGW_GE1 PGW_GE2
 * DESC:     PGW_GE RXFIFO Soft Reset per subport block.  Active high signal. 
 * SIZE:     32
 * FIELDS:
 *     PORT0            Reset Sub-Port 0.  QSGMII Mode/Ethernet Mod
 *     PORT1            Reset Sub-Port 1.  QSGMII Mode/Ethernet Mod
 *     PORT2            Reset Sub-Port 2.  QSGMII Mode/Ethernet Mod
 *     PORT3            Reset Sub-Port 3.  QSGMII Mode/Ethernet Mode
 *     PORT4            Reset Sub-Port 4.  QSGMII Mode only
 *     PORT5            Reset Sub-Port 5.  QSGMII Mode only
 *     PORT6            Reset Sub-Port 6.  QSGMII Mode only
 *     PORT7            Reset Sub-Port 7.  QSGMII Mode only
 *     PORT8            Reset Sub-Port 8.  QSGMII Mode only
 *     PORT9            Reset Sub-Port 9.  QSGMII Mode only
 *     PORT10           Reset Sub-Port 10.  QSGMII Mode only
 *     PORT11           Reset Sub-Port 11.  QSGMII Mode only
 *     PORT12           Reset Sub-Port 12.  QSGMII Mode only
 *     PORT13           Reset Sub-Port 13.  QSGMII Mode only
 *     PORT14           Reset Sub-Port 14.  QSGMII Mode only
 *     PORT15           Reset Sub-Port 15.  QSGMII Mode only
 */
#define PGW_GE_RXFIFO_SOFT_RESETr_SIZE 4

/*
 * This structure should be used to declare and program PGW_GE_RXFIFO_SOFT_RESET.
 */
typedef union PGW_GE_RXFIFO_SOFT_RESETr_s {
	uint32 v[1];
	uint32 pgw_ge_rxfifo_soft_reset[1];
	uint32 _pgw_ge_rxfifo_soft_reset;
} PGW_GE_RXFIFO_SOFT_RESETr_t;

#define PGW_GE_RXFIFO_SOFT_RESETr_CLR(r) (r).pgw_ge_rxfifo_soft_reset[0] = 0
#define PGW_GE_RXFIFO_SOFT_RESETr_SET(r,d) (r).pgw_ge_rxfifo_soft_reset[0] = d
#define PGW_GE_RXFIFO_SOFT_RESETr_GET(r) (r).pgw_ge_rxfifo_soft_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT0f_GET(r) (((r).pgw_ge_rxfifo_soft_reset[0]) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT0f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT1f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 1) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT1f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT2f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 2) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT2f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT3f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 3) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT3f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT4f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 4) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT4f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT5f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 5) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT5f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT6f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 6) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT6f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT7f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 7) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT7f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT8f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 8) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT8f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT9f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 9) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT9f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT10f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 10) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT10f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT11f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 11) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT11f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT12f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 12) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT12f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT13f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 13) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT13f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT14f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 14) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT14f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT15f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 15) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT15f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))

/*
 * These macros can be used to access PGW_GE_RXFIFO_SOFT_RESET.
 */
#define WRITE_PGW_GE_RXFIFO_SOFT_RESETr(u,p,r) bcm5607x_reg_set(u, bcm5607x_pgw_ge_lport_to_blockid[p], R_PGW_GE_RXFIFO_SOFT_RESET, (r._pgw_ge_rxfifo_soft_reset))
#define READ_PGW_GE_RXFIFO_SOFT_RESETr(u,p,r) bcm5607x_reg_get(u, bcm5607x_pgw_ge_lport_to_blockid[p], R_PGW_GE_RXFIFO_SOFT_RESET, &(r._pgw_ge_rxfifo_soft_reset))

/*******************************************************************************
 * End of 'PGW_GE_RXFIFO_SOFT_RESETr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PGW_XL_CONFIG
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     PORT Configuration Register, per Port 0,1,2,3,
 * SIZE:     32
 * FIELDS:
 *     RSVD             Reserved
 *     HIGIG_MODE       Deprected.  PORT is configured as HIGIG port.
 *     HIGIG2_MODE      PORT is configured as HIGIG2 port.
 *     RESERVED_15_12   reserved.
 */
#define PGW_XL_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program PGW_XL_CONFIG.
 */
typedef union PGW_XL_CONFIGr_s {
	uint32 v[1];
	uint32 pgw_xl_config[1];
	uint32 _pgw_xl_config;
} PGW_XL_CONFIGr_t;

#define PGW_XL_CONFIGr_CLR(r) (r).pgw_xl_config[0] = 0
#define PGW_XL_CONFIGr_SET(r,d) (r).pgw_xl_config[0] = d
#define PGW_XL_CONFIGr_GET(r) (r).pgw_xl_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGW_XL_CONFIGr_RSVDf_GET(r) (((r).pgw_xl_config[0]) & 0x3ff)
#define PGW_XL_CONFIGr_RSVDf_SET(r,f) (r).pgw_xl_config[0]=(((r).pgw_xl_config[0] & ~((uint32)0x3ff)) | (((uint32)f) & 0x3ff))
#define PGW_XL_CONFIGr_HIGIG_MODEf_GET(r) ((((r).pgw_xl_config[0]) >> 10) & 0x1)
#define PGW_XL_CONFIGr_HIGIG_MODEf_SET(r,f) (r).pgw_xl_config[0]=(((r).pgw_xl_config[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define PGW_XL_CONFIGr_HIGIG2_MODEf_GET(r) ((((r).pgw_xl_config[0]) >> 11) & 0x1)
#define PGW_XL_CONFIGr_HIGIG2_MODEf_SET(r,f) (r).pgw_xl_config[0]=(((r).pgw_xl_config[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define PGW_XL_CONFIGr_RESERVED_15_12f_GET(r) ((((r).pgw_xl_config[0]) >> 12) & 0xf)
#define PGW_XL_CONFIGr_RESERVED_15_12f_SET(r,f) (r).pgw_xl_config[0]=(((r).pgw_xl_config[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))

/*
 * These macros can be used to access PGW_XL_CONFIG.
 */
#define WRITE_PGW_XL_CONFIGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_PGW_XL_CONFIG(bcm5607x_xlport_lport_to_index_in_block[p]), (r._pgw_xl_config))
#define READ_PGW_XL_CONFIGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_PGW_XL_CONFIG(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._pgw_xl_config))

/*******************************************************************************
 * End of 'PGW_XL_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PGW_XL_ECC_CONTROL
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     PGW_XL memories ECC control register
 * SIZE:     32
 * FIELDS:
 *     RSVD             Reserve
 *     RXFIFO_ECC_ENABLE RXFIFO ECC ENABLE
 *     RXFIFO_EN_COR_ERR_RPT  RXFIFO report 1-bit ECC ENABLE
 *     TXFIFO_ECC_EN    TXFIFO ECC ENABLE.
 */
#define PGW_XL_ECC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PGW_XL_ECC_CONTROL.
 */
typedef union PGW_XL_ECC_CONTROLr_s {
	uint32 v[1];
	uint32 pgw_xl_ecc_control[1];
	uint32 _pgw_xl_ecc_control;
} PGW_XL_ECC_CONTROLr_t;

#define PGW_XL_ECC_CONTROLr_CLR(r) (r).pgw_xl_ecc_control[0] = 0
#define PGW_XL_ECC_CONTROLr_SET(r,d) (r).pgw_xl_ecc_control[0] = d
#define PGW_XL_ECC_CONTROLr_GET(r) (r).pgw_xl_ecc_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGW_XL_ECC_CONTROLr_RSVDf_GET(r) (((r).pgw_xl_ecc_control[0]) & 0x3f)
#define PGW_XL_ECC_CONTROLr_RSVDf_SET(r,f) (r).pgw_xl_ecc_control[0]=(((r).pgw_xl_ecc_control[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define PGW_XL_ECC_CONTROLr_RXFIFO_ECC_ENABLEf_GET(r) ((((r).pgw_xl_ecc_control[0]) >> 6) & 0x1)
#define PGW_XL_ECC_CONTROLr_RXFIFO_ECC_ENABLEf_SET(r,f) (r).pgw_xl_ecc_control[0]=(((r).pgw_xl_ecc_control[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PGW_XL_ECC_CONTROLr_RXFIFO_EN_COR_ERR_RPTf_GET(r) ((((r).pgw_xl_ecc_control[0]) >> 7) & 0x1)
#define PGW_XL_ECC_CONTROLr_RXFIFO_EN_COR_ERR_RPTf_SET(r,f) (r).pgw_xl_ecc_control[0]=(((r).pgw_xl_ecc_control[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define PGW_XL_ECC_CONTROLr_TXFIFO_ECC_ENf_GET(r) ((((r).pgw_xl_ecc_control[0]) >> 8) & 0x1)
#define PGW_XL_ECC_CONTROLr_TXFIFO_ECC_ENf_SET(r,f) (r).pgw_xl_ecc_control[0]=(((r).pgw_xl_ecc_control[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))

/*
 * These macros can be used to access PGW_XL_ECC_CONTROL.
 */
#define WRITE_PGW_XL_ECC_CONTROLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_PGW_XL_ECC_CONTROL, (r._pgw_xl_ecc_control))
#define READ_PGW_XL_ECC_CONTROLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_PGW_XL_ECC_CONTROL, &(r._pgw_xl_ecc_control))

/*******************************************************************************
 * End of 'PGW_XL_ECC_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PGW_XL_TXFIFO_CTRL
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CORE_CLR_COUNT   Software control to clear credit count on core side of async txfifo in PGW_XL (active High).
 *     MAC_CLR_COUNT    Software control to clear credit count on mac side of async txfifo in PGW_XL (active High).
 *     DELAY_PKT        Number of packets to hold in fifo before sending to xlmac for given subport.  default is 1.  Can set to 0 for faster core clock frequencies if 1 cycle latency reduction is desired.
 */
#define PGW_XL_TXFIFO_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program PGW_XL_TXFIFO_CTRL.
 */
typedef union PGW_XL_TXFIFO_CTRLr_s {
	uint32 v[1];
	uint32 pgw_xl_txfifo_ctrl[1];
	uint32 _pgw_xl_txfifo_ctrl;
} PGW_XL_TXFIFO_CTRLr_t;

#define PGW_XL_TXFIFO_CTRLr_CLR(r) (r).pgw_xl_txfifo_ctrl[0] = 0
#define PGW_XL_TXFIFO_CTRLr_SET(r,d) (r).pgw_xl_txfifo_ctrl[0] = d
#define PGW_XL_TXFIFO_CTRLr_GET(r) (r).pgw_xl_txfifo_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGW_XL_TXFIFO_CTRLr_CORE_CLR_COUNTf_GET(r) (((r).pgw_xl_txfifo_ctrl[0]) & 0x1)
#define PGW_XL_TXFIFO_CTRLr_CORE_CLR_COUNTf_SET(r,f) (r).pgw_xl_txfifo_ctrl[0]=(((r).pgw_xl_txfifo_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define PGW_XL_TXFIFO_CTRLr_MAC_CLR_COUNTf_GET(r) ((((r).pgw_xl_txfifo_ctrl[0]) >> 1) & 0x1)
#define PGW_XL_TXFIFO_CTRLr_MAC_CLR_COUNTf_SET(r,f) (r).pgw_xl_txfifo_ctrl[0]=(((r).pgw_xl_txfifo_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define PGW_XL_TXFIFO_CTRLr_DELAY_PKTf_GET(r) ((((r).pgw_xl_txfifo_ctrl[0]) >> 2) & 0x3)
#define PGW_XL_TXFIFO_CTRLr_DELAY_PKTf_SET(r,f) (r).pgw_xl_txfifo_ctrl[0]=(((r).pgw_xl_txfifo_ctrl[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))

/*
 * These macros can be used to access PGW_XL_TXFIFO_CTRL.
 */
#define WRITE_PGW_XL_TXFIFO_CTRLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_PGW_XL_TXFIFO_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), (r._pgw_xl_txfifo_ctrl))
#define READ_PGW_XL_TXFIFO_CTRLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_PGW_XL_TXFIFO_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._pgw_xl_txfifo_ctrl))

/*******************************************************************************
 * End of 'PGW_XL_TXFIFO_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PG_CTRL0
 * BLOCKS:   MMU
 * DESC:     Priority group control register
 * SIZE:     32
 * FIELDS:
 *     PRI0_GRP         The register maps input priority 0 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI1_GRP         The register maps input priority 1 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI2_GRP         The register maps input priority 2 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI3_GRP         The register maps input priority 3 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI4_GRP         The register maps input priority 4 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI5_GRP         The register maps input priority 5 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI6_GRP         The register maps input priority 6 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI7_GRP         The register maps input priority 7 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PPFC_PG_EN       Each bit is for a Priority group.Bit 0: Priority Group 0....Bit 7: Priority Group 71: Enables the MMU to trigger corresponding Tx MACs to generate PFC frames for all priorities mapped to this PG0: MMU will not trigger corresponding Tx MACs to generate PFC/SAFC frames for any priority/TC mapped to this PG even if the cell utilization for this PG has exceeded the cell limit threshold
 */
#define PG_CTRL0r_SIZE 4

/*
 * This structure should be used to declare and program PG_CTRL0.
 */
typedef union PG_CTRL0r_s {
	uint32 v[1];
	uint32 pg_ctrl0[1];
	uint32 _pg_ctrl0;
} PG_CTRL0r_t;

#define PG_CTRL0r_CLR(r) (r).pg_ctrl0[0] = 0
#define PG_CTRL0r_SET(r,d) (r).pg_ctrl0[0] = d
#define PG_CTRL0r_GET(r) (r).pg_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define PG_CTRL0r_PRI0_GRPf_GET(r) (((r).pg_ctrl0[0]) & 0x7)
#define PG_CTRL0r_PRI0_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define PG_CTRL0r_PRI1_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 3) & 0x7)
#define PG_CTRL0r_PRI1_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define PG_CTRL0r_PRI2_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 6) & 0x7)
#define PG_CTRL0r_PRI2_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define PG_CTRL0r_PRI3_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 9) & 0x7)
#define PG_CTRL0r_PRI3_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define PG_CTRL0r_PRI4_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 12) & 0x7)
#define PG_CTRL0r_PRI4_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define PG_CTRL0r_PRI5_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 15) & 0x7)
#define PG_CTRL0r_PRI5_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define PG_CTRL0r_PRI6_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 18) & 0x7)
#define PG_CTRL0r_PRI6_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define PG_CTRL0r_PRI7_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 21) & 0x7)
#define PG_CTRL0r_PRI7_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 21)) | ((((uint32)f) & 0x7) << 21))
#define PG_CTRL0r_PPFC_PG_ENf_GET(r) ((((r).pg_ctrl0[0]) >> 24) & 0xff)
#define PG_CTRL0r_PPFC_PG_ENf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))

/*
 * These macros can be used to access PG_CTRL0.
 */
#define WRITE_PG_CTRL0r(u,p,r) bcm5607x_reg_set(u,R_PG_CTRL0(p),(r._pg_ctrl0))
#define READ_PG_CTRL0r(u,p,r) bcm5607x_reg_get(u,R_PG_CTRL0(p),&(r._pg_ctrl0))

/*******************************************************************************
 * End of 'PG_CTRL0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PG_CTRL1
 * BLOCKS:   MMU
 * DESC:     Priority group control register
 * SIZE:     32
 * FIELDS:
 *     PRI8_GRP         The register maps input priority 8 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI9_GRP         The register maps input priority 9 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI10_GRP        The register maps input priority 10 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI11_GRP        The register maps input priority 11 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI12_GRP        The register maps input priority 12 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI13_GRP        The register maps input priority 13 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI14_GRP        The register maps input priority 14 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI15_GRP        The register maps input priority 15 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 */
#define PG_CTRL1r_SIZE 4

/*
 * This structure should be used to declare and program PG_CTRL1.
 */
typedef union PG_CTRL1r_s {
	uint32 v[1];
	uint32 pg_ctrl1[1];
	uint32 _pg_ctrl1;
} PG_CTRL1r_t;

#define PG_CTRL1r_CLR(r) (r).pg_ctrl1[0] = 0
#define PG_CTRL1r_SET(r,d) (r).pg_ctrl1[0] = d
#define PG_CTRL1r_GET(r) (r).pg_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define PG_CTRL1r_PRI8_GRPf_GET(r) (((r).pg_ctrl1[0]) & 0x7)
#define PG_CTRL1r_PRI8_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define PG_CTRL1r_PRI9_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 3) & 0x7)
#define PG_CTRL1r_PRI9_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define PG_CTRL1r_PRI10_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 6) & 0x7)
#define PG_CTRL1r_PRI10_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define PG_CTRL1r_PRI11_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 9) & 0x7)
#define PG_CTRL1r_PRI11_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define PG_CTRL1r_PRI12_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 12) & 0x7)
#define PG_CTRL1r_PRI12_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define PG_CTRL1r_PRI13_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 15) & 0x7)
#define PG_CTRL1r_PRI13_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define PG_CTRL1r_PRI14_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 18) & 0x7)
#define PG_CTRL1r_PRI14_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define PG_CTRL1r_PRI15_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 21) & 0x7)
#define PG_CTRL1r_PRI15_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 21)) | ((((uint32)f) & 0x7) << 21))

/*
 * These macros can be used to access PG_CTRL1.
 */
#define WRITE_PG_CTRL1r(u,p,r) bcm5607x_reg_set(u,R_PG_CTRL1(p),(r._pg_ctrl1))
#define READ_PG_CTRL1r(u,p,r) bcm5607x_reg_get(u,R_PG_CTRL1(p),&(r._pg_ctrl1))

/*******************************************************************************
 * End of 'PG_CTRL1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PKTAGINGTIMER
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DURATIONSELECT   13 bits aging interval duration select registers. Duration select determines the interval at which the age timergets incremented. After DURATIONSELECT number of clock timer ticks (pulses) the age timer will be incremented by 1.Packet aging function is disabled when set this register to 0 and is disabled by default after power-on reset.
 *     AGINGTICKSEL     Select Aging (DURATIONSELECT) tick clock source.0: 125us clock pulse1: 500ms clock pulse
 */
#define PKTAGINGTIMERr_SIZE 4

/*
 * This structure should be used to declare and program PKTAGINGTIMER.
 */
typedef union PKTAGINGTIMERr_s {
	uint32 v[1];
	uint32 pktagingtimer[1];
	uint32 _pktagingtimer;
} PKTAGINGTIMERr_t;

#define PKTAGINGTIMERr_CLR(r) (r).pktagingtimer[0] = 0
#define PKTAGINGTIMERr_SET(r,d) (r).pktagingtimer[0] = d
#define PKTAGINGTIMERr_GET(r) (r).pktagingtimer[0]

/*
 * These macros can be used to access individual fields.
 */
#define PKTAGINGTIMERr_DURATIONSELECTf_GET(r) (((r).pktagingtimer[0]) & 0x1fff)
#define PKTAGINGTIMERr_DURATIONSELECTf_SET(r,f) (r).pktagingtimer[0]=(((r).pktagingtimer[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))
#define PKTAGINGTIMERr_AGINGTICKSELf_GET(r) ((((r).pktagingtimer[0]) >> 13) & 0x1)
#define PKTAGINGTIMERr_AGINGTICKSELf_SET(r,f) (r).pktagingtimer[0]=(((r).pktagingtimer[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))

/*
 * These macros can be used to access PKTAGINGTIMER.
 */
#define WRITE_PKTAGINGTIMERr(u,r) bcm5607x_reg_set(u,R_PKTAGINGTIMER,(r._pktagingtimer))
#define READ_PKTAGINGTIMERr(u,r) bcm5607x_reg_get(u,R_PKTAGINGTIMER,&(r._pktagingtimer))

/*******************************************************************************
 * End of 'PKTAGINGTIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PMQ_XGXS0_CTRL_REG
 * BLOCKS:   PMQPORT0 PMQPORT1 PMQPORT2
 * DESC:     Controls to Merlin PMD when in PMQ mode. Equivalent to PORT_XGXS0_CTRL_REG in ethernet mode.
 * SIZE:     32
 * FIELDS:
 *     RSTB_HW          Hard reset (active low).  Resets everything.
 *     REFOUT_EN        Enables LCREFOUT to be driven by this TSC. (Valid only for 28nm, don't care for 16nm)
 *     REFIN_EN         Selects between pad and LCREF as source of refclk into this TSC PLL. (Valid only for 28nm, don't care for 16nm)
 *     PWRDWN           QTC_PCS Power Down. Drives qtc_pwrdwn input high.
 *     IDDQ             Shutdown analog clocks but leave analog section powered.
 *     PWRDWN_CML       0: Normal operation. 1: Power down the CML reference output buffer. (Valid only for 16nm, don't care for 28nm)
 *     PWRDWN_CML_LC    0: Normal operation. 1: Power down the CML LC reference output buffer. (Valid only for 16nm, don't care for 28nm)
 *     REFCMOS          0: Drive the CMOS Clock Channel. 1: CMOS Clock Channel is off. (Valid only for 16nm, don't care for 28nm)
 *     REFSEL           Reference clock select. 101: Internal LC Reference Input (default). See documentation for other values. (Valid only for 16nm, don't care for 28nm)
 */
#define PMQ_XGXS0_CTRL_REGr_SIZE 4

/*
 * This structure should be used to declare and program PMQ_XGXS0_CTRL_REG.
 */
typedef union PMQ_XGXS0_CTRL_REGr_s {
	uint32 v[1];
	uint32 pmq_xgxs0_ctrl_reg[1];
	uint32 _pmq_xgxs0_ctrl_reg;
} PMQ_XGXS0_CTRL_REGr_t;

#define PMQ_XGXS0_CTRL_REGr_CLR(r) (r).pmq_xgxs0_ctrl_reg[0] = 0
#define PMQ_XGXS0_CTRL_REGr_SET(r,d) (r).pmq_xgxs0_ctrl_reg[0] = d
#define PMQ_XGXS0_CTRL_REGr_GET(r) (r).pmq_xgxs0_ctrl_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define PMQ_XGXS0_CTRL_REGr_RSTB_HWf_GET(r) (((r).pmq_xgxs0_ctrl_reg[0]) & 0x1)
#define PMQ_XGXS0_CTRL_REGr_RSTB_HWf_SET(r,f) (r).pmq_xgxs0_ctrl_reg[0]=(((r).pmq_xgxs0_ctrl_reg[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define PMQ_XGXS0_CTRL_REGr_REFOUT_ENf_GET(r) ((((r).pmq_xgxs0_ctrl_reg[0]) >> 1) & 0x1)
#define PMQ_XGXS0_CTRL_REGr_REFOUT_ENf_SET(r,f) (r).pmq_xgxs0_ctrl_reg[0]=(((r).pmq_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define PMQ_XGXS0_CTRL_REGr_REFIN_ENf_GET(r) ((((r).pmq_xgxs0_ctrl_reg[0]) >> 2) & 0x1)
#define PMQ_XGXS0_CTRL_REGr_REFIN_ENf_SET(r,f) (r).pmq_xgxs0_ctrl_reg[0]=(((r).pmq_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define PMQ_XGXS0_CTRL_REGr_PWRDWNf_GET(r) ((((r).pmq_xgxs0_ctrl_reg[0]) >> 3) & 0x1)
#define PMQ_XGXS0_CTRL_REGr_PWRDWNf_SET(r,f) (r).pmq_xgxs0_ctrl_reg[0]=(((r).pmq_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define PMQ_XGXS0_CTRL_REGr_IDDQf_GET(r) ((((r).pmq_xgxs0_ctrl_reg[0]) >> 4) & 0x1)
#define PMQ_XGXS0_CTRL_REGr_IDDQf_SET(r,f) (r).pmq_xgxs0_ctrl_reg[0]=(((r).pmq_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define PMQ_XGXS0_CTRL_REGr_PWRDWN_CMLf_GET(r) ((((r).pmq_xgxs0_ctrl_reg[0]) >> 5) & 0x1)
#define PMQ_XGXS0_CTRL_REGr_PWRDWN_CMLf_SET(r,f) (r).pmq_xgxs0_ctrl_reg[0]=(((r).pmq_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PMQ_XGXS0_CTRL_REGr_PWRDWN_CML_LCf_GET(r) ((((r).pmq_xgxs0_ctrl_reg[0]) >> 6) & 0x1)
#define PMQ_XGXS0_CTRL_REGr_PWRDWN_CML_LCf_SET(r,f) (r).pmq_xgxs0_ctrl_reg[0]=(((r).pmq_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PMQ_XGXS0_CTRL_REGr_REFCMOSf_GET(r) ((((r).pmq_xgxs0_ctrl_reg[0]) >> 7) & 0x1)
#define PMQ_XGXS0_CTRL_REGr_REFCMOSf_SET(r,f) (r).pmq_xgxs0_ctrl_reg[0]=(((r).pmq_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define PMQ_XGXS0_CTRL_REGr_REFSELf_GET(r) ((((r).pmq_xgxs0_ctrl_reg[0]) >> 8) & 0x7)
#define PMQ_XGXS0_CTRL_REGr_REFSELf_SET(r,f) (r).pmq_xgxs0_ctrl_reg[0]=(((r).pmq_xgxs0_ctrl_reg[0] & ~((uint32)0x7 << 8)) | ((((uint32)f) & 0x7) << 8))

/*
 * These macros can be used to access PMQ_XGXS0_CTRL_REG.
 */
#define WRITE_PMQ_XGXS0_CTRL_REGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_pmqport_lport_to_blockid[p], R_PMQ_XGXS0_CTRL_REG, (r._pmq_xgxs0_ctrl_reg))
#define READ_PMQ_XGXS0_CTRL_REGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_pmqport_lport_to_blockid[p], R_PMQ_XGXS0_CTRL_REG, &(r._pmq_xgxs0_ctrl_reg))

/*******************************************************************************
 * End of 'PMQ_XGXS0_CTRL_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  PORT
 * BLOCKS:   IPIPE
 * DESC:     Port Configuration Table.
This table is used to control basic switching logic on a per port basis. The port number corresponds to the index.
Note: MY_MODID for HiGig ports must be defined in IPORT_TABLE.MY_MODID.
 * SIZE:     384
 * FIELDS:
 *     DATA_0           Physical memory data field #0
 *     FILTER_ENABLE    Enable Filtering
 *     VT_MISS_DROP     VLAN translation miss drop
 *     VT_ENABLE        VLAN translation enable
 *     TRUST_DSCP_V4    Ingress port is trusted port, trust incoming IPv4 DSCP
 *     TRUST_DSCP_V6    Ingress port is trusted port, trust incoming IPv6 DSCP
 *     EN_IFILTER       Enable ingress filtering
 *     MIRROR           Mirror enable (same as MIRROR0) 
 *     MIRROR0          Mirror 0 enable
 *     PORT_PRI         Port default priority, when using default PORT VLAN_ID
 *     IPMC_DO_VLAN     If set, include the VLAN ID as part of the IPMC search key in the L3_ENTRY table when doing the {S,V,G} lookups, else the VID will be zero for those lookups.
 *     V6IPMC_ENABLE    IPv6 IPMC enable
 *     V4IPMC_ENABLE    IPv4 IPMC enable
 *     V6IPMC_L2_ENABLE Enables L2-only forwarding of IPMCv6 packets on this port based on (SGV,*GV) lookups.
 *     V4IPMC_L2_ENABLE Enables L2-only forwarding of IPMCv4 packets on this port based on (SGV,*GV) lookups.
 *     V6L3_ENABLE      IPv6 L3 enable
 *     V4L3_ENABLE      IPv4 L3 enable
 *     DROP_BPDU        when set, ingress drops BPDUs
 *     PORT_DIS_TAG     Drop all tagged packets
 *     PORT_DIS_UNTAG   Drop all untagged packets
 *     PASS_CONTROL_FRAMES Pass pause frames through without dropping
 *     SUBNET_BASED_VID_ENABLE Enable subnet-based VLANs
 *     MAC_BASED_VID_ENABLE Enable MAC-based VLANs
 *     OVID             Internal outer VLAN ID
 *     PORT_VID         Port VLAN
 *     PORT_TYPE        Port can be Ethernet, HiGig port, MIM loopback port or Embeded HiGig port
 *     DUAL_MODID_ENABLE Enable dual modid mode where this chip looks like two MODIDs to rest of system. Incoming higig packets using (MY_MODID+1)/Port_ID are mapped to MY_MODID/(Port_ID+32) for internal processing. Note that when set, MY_MODID must be even (ends in 0). When not set, all ports belong to single MY_MODID.
 *     MAP_TAG_PKT_PRIORITY Map the incoming packet priority
 *     MY_MODID         Stacking module ID for this module. Valid values are from 0 - 256.
 *     PORT_BRIDGE      Allows L2 bridging to the incoming port
 *     IGNORE_IPMC_L2_BITMAP Set this bit to disable L2 switching of IPMC pkts on this port.
 *     IGNORE_IPMC_L3_BITMAP Set this bit to disable L3 routing of IPMC pkts on this port.
 *     HIGIG_TRUNK      Set this bit if the port is a member if a higig trunkIf set, then HIGIG_PACKET must also be set.
 *     HIGIG_TRUNK_ID   If HIGIG_TRUNK=1, then this is the trunk ID
 *     VLAN_PRECEDENCE  Determine the priorities for selecting VLAN (MAC-based, subnet-based VLANs). If set, subnet-based VLAN assignment has higher priority than MAC-based vlan assignment.
 *     RESERVED_0       Reserved.
 *     HIGIG2           If HIGIG_PACKET=1, then this bit indicates if the port is in HiGig2 mode (if HIGIG2=1) or in HiGig mode (if HIGIG2=0)
 *     ALLOW_SRC_MOD    When set, packets whose source modid is equal to my_modid are not dropped
 *     TRUST_OUTER_DOT1P If this bit is set, outer 802.1p bits will be used to derive (int_pri,CNG) in the ING_PRI_CNG_MAP table 
 *     RTAG7_PORT_LBN   A per-port value configured by software for splitting traffic.
 *     REMOVE_HG_HDR_SRC_PORT If set to 1, do not forward the pkt to the non-trunk (i.e., not LAG) source port in module header when the MH.SRC_MODID is same as ING_CONFIG.MY_MODID. NOTE: If module header's source port is a trunk (LAG) port, the pkts are not forwarded to its LAG members irrespective of this control bit
 *     FP_PORT_SELECT_TYPE Controls whether PORT_FIELD_SEL_INDEX1 or PORT_FIELD_SEL_INDEX0 is selected as the input into the FP_PORT_FIELD_SELECT table
 *     VFP_ENABLE       VFP ENABLE.
 *     VFP_PORT_GROUP_ID VFP PORT GROUP ID.
 *     URPF_MODE        RESERVED.
 *     URPF_DEFAULTROUTECHECK RESERVED.
 *     CFI_AS_CNG       Indicates for ING_OUTER_TPID[3] to ING_OUTER_TPID[0] if the CFI bit in the packet indicates CNG
 *     USE_INNER_PRI    If set, use the packet's inner priority.
 *     ECCP_0           Memory_0 ECC + Parity bits.
 *     ECC_0            Memory_0 ECC bits for 1-bit error correction.
 *     PARITY_0         Memory_0 Parity bit for 2-bit error detection.
 *     DATA_1           Physical memory data field #1
 *     OUTER_TPID_ENABLE Indicates if ING_OUTER_TPID[3] to ING_OUTER_TPID[0] are allowed outer TPID values.
 *     OUTER_TPID_VERIFY If set, indicates to verify the packet's outer TPID matches the VLAN tables TPID value
 *     USE_INCOMING_DOT1P If set, preserve incoming 802.1p priority in the packet
 *     PVLAN_ENABLE     If set, enable private VLAN on this port
 *     TAG_ACTION_PROFILE_PTR Ingress VLAN tag action profile pointer, used as the index into the tING_VLAN_TAG_ACTION_PROFILE table.
 *     IVID             Internal inner VLAN ID
 *     TRUST_INCOMING_VID If set, trust incoming outer and inner VLAN tags.  NOTE: If VT_ENABLE is set, the incoming outer and inner VLAN tags are trusted regardless of the setting of this bit.
 *     VT_KEY_TYPE      Indicates the key type for the first lookup to the ingress VLAN translation table -- see encodings in VLAN_XLATE
 *     VT_KEY_TYPE_USE_GLP If set then the GLP (T,MODID,PORT) is included as part of the VLAN_XLATE Key, else the GLP is set to all one's to be port-independant.
 *     VT_KEY_TYPE_2    Indicates the key type for the first lookup to the ingress VLAN translation table -- see encodings in VLAN_XLATE
 *     VT_KEY_TYPE_2_USE_GLP If set then the GLP (T,MODID,PORT) is included as part of the VLAN_XLATE Key for the second key lookup, else the GLP is set to all one's to be port-independant.
 *     CML_FLAGS_NEW    CPU managed learning control for new entries		    What to do when a L2 miss occurs:		    bit[0] = Drop the packet		    bit[1] = Copy to CPU		    bit[2] = Set the Pending bit on HW Learn		    bit[3] = Do HW Learn
 *     CML_FLAGS_MOVE   CPU managed learning control for station moves		    What to do when a L2 station move is detected:		    bit[0] = Drop the packet		    bit[1] = Copy to CPU		    bit[2] = Set the Pending bit on HW Station Move		    bit[3] = Do HW Station Move
 *     PRI_MAPPING      3-bits for each of 8 Pkt Priority values		    [2:0]   = lookup_pri for pkt_pri=0		    [5:3]   = lookup_pri for pkt_pri=1		    [8:6]   = lookup_pri for pkt_pri=2		    [11:9]  = lookup_pri for pkt_pri=3		    [14:12] = lookup_pri for pkt_pri=4		    [17:15] = lookup_pri for pkt_pri=5		    [20:18] = lookup_pri for pkt_pri=6		    [23:21] = lookup_pri for pkt_pri=7
 *     CFI_0_MAPPING    Mapped value When CFI==0 for VXLT keys
 *     CFI_1_MAPPING    Mapped value When CFI==0 for VXLT keys
 *     PORT_OPERATION   Default Port Operation		                 0 = normal operation		                 1 = Reserved		                 2 = Reserved		                 3 = Reserved                                 4 = normal operation but use per-port VLAN                                 5 = normal operation but use per-port VFI
 *     MAC_IP_BIND_LOOKUP_MISS_DROP enable drop due to HPAE: source IP binding with SA_MAC and Src Port checking failure.
 *     REMOTE_CPU_EN    Enables remote cpu packet parsing
 *     DISABLE_STATIC_MOVE_DROP When set, this bit allows packets to be forwarded even if the MACSA has moved and is marked as static in the L2 table
 *     USE_IVID_AS_OVID When set, use the inner VID as the learning and forwarding VID. Note that VXLT and VFP hits will override this setting.
 *     MH_INGRESS_TAGGED_SEL Controls how to interpret the INGRESS_TAGGED bit in the module header
 *     CLASS_BASED_SM_ENABLE Enable class based station movement checks
 *     RESERVED_1       Reserved.
 *     ECCP_1           Memory_1 ECC + Parity bits.
 *     ECC_1            Memory_1 ECC bits for 1-bit error correction.
 *     PARITY_1         Memory_1 Parity bit for 2-bit error detection.
 *     DATA_2           Physical memory data field #2
 *     USE_CUSTOM_HEADER_FOR_PRI Use CUSTOME_HEADER to derive INT_PRI and CNG.                               00 = noop                               01 = Replace INT_PRI and CNG with value programmed CUSTOM_HEADER_POLICY table                               10 = Use QOS_MAPPING_PTR from CUSTOM_HEADER_POLICY table as INT_PRI_CNG_MAPPING_PTR                               11 = Use QOS_MAPPING_PTR from CUSTOM_HEADER_POLICY table as TRUST_DSCP_PTR
 *     TRUST_DOT1P_PTR  Profile pointer into the ING_PRI_CNG_MAP table. Valid values are 0 to 62.
 *     IEEE_802_1AS_ENABLE If this bit is set, then any IEEE 802.1AS packet that matches in the IEEE 802.1AS Control Register is trapped to the CPU
 *     USE_PORT_TABLE_GROUP_ID 0== Use port_group_id from SOURCE_TRUNK_MAP table for VFP key.  1== Use port_group_id from LPORT table for VFP key
 *     OAM_ENABLE       Per Port OAM enable for parsing
 *     RESERVED_210     Reserved.
 *     PROTOCOL_PKT_INDEX Protocol pkt index.
 *     MDL_BITMAP       MDL Bitmap used by a DOWN MEP.
 *     CTRL_PROFILE_INDEX_1588 Index to ING_1588_INGRESS_CTRL table for per 1588 message type actions
 *     INNER_TPID_ENABLE If set to 1, enable the inner TPID
 *     NIV_UPLINK_PORT  If set, this ingress port is an uplink port. This field is used for checking the validity and format of incoming VNTAG/ETAG's.
 *     NIV_VIF_ID       This port's NIV/PE - Virtual Interface (VIF) identifier. If this ports is a downlink Access-IV/PE, this configuration field shall be used to set src_vif of the ingress port-based VNTAG/ETAG added in the packet.
 *     NIV_NAMESPACE    The NIV/PE-namespace associated with this ingress port. If this port is a downlink port, this field typically takes a compressed GLP value of it's associated NIV/PE uplink port. If this port is an uplink port, it takes a compressed value of it's own GLP. This field is used for forwarding lookups in the VIF table when this ingress port is an uplink port. This field is used for RPF lookups when this ingress port is a downlink port.
 *     PROHIBITED_DOT1P The 802.1p priorities prohibited from ingressing on this port. If set to 1, corresponding dot1p priorities are not allowed to ingress if packet is VLAN tagged or Priority tagged.
 *     NIV_RPF_CHECK_ENABLE If set, all VNTAG/ETAG'ed packets ingressing at this port are checked for Reverse Path Forwarding (RPF). Drop the packet if this check fails.
 *     NIV_VIF_LOOKUP_ENABLE If set, L2_ENTRY table lookup is an NIV/PE based lookup using the VIF key type. This is set for IV/PE uplink ports.
 *     USE_MIML_PCP_FOR_PRI Use MIML_PCP and MIML_CFI to derive INT_PRI and CNG.
 *     MIML_ENABLE      Enable MIML feature.
 *     RESERVED_272     Reserved.
 *     CUSTOM_HEADER_ENABLE Enable CUSTOME_HEADER feature.
 *     MIML_DOT1P_MAPPING_PTR Used to pick a mapping profile when USE_MIML_PCP_FOR_PRI is set.
 *     ECCP_2           Memory_2 ECC + Parity bits.
 *     ECC_2            Memory_2 ECC bits for 1-bit error correction.
 *     PARITY_2         Memory_2 Parity bit for 2-bit error detection.
 *     DATA_3           Physical memory data field #3
 *     TX_DEST_PORT     Destination Global Logical Port (DGLP) associated with this ingress port. When TX_DEST_PORT_ENABLE is set, all ingress traffic shall be sent to the DGLP configured. {Trunk, Modid(7,0), Port(6,0)}
 *     TX_DEST_PORT_ENABLE If set, all the ingress packets are sent to the TX_DEST_PORT configured for this ingress port. This mode is to support the packet forwarding requirement of an upstream IV/PE.
 *     VNTAG_ACTIONS_IF_NOT_PRESENT VNATG/ETAG actions if not present.
 *     VNTAG_ACTIONS_IF_PRESENT VNTAG/ETAG actions if present.
 *     DISCARD_IF_VNTAG_PRESENT Drop the ingress packet if it contains a VNTAG/ETAG. Ingress packets that contain VNTAG are typically dropped by Access-IV's in the upstream direction.
 *     DISCARD_IF_VNTAG_NOT_PRESENT Drop the ingress packet if it does not contain a VNTAG/ETAG. Ingress packets that don't contain VNTAG/ETAG are dropped by Transit-IV's in the upstream direction and all IV's in the downstream direction.
 *     ETAG_PCP_DE_MAPPING_PTR Profile used to derive ETAG's {PCP,DE} from incoming outer/inner VLAN tag's {pri,cfi} by indexing the ING_ETAG_PCP_MAPPING table.
 *     PHB_FROM_ETAG    int_pri and cng are derived from ETAG.PCP and ETAG.DE based on PORT__TRUST_DOT1P_PTR.
 *     ETAG_DOT1P_MAPPING_PTR ETAG dot1p mapping ptr
 *     ETAG_DE          When an Ingress Port based ETAG is added DE field is populated from this value.
 *     ETAG_PCP         When an Ingress Port based ETAG is added PCP field is populated from this value.
 *     RESERVED_322     Reserved.
 *     ETAG_PCP_DE_SOURCE Specifies the Source of PCP and DE fields when an Ingress Port based ETAG is added to the packet.
 *     IPMCV4_UNICAST_MACDA_ENABLE Enable Routing IPMCV4 packet with unicast MACDA.
 *     IPMCV6_UNICAST_MACDA_ENABLE Enable Routing IPMCV6 packet with unicast MACDA.
 *     VLAN_PROTOCOL_DATA_INDEX Index to the 16 entry block into VLAN_PROTOCOL_DATA table.
 *     SVC_METER_OFFSET_MODE Used in generating index into offset TCAM.
 *     SVC_METER_INDEX  256 Meter Indexes.
 *     RESERVED_344     Reserved bits due to size reduction of SVM_METER_TABLE.
 *     RTAG7_PORT_PROFILE_INDEX Index to RTAG7_PORT_BASED_HASH Table. Per port attribute.
 *     PTP_DOMAIN_ID    Represents a bitmap that indicates which  of the 4 Domain_IDs are supported on this port.
 *     TAF_GATE_ID_PROFILE Gate ID Profile used to lookup GATE_ID.
 *     RESERVED_366     Reserved.
 *     L2_ENTRY_GATE_ID_SELECT GATE_ID selection bit from L2_ENTRY table lookups:                               0 = L2 (SA).GATE_ID                               1 = L2 (DA).GATE_ID                               If VFP.GATE_ID is valid, it overrides the L2.GATE_ID.
 *     TAF_ENABLE       Time Aware Filtering Policing (TAF) Enable.                               0 = TAF is disabled on this port. Just behave like a standard switch.                               1 = TAF is enabled on this port.
 *     RESERVED_4       Reserved.
 *     ECCP_3           Memory_3 ECC + Parity bits.
 *     ECC_3            Memory_3 ECC bits for 1-bit error correction.
 *     PARITY_3         Memory_3 Parity bit for 2-bit error detection.
 */
#define PORTm_MIN 0
#define PORTm_MAX 65
#define PORTm_CMAX(u) 65
#define PORTm_SIZE 48

/*
 * This structure should be used to declare and program PORT.
 */
typedef union PORTm_s {
	uint32 v[12];
	uint32 port[12];
	uint32 _port;
} PORTm_t;

#define PORTm_CLR(r) sal_memset(&((r)._port), 0, sizeof(PORTm_t))
#define PORTm_SET(r,i,d) (r).port[i] = d
#define PORTm_GET(r,i) (r).port[i]

/*
 * These macros can be used to access individual fields.
 */
#define PORTm_DATA_0f_GET(r,a) field_get((r).port,0,87,a)
#define PORTm_DATA_0f_SET(r,a) field_set((r).port,0,87,a)
#define PORTm_FILTER_ENABLEf_GET(r) (((r).port[0]) & 0x1)
#define PORTm_FILTER_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define PORTm_VT_MISS_DROPf_GET(r) ((((r).port[0]) >> 1) & 0x1)
#define PORTm_VT_MISS_DROPf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define PORTm_VT_ENABLEf_GET(r) ((((r).port[0]) >> 2) & 0x1)
#define PORTm_VT_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define PORTm_TRUST_DSCP_V4f_GET(r) ((((r).port[0]) >> 3) & 0x1)
#define PORTm_TRUST_DSCP_V4f_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define PORTm_TRUST_DSCP_V6f_GET(r) ((((r).port[0]) >> 4) & 0x1)
#define PORTm_TRUST_DSCP_V6f_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define PORTm_EN_IFILTERf_GET(r) ((((r).port[0]) >> 5) & 0x1)
#define PORTm_EN_IFILTERf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PORTm_MIRRORf_GET(r) ((((r).port[0]) >> 6) & 0x1)
#define PORTm_MIRRORf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PORTm_MIRROR0f_GET(r) ((((r).port[0]) >> 6) & 0x1)
#define PORTm_MIRROR0f_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PORTm_PORT_PRIf_GET(r) ((((r).port[0]) >> 8) & 0x7)
#define PORTm_PORT_PRIf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x7 << 8)) | ((((uint32)f) & 0x7) << 8))
#define PORTm_IPMC_DO_VLANf_GET(r) ((((r).port[0]) >> 11) & 0x1)
#define PORTm_IPMC_DO_VLANf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define PORTm_V6IPMC_ENABLEf_GET(r) ((((r).port[0]) >> 12) & 0x1)
#define PORTm_V6IPMC_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define PORTm_V4IPMC_ENABLEf_GET(r) ((((r).port[0]) >> 13) & 0x1)
#define PORTm_V4IPMC_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define PORTm_V6IPMC_L2_ENABLEf_GET(r) ((((r).port[0]) >> 14) & 0x1)
#define PORTm_V6IPMC_L2_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define PORTm_V4IPMC_L2_ENABLEf_GET(r) ((((r).port[0]) >> 15) & 0x1)
#define PORTm_V4IPMC_L2_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define PORTm_V6L3_ENABLEf_GET(r) ((((r).port[0]) >> 16) & 0x1)
#define PORTm_V6L3_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define PORTm_V4L3_ENABLEf_GET(r) ((((r).port[0]) >> 17) & 0x1)
#define PORTm_V4L3_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define PORTm_DROP_BPDUf_GET(r) ((((r).port[0]) >> 18) & 0x1)
#define PORTm_DROP_BPDUf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define PORTm_PORT_DIS_TAGf_GET(r) ((((r).port[0]) >> 19) & 0x1)
#define PORTm_PORT_DIS_TAGf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define PORTm_PORT_DIS_UNTAGf_GET(r) ((((r).port[0]) >> 20) & 0x1)
#define PORTm_PORT_DIS_UNTAGf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define PORTm_PASS_CONTROL_FRAMESf_GET(r) ((((r).port[0]) >> 21) & 0x1)
#define PORTm_PASS_CONTROL_FRAMESf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define PORTm_SUBNET_BASED_VID_ENABLEf_GET(r) ((((r).port[0]) >> 22) & 0x1)
#define PORTm_SUBNET_BASED_VID_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define PORTm_MAC_BASED_VID_ENABLEf_GET(r) ((((r).port[0]) >> 23) & 0x1)
#define PORTm_MAC_BASED_VID_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define PORTm_OVIDf_GET(r) field32_get((r).port,24,35)
#define PORTm_OVIDf_SET(r,f) field32_set((r).port,24,35,f)
#define PORTm_PORT_VIDf_GET(r) field32_get((r).port,24,35)
#define PORTm_PORT_VIDf_SET(r,f) field32_set((r).port,24,35,f)
#define PORTm_PORT_TYPEf_GET(r) ((((r).port[1]) >> 4) & 0x3)
#define PORTm_PORT_TYPEf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define PORTm_DUAL_MODID_ENABLEf_GET(r) ((((r).port[1]) >> 6) & 0x1)
#define PORTm_DUAL_MODID_ENABLEf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PORTm_MAP_TAG_PKT_PRIORITYf_GET(r) ((((r).port[1]) >> 7) & 0x1)
#define PORTm_MAP_TAG_PKT_PRIORITYf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define PORTm_MY_MODIDf_GET(r) ((((r).port[1]) >> 8) & 0xff)
#define PORTm_MY_MODIDf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define PORTm_PORT_BRIDGEf_GET(r) ((((r).port[1]) >> 16) & 0x1)
#define PORTm_PORT_BRIDGEf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define PORTm_IGNORE_IPMC_L2_BITMAPf_GET(r) ((((r).port[1]) >> 17) & 0x1)
#define PORTm_IGNORE_IPMC_L2_BITMAPf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define PORTm_IGNORE_IPMC_L3_BITMAPf_GET(r) ((((r).port[1]) >> 18) & 0x1)
#define PORTm_IGNORE_IPMC_L3_BITMAPf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define PORTm_HIGIG_TRUNKf_GET(r) ((((r).port[1]) >> 19) & 0x1)
#define PORTm_HIGIG_TRUNKf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define PORTm_HIGIG_TRUNK_IDf_GET(r) ((((r).port[1]) >> 20) & 0xf)
#define PORTm_HIGIG_TRUNK_IDf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define PORTm_VLAN_PRECEDENCEf_GET(r) ((((r).port[1]) >> 24) & 0x1)
#define PORTm_VLAN_PRECEDENCEf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define PORTm_RESERVED_0f_GET(r) ((((r).port[1]) >> 25) & 0x1)
#define PORTm_RESERVED_0f_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define PORTm_HIGIG2f_GET(r) ((((r).port[1]) >> 26) & 0x1)
#define PORTm_HIGIG2f_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define PORTm_ALLOW_SRC_MODf_GET(r) ((((r).port[1]) >> 27) & 0x1)
#define PORTm_ALLOW_SRC_MODf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define PORTm_TRUST_OUTER_DOT1Pf_GET(r) ((((r).port[1]) >> 28) & 0x1)
#define PORTm_TRUST_OUTER_DOT1Pf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define PORTm_RTAG7_PORT_LBNf_GET(r) field32_get((r).port,61,64)
#define PORTm_RTAG7_PORT_LBNf_SET(r,f) field32_set((r).port,61,64,f)
#define PORTm_REMOVE_HG_HDR_SRC_PORTf_GET(r) ((((r).port[2]) >> 5) & 0x1)
#define PORTm_REMOVE_HG_HDR_SRC_PORTf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PORTm_FP_PORT_SELECT_TYPEf_GET(r) ((((r).port[2]) >> 6) & 0x1)
#define PORTm_FP_PORT_SELECT_TYPEf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PORTm_VFP_ENABLEf_GET(r) ((((r).port[2]) >> 7) & 0x1)
#define PORTm_VFP_ENABLEf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define PORTm_VFP_PORT_GROUP_IDf_GET(r) ((((r).port[2]) >> 8) & 0xff)
#define PORTm_VFP_PORT_GROUP_IDf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define PORTm_URPF_MODEf_GET(r) ((((r).port[2]) >> 16) & 0x3)
#define PORTm_URPF_MODEf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define PORTm_URPF_DEFAULTROUTECHECKf_GET(r) ((((r).port[2]) >> 18) & 0x1)
#define PORTm_URPF_DEFAULTROUTECHECKf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define PORTm_CFI_AS_CNGf_GET(r) ((((r).port[2]) >> 19) & 0xf)
#define PORTm_CFI_AS_CNGf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0xf << 19)) | ((((uint32)f) & 0xf) << 19))
#define PORTm_USE_INNER_PRIf_GET(r) ((((r).port[2]) >> 23) & 0x1)
#define PORTm_USE_INNER_PRIf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define PORTm_ECCP_0f_GET(r) ((((r).port[2]) >> 24) & 0xff)
#define PORTm_ECCP_0f_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define PORTm_ECC_0f_GET(r) ((((r).port[2]) >> 24) & 0x7f)
#define PORTm_ECC_0f_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x7f << 24)) | ((((uint32)f) & 0x7f) << 24))
#define PORTm_PARITY_0f_GET(r) ((((r).port[2]) >> 31) & 0x1)
#define PORTm_PARITY_0f_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define PORTm_DATA_1f_GET(r,a) field_get((r).port,96,183,a)
#define PORTm_DATA_1f_SET(r,a) field_set((r).port,96,183,a)
#define PORTm_OUTER_TPID_ENABLEf_GET(r) (((r).port[3]) & 0xf)
#define PORTm_OUTER_TPID_ENABLEf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define PORTm_OUTER_TPID_VERIFYf_GET(r) ((((r).port[3]) >> 4) & 0x1)
#define PORTm_OUTER_TPID_VERIFYf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define PORTm_USE_INCOMING_DOT1Pf_GET(r) ((((r).port[3]) >> 5) & 0x1)
#define PORTm_USE_INCOMING_DOT1Pf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PORTm_PVLAN_ENABLEf_GET(r) ((((r).port[3]) >> 6) & 0x1)
#define PORTm_PVLAN_ENABLEf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PORTm_TAG_ACTION_PROFILE_PTRf_GET(r) ((((r).port[3]) >> 7) & 0x3f)
#define PORTm_TAG_ACTION_PROFILE_PTRf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x3f << 7)) | ((((uint32)f) & 0x3f) << 7))
#define PORTm_IVIDf_GET(r) ((((r).port[3]) >> 13) & 0xfff)
#define PORTm_IVIDf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0xfff << 13)) | ((((uint32)f) & 0xfff) << 13))
#define PORTm_TRUST_INCOMING_VIDf_GET(r) ((((r).port[3]) >> 25) & 0x1)
#define PORTm_TRUST_INCOMING_VIDf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define PORTm_VT_KEY_TYPEf_GET(r) ((((r).port[3]) >> 26) & 0xf)
#define PORTm_VT_KEY_TYPEf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0xf << 26)) | ((((uint32)f) & 0xf) << 26))
#define PORTm_VT_KEY_TYPE_USE_GLPf_GET(r) ((((r).port[3]) >> 30) & 0x1)
#define PORTm_VT_KEY_TYPE_USE_GLPf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define PORTm_VT_KEY_TYPE_2f_GET(r) field32_get((r).port,127,130)
#define PORTm_VT_KEY_TYPE_2f_SET(r,f) field32_set((r).port,127,130,f)
#define PORTm_VT_KEY_TYPE_2_USE_GLPf_GET(r) ((((r).port[4]) >> 3) & 0x1)
#define PORTm_VT_KEY_TYPE_2_USE_GLPf_SET(r,f) (r).port[4]=(((r).port[4] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define PORTm_CML_FLAGS_NEWf_GET(r) ((((r).port[4]) >> 4) & 0xf)
#define PORTm_CML_FLAGS_NEWf_SET(r,f) (r).port[4]=(((r).port[4] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define PORTm_CML_FLAGS_MOVEf_GET(r) ((((r).port[4]) >> 8) & 0xf)
#define PORTm_CML_FLAGS_MOVEf_SET(r,f) (r).port[4]=(((r).port[4] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define PORTm_PRI_MAPPINGf_GET(r) field32_get((r).port,140,163)
#define PORTm_PRI_MAPPINGf_SET(r,f) field32_set((r).port,140,163,f)
#define PORTm_CFI_0_MAPPINGf_GET(r) ((((r).port[5]) >> 4) & 0x1)
#define PORTm_CFI_0_MAPPINGf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define PORTm_CFI_1_MAPPINGf_GET(r) ((((r).port[5]) >> 5) & 0x1)
#define PORTm_CFI_1_MAPPINGf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PORTm_PORT_OPERATIONf_GET(r) ((((r).port[5]) >> 7) & 0x7)
#define PORTm_PORT_OPERATIONf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x7 << 7)) | ((((uint32)f) & 0x7) << 7))
#define PORTm_MAC_IP_BIND_LOOKUP_MISS_DROPf_GET(r) ((((r).port[5]) >> 10) & 0x1)
#define PORTm_MAC_IP_BIND_LOOKUP_MISS_DROPf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define PORTm_REMOTE_CPU_ENf_GET(r) ((((r).port[5]) >> 11) & 0x1)
#define PORTm_REMOTE_CPU_ENf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define PORTm_DISABLE_STATIC_MOVE_DROPf_GET(r) ((((r).port[5]) >> 12) & 0x1)
#define PORTm_DISABLE_STATIC_MOVE_DROPf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define PORTm_USE_IVID_AS_OVIDf_GET(r) ((((r).port[5]) >> 13) & 0x1)
#define PORTm_USE_IVID_AS_OVIDf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define PORTm_MH_INGRESS_TAGGED_SELf_GET(r) ((((r).port[5]) >> 20) & 0x1)
#define PORTm_MH_INGRESS_TAGGED_SELf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define PORTm_CLASS_BASED_SM_ENABLEf_GET(r) ((((r).port[5]) >> 21) & 0x1)
#define PORTm_CLASS_BASED_SM_ENABLEf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define PORTm_RESERVED_1f_GET(r) ((((r).port[5]) >> 22) & 0x3)
#define PORTm_RESERVED_1f_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define PORTm_ECCP_1f_GET(r) ((((r).port[5]) >> 24) & 0xff)
#define PORTm_ECCP_1f_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define PORTm_ECC_1f_GET(r) ((((r).port[5]) >> 24) & 0x7f)
#define PORTm_ECC_1f_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x7f << 24)) | ((((uint32)f) & 0x7f) << 24))
#define PORTm_PARITY_1f_GET(r) ((((r).port[5]) >> 31) & 0x1)
#define PORTm_PARITY_1f_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define PORTm_DATA_2f_GET(r,a) field_get((r).port,192,279,a)
#define PORTm_DATA_2f_SET(r,a) field_set((r).port,192,279,a)
#define PORTm_USE_CUSTOM_HEADER_FOR_PRIf_GET(r) (((r).port[6]) & 0x3)
#define PORTm_USE_CUSTOM_HEADER_FOR_PRIf_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define PORTm_TRUST_DOT1P_PTRf_GET(r) ((((r).port[6]) >> 2) & 0x3f)
#define PORTm_TRUST_DOT1P_PTRf_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x3f << 2)) | ((((uint32)f) & 0x3f) << 2))
#define PORTm_IEEE_802_1AS_ENABLEf_GET(r) ((((r).port[6]) >> 8) & 0x1)
#define PORTm_IEEE_802_1AS_ENABLEf_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define PORTm_USE_PORT_TABLE_GROUP_IDf_GET(r) ((((r).port[6]) >> 9) & 0x1)
#define PORTm_USE_PORT_TABLE_GROUP_IDf_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define PORTm_OAM_ENABLEf_GET(r) ((((r).port[6]) >> 17) & 0x1)
#define PORTm_OAM_ENABLEf_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define PORTm_RESERVED_210f_GET(r) ((((r).port[6]) >> 18) & 0x7)
#define PORTm_RESERVED_210f_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define PORTm_PROTOCOL_PKT_INDEXf_GET(r) ((((r).port[6]) >> 21) & 0x7f)
#define PORTm_PROTOCOL_PKT_INDEXf_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x7f << 21)) | ((((uint32)f) & 0x7f) << 21))
#define PORTm_MDL_BITMAPf_GET(r) field32_get((r).port,220,227)
#define PORTm_MDL_BITMAPf_SET(r,f) field32_set((r).port,220,227,f)
#define PORTm_CTRL_PROFILE_INDEX_1588f_GET(r) ((((r).port[7]) >> 4) & 0x3f)
#define PORTm_CTRL_PROFILE_INDEX_1588f_SET(r,f) (r).port[7]=(((r).port[7] & ~((uint32)0x3f << 4)) | ((((uint32)f) & 0x3f) << 4))
#define PORTm_INNER_TPID_ENABLEf_GET(r) ((((r).port[7]) >> 10) & 0x1)
#define PORTm_INNER_TPID_ENABLEf_SET(r,f) (r).port[7]=(((r).port[7] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define PORTm_NIV_UPLINK_PORTf_GET(r) ((((r).port[7]) >> 11) & 0x1)
#define PORTm_NIV_UPLINK_PORTf_SET(r,f) (r).port[7]=(((r).port[7] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define PORTm_NIV_VIF_IDf_GET(r) ((((r).port[7]) >> 12) & 0xfff)
#define PORTm_NIV_VIF_IDf_SET(r,f) (r).port[7]=(((r).port[7] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))
#define PORTm_NIV_NAMESPACEf_GET(r) field32_get((r).port,248,259)
#define PORTm_NIV_NAMESPACEf_SET(r,f) field32_set((r).port,248,259,f)
#define PORTm_PROHIBITED_DOT1Pf_GET(r) ((((r).port[8]) >> 4) & 0xff)
#define PORTm_PROHIBITED_DOT1Pf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0xff << 4)) | ((((uint32)f) & 0xff) << 4))
#define PORTm_NIV_RPF_CHECK_ENABLEf_GET(r) ((((r).port[8]) >> 12) & 0x1)
#define PORTm_NIV_RPF_CHECK_ENABLEf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define PORTm_NIV_VIF_LOOKUP_ENABLEf_GET(r) ((((r).port[8]) >> 13) & 0x1)
#define PORTm_NIV_VIF_LOOKUP_ENABLEf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define PORTm_USE_MIML_PCP_FOR_PRIf_GET(r) ((((r).port[8]) >> 14) & 0x1)
#define PORTm_USE_MIML_PCP_FOR_PRIf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define PORTm_MIML_ENABLEf_GET(r) ((((r).port[8]) >> 15) & 0x1)
#define PORTm_MIML_ENABLEf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define PORTm_RESERVED_272f_GET(r) ((((r).port[8]) >> 16) & 0x1)
#define PORTm_RESERVED_272f_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define PORTm_CUSTOM_HEADER_ENABLEf_GET(r) ((((r).port[8]) >> 17) & 0x1)
#define PORTm_CUSTOM_HEADER_ENABLEf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define PORTm_MIML_DOT1P_MAPPING_PTRf_GET(r) ((((r).port[8]) >> 18) & 0x3f)
#define PORTm_MIML_DOT1P_MAPPING_PTRf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))
#define PORTm_ECCP_2f_GET(r) ((((r).port[8]) >> 24) & 0xff)
#define PORTm_ECCP_2f_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define PORTm_ECC_2f_GET(r) ((((r).port[8]) >> 24) & 0x7f)
#define PORTm_ECC_2f_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x7f << 24)) | ((((uint32)f) & 0x7f) << 24))
#define PORTm_PARITY_2f_GET(r) ((((r).port[8]) >> 31) & 0x1)
#define PORTm_PARITY_2f_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define PORTm_DATA_3f_GET(r,a) field_get((r).port,288,375,a)
#define PORTm_DATA_3f_SET(r,a) field_set((r).port,288,375,a)
#define PORTm_TX_DEST_PORTf_GET(r) (((r).port[9]) & 0xffff)
#define PORTm_TX_DEST_PORTf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define PORTm_TX_DEST_PORT_ENABLEf_GET(r) ((((r).port[9]) >> 16) & 0x1)
#define PORTm_TX_DEST_PORT_ENABLEf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define PORTm_VNTAG_ACTIONS_IF_NOT_PRESENTf_GET(r) ((((r).port[9]) >> 17) & 0x3)
#define PORTm_VNTAG_ACTIONS_IF_NOT_PRESENTf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x3 << 17)) | ((((uint32)f) & 0x3) << 17))
#define PORTm_VNTAG_ACTIONS_IF_PRESENTf_GET(r) ((((r).port[9]) >> 19) & 0x3)
#define PORTm_VNTAG_ACTIONS_IF_PRESENTf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define PORTm_DISCARD_IF_VNTAG_PRESENTf_GET(r) ((((r).port[9]) >> 21) & 0x1)
#define PORTm_DISCARD_IF_VNTAG_PRESENTf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define PORTm_DISCARD_IF_VNTAG_NOT_PRESENTf_GET(r) ((((r).port[9]) >> 22) & 0x1)
#define PORTm_DISCARD_IF_VNTAG_NOT_PRESENTf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define PORTm_ETAG_PCP_DE_MAPPING_PTRf_GET(r) ((((r).port[9]) >> 23) & 0x3f)
#define PORTm_ETAG_PCP_DE_MAPPING_PTRf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x3f << 23)) | ((((uint32)f) & 0x3f) << 23))
#define PORTm_PHB_FROM_ETAGf_GET(r) ((((r).port[9]) >> 29) & 0x1)
#define PORTm_PHB_FROM_ETAGf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define PORTm_ETAG_DOT1P_MAPPING_PTRf_GET(r) field32_get((r).port,318,321)
#define PORTm_ETAG_DOT1P_MAPPING_PTRf_SET(r,f) field32_set((r).port,318,321,f)
#define PORTm_ETAG_DEf_GET(r) ((((r).port[9]) >> 30) & 0x1)
#define PORTm_ETAG_DEf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define PORTm_ETAG_PCPf_GET(r) field32_get((r).port,319,321)
#define PORTm_ETAG_PCPf_SET(r,f) field32_set((r).port,319,321,f)
#define PORTm_RESERVED_322f_GET(r) ((((r).port[10]) >> 2) & 0x1)
#define PORTm_RESERVED_322f_SET(r,f) (r).port[10]=(((r).port[10] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define PORTm_ETAG_PCP_DE_SOURCEf_GET(r) ((((r).port[10]) >> 3) & 0x3)
#define PORTm_ETAG_PCP_DE_SOURCEf_SET(r,f) (r).port[10]=(((r).port[10] & ~((uint32)0x3 << 3)) | ((((uint32)f) & 0x3) << 3))
#define PORTm_IPMCV4_UNICAST_MACDA_ENABLEf_GET(r) ((((r).port[10]) >> 5) & 0x1)
#define PORTm_IPMCV4_UNICAST_MACDA_ENABLEf_SET(r,f) (r).port[10]=(((r).port[10] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PORTm_IPMCV6_UNICAST_MACDA_ENABLEf_GET(r) ((((r).port[10]) >> 6) & 0x1)
#define PORTm_IPMCV6_UNICAST_MACDA_ENABLEf_SET(r,f) (r).port[10]=(((r).port[10] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PORTm_VLAN_PROTOCOL_DATA_INDEXf_GET(r) ((((r).port[10]) >> 7) & 0x7f)
#define PORTm_VLAN_PROTOCOL_DATA_INDEXf_SET(r,f) (r).port[10]=(((r).port[10] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define PORTm_SVC_METER_OFFSET_MODEf_GET(r) ((((r).port[10]) >> 14) & 0x3)
#define PORTm_SVC_METER_OFFSET_MODEf_SET(r,f) (r).port[10]=(((r).port[10] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define PORTm_SVC_METER_INDEXf_GET(r) ((((r).port[10]) >> 16) & 0xff)
#define PORTm_SVC_METER_INDEXf_SET(r,f) (r).port[10]=(((r).port[10] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define PORTm_RESERVED_344f_GET(r) ((((r).port[10]) >> 24) & 0xf)
#define PORTm_RESERVED_344f_SET(r,f) (r).port[10]=(((r).port[10] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define PORTm_RTAG7_PORT_PROFILE_INDEXf_GET(r) field32_get((r).port,348,355)
#define PORTm_RTAG7_PORT_PROFILE_INDEXf_SET(r,f) field32_set((r).port,348,355,f)
#define PORTm_PTP_DOMAIN_IDf_GET(r) ((((r).port[11]) >> 4) & 0xf)
#define PORTm_PTP_DOMAIN_IDf_SET(r,f) (r).port[11]=(((r).port[11] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define PORTm_TAF_GATE_ID_PROFILEf_GET(r) ((((r).port[11]) >> 8) & 0x3f)
#define PORTm_TAF_GATE_ID_PROFILEf_SET(r,f) (r).port[11]=(((r).port[11] & ~((uint32)0x3f << 8)) | ((((uint32)f) & 0x3f) << 8))
#define PORTm_RESERVED_366f_GET(r) ((((r).port[11]) >> 14) & 0x1)
#define PORTm_RESERVED_366f_SET(r,f) (r).port[11]=(((r).port[11] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define PORTm_L2_ENTRY_GATE_ID_SELECTf_GET(r) ((((r).port[11]) >> 15) & 0x1)
#define PORTm_L2_ENTRY_GATE_ID_SELECTf_SET(r,f) (r).port[11]=(((r).port[11] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define PORTm_TAF_ENABLEf_GET(r) ((((r).port[11]) >> 16) & 0x1)
#define PORTm_TAF_ENABLEf_SET(r,f) (r).port[11]=(((r).port[11] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define PORTm_RESERVED_4f_GET(r) ((((r).port[11]) >> 17) & 0x7f)
#define PORTm_RESERVED_4f_SET(r,f) (r).port[11]=(((r).port[11] & ~((uint32)0x7f << 17)) | ((((uint32)f) & 0x7f) << 17))
#define PORTm_ECCP_3f_GET(r) ((((r).port[11]) >> 24) & 0xff)
#define PORTm_ECCP_3f_SET(r,f) (r).port[11]=(((r).port[11] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define PORTm_ECC_3f_GET(r) ((((r).port[11]) >> 24) & 0x7f)
#define PORTm_ECC_3f_SET(r,f) (r).port[11]=(((r).port[11] & ~((uint32)0x7f << 24)) | ((((uint32)f) & 0x7f) << 24))
#define PORTm_PARITY_3f_GET(r) ((((r).port[11]) >> 31) & 0x1)
#define PORTm_PARITY_3f_SET(r,f) (r).port[11]=(((r).port[11] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access PORT.
 */
#define WRITE_PORTm(u,i,r) bcm5607x_mem_set(u, M_PORT(i), &(r._port), 12)
#define READ_PORTm(u,i,r) bcm5607x_mem_get(u, M_PORT(i), &(r._port), 12)

/*******************************************************************************
 * End of 'PORTm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  PROTOCOL_PKT_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Protocol Packet Control Register
 * SIZE:     32
 * FIELDS:
 *     DHCP_PKT_TO_CPU  Send DHCP Packets to the CPU
 *     DHCP_PKT_DROP    Drop DHCP Packets
 *     ND_PKT_TO_CPU    Send ND Packets to the CPU
 *     ND_PKT_DROP      Drop ND Packets
 *     ARP_REQUEST_TO_CPU Send ARP Request Packets to the CPU
 *     ARP_REQUEST_DROP Drop ARP Request Packets
 *     ARP_REPLY_TO_CPU Send ARP Reply Packets to the CPU
 *     ARP_REPLY_DROP   Drop ARP Reply Packets
 *     RESERVED_1       RESERVED_1
 *     RESERVED_2       RESERVED_2
 *     RESERVED_3       RESERVED_3
 *     RESERVED_4       RESERVED_4
 */
#define PROTOCOL_PKT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PROTOCOL_PKT_CONTROL.
 */
typedef union PROTOCOL_PKT_CONTROLr_s {
	uint32 v[1];
	uint32 protocol_pkt_control[1];
	uint32 _protocol_pkt_control;
} PROTOCOL_PKT_CONTROLr_t;

#define PROTOCOL_PKT_CONTROLr_CLR(r) (r).protocol_pkt_control[0] = 0
#define PROTOCOL_PKT_CONTROLr_SET(r,d) (r).protocol_pkt_control[0] = d
#define PROTOCOL_PKT_CONTROLr_GET(r) (r).protocol_pkt_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET(r) (((r).protocol_pkt_control[0]) & 0x1)
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 1) & 0x1)
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 2) & 0x1)
#define PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 3) & 0x1)
#define PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 4) & 0x1)
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 5) & 0x1)
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 6) & 0x1)
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 7) & 0x1)
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define PROTOCOL_PKT_CONTROLr_RESERVED_1f_GET(r) ((((r).protocol_pkt_control[0]) >> 8) & 0x1)
#define PROTOCOL_PKT_CONTROLr_RESERVED_1f_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define PROTOCOL_PKT_CONTROLr_RESERVED_2f_GET(r) ((((r).protocol_pkt_control[0]) >> 9) & 0x3)
#define PROTOCOL_PKT_CONTROLr_RESERVED_2f_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define PROTOCOL_PKT_CONTROLr_RESERVED_3f_GET(r) ((((r).protocol_pkt_control[0]) >> 11) & 0x1)
#define PROTOCOL_PKT_CONTROLr_RESERVED_3f_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define PROTOCOL_PKT_CONTROLr_RESERVED_4f_GET(r) ((((r).protocol_pkt_control[0]) >> 12) & 0x3)
#define PROTOCOL_PKT_CONTROLr_RESERVED_4f_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))

/*
 * These macros can be used to access PROTOCOL_PKT_CONTROL.
 */
#define WRITE_PROTOCOL_PKT_CONTROLr(u,p,r) bcm5607x_reg_set(u,R_PROTOCOL_PKT_CONTROL(p),(r._protocol_pkt_control))
#define READ_PROTOCOL_PKT_CONTROLr(u,p,r) bcm5607x_reg_get(u,R_PROTOCOL_PKT_CONTROL(p),&(r._protocol_pkt_control))

/*******************************************************************************
 * End of 'PROTOCOL_PKT_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  QSPI_bspi_registers_REVISION_ID
 * BLOCKS:   IPROC
 * DESC:     Revision ID
 * SIZE:     32
 * FIELDS:
 *     MINOR            Minor revision of BSPI
 *     MAJOR            Major revision of BSPI
 *     RESERVED         Reserved bits write has no effect and read always returns 0
 */
#define QSPI_BSPI_REGISTERS_REVISION_IDr_SIZE 4

/*
 * This structure should be used to declare and program QSPI_bspi_registers_REVISION_ID.
 */
typedef union QSPI_BSPI_REGISTERS_REVISION_IDr_s {
	uint32 v[1];
	uint32 qspi_bspi_registers_revision_id[1];
	uint32 _qspi_bspi_registers_revision_id;
} QSPI_BSPI_REGISTERS_REVISION_IDr_t;

#define QSPI_BSPI_REGISTERS_REVISION_IDr_CLR(r) (r).qspi_bspi_registers_revision_id[0] = 0
#define QSPI_BSPI_REGISTERS_REVISION_IDr_SET(r,d) (r).qspi_bspi_registers_revision_id[0] = d
#define QSPI_BSPI_REGISTERS_REVISION_IDr_GET(r) (r).qspi_bspi_registers_revision_id[0]

/*
 * These macros can be used to access individual fields.
 */
#define QSPI_BSPI_REGISTERS_REVISION_IDr_MINORf_GET(r) (((r).qspi_bspi_registers_revision_id[0]) & 0xff)
#define QSPI_BSPI_REGISTERS_REVISION_IDr_MINORf_SET(r,f) (r).qspi_bspi_registers_revision_id[0]=(((r).qspi_bspi_registers_revision_id[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define QSPI_BSPI_REGISTERS_REVISION_IDr_MAJORf_GET(r) ((((r).qspi_bspi_registers_revision_id[0]) >> 8) & 0xff)
#define QSPI_BSPI_REGISTERS_REVISION_IDr_MAJORf_SET(r,f) (r).qspi_bspi_registers_revision_id[0]=(((r).qspi_bspi_registers_revision_id[0] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define QSPI_BSPI_REGISTERS_REVISION_IDr_RESERVEDf_GET(r) ((((r).qspi_bspi_registers_revision_id[0]) >> 16) & 0xffff)
#define QSPI_BSPI_REGISTERS_REVISION_IDr_RESERVEDf_SET(r,f) (r).qspi_bspi_registers_revision_id[0]=(((r).qspi_bspi_registers_revision_id[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access QSPI_bspi_registers_REVISION_ID.
 */
#define READ_QSPI_BSPI_REGISTERS_REVISION_IDr(u,r) bcm5607x_read32(u, R_QSPI_BSPI_REGISTERS_REVISION_ID, &(r._qspi_bspi_registers_revision_id))
#define WRITE_QSPI_BSPI_REGISTERS_REVISION_IDr(u,r) bcm5607x_write32(u, R_QSPI_BSPI_REGISTERS_REVISION_ID, (r._qspi_bspi_registers_revision_id))

/*******************************************************************************
 * End of 'QSPI_BSPI_REGISTERS_REVISION_IDr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  RESCAL_STATUS_0
 * BLOCKS:   TOP
 * DESC:     Resistor Calibration #0 Status 0 register
 * SIZE:     32
 * FIELDS:
 *     RESCAL_DONE      RESCAL_DONE asserted after rescal is done
 *     RESCAL_VALID     asserted when rescal is done and a valid pon value is found
 *     RESCALCOMP       analog rescalcomp value
 *     RSVD             Reserved
 *     RESCAL_STATE     rescal digital state3'd0: INIT3'd1: WAIT_PWRUP3'd2: COMP_ACC3'd3: WAIT_PON_INC
 *     RESCAL_PREV_COMP_CNT accumulated comparison for previous pon value
 *     RESCAL_CURR_COMP_CNT accumulated comparison for current pon value
 *     RESCAL_PON       pon value; stable after rescal is done or o_done is assertedOutput On-chip Sheet Resistance0000 -24% ~ -21%0001 -21% ~ -18%0010 -18% ~ -15%0011 -15% ~ -12%0100 -12% ~ -9%0101 -9% ~ -6%0110 -6% ~ -3%0111 -3% ~ +0%1000 +0% ~ +3%1001 +3% ~ +6%1010 +6% ~ +9%1011 +9% ~ +12%1100 +12% ~ +15%1101 +15% ~ +18%1110 +18% ~ +21%1111 +21% ~ +24%
 */
#define RESCAL_STATUS_0r_SIZE 4

/*
 * This structure should be used to declare and program RESCAL_STATUS_0.
 */
typedef union RESCAL_STATUS_0r_s {
	uint32 v[1];
	uint32 rescal_status_0[1];
	uint32 _rescal_status_0;
} RESCAL_STATUS_0r_t;

#define RESCAL_STATUS_0r_CLR(r) (r).rescal_status_0[0] = 0
#define RESCAL_STATUS_0r_SET(r,d) (r).rescal_status_0[0] = d
#define RESCAL_STATUS_0r_GET(r) (r).rescal_status_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define RESCAL_STATUS_0r_RESCAL_DONEf_GET(r) (((r).rescal_status_0[0]) & 0x1)
#define RESCAL_STATUS_0r_RESCAL_DONEf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define RESCAL_STATUS_0r_RESCAL_VALIDf_GET(r) ((((r).rescal_status_0[0]) >> 1) & 0x1)
#define RESCAL_STATUS_0r_RESCAL_VALIDf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define RESCAL_STATUS_0r_RESCALCOMPf_GET(r) ((((r).rescal_status_0[0]) >> 2) & 0x1)
#define RESCAL_STATUS_0r_RESCALCOMPf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define RESCAL_STATUS_0r_RSVDf_GET(r) ((((r).rescal_status_0[0]) >> 3) & 0xfff)
#define RESCAL_STATUS_0r_RSVDf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define RESCAL_STATUS_0r_RESCAL_STATEf_GET(r) ((((r).rescal_status_0[0]) >> 15) & 0x7)
#define RESCAL_STATUS_0r_RESCAL_STATEf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define RESCAL_STATUS_0r_RESCAL_PREV_COMP_CNTf_GET(r) ((((r).rescal_status_0[0]) >> 18) & 0xf)
#define RESCAL_STATUS_0r_RESCAL_PREV_COMP_CNTf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0xf << 18)) | ((((uint32)f) & 0xf) << 18))
#define RESCAL_STATUS_0r_RESCAL_CURR_COMP_CNTf_GET(r) ((((r).rescal_status_0[0]) >> 22) & 0x3f)
#define RESCAL_STATUS_0r_RESCAL_CURR_COMP_CNTf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0x3f << 22)) | ((((uint32)f) & 0x3f) << 22))
#define RESCAL_STATUS_0r_RESCAL_PONf_GET(r) ((((r).rescal_status_0[0]) >> 28) & 0xf)
#define RESCAL_STATUS_0r_RESCAL_PONf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access RESCAL_STATUS_0.
 */
#define WRITE_RESCAL_STATUS_0r(u,r) bcm5607x_reg_set(u,R_RESCAL_STATUS_0,(r._rescal_status_0))
#define READ_RESCAL_STATUS_0r(u,r) bcm5607x_reg_get(u,R_RESCAL_STATUS_0,&(r._rescal_status_0))

/*******************************************************************************
 * End of 'RESCAL_STATUS_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * SWFORMAT:  RX_DCB
 * BLOCKS:  
 * DESC:     Packet DMA descriptor.
 * SIZE:     128
 * FIELDS:
 *     BYTES_TRANSFERRED Number of bytes transferred.
 *     END_BIT          Descriptor is for last (or only) packet fragment.
 *     START_BIT        Descriptor is for first (or only) packet fragment.
 *     ERROR            Internal RX error encountered.
 *     DONE             Descriptor done.
 *     BYTE_COUNT       Maximum number of bytes for this transfer.
 *     CHAIN            Indicates that next sequential descriptor is valid.
 *     SG               Scatter/Gather - packet may continue in the next DMA descriptor.
 *     RELOAD           Load next descriptor from address in ADDR field.
 *     DESC_DONE_INTR   Assert descriptor done interrupt.
 *     DESC_CTRL_INTR   Assert descriptor controlled interrupt.
 *     DESC_REMAIN      Descriptors remaining.
 *     DESC_STAT_WR_DISABLE Disable descriptor status write if it is not needed.
 *     ADDR_HI          Physical memory address for the transfer bits [63:32].
 *     ADDR_LO          Physical memory address for the transfer bits [31:0].
 */
#define RX_DCB_SIZE 16

/*
 * This structure should be used to declare and program RX_DCB.
 */
typedef union RX_DCB_s {
	uint32 v[4];
	uint32 rx_dcb[4];
	uint32 _rx_dcb;
} RX_DCB_t;

#define RX_DCB_CLR(r) sal_memset(&((r)._rx_dcb), 0, sizeof(RX_DCB_t))
#define RX_DCB_SET(r,i,d) (r).rx_dcb[i] = d
#define RX_DCB_GET(r,i) (r).rx_dcb[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).rx_dcb[3]) & 0xffff)
#define RX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).rx_dcb[3]=(((r).rx_dcb[3] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define RX_DCB_END_BITf_GET(r) ((((r).rx_dcb[3]) >> 16) & 0x1)
#define RX_DCB_END_BITf_SET(r,f) (r).rx_dcb[3]=(((r).rx_dcb[3] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define RX_DCB_START_BITf_GET(r) ((((r).rx_dcb[3]) >> 17) & 0x1)
#define RX_DCB_START_BITf_SET(r,f) (r).rx_dcb[3]=(((r).rx_dcb[3] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define RX_DCB_ERRORf_GET(r) ((((r).rx_dcb[3]) >> 18) & 0x1)
#define RX_DCB_ERRORf_SET(r,f) (r).rx_dcb[3]=(((r).rx_dcb[3] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define RX_DCB_DONEf_GET(r) ((((r).rx_dcb[3]) >> 31) & 0x1)
#define RX_DCB_DONEf_SET(r,f) (r).rx_dcb[3]=(((r).rx_dcb[3] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define RX_DCB_BYTE_COUNTf_GET(r) (((r).rx_dcb[2]) & 0xffff)
#define RX_DCB_BYTE_COUNTf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define RX_DCB_CHAINf_GET(r) ((((r).rx_dcb[2]) >> 16) & 0x1)
#define RX_DCB_CHAINf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define RX_DCB_SGf_GET(r) ((((r).rx_dcb[2]) >> 17) & 0x1)
#define RX_DCB_SGf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define RX_DCB_RELOADf_GET(r) ((((r).rx_dcb[2]) >> 18) & 0x1)
#define RX_DCB_RELOADf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define RX_DCB_DESC_DONE_INTRf_GET(r) ((((r).rx_dcb[2]) >> 23) & 0x1)
#define RX_DCB_DESC_DONE_INTRf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define RX_DCB_DESC_CTRL_INTRf_GET(r) ((((r).rx_dcb[2]) >> 24) & 0x1)
#define RX_DCB_DESC_CTRL_INTRf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define RX_DCB_DESC_REMAINf_GET(r) ((((r).rx_dcb[2]) >> 25) & 0xf)
#define RX_DCB_DESC_REMAINf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32)0xf << 25)) | ((((uint32)f) & 0xf) << 25))
#define RX_DCB_DESC_STAT_WR_DISABLEf_GET(r) ((((r).rx_dcb[2]) >> 29) & 0x1)
#define RX_DCB_DESC_STAT_WR_DISABLEf_SET(r,f) (r).rx_dcb[2]=(((r).rx_dcb[2] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define RX_DCB_ADDR_HIf_GET(r) ((r).rx_dcb[1])
#define RX_DCB_ADDR_HIf_SET(r,f) (r).rx_dcb[1]=((uint32)f)
#define RX_DCB_ADDR_LOf_GET(r) ((r).rx_dcb[0])
#define RX_DCB_ADDR_LOf_SET(r,f) (r).rx_dcb[0]=((uint32)f)

/*******************************************************************************
 * End of 'RX_DCB'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * SWFORMAT:  SCHAN
 * BLOCKS:  
 * DESC:     Phase 0 of S-bus message
 * SIZE:     32
 * FIELDS:
 *     NACK             NACK (Negative ACK) bit. Set when a legal S-bus commandcannot be serviced due to hardware resource limitations.Valid only for S-bus ACKs, not for S-bus commands.
 *     BANK             Disable for half-buckets on table ops
 *     DMA              0=PIO by CPU, 1=DMA by CMIC. This bit is set by CMIC DMA engine for DMA-generated SBus accesses. Note: CPU PIO commands must leave this bit zero when issusing SBUS commands.
 *     ECODE            Error code (cause for ERR bit getting set).Valid only for S-bus ACKs, not for S-bus commands.
 *     ERR              Error bit. Set due to an illegal/invalid access.Valid only for S-bus ACKs, not for S-bus commands.
 *     DATA_LEN         Data length, in bytes. Valid only for S-bus commands, not for S-bus ACKs.
 *     ACC              Command access type.
 *     DEST_BLOCK       Destination Port
 *     OP_CODE          Opcode
 */
#define SCHAN_SIZE 4

/*
 * This structure should be used to declare and program SCHAN.
 */
typedef union SCHAN_s {
	uint32 v[1];
	uint32 schan[1];
	uint32 _schan;
} SCHAN_t;

#define SCHAN_CLR(r) (r).schan[0] = 0
#define SCHAN_SET(r,d) (r).schan[0] = d
#define SCHAN_GET(r) (r).schan[0]

/*
 * These macros can be used to access individual fields.
 */
#define SCHAN_NACKf_GET(r) (((r).schan[0]) & 0x1)
#define SCHAN_NACKf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define SCHAN_BANKf_GET(r) ((((r).schan[0]) >> 1) & 0x3)
#define SCHAN_BANKf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x3 << 1)) | ((((uint32)f) & 0x3) << 1))
#define SCHAN_DMAf_GET(r) ((((r).schan[0]) >> 3) & 0x1)
#define SCHAN_DMAf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define SCHAN_ECODEf_GET(r) ((((r).schan[0]) >> 4) & 0x3)
#define SCHAN_ECODEf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define SCHAN_ERRf_GET(r) ((((r).schan[0]) >> 6) & 0x1)
#define SCHAN_ERRf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define SCHAN_DATA_LENf_GET(r) ((((r).schan[0]) >> 7) & 0x7f)
#define SCHAN_DATA_LENf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define SCHAN_ACCf_GET(r) ((((r).schan[0]) >> 14) & 0x1f)
#define SCHAN_ACCf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x1f << 14)) | ((((uint32)f) & 0x1f) << 14))
#define SCHAN_DEST_BLOCKf_GET(r) ((((r).schan[0]) >> 19) & 0x7f)
#define SCHAN_DEST_BLOCKf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x7f << 19)) | ((((uint32)f) & 0x7f) << 19))
#define SCHAN_OP_CODEf_GET(r) ((((r).schan[0]) >> 26) & 0x3f)
#define SCHAN_OP_CODEf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*******************************************************************************
 * End of 'SCHAN'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  SHARED_POOL_CTRL
 * BLOCKS:   MMU
 * DESC:     Priority group mapping register
 * SIZE:     32
 * FIELDS:
 *     SHARED_POOL_XOFF_EN Each bit is for a Priority group.Bit 0: PG0.....	Bit 7: PG7Enable accounting of shared pool cell availability to trigger PFC for this PG. 0: usage of global buffers by the PG is not tracked by the MMU1: usage of global buffers by the PG is tracked by the MMU and if it exceeds the global cell limit GBLLIMITSETLIMIT, all priorities mapped to the PG are backpressured
 *     SHARED_POOL_DISCARD_EN Each bit is for a Priority group.Bit 0: Priority Group 0....Bit 7: Priority Group 7If the PPFC_SHARED_POOL_DISCARD_EN bit is set for a PG, and the TOTALDYNCELLSETLIMIT is exceeded, entire packets in this Priority Group will be tail dropped or discarded even if part of the packet has already been stored. TOTALDYNCELLSETLIMIT is an optional limit on the global cell count.  Otherwise, packets in this Priority Group will be stored even though the shared pool cell limit is exceeded.
 *     DYNAMIC_COS_DROP_EN Each bit is for a COS.Bit 0: cos 0....Bit 7: cos 7In Dynamic memory mode, if global shared pool counter >=  TOTALDYNCELLSETLIMIT and HOL counter of cos-n >= cos-n's LWMCOSCELLSETLIMIT, then this packet could be discarded by MMU. This register will control this dynamic mode cos-n drop behavior."1": drop the packet if the above condition is meet"0": don't drop the packet if the above condition is meetDefault value is 0xFF for HC2 backward compatible.
 */
#define SHARED_POOL_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program SHARED_POOL_CTRL.
 */
typedef union SHARED_POOL_CTRLr_s {
	uint32 v[1];
	uint32 shared_pool_ctrl[1];
	uint32 _shared_pool_ctrl;
} SHARED_POOL_CTRLr_t;

#define SHARED_POOL_CTRLr_CLR(r) (r).shared_pool_ctrl[0] = 0
#define SHARED_POOL_CTRLr_SET(r,d) (r).shared_pool_ctrl[0] = d
#define SHARED_POOL_CTRLr_GET(r) (r).shared_pool_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define SHARED_POOL_CTRLr_SHARED_POOL_XOFF_ENf_GET(r) (((r).shared_pool_ctrl[0]) & 0xff)
#define SHARED_POOL_CTRLr_SHARED_POOL_XOFF_ENf_SET(r,f) (r).shared_pool_ctrl[0]=(((r).shared_pool_ctrl[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define SHARED_POOL_CTRLr_SHARED_POOL_DISCARD_ENf_GET(r) ((((r).shared_pool_ctrl[0]) >> 8) & 0xff)
#define SHARED_POOL_CTRLr_SHARED_POOL_DISCARD_ENf_SET(r,f) (r).shared_pool_ctrl[0]=(((r).shared_pool_ctrl[0] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define SHARED_POOL_CTRLr_DYNAMIC_COS_DROP_ENf_GET(r) ((((r).shared_pool_ctrl[0]) >> 16) & 0xff)
#define SHARED_POOL_CTRLr_DYNAMIC_COS_DROP_ENf_SET(r,f) (r).shared_pool_ctrl[0]=(((r).shared_pool_ctrl[0] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))

/*
 * These macros can be used to access SHARED_POOL_CTRL.
 */
#define WRITE_SHARED_POOL_CTRLr(u,p,r) bcm5607x_reg_set(u,R_SHARED_POOL_CTRL(p),(r._shared_pool_ctrl))
#define READ_SHARED_POOL_CTRLr(u,p,r) bcm5607x_reg_get(u,R_SHARED_POOL_CTRL(p),&(r._shared_pool_ctrl))

/*******************************************************************************
 * End of 'SHARED_POOL_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  SHARED_POOL_CTRL_EXT1
 * BLOCKS:   MMU
 * DESC:     Priority group mapping register
 * SIZE:     32
 * FIELDS:
 *     RESERVED         reserved bit
 *     DYNAMIC_COS_DROP_EN Each bit is for a COS.Bit 8: cos 8....Bit 31: cos 31In Dynamic memory mode, if global shared pool counter >=  TOTALDYNCELLSETLIMIT and HOL counter of cos-n >= cos-n's LWMCOSCELLSETLIMIT, then this packet could be discarded by MMU. This register will control this dynamic mode cos-n drop behavior."1": drop the packet if the above condition is meet"0": don't drop the packet if the above condition is meetDefault value is all ONEs for HC2 backward compatible.
 */
#define SHARED_POOL_CTRL_EXT1r_SIZE 4

/* SHARED_POOL_CTRL_EXT1r is element of SHARED_POOL_CTRL_EXT */

/*
 * This structure should be used to declare and program SHARED_POOL_CTRL_EXT1.
 */
typedef union SHARED_POOL_CTRL_EXT1r_s {
	uint32 v[1];
	uint32 shared_pool_ctrl_ext1[1];
	uint32 _shared_pool_ctrl_ext1;
} SHARED_POOL_CTRL_EXT1r_t;

#define SHARED_POOL_CTRL_EXT1r_CLR(r) (r).shared_pool_ctrl_ext1[0] = 0
#define SHARED_POOL_CTRL_EXT1r_SET(r,d) (r).shared_pool_ctrl_ext1[0] = d
#define SHARED_POOL_CTRL_EXT1r_GET(r) (r).shared_pool_ctrl_ext1[0]

/*
 * These macros can be used to access individual fields.
 */
#define SHARED_POOL_CTRL_EXT1r_RESERVEDf_GET(r) (((r).shared_pool_ctrl_ext1[0]) & 0xff)
#define SHARED_POOL_CTRL_EXT1r_RESERVEDf_SET(r,f) (r).shared_pool_ctrl_ext1[0]=(((r).shared_pool_ctrl_ext1[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define SHARED_POOL_CTRL_EXT1r_DYNAMIC_COS_DROP_ENf_GET(r) ((((r).shared_pool_ctrl_ext1[0]) >> 8) & 0xffffff)
#define SHARED_POOL_CTRL_EXT1r_DYNAMIC_COS_DROP_ENf_SET(r,f) (r).shared_pool_ctrl_ext1[0]=(((r).shared_pool_ctrl_ext1[0] & ~((uint32)0xffffff << 8)) | ((((uint32)f) & 0xffffff) << 8))

/*
 * These macros can be used to access SHARED_POOL_CTRL_EXT1.
 */
#define WRITE_SHARED_POOL_CTRL_EXT1r(u,p,r) bcm5607x_reg_set(u,R_SHARED_POOL_CTRL_EXT1(p),(r._shared_pool_ctrl_ext1))
#define READ_SHARED_POOL_CTRL_EXT1r(u,p,r) bcm5607x_reg_get(u,R_SHARED_POOL_CTRL_EXT1(p),&(r._shared_pool_ctrl_ext1))

/*******************************************************************************
 * End of 'SHARED_POOL_CTRL_EXT1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  SHARED_POOL_CTRL_EXT2
 * BLOCKS:   MMU
 * DESC:     Priority group mapping register
 * SIZE:     32
 * FIELDS:
 *     DYNAMIC_COS_DROP_EN Each bit is for a COS.Bit 0: cos 32....Bit 31: cos 63In Dynamic memory mode, if global shared pool counter >=  TOTALDYNCELLSETLIMIT and HOL counter of cos-n >= cos-n's LWMCOSCELLSETLIMIT, then this packet could be discarded by MMU. This register will control this dynamic mode cos-n drop behavior."1": drop the packet if the above condition is meet"0": don't drop the packet if the above condition is meetDefault value is all ONEs for HC2 backward compatible.
 */
#define SHARED_POOL_CTRL_EXT2r_SIZE 4

/* SHARED_POOL_CTRL_EXT2r is element of SHARED_POOL_CTRL_EXT */

/*
 * This structure should be used to declare and program SHARED_POOL_CTRL_EXT2.
 */
typedef union SHARED_POOL_CTRL_EXT2r_s {
	uint32 v[1];
	uint32 shared_pool_ctrl_ext2[1];
	uint32 _shared_pool_ctrl_ext2;
} SHARED_POOL_CTRL_EXT2r_t;

#define SHARED_POOL_CTRL_EXT2r_CLR(r) (r).shared_pool_ctrl_ext2[0] = 0
#define SHARED_POOL_CTRL_EXT2r_SET(r,d) (r).shared_pool_ctrl_ext2[0] = d
#define SHARED_POOL_CTRL_EXT2r_GET(r) (r).shared_pool_ctrl_ext2[0]

/*
 * These macros can be used to access individual fields.
 */
#define SHARED_POOL_CTRL_EXT2r_DYNAMIC_COS_DROP_ENf_GET(r) ((r).shared_pool_ctrl_ext2[0])
#define SHARED_POOL_CTRL_EXT2r_DYNAMIC_COS_DROP_ENf_SET(r,f) (r).shared_pool_ctrl_ext2[0]=((uint32)f)

/*
 * These macros can be used to access SHARED_POOL_CTRL_EXT2.
 */
#define WRITE_SHARED_POOL_CTRL_EXT2r(u,p,r) bcm5607x_reg_set(u,R_SHARED_POOL_CTRL_EXT2(p),(r._shared_pool_ctrl_ext2))
#define READ_SHARED_POOL_CTRL_EXT2r(u,p,r) bcm5607x_reg_get(u,R_SHARED_POOL_CTRL_EXT2(p),&(r._shared_pool_ctrl_ext2))

/*******************************************************************************
 * End of 'SHARED_POOL_CTRL_EXT2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  SOURCE_TRUNK_MAP
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Map Table. 
This table is used to support trunking across different MODIDs.
This table is indexed by the concatenation of \{MY_MODID[7:0], INGRESS_PORT[5:0]\} 
 * SIZE:     66
 * FIELDS:
 *     PORT_TYPE        Indicates source port type
 *     TGID             Source port TGID
 *     LPORT_PROFILE_IDX Index to LPORT PROFILE Table.
 *     CLASS_ID         Source port Class ID
 *     VLAN_RANGE_IDX   Source port vlan range table index
 *     OVID             Per-system port default VLAN
 *     VFI              Used to provide default VFI (for untag & ptag packets)  which is used for indexing L2_ENTRY table.
 *     L3_IIF           Per-port default L3 Interface.
 *     VRF_ID           VRF ID: used to access routing/forwarding tables.
 *     VFP_PORT_GROUP_ID VFP port group ID (used in the VFP for grouping ports)
 *     MA_BASE_POINTER   This pointer forms a part of the index to the MA_INDEX Table.
 *     PACKET_MODIFICATION_DISABLE Used to prevent packet modifications in the upstream direction except for MIML encap.
 *     DISABLE_VLAN_CHECKS If set, then spanning tree and VLAN memberships checks are not performed.
 *     EVEN_PARITY      Even parity for the SOURCE_TRUNK_MAP table
 */
#define SOURCE_TRUNK_MAPm_MIN 0
#define SOURCE_TRUNK_MAPm_MAX 8191
#define SOURCE_TRUNK_MAPm_CMAX(u) 8191
#define SOURCE_TRUNK_MAPm_SIZE 9

/*
 * This structure should be used to declare and program SOURCE_TRUNK_MAP.
 */
typedef union SOURCE_TRUNK_MAPm_s {
	uint32 v[3];
	uint32 source_trunk_map[3];
	uint32 _source_trunk_map;
} SOURCE_TRUNK_MAPm_t;

#define SOURCE_TRUNK_MAPm_CLR(r) sal_memset(&((r)._source_trunk_map), 0, sizeof(SOURCE_TRUNK_MAPm_t))
#define SOURCE_TRUNK_MAPm_SET(r,i,d) (r).source_trunk_map[i] = d
#define SOURCE_TRUNK_MAPm_GET(r,i) (r).source_trunk_map[i]

/*
 * These macros can be used to access individual fields.
 */
#define SOURCE_TRUNK_MAPm_PORT_TYPEf_GET(r) (((r).source_trunk_map[0]) & 0x3)
#define SOURCE_TRUNK_MAPm_PORT_TYPEf_SET(r,f) (r).source_trunk_map[0]=(((r).source_trunk_map[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define SOURCE_TRUNK_MAPm_TGIDf_GET(r) ((((r).source_trunk_map[0]) >> 2) & 0x7f)
#define SOURCE_TRUNK_MAPm_TGIDf_SET(r,f) (r).source_trunk_map[0]=(((r).source_trunk_map[0] & ~((uint32)0x7f << 2)) | ((((uint32)f) & 0x7f) << 2))
#define SOURCE_TRUNK_MAPm_LPORT_PROFILE_IDXf_GET(r) ((((r).source_trunk_map[0]) >> 9) & 0x7f)
#define SOURCE_TRUNK_MAPm_LPORT_PROFILE_IDXf_SET(r,f) (r).source_trunk_map[0]=(((r).source_trunk_map[0] & ~((uint32)0x7f << 9)) | ((((uint32)f) & 0x7f) << 9))
#define SOURCE_TRUNK_MAPm_CLASS_IDf_GET(r) ((((r).source_trunk_map[0]) >> 16) & 0xff)
#define SOURCE_TRUNK_MAPm_CLASS_IDf_SET(r,f) (r).source_trunk_map[0]=(((r).source_trunk_map[0] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define SOURCE_TRUNK_MAPm_VLAN_RANGE_IDXf_GET(r) ((((r).source_trunk_map[0]) >> 24) & 0x7f)
#define SOURCE_TRUNK_MAPm_VLAN_RANGE_IDXf_SET(r,f) (r).source_trunk_map[0]=(((r).source_trunk_map[0] & ~((uint32)0x7f << 24)) | ((((uint32)f) & 0x7f) << 24))
#define SOURCE_TRUNK_MAPm_OVIDf_GET(r) field32_get((r).source_trunk_map,31,43)
#define SOURCE_TRUNK_MAPm_OVIDf_SET(r,f) field32_set((r).source_trunk_map,31,43,f)
#define SOURCE_TRUNK_MAPm_VFIf_GET(r) field32_get((r).source_trunk_map,31,40)
#define SOURCE_TRUNK_MAPm_VFIf_SET(r,f) field32_set((r).source_trunk_map,31,40,f)
#define SOURCE_TRUNK_MAPm_L3_IIFf_GET(r) field32_get((r).source_trunk_map,31,37)
#define SOURCE_TRUNK_MAPm_L3_IIFf_SET(r,f) field32_set((r).source_trunk_map,31,37,f)
#define SOURCE_TRUNK_MAPm_VRF_IDf_GET(r) field32_get((r).source_trunk_map,31,34)
#define SOURCE_TRUNK_MAPm_VRF_IDf_SET(r,f) field32_set((r).source_trunk_map,31,34,f)
#define SOURCE_TRUNK_MAPm_VFP_PORT_GROUP_IDf_GET(r) ((((r).source_trunk_map[1]) >> 12) & 0xff)
#define SOURCE_TRUNK_MAPm_VFP_PORT_GROUP_IDf_SET(r,f) (r).source_trunk_map[1]=(((r).source_trunk_map[1] & ~((uint32)0xff << 12)) | ((((uint32)f) & 0xff) << 12))
#define SOURCE_TRUNK_MAPm_MA_BASE_POINTERf_GET(r) ((((r).source_trunk_map[1]) >> 20) & 0x7ff)
#define SOURCE_TRUNK_MAPm_MA_BASE_POINTERf_SET(r,f) (r).source_trunk_map[1]=(((r).source_trunk_map[1] & ~((uint32)0x7ff << 20)) | ((((uint32)f) & 0x7ff) << 20))
#define SOURCE_TRUNK_MAPm_PACKET_MODIFICATION_DISABLEf_GET(r) ((((r).source_trunk_map[1]) >> 31) & 0x1)
#define SOURCE_TRUNK_MAPm_PACKET_MODIFICATION_DISABLEf_SET(r,f) (r).source_trunk_map[1]=(((r).source_trunk_map[1] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define SOURCE_TRUNK_MAPm_DISABLE_VLAN_CHECKSf_GET(r) (((r).source_trunk_map[2]) & 0x1)
#define SOURCE_TRUNK_MAPm_DISABLE_VLAN_CHECKSf_SET(r,f) (r).source_trunk_map[2]=(((r).source_trunk_map[2] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define SOURCE_TRUNK_MAPm_EVEN_PARITYf_GET(r) ((((r).source_trunk_map[2]) >> 1) & 0x1)
#define SOURCE_TRUNK_MAPm_EVEN_PARITYf_SET(r,f) (r).source_trunk_map[2]=(((r).source_trunk_map[2] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access SOURCE_TRUNK_MAP.
 */
#define WRITE_SOURCE_TRUNK_MAPm(u,i,r) bcm5607x_mem_set(u, M_SOURCE_TRUNK_MAP(i), &(r._source_trunk_map), 3)
#define READ_SOURCE_TRUNK_MAPm(u,i,r) bcm5607x_mem_get(u, M_SOURCE_TRUNK_MAP(i), &(r._source_trunk_map), 3)

/*******************************************************************************
 * End of 'SOURCE_TRUNK_MAPm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  SOURCE_TRUNK_MAP_MODBASE
 * BLOCKS:   IPIPE
 * DESC:     For HG/HG+/HG2 packets, index (MOD ID) is from MH; Else, index is from PORT_TABLE
 * SIZE:     14
 * FIELDS:
 *     BASE             Index into the system port table for this feature.
 *     EVEN_PARITY      PARITY BIT to make the entry parity even.
 */
#define SOURCE_TRUNK_MAP_MODBASEm_MIN 0
#define SOURCE_TRUNK_MAP_MODBASEm_MAX 255
#define SOURCE_TRUNK_MAP_MODBASEm_CMAX(u) 255
#define SOURCE_TRUNK_MAP_MODBASEm_SIZE 2

/*
 * This structure should be used to declare and program SOURCE_TRUNK_MAP_MODBASE.
 */
typedef union SOURCE_TRUNK_MAP_MODBASEm_s {
	uint32 v[1];
	uint32 source_trunk_map_modbase[1];
	uint32 _source_trunk_map_modbase;
} SOURCE_TRUNK_MAP_MODBASEm_t;

#define SOURCE_TRUNK_MAP_MODBASEm_CLR(r) (r).source_trunk_map_modbase[0] = 0
#define SOURCE_TRUNK_MAP_MODBASEm_SET(r,d) (r).source_trunk_map_modbase[0] = d
#define SOURCE_TRUNK_MAP_MODBASEm_GET(r) (r).source_trunk_map_modbase[0]

/*
 * These macros can be used to access individual fields.
 */
#define SOURCE_TRUNK_MAP_MODBASEm_BASEf_GET(r) (((r).source_trunk_map_modbase[0]) & 0x1fff)
#define SOURCE_TRUNK_MAP_MODBASEm_BASEf_SET(r,f) (r).source_trunk_map_modbase[0]=(((r).source_trunk_map_modbase[0] & ~((uint32)0x1fff)) | (((uint32)f) & 0x1fff))
#define SOURCE_TRUNK_MAP_MODBASEm_EVEN_PARITYf_GET(r) ((((r).source_trunk_map_modbase[0]) >> 13) & 0x1)
#define SOURCE_TRUNK_MAP_MODBASEm_EVEN_PARITYf_SET(r,f) (r).source_trunk_map_modbase[0]=(((r).source_trunk_map_modbase[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))

/*
 * These macros can be used to access SOURCE_TRUNK_MAP_MODBASE.
 */
#define WRITE_SOURCE_TRUNK_MAP_MODBASEm(u,i,r) bcm5607x_mem_set(u, M_SOURCE_TRUNK_MAP_MODBASE(i), &(r._source_trunk_map_modbase), 1)
#define READ_SOURCE_TRUNK_MAP_MODBASEm(u,i,r) bcm5607x_mem_get(u, M_SOURCE_TRUNK_MAP_MODBASE(i), &(r._source_trunk_map_modbase), 1)

/*******************************************************************************
 * End of 'SOURCE_TRUNK_MAP_MODBASEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  STORM_CONTROL_METER_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Per-port configuration and enables for storm control meters
 * SIZE:     32
 * FIELDS:
 *     PACKET_QUANTUM   Number of tokens consumed by each packet when storm control meters are in packet mode (METER_BYTE_MODE=0).
 *     BYTE_MODE        0=Packet-based metering, 1=Byte-based metering.
 *     BCAST_ENABLE     Turn on storm control metering for broadcast packets
 *     KNOWN_L2MC_ENABLE Turn on storm control metering for known L2MC packets
 *     UNKNOWN_L2MC_ENABLE Turn on storm control metering for unknown L2MC packets
 *     KNOWN_IPMC_ENABLE Turn on storm control metering for known IPMC packets
 *     UNKNOWN_IPMC_ENABLE Turn on storm control metering for unknown IPMC packets
 *     DLFBC_ENABLE     Turn on storm control metering for DLF/BC packets
 */
#define STORM_CONTROL_METER_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program STORM_CONTROL_METER_CONFIG.
 */
typedef union STORM_CONTROL_METER_CONFIGr_s {
	uint32 v[1];
	uint32 storm_control_meter_config[1];
	uint32 _storm_control_meter_config;
} STORM_CONTROL_METER_CONFIGr_t;

#define STORM_CONTROL_METER_CONFIGr_CLR(r) (r).storm_control_meter_config[0] = 0
#define STORM_CONTROL_METER_CONFIGr_SET(r,d) (r).storm_control_meter_config[0] = d
#define STORM_CONTROL_METER_CONFIGr_GET(r) (r).storm_control_meter_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define STORM_CONTROL_METER_CONFIGr_PACKET_QUANTUMf_GET(r) (((r).storm_control_meter_config[0]) & 0xfff)
#define STORM_CONTROL_METER_CONFIGr_PACKET_QUANTUMf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define STORM_CONTROL_METER_CONFIGr_BYTE_MODEf_GET(r) ((((r).storm_control_meter_config[0]) >> 12) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_BYTE_MODEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define STORM_CONTROL_METER_CONFIGr_BCAST_ENABLEf_GET(r) ((((r).storm_control_meter_config[0]) >> 13) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_BCAST_ENABLEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define STORM_CONTROL_METER_CONFIGr_KNOWN_L2MC_ENABLEf_GET(r) ((((r).storm_control_meter_config[0]) >> 14) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_KNOWN_L2MC_ENABLEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define STORM_CONTROL_METER_CONFIGr_UNKNOWN_L2MC_ENABLEf_GET(r) ((((r).storm_control_meter_config[0]) >> 15) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_UNKNOWN_L2MC_ENABLEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define STORM_CONTROL_METER_CONFIGr_KNOWN_IPMC_ENABLEf_GET(r) ((((r).storm_control_meter_config[0]) >> 16) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_KNOWN_IPMC_ENABLEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define STORM_CONTROL_METER_CONFIGr_UNKNOWN_IPMC_ENABLEf_GET(r) ((((r).storm_control_meter_config[0]) >> 17) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_UNKNOWN_IPMC_ENABLEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define STORM_CONTROL_METER_CONFIGr_DLFBC_ENABLEf_GET(r) ((((r).storm_control_meter_config[0]) >> 18) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_DLFBC_ENABLEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))

/*
 * These macros can be used to access STORM_CONTROL_METER_CONFIG.
 */
#define WRITE_STORM_CONTROL_METER_CONFIGr(u,p,r) bcm5607x_reg_set(u,R_STORM_CONTROL_METER_CONFIG(p),(r._storm_control_meter_config))
#define READ_STORM_CONTROL_METER_CONFIGr(u,p,r) bcm5607x_reg_get(u,R_STORM_CONTROL_METER_CONFIG(p),&(r._storm_control_meter_config))

/*******************************************************************************
 * End of 'STORM_CONTROL_METER_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  SW2_FP_DST_ACTION_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Enable functions when IFP generates a REDIRECT, REPLACE_PBM or OR_PBM action 
 * SIZE:     32
 * FIELDS:
 *     SRC_REMOVAL_EN   Enables L2 Source Knockout
 *     HG_SRC_REMOVAL_EN Enables HiGiG L2 Source Knockout
 *     LAG_RES_EN       Enables Trunk Resolution
 *     HGTRUNK_RES_EN   Enables HiGiG Trunk Resolution
 *     VLAN_CHECK_EN    Enables Ingress VLAN Membership checks
 *     PORT_BLOCK_EN    Enables application of various port block masks
 *     VLAN_BLOCK_EN    Enables application of vlan block masks
 *     SRC_REMOVAL_EN_FOR_REDIRECT_TO_NHI Enables removal of system ingress port from port-bitmap for packets that have been Redirected to a Next-hop index by the IFP.
 */
#define SW2_FP_DST_ACTION_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SW2_FP_DST_ACTION_CONTROL.
 */
typedef union SW2_FP_DST_ACTION_CONTROLr_s {
	uint32 v[1];
	uint32 sw2_fp_dst_action_control[1];
	uint32 _sw2_fp_dst_action_control;
} SW2_FP_DST_ACTION_CONTROLr_t;

#define SW2_FP_DST_ACTION_CONTROLr_CLR(r) (r).sw2_fp_dst_action_control[0] = 0
#define SW2_FP_DST_ACTION_CONTROLr_SET(r,d) (r).sw2_fp_dst_action_control[0] = d
#define SW2_FP_DST_ACTION_CONTROLr_GET(r) (r).sw2_fp_dst_action_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define SW2_FP_DST_ACTION_CONTROLr_SRC_REMOVAL_ENf_GET(r) (((r).sw2_fp_dst_action_control[0]) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_SRC_REMOVAL_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define SW2_FP_DST_ACTION_CONTROLr_HG_SRC_REMOVAL_ENf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 1) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_HG_SRC_REMOVAL_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define SW2_FP_DST_ACTION_CONTROLr_LAG_RES_ENf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 2) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_LAG_RES_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define SW2_FP_DST_ACTION_CONTROLr_HGTRUNK_RES_ENf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 3) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_HGTRUNK_RES_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define SW2_FP_DST_ACTION_CONTROLr_VLAN_CHECK_ENf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 4) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_VLAN_CHECK_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define SW2_FP_DST_ACTION_CONTROLr_PORT_BLOCK_ENf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 5) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_PORT_BLOCK_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define SW2_FP_DST_ACTION_CONTROLr_VLAN_BLOCK_ENf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 6) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_VLAN_BLOCK_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define SW2_FP_DST_ACTION_CONTROLr_SRC_REMOVAL_EN_FOR_REDIRECT_TO_NHIf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 7) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_SRC_REMOVAL_EN_FOR_REDIRECT_TO_NHIf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access SW2_FP_DST_ACTION_CONTROL.
 */
#define WRITE_SW2_FP_DST_ACTION_CONTROLr(u,r) bcm5607x_reg_set(u,R_SW2_FP_DST_ACTION_CONTROL,(r._sw2_fp_dst_action_control))
#define READ_SW2_FP_DST_ACTION_CONTROLr(u,r) bcm5607x_reg_get(u,R_SW2_FP_DST_ACTION_CONTROL,&(r._sw2_fp_dst_action_control))

/*******************************************************************************
 * End of 'SW2_FP_DST_ACTION_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  SW2_RAM_CONTROL_4_64
 * BLOCKS:   IPIPE
 * DESC:     Debug Register to drive the TM inputs of internal rams
 * SIZE:     64
 * FIELDS:
 *     CPU_COS_MAP_TCAM_TM 
 *     IP_STATS_MEM_TM  
 *     STATS_MEM_0_TM   
 *     STATS_MEM_1_TM   
 */
#define SW2_RAM_CONTROL_4_64r_SIZE 8

/*
 * This structure should be used to declare and program SW2_RAM_CONTROL_4_64.
 */
typedef union SW2_RAM_CONTROL_4_64r_s {
	uint32 v[2];
	uint32 sw2_ram_control_4_64[2];
	uint32 _sw2_ram_control_4_64;
} SW2_RAM_CONTROL_4_64r_t;

#define SW2_RAM_CONTROL_4_64r_CLR(r) sal_memset(&((r)._sw2_ram_control_4_64), 0, sizeof(SW2_RAM_CONTROL_4_64r_t))
#define SW2_RAM_CONTROL_4_64r_SET(r,i,d) (r).sw2_ram_control_4_64[i] = d
#define SW2_RAM_CONTROL_4_64r_GET(r,i) (r).sw2_ram_control_4_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define SW2_RAM_CONTROL_4_64r_CPU_COS_MAP_TCAM_TMf_GET(r) (((r).sw2_ram_control_4_64[0]) & 0xffff)
#define SW2_RAM_CONTROL_4_64r_CPU_COS_MAP_TCAM_TMf_SET(r,f) (r).sw2_ram_control_4_64[0]=(((r).sw2_ram_control_4_64[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define SW2_RAM_CONTROL_4_64r_IP_STATS_MEM_TMf_GET(r) ((((r).sw2_ram_control_4_64[0]) >> 16) & 0x7f)
#define SW2_RAM_CONTROL_4_64r_IP_STATS_MEM_TMf_SET(r,f) (r).sw2_ram_control_4_64[0]=(((r).sw2_ram_control_4_64[0] & ~((uint32)0x7f << 16)) | ((((uint32)f) & 0x7f) << 16))
#define SW2_RAM_CONTROL_4_64r_STATS_MEM_0_TMf_GET(r) ((((r).sw2_ram_control_4_64[0]) >> 23) & 0x7f)
#define SW2_RAM_CONTROL_4_64r_STATS_MEM_0_TMf_SET(r,f) (r).sw2_ram_control_4_64[0]=(((r).sw2_ram_control_4_64[0] & ~((uint32)0x7f << 23)) | ((((uint32)f) & 0x7f) << 23))
#define SW2_RAM_CONTROL_4_64r_STATS_MEM_1_TMf_GET(r) field32_get((r).sw2_ram_control_4_64,30,36)
#define SW2_RAM_CONTROL_4_64r_STATS_MEM_1_TMf_SET(r,f) field32_set((r).sw2_ram_control_4_64,30,36,f)

/*
 * These macros can be used to access SW2_RAM_CONTROL_4_64.
 */
#define WRITE_SW2_RAM_CONTROL_4_64r(u,r) bcm5607x_reg64_set(u,R_SW2_RAM_CONTROL_4_64,&(r._sw2_ram_control_4_64),2)
#define READ_SW2_RAM_CONTROL_4_64r(u,r) bcm5607x_reg64_get(u,R_SW2_RAM_CONTROL_4_64,&(r._sw2_ram_control_4_64),2)

/*******************************************************************************
 * End of 'SW2_RAM_CONTROL_4_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  SYSTEM_CONFIG_TABLE
 * BLOCKS:   IPIPE
 * DESC:     System Port Table.
This table holds fields to further parse HiGig packets.
This table is indexed via \{SRC_MODID[7:0], SRC_PORT[5:0]\}
 * SIZE:     8
 * FIELDS:
 *     OUTER_TPID_ENABLE Indicates if ING_OUTER_TPID[3] to ING_OUTER_TPID[0] are allowed outer TPID values.
 *     INNER_TPID_ENABLE .
 *     MIML_ENABLE      Enable MIML feature.
 *     CUSTOM_HEADER_ENABLE Enable CUSTOME_HEADER feature.
 *     EVEN_PARITY      PARITY BIT to make the entry parity even.
 */
#define SYSTEM_CONFIG_TABLEm_MIN 0
#define SYSTEM_CONFIG_TABLEm_MAX 8191
#define SYSTEM_CONFIG_TABLEm_CMAX(u) 8191
#define SYSTEM_CONFIG_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program SYSTEM_CONFIG_TABLE.
 */
typedef union SYSTEM_CONFIG_TABLEm_s {
	uint32 v[1];
	uint32 system_config_table[1];
	uint32 _system_config_table;
} SYSTEM_CONFIG_TABLEm_t;

#define SYSTEM_CONFIG_TABLEm_CLR(r) (r).system_config_table[0] = 0
#define SYSTEM_CONFIG_TABLEm_SET(r,d) (r).system_config_table[0] = d
#define SYSTEM_CONFIG_TABLEm_GET(r) (r).system_config_table[0]

/*
 * These macros can be used to access individual fields.
 */
#define SYSTEM_CONFIG_TABLEm_OUTER_TPID_ENABLEf_GET(r) (((r).system_config_table[0]) & 0xf)
#define SYSTEM_CONFIG_TABLEm_OUTER_TPID_ENABLEf_SET(r,f) (r).system_config_table[0]=(((r).system_config_table[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define SYSTEM_CONFIG_TABLEm_INNER_TPID_ENABLEf_GET(r) ((((r).system_config_table[0]) >> 4) & 0x1)
#define SYSTEM_CONFIG_TABLEm_INNER_TPID_ENABLEf_SET(r,f) (r).system_config_table[0]=(((r).system_config_table[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define SYSTEM_CONFIG_TABLEm_MIML_ENABLEf_GET(r) ((((r).system_config_table[0]) >> 5) & 0x1)
#define SYSTEM_CONFIG_TABLEm_MIML_ENABLEf_SET(r,f) (r).system_config_table[0]=(((r).system_config_table[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define SYSTEM_CONFIG_TABLEm_CUSTOM_HEADER_ENABLEf_GET(r) ((((r).system_config_table[0]) >> 6) & 0x1)
#define SYSTEM_CONFIG_TABLEm_CUSTOM_HEADER_ENABLEf_SET(r,f) (r).system_config_table[0]=(((r).system_config_table[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define SYSTEM_CONFIG_TABLEm_EVEN_PARITYf_GET(r) ((((r).system_config_table[0]) >> 7) & 0x1)
#define SYSTEM_CONFIG_TABLEm_EVEN_PARITYf_SET(r,f) (r).system_config_table[0]=(((r).system_config_table[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access SYSTEM_CONFIG_TABLE.
 */
#define WRITE_SYSTEM_CONFIG_TABLEm(u,i,r) bcm5607x_mem_set(u, M_SYSTEM_CONFIG_TABLE(i), &(r._system_config_table), 1)
#define READ_SYSTEM_CONFIG_TABLEm(u,i,r) bcm5607x_mem_get(u, M_SYSTEM_CONFIG_TABLE(i), &(r._system_config_table), 1)

/*******************************************************************************
 * End of 'SYSTEM_CONFIG_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_CLOCKING_ENFORCE_PSG
 * BLOCKS:   TOP
 * DESC:     TOP CLOCKING_ENFORCE_PSG Register
 * SIZE:     32
 * FIELDS:
 *     L3MC_PSG         L3MC clocking enforce PSG
 *     ICFG_PSG         ICFG clocking enforce PSG
 *     IDISC_PSG        IDISC clocking enforce PSG
 *     IFP_PSG          IFP clocking enforce PSG
 *     IVLAN_PSG        IVLAN clocking enforce PSG
 *     IPARS_PSG        IPARS clocking enforce PSG
 *     IRSEL1_PSG       IRSEL1 clocking enforce PSG
 *     IRSEL2_PSG       IRSEL2 clocking enforce PSG
 *     ISW1_PSG         ISW1 clocking enforce PSG
 *     ECFG_PSG         ECFG clocking enforce PSG
 *     IVXLT_PSG        IVXLT clocking enforce PSG
 *     EPARS_PSG        EPARS clocking enforce PSG
 *     EFP_PSG          EFP clocking enforce PSG
 *     EFPMOD_PSG       EFPMOD clocking enforce PSG
 *     EFPPARS_PSG      EFPPARS clocking enforce PSG
 *     EHCPM_PSG        EHCPM clocking enforce PSG
 *     EINITBUF_PSG     EINITBUF clocking enforce PSG
 *     EVXLT_PSG        EVXLT clocking enforce PSG
 *     EL3_PSG          EL3 clocking enforce PSG
 *     EPMOD_PSG        EPMOD clocking enforce PSG
 *     ESW_PSG          ESW clocking enforce PSG
 *     EVLAN_PSG        EVLAN clocking enforce PSG
 *     L2LU_CLK_ENFORCE L2LU clocking enforce PSG
 *     L2MC_CLK_ENFORCE L2MC clocking enforce PSG
 *     L3LU_CLK_ENFORCE L3LU clocking enforce PSG
 *     CLK_ENFORCE      clocking enforce
 *     RSVD_26          Reserved
 */
#define TOP_CLOCKING_ENFORCE_PSGr_SIZE 4

/*
 * This structure should be used to declare and program TOP_CLOCKING_ENFORCE_PSG.
 */
typedef union TOP_CLOCKING_ENFORCE_PSGr_s {
	uint32 v[1];
	uint32 top_clocking_enforce_psg[1];
	uint32 _top_clocking_enforce_psg;
} TOP_CLOCKING_ENFORCE_PSGr_t;

#define TOP_CLOCKING_ENFORCE_PSGr_CLR(r) (r).top_clocking_enforce_psg[0] = 0
#define TOP_CLOCKING_ENFORCE_PSGr_SET(r,d) (r).top_clocking_enforce_psg[0] = d
#define TOP_CLOCKING_ENFORCE_PSGr_GET(r) (r).top_clocking_enforce_psg[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_CLOCKING_ENFORCE_PSGr_L3MC_PSGf_GET(r) (((r).top_clocking_enforce_psg[0]) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_L3MC_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_CLOCKING_ENFORCE_PSGr_ICFG_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 1) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_ICFG_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TOP_CLOCKING_ENFORCE_PSGr_IDISC_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 2) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IDISC_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define TOP_CLOCKING_ENFORCE_PSGr_IFP_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 3) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IFP_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define TOP_CLOCKING_ENFORCE_PSGr_IVLAN_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 4) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IVLAN_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define TOP_CLOCKING_ENFORCE_PSGr_IPARS_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 5) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IPARS_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define TOP_CLOCKING_ENFORCE_PSGr_IRSEL1_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 6) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IRSEL1_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define TOP_CLOCKING_ENFORCE_PSGr_IRSEL2_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 7) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IRSEL2_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define TOP_CLOCKING_ENFORCE_PSGr_ISW1_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 8) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_ISW1_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define TOP_CLOCKING_ENFORCE_PSGr_ECFG_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 9) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_ECFG_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_CLOCKING_ENFORCE_PSGr_IVXLT_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 10) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IVXLT_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define TOP_CLOCKING_ENFORCE_PSGr_EPARS_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 11) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EPARS_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define TOP_CLOCKING_ENFORCE_PSGr_EFP_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 12) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EFP_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define TOP_CLOCKING_ENFORCE_PSGr_EFPMOD_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 13) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EFPMOD_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define TOP_CLOCKING_ENFORCE_PSGr_EFPPARS_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 14) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EFPPARS_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define TOP_CLOCKING_ENFORCE_PSGr_EHCPM_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 15) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EHCPM_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define TOP_CLOCKING_ENFORCE_PSGr_EINITBUF_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 16) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EINITBUF_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define TOP_CLOCKING_ENFORCE_PSGr_EVXLT_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 17) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EVXLT_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define TOP_CLOCKING_ENFORCE_PSGr_EL3_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 18) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EL3_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define TOP_CLOCKING_ENFORCE_PSGr_EPMOD_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 19) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EPMOD_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define TOP_CLOCKING_ENFORCE_PSGr_ESW_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 20) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_ESW_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define TOP_CLOCKING_ENFORCE_PSGr_EVLAN_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 21) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EVLAN_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define TOP_CLOCKING_ENFORCE_PSGr_L2LU_CLK_ENFORCEf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 22) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_L2LU_CLK_ENFORCEf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define TOP_CLOCKING_ENFORCE_PSGr_L2MC_CLK_ENFORCEf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 23) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_L2MC_CLK_ENFORCEf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define TOP_CLOCKING_ENFORCE_PSGr_L3LU_CLK_ENFORCEf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 24) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_L3LU_CLK_ENFORCEf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define TOP_CLOCKING_ENFORCE_PSGr_CLK_ENFORCEf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 25) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_CLK_ENFORCEf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define TOP_CLOCKING_ENFORCE_PSGr_RSVD_26f_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 26) & 0x3f)
#define TOP_CLOCKING_ENFORCE_PSGr_RSVD_26f_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access TOP_CLOCKING_ENFORCE_PSG.
 */
#define WRITE_TOP_CLOCKING_ENFORCE_PSGr(u,r) bcm5607x_reg_set(u,R_TOP_CLOCKING_ENFORCE_PSG,(r._top_clocking_enforce_psg))
#define READ_TOP_CLOCKING_ENFORCE_PSGr(u,r) bcm5607x_reg_get(u,R_TOP_CLOCKING_ENFORCE_PSG,&(r._top_clocking_enforce_psg))

/*******************************************************************************
 * End of 'TOP_CLOCKING_ENFORCE_PSGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_CORE_PLL_CTRL3
 * BLOCKS:   TOP
 * DESC:     TOP_CORE_PLL_CTRL3 (MSTR_PLL_CTRL1)
 * SIZE:     32
 * FIELDS:
 *     MSTR_NDIV_INT                    Integer part of Feedback Divider Rate (N). Default is 140 (decimal).                f(vcoclk) = f(i_refclk) * N / P., where                N = Integer part, from the table below + Fractional part.                P = value of i_pdiv                    0000000000 = 1024                    0000000001 = XXXX                    ....                    0000001011 = XXXX                    0000001100 = 12                    0000001101 = 13                    0000001110 = 14                    ....                    1111111111 = 1023
 *     MSTR_NDIV_FRAC                   Fractional part of Feedback Divider Rate (N).Default is 0 (decimal).                This value, divided by 2^20, is added to i_ndiv_int to determine the                 effective feedback divider rate N.                Concatinating these busses {i_ndiv_int, i_ndiv_frac} creates a 30-bit number                sometimes referred to as the Frequency Control Word (fcw), with 10 integer                 bits and 20 fractional bits.
 *     RSVD             Reserved
 */
#define TOP_CORE_PLL_CTRL3r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CORE_PLL_CTRL3.
 */
typedef union TOP_CORE_PLL_CTRL3r_s {
	uint32 v[1];
	uint32 top_core_pll_ctrl3[1];
	uint32 _top_core_pll_ctrl3;
} TOP_CORE_PLL_CTRL3r_t;

#define TOP_CORE_PLL_CTRL3r_CLR(r) (r).top_core_pll_ctrl3[0] = 0
#define TOP_CORE_PLL_CTRL3r_SET(r,d) (r).top_core_pll_ctrl3[0] = d
#define TOP_CORE_PLL_CTRL3r_GET(r) (r).top_core_pll_ctrl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_CORE_PLL_CTRL3r_MSTR_NDIV_INTf_GET(r) (((r).top_core_pll_ctrl3[0]) & 0x3ff)
#define TOP_CORE_PLL_CTRL3r_MSTR_NDIV_INTf_SET(r,f) (r).top_core_pll_ctrl3[0]=(((r).top_core_pll_ctrl3[0] & ~((uint32)0x3ff)) | (((uint32)f) & 0x3ff))
#define TOP_CORE_PLL_CTRL3r_MSTR_NDIV_FRACf_GET(r) ((((r).top_core_pll_ctrl3[0]) >> 10) & 0xfffff)
#define TOP_CORE_PLL_CTRL3r_MSTR_NDIV_FRACf_SET(r,f) (r).top_core_pll_ctrl3[0]=(((r).top_core_pll_ctrl3[0] & ~((uint32)0xfffff << 10)) | ((((uint32)f) & 0xfffff) << 10))
#define TOP_CORE_PLL_CTRL3r_RSVDf_GET(r) ((((r).top_core_pll_ctrl3[0]) >> 30) & 0x3)
#define TOP_CORE_PLL_CTRL3r_RSVDf_SET(r,f) (r).top_core_pll_ctrl3[0]=(((r).top_core_pll_ctrl3[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))

/*
 * These macros can be used to access TOP_CORE_PLL_CTRL3.
 */
#define WRITE_TOP_CORE_PLL_CTRL3r(u,r) bcm5607x_reg_set(u,R_TOP_CORE_PLL_CTRL3,(r._top_core_pll_ctrl3))
#define READ_TOP_CORE_PLL_CTRL3r(u,r) bcm5607x_reg_get(u,R_TOP_CORE_PLL_CTRL3,&(r._top_core_pll_ctrl3))

/*******************************************************************************
 * End of 'TOP_CORE_PLL_CTRL3r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_CORE_PLL_CTRL4
 * BLOCKS:   TOP
 * DESC:     TOP_CORE_PLL_CTRL4(MSTR_PLL_CTRL2)
 * SIZE:     32
 * FIELDS:
 *     MSTR_PDIV                        input reference clock pre-divider control, default is 1 (decimal)                    0001 = divide by 1                    0010 = divide by 2                    ....                    1111 = divide by 15                    0000 = divide by 16                Note: When strap_xtal_freq_sel is set to 1'b1 for 50MHz XTAL reference clock output, the effective pdiv would be automatically multiplied by 2 from this register for pll.
 *     MSTR_CH0_MDIV                    Post-divider ratio of channel-0, default is 5 (decimal)                    00000000= 256                    00000001= 1                    00000010= 2                    00000011= 3                    :                    :                    11111101= 253                    11111110= 254                    11111111= 255
 *     MSTR_CH0_MDEL                    Programmable delay for post-divider channel-0 (1/2VCO period steps)                    000= NO delay                    001= one VCO period delay                    others = useless
 *     MSTR_CH1_MDIV                    Post-divider ratio of channel-1, default is 28 (decimal)                    00000000= 256                    00000001= 1                    00000010= 2                    00000011= 3                    :                    :                    11111101= 253                    11111110= 254                    11111111= 255
 *     MSTR_CH1_MDEL                    Programmable delay for post-divider channel-1 (1/2VCO period steps)                    000= NO delay                    001= one VCO period delay                    others = useless
 *     RSVD             Reserved
 */
#define TOP_CORE_PLL_CTRL4r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CORE_PLL_CTRL4.
 */
typedef union TOP_CORE_PLL_CTRL4r_s {
	uint32 v[1];
	uint32 top_core_pll_ctrl4[1];
	uint32 _top_core_pll_ctrl4;
} TOP_CORE_PLL_CTRL4r_t;

#define TOP_CORE_PLL_CTRL4r_CLR(r) (r).top_core_pll_ctrl4[0] = 0
#define TOP_CORE_PLL_CTRL4r_SET(r,d) (r).top_core_pll_ctrl4[0] = d
#define TOP_CORE_PLL_CTRL4r_GET(r) (r).top_core_pll_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_CORE_PLL_CTRL4r_MSTR_PDIVf_GET(r) (((r).top_core_pll_ctrl4[0]) & 0xf)
#define TOP_CORE_PLL_CTRL4r_MSTR_PDIVf_SET(r,f) (r).top_core_pll_ctrl4[0]=(((r).top_core_pll_ctrl4[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define TOP_CORE_PLL_CTRL4r_MSTR_CH0_MDIVf_GET(r) ((((r).top_core_pll_ctrl4[0]) >> 4) & 0x1ff)
#define TOP_CORE_PLL_CTRL4r_MSTR_CH0_MDIVf_SET(r,f) (r).top_core_pll_ctrl4[0]=(((r).top_core_pll_ctrl4[0] & ~((uint32)0x1ff << 4)) | ((((uint32)f) & 0x1ff) << 4))
#define TOP_CORE_PLL_CTRL4r_MSTR_CH0_MDELf_GET(r) ((((r).top_core_pll_ctrl4[0]) >> 13) & 0x1)
#define TOP_CORE_PLL_CTRL4r_MSTR_CH0_MDELf_SET(r,f) (r).top_core_pll_ctrl4[0]=(((r).top_core_pll_ctrl4[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define TOP_CORE_PLL_CTRL4r_MSTR_CH1_MDIVf_GET(r) ((((r).top_core_pll_ctrl4[0]) >> 15) & 0x1ff)
#define TOP_CORE_PLL_CTRL4r_MSTR_CH1_MDIVf_SET(r,f) (r).top_core_pll_ctrl4[0]=(((r).top_core_pll_ctrl4[0] & ~((uint32)0x1ff << 15)) | ((((uint32)f) & 0x1ff) << 15))
#define TOP_CORE_PLL_CTRL4r_MSTR_CH1_MDELf_GET(r) ((((r).top_core_pll_ctrl4[0]) >> 24) & 0x1)
#define TOP_CORE_PLL_CTRL4r_MSTR_CH1_MDELf_SET(r,f) (r).top_core_pll_ctrl4[0]=(((r).top_core_pll_ctrl4[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define TOP_CORE_PLL_CTRL4r_RSVDf_GET(r) ((((r).top_core_pll_ctrl4[0]) >> 26) & 0x3f)
#define TOP_CORE_PLL_CTRL4r_RSVDf_SET(r,f) (r).top_core_pll_ctrl4[0]=(((r).top_core_pll_ctrl4[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access TOP_CORE_PLL_CTRL4.
 */
#define WRITE_TOP_CORE_PLL_CTRL4r(u,r) bcm5607x_reg_set(u,R_TOP_CORE_PLL_CTRL4,(r._top_core_pll_ctrl4))
#define READ_TOP_CORE_PLL_CTRL4r(u,r) bcm5607x_reg_get(u,R_TOP_CORE_PLL_CTRL4,&(r._top_core_pll_ctrl4))

/*******************************************************************************
 * End of 'TOP_CORE_PLL_CTRL4r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_CORE_PLL_CTRL5
 * BLOCKS:   TOP
 * DESC:     TOP_CORE_PLL_CTRL5(MSTR_PLL_CTRL3)
 * SIZE:     32
 * FIELDS:
 *     MSTR_KP          Master PLL KP, default is 3 (decimal)
 *     MSTR_KI          Master PLL KI, default is 2 (decimal)
 *     MSTR_KA          Master PLL KA, default is 0 (decimal)
 *     RSVD_1           Reserved
 *     MSTR_CH2_MDIV                    Post-divider ratio of channel-2, default is 14 (decimal)                    00000000= 256                    00000001= 1                    00000010= 2                    00000011= 3                    :                    :                    11111101= 253                    11111110= 254                    11111111= 255
 *     MSTR_CH2_MDEL                    Programmable delay for post-divider channel-2 (1/2VCO period steps)                    000= NO delay                    001= one VCO period delay                    others = useless
 *     RSVD             Reserved
 */
#define TOP_CORE_PLL_CTRL5r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CORE_PLL_CTRL5.
 */
typedef union TOP_CORE_PLL_CTRL5r_s {
	uint32 v[1];
	uint32 top_core_pll_ctrl5[1];
	uint32 _top_core_pll_ctrl5;
} TOP_CORE_PLL_CTRL5r_t;

#define TOP_CORE_PLL_CTRL5r_CLR(r) (r).top_core_pll_ctrl5[0] = 0
#define TOP_CORE_PLL_CTRL5r_SET(r,d) (r).top_core_pll_ctrl5[0] = d
#define TOP_CORE_PLL_CTRL5r_GET(r) (r).top_core_pll_ctrl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_CORE_PLL_CTRL5r_MSTR_KPf_GET(r) (((r).top_core_pll_ctrl5[0]) & 0xf)
#define TOP_CORE_PLL_CTRL5r_MSTR_KPf_SET(r,f) (r).top_core_pll_ctrl5[0]=(((r).top_core_pll_ctrl5[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define TOP_CORE_PLL_CTRL5r_MSTR_KIf_GET(r) ((((r).top_core_pll_ctrl5[0]) >> 4) & 0x7)
#define TOP_CORE_PLL_CTRL5r_MSTR_KIf_SET(r,f) (r).top_core_pll_ctrl5[0]=(((r).top_core_pll_ctrl5[0] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define TOP_CORE_PLL_CTRL5r_MSTR_KAf_GET(r) ((((r).top_core_pll_ctrl5[0]) >> 7) & 0xf)
#define TOP_CORE_PLL_CTRL5r_MSTR_KAf_SET(r,f) (r).top_core_pll_ctrl5[0]=(((r).top_core_pll_ctrl5[0] & ~((uint32)0xf << 7)) | ((((uint32)f) & 0xf) << 7))
#define TOP_CORE_PLL_CTRL5r_RSVD_1f_GET(r) ((((r).top_core_pll_ctrl5[0]) >> 11) & 0x7f)
#define TOP_CORE_PLL_CTRL5r_RSVD_1f_SET(r,f) (r).top_core_pll_ctrl5[0]=(((r).top_core_pll_ctrl5[0] & ~((uint32)0x7f << 11)) | ((((uint32)f) & 0x7f) << 11))
#define TOP_CORE_PLL_CTRL5r_MSTR_CH2_MDIVf_GET(r) ((((r).top_core_pll_ctrl5[0]) >> 18) & 0x1ff)
#define TOP_CORE_PLL_CTRL5r_MSTR_CH2_MDIVf_SET(r,f) (r).top_core_pll_ctrl5[0]=(((r).top_core_pll_ctrl5[0] & ~((uint32)0x1ff << 18)) | ((((uint32)f) & 0x1ff) << 18))
#define TOP_CORE_PLL_CTRL5r_MSTR_CH2_MDELf_GET(r) ((((r).top_core_pll_ctrl5[0]) >> 27) & 0x1)
#define TOP_CORE_PLL_CTRL5r_MSTR_CH2_MDELf_SET(r,f) (r).top_core_pll_ctrl5[0]=(((r).top_core_pll_ctrl5[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define TOP_CORE_PLL_CTRL5r_RSVDf_GET(r) ((((r).top_core_pll_ctrl5[0]) >> 29) & 0x7)
#define TOP_CORE_PLL_CTRL5r_RSVDf_SET(r,f) (r).top_core_pll_ctrl5[0]=(((r).top_core_pll_ctrl5[0] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))

/*
 * These macros can be used to access TOP_CORE_PLL_CTRL5.
 */
#define WRITE_TOP_CORE_PLL_CTRL5r(u,r) bcm5607x_reg_set(u,R_TOP_CORE_PLL_CTRL5,(r._top_core_pll_ctrl5))
#define READ_TOP_CORE_PLL_CTRL5r(u,r) bcm5607x_reg_get(u,R_TOP_CORE_PLL_CTRL5,&(r._top_core_pll_ctrl5))

/*******************************************************************************
 * End of 'TOP_CORE_PLL_CTRL5r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_CORE_PLL_CTRL6
 * BLOCKS:   TOP
 * DESC:     TOP_CORE_PLL_CTRL6(MSTR_PLL_CTRL4)
 * SIZE:     32
 * FIELDS:
 *     MSTR_CH3_MDIV                    Post-divider ratio of channel-3, default is 7 (decimal)                    00000000= 256                    00000001= 1                    00000010= 2                    00000011= 3                    :                    :                    11111101= 253                    11111110= 254                    11111111= 255
 *     MSTR_CH3_MDEL                    Programmable delay for post-divider channel-3 (1/2VCO period steps)                    000= NO delay                    001= one VCO period delay                    others = useless
 *     RSVD             Reserved
 */
#define TOP_CORE_PLL_CTRL6r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CORE_PLL_CTRL6.
 */
typedef union TOP_CORE_PLL_CTRL6r_s {
	uint32 v[1];
	uint32 top_core_pll_ctrl6[1];
	uint32 _top_core_pll_ctrl6;
} TOP_CORE_PLL_CTRL6r_t;

#define TOP_CORE_PLL_CTRL6r_CLR(r) (r).top_core_pll_ctrl6[0] = 0
#define TOP_CORE_PLL_CTRL6r_SET(r,d) (r).top_core_pll_ctrl6[0] = d
#define TOP_CORE_PLL_CTRL6r_GET(r) (r).top_core_pll_ctrl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_CORE_PLL_CTRL6r_MSTR_CH3_MDIVf_GET(r) (((r).top_core_pll_ctrl6[0]) & 0x1ff)
#define TOP_CORE_PLL_CTRL6r_MSTR_CH3_MDIVf_SET(r,f) (r).top_core_pll_ctrl6[0]=(((r).top_core_pll_ctrl6[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define TOP_CORE_PLL_CTRL6r_MSTR_CH3_MDELf_GET(r) ((((r).top_core_pll_ctrl6[0]) >> 9) & 0x1)
#define TOP_CORE_PLL_CTRL6r_MSTR_CH3_MDELf_SET(r,f) (r).top_core_pll_ctrl6[0]=(((r).top_core_pll_ctrl6[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_CORE_PLL_CTRL6r_RSVDf_GET(r) ((((r).top_core_pll_ctrl6[0]) >> 11) & 0x1fffff)
#define TOP_CORE_PLL_CTRL6r_RSVDf_SET(r,f) (r).top_core_pll_ctrl6[0]=(((r).top_core_pll_ctrl6[0] & ~((uint32)0x1fffff << 11)) | ((((uint32)f) & 0x1fffff) << 11))

/*
 * These macros can be used to access TOP_CORE_PLL_CTRL6.
 */
#define WRITE_TOP_CORE_PLL_CTRL6r(u,r) bcm5607x_reg_set(u,R_TOP_CORE_PLL_CTRL6,(r._top_core_pll_ctrl6))
#define READ_TOP_CORE_PLL_CTRL6r(u,r) bcm5607x_reg_get(u,R_TOP_CORE_PLL_CTRL6,&(r._top_core_pll_ctrl6))

/*******************************************************************************
 * End of 'TOP_CORE_PLL_CTRL6r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_CORE_PLL_DEBUG_CTRL_2
 * BLOCKS:   TOP
 * DESC:     PLL bypass enable and refclk select register
 * SIZE:     32
 * FIELDS:
 *     STAT_MODE        CORE_PLL stat_mode:00= disabled01= phase error stats10= dco control code_inst11= dco control code_avg
 *     STAT_SELECT      CORE_PLL stat_select:000= [ka,1'b0,ki,kp]001= stat_min, selection based on i_stat_mode[1:0]010= stat_max, selection based on i_stat_mode[1:0]011= [6'b0, wdt_latch, lock_lost, lock_stat[3:0]]100= DCO control code, can be used for open loop101= expected phase110= [config status, vco_fb_div2, pwm_rate]111= number of reference cycle needed to lock
 *     STAT_UPDATE      CORE_PLL stat_update: on the synchronized rising edge of this control signal the value selected by stat_select[2:0] is clocked into o_stat_out
 *     STAT_RESET       CORE_PLL stat_reset: reset of internal statistics meansurement, 1= reset
 *     TBUF_RESADJ      CORE_PLL output clock pad loading impedance match:00  : 50 Ohm01  : 54 Ohm10  : 46 Ohm11  : 42 Ohm
 *     TBUF_LOWPWR_EN   CORE_PLL drive strength control for CMO driver output: 0-high power mode, 1-low power mode
 *     LDO_CML2CMOS     CORE_PLL reference inputs to ldo running D2C circuits is programmable00 = 0.81 V01 =0.857V10 = 0.828V11 =0.785V
 *     D2C_TERM_EN      CORE_PLL D2C termination resistance:000       = 100 Ohm001, 010  = 133 Ohm011       = 200 Ohm101, 110  = 400 Ohm111       = no termination
 *     D2C_GATE_BIAS    CORE_PLL D2C gate voltage bias: 00-0.66V 01-0.58V 10-0.74V 11-0V
 *     D2C_TAIL_RES     CORE_PLL D2C tail resistance:000 = 950 Ohm001 = 760 Ohm010 = 630 Ohm011 = 545 Ohm100 = open101 = 3.8 KOhm110 = 1.9 KOhm111 = 1.24 KOhm
 *     PLL_RESERVED     CORE_PLL input i_reserved[4:0]
 *     RESERVED         CORE_PLL CH4_MDIV settings
 */
#define TOP_CORE_PLL_DEBUG_CTRL_2r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CORE_PLL_DEBUG_CTRL_2.
 */
typedef union TOP_CORE_PLL_DEBUG_CTRL_2r_s {
	uint32 v[1];
	uint32 top_core_pll_debug_ctrl_2[1];
	uint32 _top_core_pll_debug_ctrl_2;
} TOP_CORE_PLL_DEBUG_CTRL_2r_t;

#define TOP_CORE_PLL_DEBUG_CTRL_2r_CLR(r) (r).top_core_pll_debug_ctrl_2[0] = 0
#define TOP_CORE_PLL_DEBUG_CTRL_2r_SET(r,d) (r).top_core_pll_debug_ctrl_2[0] = d
#define TOP_CORE_PLL_DEBUG_CTRL_2r_GET(r) (r).top_core_pll_debug_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_CORE_PLL_DEBUG_CTRL_2r_STAT_MODEf_GET(r) (((r).top_core_pll_debug_ctrl_2[0]) & 0x3)
#define TOP_CORE_PLL_DEBUG_CTRL_2r_STAT_MODEf_SET(r,f) (r).top_core_pll_debug_ctrl_2[0]=(((r).top_core_pll_debug_ctrl_2[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define TOP_CORE_PLL_DEBUG_CTRL_2r_STAT_SELECTf_GET(r) ((((r).top_core_pll_debug_ctrl_2[0]) >> 2) & 0x7)
#define TOP_CORE_PLL_DEBUG_CTRL_2r_STAT_SELECTf_SET(r,f) (r).top_core_pll_debug_ctrl_2[0]=(((r).top_core_pll_debug_ctrl_2[0] & ~((uint32)0x7 << 2)) | ((((uint32)f) & 0x7) << 2))
#define TOP_CORE_PLL_DEBUG_CTRL_2r_STAT_UPDATEf_GET(r) ((((r).top_core_pll_debug_ctrl_2[0]) >> 5) & 0x1)
#define TOP_CORE_PLL_DEBUG_CTRL_2r_STAT_UPDATEf_SET(r,f) (r).top_core_pll_debug_ctrl_2[0]=(((r).top_core_pll_debug_ctrl_2[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define TOP_CORE_PLL_DEBUG_CTRL_2r_STAT_RESETf_GET(r) ((((r).top_core_pll_debug_ctrl_2[0]) >> 6) & 0x1)
#define TOP_CORE_PLL_DEBUG_CTRL_2r_STAT_RESETf_SET(r,f) (r).top_core_pll_debug_ctrl_2[0]=(((r).top_core_pll_debug_ctrl_2[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define TOP_CORE_PLL_DEBUG_CTRL_2r_TBUF_RESADJf_GET(r) ((((r).top_core_pll_debug_ctrl_2[0]) >> 7) & 0x3)
#define TOP_CORE_PLL_DEBUG_CTRL_2r_TBUF_RESADJf_SET(r,f) (r).top_core_pll_debug_ctrl_2[0]=(((r).top_core_pll_debug_ctrl_2[0] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define TOP_CORE_PLL_DEBUG_CTRL_2r_TBUF_LOWPWR_ENf_GET(r) ((((r).top_core_pll_debug_ctrl_2[0]) >> 9) & 0x1)
#define TOP_CORE_PLL_DEBUG_CTRL_2r_TBUF_LOWPWR_ENf_SET(r,f) (r).top_core_pll_debug_ctrl_2[0]=(((r).top_core_pll_debug_ctrl_2[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_CORE_PLL_DEBUG_CTRL_2r_LDO_CML2CMOSf_GET(r) ((((r).top_core_pll_debug_ctrl_2[0]) >> 10) & 0x3)
#define TOP_CORE_PLL_DEBUG_CTRL_2r_LDO_CML2CMOSf_SET(r,f) (r).top_core_pll_debug_ctrl_2[0]=(((r).top_core_pll_debug_ctrl_2[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define TOP_CORE_PLL_DEBUG_CTRL_2r_D2C_TERM_ENf_GET(r) ((((r).top_core_pll_debug_ctrl_2[0]) >> 12) & 0x7)
#define TOP_CORE_PLL_DEBUG_CTRL_2r_D2C_TERM_ENf_SET(r,f) (r).top_core_pll_debug_ctrl_2[0]=(((r).top_core_pll_debug_ctrl_2[0] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define TOP_CORE_PLL_DEBUG_CTRL_2r_D2C_GATE_BIASf_GET(r) ((((r).top_core_pll_debug_ctrl_2[0]) >> 15) & 0x3)
#define TOP_CORE_PLL_DEBUG_CTRL_2r_D2C_GATE_BIASf_SET(r,f) (r).top_core_pll_debug_ctrl_2[0]=(((r).top_core_pll_debug_ctrl_2[0] & ~((uint32)0x3 << 15)) | ((((uint32)f) & 0x3) << 15))
#define TOP_CORE_PLL_DEBUG_CTRL_2r_D2C_TAIL_RESf_GET(r) ((((r).top_core_pll_debug_ctrl_2[0]) >> 17) & 0x7)
#define TOP_CORE_PLL_DEBUG_CTRL_2r_D2C_TAIL_RESf_SET(r,f) (r).top_core_pll_debug_ctrl_2[0]=(((r).top_core_pll_debug_ctrl_2[0] & ~((uint32)0x7 << 17)) | ((((uint32)f) & 0x7) << 17))
#define TOP_CORE_PLL_DEBUG_CTRL_2r_PLL_RESERVEDf_GET(r) ((((r).top_core_pll_debug_ctrl_2[0]) >> 20) & 0x1f)
#define TOP_CORE_PLL_DEBUG_CTRL_2r_PLL_RESERVEDf_SET(r,f) (r).top_core_pll_debug_ctrl_2[0]=(((r).top_core_pll_debug_ctrl_2[0] & ~((uint32)0x1f << 20)) | ((((uint32)f) & 0x1f) << 20))
#define TOP_CORE_PLL_DEBUG_CTRL_2r_RESERVEDf_GET(r) ((((r).top_core_pll_debug_ctrl_2[0]) >> 25) & 0x7f)
#define TOP_CORE_PLL_DEBUG_CTRL_2r_RESERVEDf_SET(r,f) (r).top_core_pll_debug_ctrl_2[0]=(((r).top_core_pll_debug_ctrl_2[0] & ~((uint32)0x7f << 25)) | ((((uint32)f) & 0x7f) << 25))

/*
 * These macros can be used to access TOP_CORE_PLL_DEBUG_CTRL_2.
 */
#define WRITE_TOP_CORE_PLL_DEBUG_CTRL_2r(u,r) bcm5607x_reg_set(u,R_TOP_CORE_PLL_DEBUG_CTRL_2,(r._top_core_pll_debug_ctrl_2))
#define READ_TOP_CORE_PLL_DEBUG_CTRL_2r(u,r) bcm5607x_reg_get(u,R_TOP_CORE_PLL_DEBUG_CTRL_2,&(r._top_core_pll_debug_ctrl_2))

/*******************************************************************************
 * End of 'TOP_CORE_PLL_DEBUG_CTRL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_DEV_REV_ID
 * BLOCKS:   TOP
 * DESC:     Device/revision ID
 * SIZE:     32
 * FIELDS:
 *     DEV_ID           Device ID
 *     REV_ID           Revision ID
 *     CHIP_ID          CHIP ID
 *     RESERVED_1       Reserved
 */
#define TOP_DEV_REV_IDr_SIZE 4

/*
 * This structure should be used to declare and program TOP_DEV_REV_ID.
 */
typedef union TOP_DEV_REV_IDr_s {
	uint32 v[1];
	uint32 top_dev_rev_id[1];
	uint32 _top_dev_rev_id;
} TOP_DEV_REV_IDr_t;

#define TOP_DEV_REV_IDr_CLR(r) (r).top_dev_rev_id[0] = 0
#define TOP_DEV_REV_IDr_SET(r,d) (r).top_dev_rev_id[0] = d
#define TOP_DEV_REV_IDr_GET(r) (r).top_dev_rev_id[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_DEV_REV_IDr_DEV_IDf_GET(r) (((r).top_dev_rev_id[0]) & 0xffff)
#define TOP_DEV_REV_IDr_DEV_IDf_SET(r,f) (r).top_dev_rev_id[0]=(((r).top_dev_rev_id[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define TOP_DEV_REV_IDr_REV_IDf_GET(r) ((((r).top_dev_rev_id[0]) >> 16) & 0xff)
#define TOP_DEV_REV_IDr_REV_IDf_SET(r,f) (r).top_dev_rev_id[0]=(((r).top_dev_rev_id[0] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define TOP_DEV_REV_IDr_CHIP_IDf_GET(r) ((((r).top_dev_rev_id[0]) >> 24) & 0x7)
#define TOP_DEV_REV_IDr_CHIP_IDf_SET(r,f) (r).top_dev_rev_id[0]=(((r).top_dev_rev_id[0] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define TOP_DEV_REV_IDr_RESERVED_1f_GET(r) ((((r).top_dev_rev_id[0]) >> 27) & 0x1f)
#define TOP_DEV_REV_IDr_RESERVED_1f_SET(r,f) (r).top_dev_rev_id[0]=(((r).top_dev_rev_id[0] & ~((uint32)0x1f << 27)) | ((((uint32)f) & 0x1f) << 27))

/*
 * These macros can be used to access TOP_DEV_REV_ID.
 */
#define WRITE_TOP_DEV_REV_IDr(u,r) bcm5607x_reg_set(u,R_TOP_DEV_REV_ID,(r._top_dev_rev_id))
#define READ_TOP_DEV_REV_IDr(u,r) bcm5607x_reg_get(u,R_TOP_DEV_REV_ID,&(r._top_dev_rev_id))

/*******************************************************************************
 * End of 'TOP_DEV_REV_IDr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_L1_RCVD_CLK_CONTROL
 * BLOCKS:   TOP
 * DESC:     TOP L1 RECOVERED CLOCK Control register
 * SIZE:     32
 * FIELDS:
 *     L1_RCVD_CLK_BKUP_RSTN L1 recovered clock backup output reset (low active)
 *     L1_RCVD_CLK_RSTN L1 recovered clock output reset (low active)
 *     L1_RCVD_FREQ_SEL L1 recovery clock frequency select: 00 = As is, 01 = DIV_BY_5, 10 = DIV_BY_10, 11 = DIV_BY_2
 *     L1_RCVD_BKUP_FREQ_SEL L1 recovery clock backup version frequency select: 00 = As is, 01 = DIV_BY_5, 10 = DIV_BY_10, 11 = DIV_BY_2
 *     L1_RCVD_SW_OVWR_VALID L1 recovery clock, soft ware overwrite. When L1_RCVD_SW_OVWR_EN = 1, sw control this bit
 *     L1_RCVD_SW_OVWR_BKUP_VALID L1 recovery clock bkup version, soft ware overwrite. When L1_RCVD_SW_OVWR_EN = 1, sw control this bit
 *     L1_RCVD_SW_OVWR_EN set this bit to enable the L1_RCVD_SW_OVWR_VALID and L1_RCVD_SW_OVWR_BKUP_VALID
 *     RSVD             Reserved
 */
#define TOP_L1_RCVD_CLK_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program TOP_L1_RCVD_CLK_CONTROL.
 */
typedef union TOP_L1_RCVD_CLK_CONTROLr_s {
	uint32 v[1];
	uint32 top_l1_rcvd_clk_control[1];
	uint32 _top_l1_rcvd_clk_control;
} TOP_L1_RCVD_CLK_CONTROLr_t;

#define TOP_L1_RCVD_CLK_CONTROLr_CLR(r) (r).top_l1_rcvd_clk_control[0] = 0
#define TOP_L1_RCVD_CLK_CONTROLr_SET(r,d) (r).top_l1_rcvd_clk_control[0] = d
#define TOP_L1_RCVD_CLK_CONTROLr_GET(r) (r).top_l1_rcvd_clk_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_CLK_BKUP_RSTNf_GET(r) (((r).top_l1_rcvd_clk_control[0]) & 0x1)
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_CLK_BKUP_RSTNf_SET(r,f) (r).top_l1_rcvd_clk_control[0]=(((r).top_l1_rcvd_clk_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_CLK_RSTNf_GET(r) ((((r).top_l1_rcvd_clk_control[0]) >> 1) & 0x1)
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_CLK_RSTNf_SET(r,f) (r).top_l1_rcvd_clk_control[0]=(((r).top_l1_rcvd_clk_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_FREQ_SELf_GET(r) ((((r).top_l1_rcvd_clk_control[0]) >> 2) & 0x3)
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_FREQ_SELf_SET(r,f) (r).top_l1_rcvd_clk_control[0]=(((r).top_l1_rcvd_clk_control[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_BKUP_FREQ_SELf_GET(r) ((((r).top_l1_rcvd_clk_control[0]) >> 4) & 0x3)
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_BKUP_FREQ_SELf_SET(r,f) (r).top_l1_rcvd_clk_control[0]=(((r).top_l1_rcvd_clk_control[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_SW_OVWR_VALIDf_GET(r) ((((r).top_l1_rcvd_clk_control[0]) >> 6) & 0x1)
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_SW_OVWR_VALIDf_SET(r,f) (r).top_l1_rcvd_clk_control[0]=(((r).top_l1_rcvd_clk_control[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_SW_OVWR_BKUP_VALIDf_GET(r) ((((r).top_l1_rcvd_clk_control[0]) >> 7) & 0x1)
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_SW_OVWR_BKUP_VALIDf_SET(r,f) (r).top_l1_rcvd_clk_control[0]=(((r).top_l1_rcvd_clk_control[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_SW_OVWR_ENf_GET(r) ((((r).top_l1_rcvd_clk_control[0]) >> 8) & 0x1)
#define TOP_L1_RCVD_CLK_CONTROLr_L1_RCVD_SW_OVWR_ENf_SET(r,f) (r).top_l1_rcvd_clk_control[0]=(((r).top_l1_rcvd_clk_control[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define TOP_L1_RCVD_CLK_CONTROLr_RSVDf_GET(r) ((((r).top_l1_rcvd_clk_control[0]) >> 9) & 0x7fffff)
#define TOP_L1_RCVD_CLK_CONTROLr_RSVDf_SET(r,f) (r).top_l1_rcvd_clk_control[0]=(((r).top_l1_rcvd_clk_control[0] & ~((uint32)0x7fffff << 9)) | ((((uint32)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access TOP_L1_RCVD_CLK_CONTROL.
 */
#define WRITE_TOP_L1_RCVD_CLK_CONTROLr(u,r) bcm5607x_reg_set(u,R_TOP_L1_RCVD_CLK_CONTROL,(r._top_l1_rcvd_clk_control))
#define READ_TOP_L1_RCVD_CLK_CONTROLr(u,r) bcm5607x_reg_get(u,R_TOP_L1_RCVD_CLK_CONTROL,&(r._top_l1_rcvd_clk_control))

/*******************************************************************************
 * End of 'TOP_L1_RCVD_CLK_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_MISC_CONTROL_1
 * BLOCKS:   TOP
 * DESC:     TOP Misc Control Register 1
 * SIZE:     32
 * FIELDS:
 *     XG_PLL0_PWRDWN   LCPLL0 power down
 *     XG_PLL1_PWRDWN   LCPLL1 power down
 *     BS_PLL0_PWRDWN   BSPLL0 power down
 *     BS_PLL1_PWRDWN   BSPLL1 power down
 *     RSVD             Reserved
 *     OSC_TEST_ENABLE  set this bit to enable OSC test
 *     CMIC_TO_CORE_PLL_LOAD set this bit to enable SW overwrite to CORE PLL value
 *     CMIC_TO_TS_PLL_LOAD set this bit to enable SW overwrite to TS PLL value
 *     CMIC_TO_XG_PLL0_SW_OVWR set this bit to enable SW overwrite to LCPLL0 settings
 *     CMIC_TO_XG_PLL1_SW_OVWR set this bit to enable SW overwrite to LCPLL1 settings
 *     CMIC_TO_BS_PLL0_SW_OVWR set this bit to enable SW overwrite to BSPLL0 settings
 *     CMIC_TO_BS_PLL1_SW_OVWR set this bit to enable SW overwrite to BSPLL1 settings
 *     IO_IND_CTRL      Control ind of io pad BCM16FFCX22D33_D3333V_THP. For ATE IO characterization only
 *     IO_HYS_EN_CTRL   Control hys_en of io pad BCM16FFCX22D33_D3333V_THP. For ATE IO characterization only
 *     IO_SEL0_CTRL     Control sel0 of io pad BCM16FFCX22D33_D3333V_THP. For ATE IO characterization only
 *     IO_SEL1_CTRL     Control sel1 of io pad BCM16FFCX22D33_D3333V_THP. For ATE IO characterization only
 *     IO_SEL2_CTRL     Control sel2 of io pad BCM16FFCX22D33_D3333V_THP. For ATE IO characterization only
 *     IO_SRC_CTRL      Control src of io pad BCM16FFCX22D33_D3333V_THP. For ATE IO characterization only
 */
#define TOP_MISC_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program TOP_MISC_CONTROL_1.
 */
typedef union TOP_MISC_CONTROL_1r_s {
	uint32 v[1];
	uint32 top_misc_control_1[1];
	uint32 _top_misc_control_1;
} TOP_MISC_CONTROL_1r_t;

#define TOP_MISC_CONTROL_1r_CLR(r) (r).top_misc_control_1[0] = 0
#define TOP_MISC_CONTROL_1r_SET(r,d) (r).top_misc_control_1[0] = d
#define TOP_MISC_CONTROL_1r_GET(r) (r).top_misc_control_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_MISC_CONTROL_1r_XG_PLL0_PWRDWNf_GET(r) (((r).top_misc_control_1[0]) & 0x1)
#define TOP_MISC_CONTROL_1r_XG_PLL0_PWRDWNf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_MISC_CONTROL_1r_XG_PLL1_PWRDWNf_GET(r) ((((r).top_misc_control_1[0]) >> 1) & 0x1)
#define TOP_MISC_CONTROL_1r_XG_PLL1_PWRDWNf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TOP_MISC_CONTROL_1r_BS_PLL0_PWRDWNf_GET(r) ((((r).top_misc_control_1[0]) >> 2) & 0x1)
#define TOP_MISC_CONTROL_1r_BS_PLL0_PWRDWNf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define TOP_MISC_CONTROL_1r_BS_PLL1_PWRDWNf_GET(r) ((((r).top_misc_control_1[0]) >> 3) & 0x1)
#define TOP_MISC_CONTROL_1r_BS_PLL1_PWRDWNf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define TOP_MISC_CONTROL_1r_RSVDf_GET(r) ((((r).top_misc_control_1[0]) >> 4) & 0x3f)
#define TOP_MISC_CONTROL_1r_RSVDf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x3f << 4)) | ((((uint32)f) & 0x3f) << 4))
#define TOP_MISC_CONTROL_1r_OSC_TEST_ENABLEf_GET(r) ((((r).top_misc_control_1[0]) >> 10) & 0x1)
#define TOP_MISC_CONTROL_1r_OSC_TEST_ENABLEf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define TOP_MISC_CONTROL_1r_CMIC_TO_CORE_PLL_LOADf_GET(r) ((((r).top_misc_control_1[0]) >> 11) & 0x1)
#define TOP_MISC_CONTROL_1r_CMIC_TO_CORE_PLL_LOADf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define TOP_MISC_CONTROL_1r_CMIC_TO_TS_PLL_LOADf_GET(r) ((((r).top_misc_control_1[0]) >> 12) & 0x1)
#define TOP_MISC_CONTROL_1r_CMIC_TO_TS_PLL_LOADf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define TOP_MISC_CONTROL_1r_CMIC_TO_XG_PLL0_SW_OVWRf_GET(r) ((((r).top_misc_control_1[0]) >> 13) & 0x1)
#define TOP_MISC_CONTROL_1r_CMIC_TO_XG_PLL0_SW_OVWRf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define TOP_MISC_CONTROL_1r_CMIC_TO_XG_PLL1_SW_OVWRf_GET(r) ((((r).top_misc_control_1[0]) >> 14) & 0x1)
#define TOP_MISC_CONTROL_1r_CMIC_TO_XG_PLL1_SW_OVWRf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define TOP_MISC_CONTROL_1r_CMIC_TO_BS_PLL0_SW_OVWRf_GET(r) ((((r).top_misc_control_1[0]) >> 15) & 0x1)
#define TOP_MISC_CONTROL_1r_CMIC_TO_BS_PLL0_SW_OVWRf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define TOP_MISC_CONTROL_1r_CMIC_TO_BS_PLL1_SW_OVWRf_GET(r) ((((r).top_misc_control_1[0]) >> 16) & 0x1)
#define TOP_MISC_CONTROL_1r_CMIC_TO_BS_PLL1_SW_OVWRf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define TOP_MISC_CONTROL_1r_IO_IND_CTRLf_GET(r) ((((r).top_misc_control_1[0]) >> 26) & 0x1)
#define TOP_MISC_CONTROL_1r_IO_IND_CTRLf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define TOP_MISC_CONTROL_1r_IO_HYS_EN_CTRLf_GET(r) ((((r).top_misc_control_1[0]) >> 27) & 0x1)
#define TOP_MISC_CONTROL_1r_IO_HYS_EN_CTRLf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define TOP_MISC_CONTROL_1r_IO_SEL0_CTRLf_GET(r) ((((r).top_misc_control_1[0]) >> 28) & 0x1)
#define TOP_MISC_CONTROL_1r_IO_SEL0_CTRLf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define TOP_MISC_CONTROL_1r_IO_SEL1_CTRLf_GET(r) ((((r).top_misc_control_1[0]) >> 29) & 0x1)
#define TOP_MISC_CONTROL_1r_IO_SEL1_CTRLf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define TOP_MISC_CONTROL_1r_IO_SEL2_CTRLf_GET(r) ((((r).top_misc_control_1[0]) >> 30) & 0x1)
#define TOP_MISC_CONTROL_1r_IO_SEL2_CTRLf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define TOP_MISC_CONTROL_1r_IO_SRC_CTRLf_GET(r) ((((r).top_misc_control_1[0]) >> 31) & 0x1)
#define TOP_MISC_CONTROL_1r_IO_SRC_CTRLf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access TOP_MISC_CONTROL_1.
 */
#define WRITE_TOP_MISC_CONTROL_1r(u,r) bcm5607x_reg_set(u,R_TOP_MISC_CONTROL_1,(r._top_misc_control_1))
#define READ_TOP_MISC_CONTROL_1r(u,r) bcm5607x_reg_get(u,R_TOP_MISC_CONTROL_1,&(r._top_misc_control_1))

/*******************************************************************************
 * End of 'TOP_MISC_CONTROL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_MISC_CONTROL_2
 * BLOCKS:   TOP
 * DESC:     TOP MISC Control register 2
 * SIZE:     32
 * FIELDS:
 *     L1_RCVD_BKUP_LNKSTS_PORT_SEL L1 recovery clock backup link status port select
 *     L1_RCVD_BKUP_CLK_PORT_SEL L1 recovery clock backup port select
 *     L1_RCVD_PRI_LNKSTS_PORT_SEL L1 recovery clock link status port select
 *     L1_RCVD_PRI_CLK_PORT_SEL L1 recovery clock port select
 *     RSVD             Reserved
 */
#define TOP_MISC_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program TOP_MISC_CONTROL_2.
 */
typedef union TOP_MISC_CONTROL_2r_s {
	uint32 v[1];
	uint32 top_misc_control_2[1];
	uint32 _top_misc_control_2;
} TOP_MISC_CONTROL_2r_t;

#define TOP_MISC_CONTROL_2r_CLR(r) (r).top_misc_control_2[0] = 0
#define TOP_MISC_CONTROL_2r_SET(r,d) (r).top_misc_control_2[0] = d
#define TOP_MISC_CONTROL_2r_GET(r) (r).top_misc_control_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_MISC_CONTROL_2r_L1_RCVD_BKUP_LNKSTS_PORT_SELf_GET(r) (((r).top_misc_control_2[0]) & 0x7f)
#define TOP_MISC_CONTROL_2r_L1_RCVD_BKUP_LNKSTS_PORT_SELf_SET(r,f) (r).top_misc_control_2[0]=(((r).top_misc_control_2[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define TOP_MISC_CONTROL_2r_L1_RCVD_BKUP_CLK_PORT_SELf_GET(r) ((((r).top_misc_control_2[0]) >> 7) & 0x7f)
#define TOP_MISC_CONTROL_2r_L1_RCVD_BKUP_CLK_PORT_SELf_SET(r,f) (r).top_misc_control_2[0]=(((r).top_misc_control_2[0] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define TOP_MISC_CONTROL_2r_L1_RCVD_PRI_LNKSTS_PORT_SELf_GET(r) ((((r).top_misc_control_2[0]) >> 14) & 0x7f)
#define TOP_MISC_CONTROL_2r_L1_RCVD_PRI_LNKSTS_PORT_SELf_SET(r,f) (r).top_misc_control_2[0]=(((r).top_misc_control_2[0] & ~((uint32)0x7f << 14)) | ((((uint32)f) & 0x7f) << 14))
#define TOP_MISC_CONTROL_2r_L1_RCVD_PRI_CLK_PORT_SELf_GET(r) ((((r).top_misc_control_2[0]) >> 21) & 0x7f)
#define TOP_MISC_CONTROL_2r_L1_RCVD_PRI_CLK_PORT_SELf_SET(r,f) (r).top_misc_control_2[0]=(((r).top_misc_control_2[0] & ~((uint32)0x7f << 21)) | ((((uint32)f) & 0x7f) << 21))
#define TOP_MISC_CONTROL_2r_RSVDf_GET(r) ((((r).top_misc_control_2[0]) >> 28) & 0xf)
#define TOP_MISC_CONTROL_2r_RSVDf_SET(r,f) (r).top_misc_control_2[0]=(((r).top_misc_control_2[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access TOP_MISC_CONTROL_2.
 */
#define WRITE_TOP_MISC_CONTROL_2r(u,r) bcm5607x_reg_set(u,R_TOP_MISC_CONTROL_2,(r._top_misc_control_2))
#define READ_TOP_MISC_CONTROL_2r(u,r) bcm5607x_reg_get(u,R_TOP_MISC_CONTROL_2,&(r._top_misc_control_2))

/*******************************************************************************
 * End of 'TOP_MISC_CONTROL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_MISC_CONTROL_3
 * BLOCKS:   TOP
 * DESC:     TOP Miscellaneous Control Register 3
 * SIZE:     32
 * FIELDS:
 *     XG0_LCPLL_HO_BYP_ENABLE XG0 LCPLL holdoverlogic bypass enable
 *     XG1_LCPLL_HO_BYP_ENABLE XG1 LCPLL holdoverlogic bypass enable (obsolete)
 *     BROAD_SYNC0_LCPLL_HO_BYP_ENABLE Broad Sync -0 LCPLL holdoverlogic bypass enable
 *     BROAD_SYNC1_LCPLL_HO_BYP_ENABLE Broad Sync -1 LCPLL holdoverlogic bypass enable
 *     LCPLL_RSTFSM_STATE Holds the LCPLL reset finite state machine (FSM) current state
 *     SW_TAP_DIS       1: Disable SW TAP master drives LVTAP. FOR TEST ONLY
 *     GEPORT_EEE_POWERDOWN_EN Enable geport EEE Powerdown.
 *     XLPORT_EEE_POWERDOWN_EN Enable xlport EEE Powerdown.
 *     CLPORT_EEE_POWERDOWN_EN Enable clport EEE Powerdown.
 *     RSVD             Reserved
 *     GPIO_FOR_UPI_EN  Enable GPIO8~4 for UPI access.
 *     RVD              Reserved
 */
#define TOP_MISC_CONTROL_3r_SIZE 4

/*
 * This structure should be used to declare and program TOP_MISC_CONTROL_3.
 */
typedef union TOP_MISC_CONTROL_3r_s {
	uint32 v[1];
	uint32 top_misc_control_3[1];
	uint32 _top_misc_control_3;
} TOP_MISC_CONTROL_3r_t;

#define TOP_MISC_CONTROL_3r_CLR(r) (r).top_misc_control_3[0] = 0
#define TOP_MISC_CONTROL_3r_SET(r,d) (r).top_misc_control_3[0] = d
#define TOP_MISC_CONTROL_3r_GET(r) (r).top_misc_control_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_MISC_CONTROL_3r_XG0_LCPLL_HO_BYP_ENABLEf_GET(r) (((r).top_misc_control_3[0]) & 0x1)
#define TOP_MISC_CONTROL_3r_XG0_LCPLL_HO_BYP_ENABLEf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_MISC_CONTROL_3r_XG1_LCPLL_HO_BYP_ENABLEf_GET(r) ((((r).top_misc_control_3[0]) >> 1) & 0x1)
#define TOP_MISC_CONTROL_3r_XG1_LCPLL_HO_BYP_ENABLEf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TOP_MISC_CONTROL_3r_BROAD_SYNC0_LCPLL_HO_BYP_ENABLEf_GET(r) ((((r).top_misc_control_3[0]) >> 2) & 0x1)
#define TOP_MISC_CONTROL_3r_BROAD_SYNC0_LCPLL_HO_BYP_ENABLEf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define TOP_MISC_CONTROL_3r_BROAD_SYNC1_LCPLL_HO_BYP_ENABLEf_GET(r) ((((r).top_misc_control_3[0]) >> 3) & 0x1)
#define TOP_MISC_CONTROL_3r_BROAD_SYNC1_LCPLL_HO_BYP_ENABLEf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define TOP_MISC_CONTROL_3r_LCPLL_RSTFSM_STATEf_GET(r) ((((r).top_misc_control_3[0]) >> 4) & 0x7)
#define TOP_MISC_CONTROL_3r_LCPLL_RSTFSM_STATEf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define TOP_MISC_CONTROL_3r_SW_TAP_DISf_GET(r) ((((r).top_misc_control_3[0]) >> 7) & 0x1)
#define TOP_MISC_CONTROL_3r_SW_TAP_DISf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define TOP_MISC_CONTROL_3r_GEPORT_EEE_POWERDOWN_ENf_GET(r) ((((r).top_misc_control_3[0]) >> 10) & 0x7)
#define TOP_MISC_CONTROL_3r_GEPORT_EEE_POWERDOWN_ENf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define TOP_MISC_CONTROL_3r_XLPORT_EEE_POWERDOWN_ENf_GET(r) ((((r).top_misc_control_3[0]) >> 13) & 0x7)
#define TOP_MISC_CONTROL_3r_XLPORT_EEE_POWERDOWN_ENf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x7 << 13)) | ((((uint32)f) & 0x7) << 13))
#define TOP_MISC_CONTROL_3r_CLPORT_EEE_POWERDOWN_ENf_GET(r) ((((r).top_misc_control_3[0]) >> 16) & 0xf)
#define TOP_MISC_CONTROL_3r_CLPORT_EEE_POWERDOWN_ENf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define TOP_MISC_CONTROL_3r_RSVDf_GET(r) ((((r).top_misc_control_3[0]) >> 20) & 0x1ff)
#define TOP_MISC_CONTROL_3r_RSVDf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1ff << 20)) | ((((uint32)f) & 0x1ff) << 20))
#define TOP_MISC_CONTROL_3r_GPIO_FOR_UPI_ENf_GET(r) ((((r).top_misc_control_3[0]) >> 29) & 0x1)
#define TOP_MISC_CONTROL_3r_GPIO_FOR_UPI_ENf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define TOP_MISC_CONTROL_3r_RVDf_GET(r) ((((r).top_misc_control_3[0]) >> 30) & 0x3)
#define TOP_MISC_CONTROL_3r_RVDf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))

/*
 * These macros can be used to access TOP_MISC_CONTROL_3.
 */
#define WRITE_TOP_MISC_CONTROL_3r(u,r) bcm5607x_reg_set(u,R_TOP_MISC_CONTROL_3,(r._top_misc_control_3))
#define READ_TOP_MISC_CONTROL_3r(u,r) bcm5607x_reg_get(u,R_TOP_MISC_CONTROL_3,&(r._top_misc_control_3))

/*******************************************************************************
 * End of 'TOP_MISC_CONTROL_3r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_MISC_STATUS
 * BLOCKS:   TOP
 * DESC:     TOP Misc Status  Register
 * SIZE:     32
 * FIELDS:
 *     RSVD_0           Reserved
 *     TEST_STATUS_SEL  send the 16bits test status result to IO pad (obsolete)
 *     TEST_STATUS      [31:28] pullup enable for CMICD GPIO, [27:24] pull down enable fo CMICD GPIO; [23:16] reserved (obsolete)
 */
#define TOP_MISC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TOP_MISC_STATUS.
 */
typedef union TOP_MISC_STATUSr_s {
	uint32 v[1];
	uint32 top_misc_status[1];
	uint32 _top_misc_status;
} TOP_MISC_STATUSr_t;

#define TOP_MISC_STATUSr_CLR(r) (r).top_misc_status[0] = 0
#define TOP_MISC_STATUSr_SET(r,d) (r).top_misc_status[0] = d
#define TOP_MISC_STATUSr_GET(r) (r).top_misc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_MISC_STATUSr_RSVD_0f_GET(r) (((r).top_misc_status[0]) & 0x7fff)
#define TOP_MISC_STATUSr_RSVD_0f_SET(r,f) (r).top_misc_status[0]=(((r).top_misc_status[0] & ~((uint32)0x7fff)) | (((uint32)f) & 0x7fff))
#define TOP_MISC_STATUSr_TEST_STATUS_SELf_GET(r) ((((r).top_misc_status[0]) >> 15) & 0x1)
#define TOP_MISC_STATUSr_TEST_STATUS_SELf_SET(r,f) (r).top_misc_status[0]=(((r).top_misc_status[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define TOP_MISC_STATUSr_TEST_STATUSf_GET(r) ((((r).top_misc_status[0]) >> 16) & 0xffff)
#define TOP_MISC_STATUSr_TEST_STATUSf_SET(r,f) (r).top_misc_status[0]=(((r).top_misc_status[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access TOP_MISC_STATUS.
 */
#define WRITE_TOP_MISC_STATUSr(u,r) bcm5607x_reg_set(u,R_TOP_MISC_STATUS,(r._top_misc_status))
#define READ_TOP_MISC_STATUSr(u,r) bcm5607x_reg_get(u,R_TOP_MISC_STATUS,&(r._top_misc_status))

/*******************************************************************************
 * End of 'TOP_MISC_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_PVTMON_CTRL_0
 * BLOCKS:   TOP
 * DESC:     PVT Monitor Control Register 0
 * SIZE:     32
 * FIELDS:
 *     BG_ADJ           Bandgap Voltage (Vbg) adjustment.111:Vbg=1.226V110:Vbg=1.220V101:Vbg=1.215V100:Vbg=1.211V000:Vbg=1.205V001:Vbg=1.200V010:Vbg=1.195V011:Vbg=1.191Voutput voltage step size Vbg_u = Vbg/241 =5mV (nom)
 *     VTEST_SEL        Select one of the 16 internal test voltages (Vtest) for a quick ADC test.0000: Vtest = i_VDDC * 1/200001: Vtest = i_VDDC * 2/20...1111: Vtest = i_VDDC * 16/20
 *     RMON_SEL         Resistor monitor select111: external resistor110: reserved101: internal resistor (width=1u, Horizontal)100: internal resistor (width=1u, Vertical)011: internal resistor (width=0.5u, Horizontal)010: internal resistor (width=0.5u, Vertical)001: internal resistor (width=0.25u, Horizontal)000: internal resistor (width=0.25u, Vertical)
 *     FUNC_MODE        Function mode control000: VTMON only001: VTMON and DAC010: Burn-in CLKGEN011: DAC drives both pads (AVS control)100: ADC measures external input on pad_ADC101: ADC measures DAC output110: RMON111: expert mode (controlled by i_ctrl<17:13>)
 *     ADC_IN_SEL       effective only when i_ctrl<12:10>=3'b111ADC input select00: VTMON output01: external input on pad_ADC10: DAC output11: RMON output
 *     DAC_EN           effective only when i_ctrl<12:10>=3'b111Enable DAC when high
 *     CON_PAD          effective only when i_ctrl<12:10>=3'b111connect pad_DAC and pad_ADC when high
 *     BURNIN_EN        effective only when i_ctrl<12:10>=3'b111Enable Burn-in CLKGEN when high
 *     RSVD             Reserved
 *     VDDCMON_REFADJ_MAX1 Adjustment of VDDCMON voltage threshold: Vmax1.    Vbg_u is the Bandgap voltage step size (nom.=5mV, see i_ctrl<2:0>)Vmax11 : 227*Vbg_u (1.135V)0 : 220*Vbg_u (1.100V)
 *     VDDCMON_REFADJ_MIN0 Adjustment of VDDCMON voltage thresholds: Vwarn0 and Vmin0. Vbg is the Bandgap voltage (see i_ctrl<2:0>)Vwarn0 (Default) Vmin0 (Default)1111: 186*Vbg/240 (0.930V) 178*Vbg/240 (0.890V)1110: 184*Vbg/240 (0.920V) 176*Vbg/240 (0.880V)1101: 182*Vbg/240 (0.910V) 174*Vbg/240 (0.870V)1100: 180*Vbg/240 (0.900V) 172*Vbg/240 (0.860V)1011: 178*Vbg/240 (0.890V) 170*Vbg/240 (0.850V)1010: 176*Vbg/240 (0.880V) 168*Vbg/240 (0.840V)1001: 174*Vbg/240 (0.870V) 166*Vbg/240 (0.830V)1000: 172*Vbg/240 (0.860V) 164*Vbg/240 (0.820V)0000: 170*Vbg/240 (0.850V) 162*Vbg/240 (0.810V)0001: 168*Vbg/240 (0.840V) 160*Vbg/240 (0.800V)0010: 166*Vbg/240 (0.830V) 158*Vbg/240 (0.790V)0011: 164*Vbg/240 (0.820V) 156*Vbg/240 (0.780V)0100: 162*Vbg/240 (0.810V) 154*Vbg/240 (0.770V)0101: 160*Vbg/240 (0.800V) 152*Vbg/240 (0.760V)0110: 158*Vbg/240 (0.790V) 150*Vbg/240 (0.750V)0111: 156*Vbg/240 (0.780V) 148*Vbg/240 (0.740V)
 *     VDDCMON_REFADJ_MIN1 Adjustment of VDDCMON voltage thresholds: Vwarn1 and Vmin1. Vbg is the Bandgap voltage (see i_ctrl<2:0>)Vwarn1 (Default) Vmin1 (Default)111: 176*Vbg/240 (0.880V) 168*Vbg/240 (0.840V)110: 174*Vbg/240 (0.870V) 166*Vbg/240 (0.830V)101: 172*Vbg/240 (0.860V) 164*Vbg/240 (0.820V)100: 171*Vbg/240 (0.855V) 163*Vbg/240 (0.815V)000: 170*Vbg/240 (0.850V) 162*Vbg/240 (0.810V)001: 169*Vbg/240 (0.845V) 161*Vbg/240 (0.805V)010: 168*Vbg/240 (0.840V) 160*Vbg/240 (0.800V)011: 166*Vbg/240 (0.830V) 158*Vbg/240 (0.790V)
 *     DAC_RESET        Force DAC output voltage to min, high active
 *     DAC_SET          Force DAC output voltage to max, high active
 *     VDDCMON_REFADJ_MAX Adjustment of VDDCMON voltage threshold: Vmax0.Vbg is the Bandgap voltage (see i_ctrl<2:0>)Vmax1 (Default) = 220*Vbg/240 (1.10V)Vmax0 (Default)111: 194*Vbg/240 (0.970V)110: 192*Vbg/240 (0.960V)101: 190*Vbg/240 (0.950V)100: 189*Vbg/240 (0.945V)000: 188*Vbg/240 (0.940V)001: 187*Vbg/240 (0.935V)010: 186*Vbg/240 (0.930V)011: 184*Vbg/240 (0.920V)
 */
#define TOP_PVTMON_CTRL_0r_SIZE 4

/*
 * This structure should be used to declare and program TOP_PVTMON_CTRL_0.
 */
typedef union TOP_PVTMON_CTRL_0r_s {
	uint32 v[1];
	uint32 top_pvtmon_ctrl_0[1];
	uint32 _top_pvtmon_ctrl_0;
} TOP_PVTMON_CTRL_0r_t;

#define TOP_PVTMON_CTRL_0r_CLR(r) (r).top_pvtmon_ctrl_0[0] = 0
#define TOP_PVTMON_CTRL_0r_SET(r,d) (r).top_pvtmon_ctrl_0[0] = d
#define TOP_PVTMON_CTRL_0r_GET(r) (r).top_pvtmon_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_PVTMON_CTRL_0r_BG_ADJf_GET(r) (((r).top_pvtmon_ctrl_0[0]) & 0x7)
#define TOP_PVTMON_CTRL_0r_BG_ADJf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define TOP_PVTMON_CTRL_0r_VTEST_SELf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 3) & 0xf)
#define TOP_PVTMON_CTRL_0r_VTEST_SELf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0xf << 3)) | ((((uint32)f) & 0xf) << 3))
#define TOP_PVTMON_CTRL_0r_RMON_SELf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 7) & 0x7)
#define TOP_PVTMON_CTRL_0r_RMON_SELf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x7 << 7)) | ((((uint32)f) & 0x7) << 7))
#define TOP_PVTMON_CTRL_0r_FUNC_MODEf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 10) & 0x7)
#define TOP_PVTMON_CTRL_0r_FUNC_MODEf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define TOP_PVTMON_CTRL_0r_ADC_IN_SELf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 13) & 0x3)
#define TOP_PVTMON_CTRL_0r_ADC_IN_SELf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define TOP_PVTMON_CTRL_0r_DAC_ENf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 15) & 0x1)
#define TOP_PVTMON_CTRL_0r_DAC_ENf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define TOP_PVTMON_CTRL_0r_CON_PADf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 16) & 0x1)
#define TOP_PVTMON_CTRL_0r_CON_PADf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define TOP_PVTMON_CTRL_0r_BURNIN_ENf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 17) & 0x1)
#define TOP_PVTMON_CTRL_0r_BURNIN_ENf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define TOP_PVTMON_CTRL_0r_RSVDf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 18) & 0x1)
#define TOP_PVTMON_CTRL_0r_RSVDf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MAX1f_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 19) & 0x1)
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MAX1f_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MIN0f_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 20) & 0xf)
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MIN0f_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MIN1f_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 24) & 0x7)
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MIN1f_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define TOP_PVTMON_CTRL_0r_DAC_RESETf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 27) & 0x1)
#define TOP_PVTMON_CTRL_0r_DAC_RESETf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define TOP_PVTMON_CTRL_0r_DAC_SETf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 28) & 0x1)
#define TOP_PVTMON_CTRL_0r_DAC_SETf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MAXf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 29) & 0x7)
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MAXf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))

/*
 * These macros can be used to access TOP_PVTMON_CTRL_0.
 */
#define WRITE_TOP_PVTMON_CTRL_0r(u,r) bcm5607x_reg_set(u,R_TOP_PVTMON_CTRL_0,(r._top_pvtmon_ctrl_0))
#define READ_TOP_PVTMON_CTRL_0r(u,r) bcm5607x_reg_get(u,R_TOP_PVTMON_CTRL_0,&(r._top_pvtmon_ctrl_0))

/*******************************************************************************
 * End of 'TOP_PVTMON_CTRL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_SOFT_RESET_REG
 * BLOCKS:   TOP
 * DESC:     TOP Soft Reset register
 * SIZE:     32
 * FIELDS:
 *     TOP_IP_RST_L     IP Reset (active low)
 *     TOP_EP_RST_L     EP Reset (active low)
 *     TOP_MMU_RST_L    MMU Reset (active low)
 *     TOP_GEP0_RST_L   GE port0 Reset (active low)
 *     TOP_GEP1_RST_L   GE port1 Reset (active low)
 *     TOP_GEP2_RST_L   GE port2 Reset (active low)
 *     TOP_XLP0_RST_L   XL port0 Reset (active low)
 *     TOP_XLP1_RST_L   XL port1 Reset (active low)
 *     TOP_XLP2_RST_L   XL port2 Reset (active low)
 *     TOP_CLP0_RST_L   CL port0 Reset (active low)
 *     TOP_CLP1_RST_L   CL port0 Reset (active low)
 *     TOP_CLP2_RST_L   CL port0 Reset (active low)
 *     TOP_CLP3_RST_L   CL port0 Reset (active low)
 *     TOP_SPARE_RST_L  Reserved.
 *     TOP_TS_RST_L     Network TimeSync Reset (active low)
 *     RSVD_19          Reserved
 *     TOP_LCPLL_SOFT_RESET Write 1 to this bit to reset all the LCPLL/BSPLL, LCPLL_RSTFSM goes to RESET state.
 *     TOP_TSCQ0_RST_L  TSCQ0 core Reset (active low)
 *     TOP_TSCQ1_RST_L  TSCQ1 core Reset (active low)
 *     TOP_TSCQ2_RST_L  TSCQ2 core Reset (active low)
 *     TOP_TSCF0_RST_L  TSCF0 core Reset (active low)
 *     TOP_TSCF1_RST_L  TSCF1 core Reset (active low)
 *     TOP_TSCF2_RST_L  TSCF2 core Reset (active low)
 *     TOP_TSCF3_RST_L  TSCF3 core Reset (active low)
 *     TOP_MACSEC_RST_L MACSEC Reset (active low)
 *     RSVD             Reserved
 */
#define TOP_SOFT_RESET_REGr_SIZE 4

/*
 * This structure should be used to declare and program TOP_SOFT_RESET_REG.
 */
typedef union TOP_SOFT_RESET_REGr_s {
	uint32 v[1];
	uint32 top_soft_reset_reg[1];
	uint32 _top_soft_reset_reg;
} TOP_SOFT_RESET_REGr_t;

#define TOP_SOFT_RESET_REGr_CLR(r) (r).top_soft_reset_reg[0] = 0
#define TOP_SOFT_RESET_REGr_SET(r,d) (r).top_soft_reset_reg[0] = d
#define TOP_SOFT_RESET_REGr_GET(r) (r).top_soft_reset_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_SOFT_RESET_REGr_TOP_IP_RST_Lf_GET(r) (((r).top_soft_reset_reg[0]) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_IP_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_SOFT_RESET_REGr_TOP_EP_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 1) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_EP_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TOP_SOFT_RESET_REGr_TOP_MMU_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 2) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_MMU_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define TOP_SOFT_RESET_REGr_TOP_GEP0_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 3) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_GEP0_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define TOP_SOFT_RESET_REGr_TOP_GEP1_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 4) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_GEP1_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define TOP_SOFT_RESET_REGr_TOP_GEP2_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 5) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_GEP2_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define TOP_SOFT_RESET_REGr_TOP_XLP0_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 6) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_XLP0_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define TOP_SOFT_RESET_REGr_TOP_XLP1_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 7) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_XLP1_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define TOP_SOFT_RESET_REGr_TOP_XLP2_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 8) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_XLP2_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define TOP_SOFT_RESET_REGr_TOP_CLP0_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 9) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_CLP0_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_SOFT_RESET_REGr_TOP_CLP1_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 10) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_CLP1_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define TOP_SOFT_RESET_REGr_TOP_CLP2_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 11) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_CLP2_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define TOP_SOFT_RESET_REGr_TOP_CLP3_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 12) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_CLP3_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define TOP_SOFT_RESET_REGr_TOP_SPARE_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 13) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_SPARE_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define TOP_SOFT_RESET_REGr_TOP_TS_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 14) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_TS_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define TOP_SOFT_RESET_REGr_RSVD_19f_GET(r) ((((r).top_soft_reset_reg[0]) >> 15) & 0x1f)
#define TOP_SOFT_RESET_REGr_RSVD_19f_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1f << 15)) | ((((uint32)f) & 0x1f) << 15))
#define TOP_SOFT_RESET_REGr_TOP_LCPLL_SOFT_RESETf_GET(r) ((((r).top_soft_reset_reg[0]) >> 20) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_LCPLL_SOFT_RESETf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define TOP_SOFT_RESET_REGr_TOP_TSCQ0_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 21) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_TSCQ0_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define TOP_SOFT_RESET_REGr_TOP_TSCQ1_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 22) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_TSCQ1_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define TOP_SOFT_RESET_REGr_TOP_TSCQ2_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 23) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_TSCQ2_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define TOP_SOFT_RESET_REGr_TOP_TSCF0_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 24) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_TSCF0_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define TOP_SOFT_RESET_REGr_TOP_TSCF1_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 25) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_TSCF1_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define TOP_SOFT_RESET_REGr_TOP_TSCF2_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 26) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_TSCF2_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define TOP_SOFT_RESET_REGr_TOP_TSCF3_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 27) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_TSCF3_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define TOP_SOFT_RESET_REGr_TOP_MACSEC_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 28) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_MACSEC_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define TOP_SOFT_RESET_REGr_RSVDf_GET(r) ((((r).top_soft_reset_reg[0]) >> 29) & 0x7)
#define TOP_SOFT_RESET_REGr_RSVDf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))

/*
 * These macros can be used to access TOP_SOFT_RESET_REG.
 */
#define WRITE_TOP_SOFT_RESET_REGr(u,r) bcm5607x_reg_set(u,R_TOP_SOFT_RESET_REG,(r._top_soft_reset_reg))
#define READ_TOP_SOFT_RESET_REGr(u,r) bcm5607x_reg_get(u,R_TOP_SOFT_RESET_REG,&(r._top_soft_reset_reg))

/*******************************************************************************
 * End of 'TOP_SOFT_RESET_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_SOFT_RESET_REG_2
 * BLOCKS:   TOP
 * DESC:     TOP Soft Reset register 2
 * SIZE:     32
 * FIELDS:
 *     TOP_XG_PLL0_RST_L XG_PLL0 (for PM4x10Q) Reset (active low): Obsolete
 *     TOP_XG_PLL0_POST_RST_L XG_PLL0 (for PM4x10Q) Post Reset (active low): Obsolete
 *     TOP_XG_PLL1_RST_L XG_PLL1 (for TSCF) Reset (active low): Obosolete
 *     TOP_XG_PLL1_POST_RST_L XG_PLL1 (for TSCF) Post Reset (active low): Obsolete
 *     RSVD_6           Reserved
 *     TOP_PGW_PLL_RST_L PGW_PLL Reset (active low)
 *     TOP_TS_PLL_RST_L TS_PLL Reset (active low)
 *     TOP_TS_PLL_POST_RST_L TS_PLL Post Reset (active low)
 *     TOP_BS_PLL0_RST_L BS_PLL0 Reset (active low): Obsolete
 *     TOP_BS_PLL0_POST_RST_L BS_PLL0 Post Reset (active low): Obsolete
 *     TOP_BS_PLL1_RST_L BS_PLL1 Reset (active low): Obsolete
 *     TOP_BS_PLL1_POST_RST_L BS_PLL1 Post Reset (active low): Obsolete
 *     TOP_PGW_PLL_POST_RST_L PGW_PLL Post Reset (active low)
 *     RSVD_15          Reserved
 *     TOP_TEMP_MON_PEAK_RST_L Temperature Monitor peak value Reset (active low)
 *     RSVD_17          Reserved
 */
#define TOP_SOFT_RESET_REG_2r_SIZE 4

/*
 * This structure should be used to declare and program TOP_SOFT_RESET_REG_2.
 */
typedef union TOP_SOFT_RESET_REG_2r_s {
	uint32 v[1];
	uint32 top_soft_reset_reg_2[1];
	uint32 _top_soft_reset_reg_2;
} TOP_SOFT_RESET_REG_2r_t;

#define TOP_SOFT_RESET_REG_2r_CLR(r) (r).top_soft_reset_reg_2[0] = 0
#define TOP_SOFT_RESET_REG_2r_SET(r,d) (r).top_soft_reset_reg_2[0] = d
#define TOP_SOFT_RESET_REG_2r_GET(r) (r).top_soft_reset_reg_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_SOFT_RESET_REG_2r_TOP_XG_PLL0_RST_Lf_GET(r) (((r).top_soft_reset_reg_2[0]) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_XG_PLL0_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_SOFT_RESET_REG_2r_TOP_XG_PLL0_POST_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 1) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_XG_PLL0_POST_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TOP_SOFT_RESET_REG_2r_TOP_XG_PLL1_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 2) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_XG_PLL1_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define TOP_SOFT_RESET_REG_2r_TOP_XG_PLL1_POST_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 3) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_XG_PLL1_POST_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define TOP_SOFT_RESET_REG_2r_RSVD_6f_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 4) & 0x7)
#define TOP_SOFT_RESET_REG_2r_RSVD_6f_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define TOP_SOFT_RESET_REG_2r_TOP_PGW_PLL_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 7) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_PGW_PLL_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define TOP_SOFT_RESET_REG_2r_TOP_TS_PLL_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 8) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_TS_PLL_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define TOP_SOFT_RESET_REG_2r_TOP_TS_PLL_POST_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 9) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_TS_PLL_POST_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_SOFT_RESET_REG_2r_TOP_BS_PLL0_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 10) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_BS_PLL0_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define TOP_SOFT_RESET_REG_2r_TOP_BS_PLL0_POST_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 11) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_BS_PLL0_POST_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define TOP_SOFT_RESET_REG_2r_TOP_BS_PLL1_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 12) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_BS_PLL1_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define TOP_SOFT_RESET_REG_2r_TOP_BS_PLL1_POST_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 13) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_BS_PLL1_POST_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define TOP_SOFT_RESET_REG_2r_TOP_PGW_PLL_POST_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 14) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_PGW_PLL_POST_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define TOP_SOFT_RESET_REG_2r_RSVD_15f_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 15) & 0x1)
#define TOP_SOFT_RESET_REG_2r_RSVD_15f_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define TOP_SOFT_RESET_REG_2r_TOP_TEMP_MON_PEAK_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 16) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_TEMP_MON_PEAK_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define TOP_SOFT_RESET_REG_2r_RSVD_17f_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 17) & 0x7fff)
#define TOP_SOFT_RESET_REG_2r_RSVD_17f_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x7fff << 17)) | ((((uint32)f) & 0x7fff) << 17))

/*
 * These macros can be used to access TOP_SOFT_RESET_REG_2.
 */
#define WRITE_TOP_SOFT_RESET_REG_2r(u,r) bcm5607x_reg_set(u,R_TOP_SOFT_RESET_REG_2,(r._top_soft_reset_reg_2))
#define READ_TOP_SOFT_RESET_REG_2r(u,r) bcm5607x_reg_get(u,R_TOP_SOFT_RESET_REG_2,&(r._top_soft_reset_reg_2))

/*******************************************************************************
 * End of 'TOP_SOFT_RESET_REG_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_STRAP_STATUS
 * BLOCKS:   TOP
 * DESC:     top strap pin status register
 * SIZE:     32
 * FIELDS:
 *     STRAP_BOOT_DEV   strap_boot_dev 0 : SPI NOR flash, starting at 0x1E00_0000 1 : NAND flash, starting at 0x1C00_0000 2 : Boot ROM, starting at 0xFFFD_0000 3 : Host processor (code are expected to be directly fetched and executed from external host memory) 4 : Parallel NOR flash 7: ATE mode
 *     STRAP_IPROC_MHOST1_BOOT_DEV strap_iproc_mhost1_boot_dev 0 : ROM 1 : External
 *     STRAP_IPROC_MHOST0_BOOT_DEV strap_iproc_mhost0_boot_dev 0 : ROM 1 : External
 *     STRAP_IPROC_DISABLE_MHOST1 strap_iproc_disable_mhost1 0 : Enable 1 : Disable
 *     STRAP_IPROC_DISABLE_MHOST0 strap_iproc_disable_mhost0 0 : Enable 1 : Disable
 *     STRAP_IPROC_I2C2_SA strap_iproc_i2c_sa 0 : addr is 0x80 1 : addr is 0x81 2 : addr is 0x82 3 : addr is 0x83
 *     STRAP_IPROC_SPI_CHIPID strap_iproc_spi_chipid
 *     STRAP_QSPI_QUAD_LANE QSPI quad lane
 *     STRAP_QSPI_DUAL_LANE QSPI quad lane
 *     STRAP_QSPI_ADDR_BPC_MODE QSPI quad lane
 *     STRAP_QSPI_4BYTE_ADDR strap_qspi_4byte_addr 0 : SPI 3-byte addressing mode 1 : SPI 4-byte addressing mode
 *     STRAP_PCIE_FORCE_GEN strap_pcie_force_gen1 0 : Gen3 1 : Gen1 2 : Gen2
 *     STRAP_LCPLL1_REFCLK_SEL strap_lcpll1_refclk_sel 0 : from LCPLL1 differential pad 1 : from i_refclk, Xtal
 *     STRAP_XTAL_FREQ_SEL strap_xtal_freq_sel 0 : XTAL output clock frequence is 25MHz. 1 : XTAL output clock frequence is 50MHz.
 *     STRAP_XTAL_BYPASS XTAL bypass
 *     STRAP_XTAL_CORE_CUR XTAL core current
 *     STRAP_TSCQ0_PWR_OFF  0 : Indicate Power is On 1 : Indicate Power is Off
 *     STRAP_TSCQ1_PWR_OFF  0 : Indicate Power is On 1 : Indicate Power is Off
 *     STRAP_TSCQ2_PWR_OFF  0 : Indicate Power is On 1 : Indicate Power is Off
 *     STRAP_TSCF0_PWR_OFF  0 : Indicate Power is On 1 : Indicate Power is Off
 *     STRAP_TSCF1_PWR_OFF  0 : Indicate Power is On 1 : Indicate Power is Off
 *     STRAP_TSCF2_PWR_OFF  0 : Indicate Power is On 1 : Indicate Power is Off
 *     STRAP_TSCF3_PWR_OFF  0 : Indicate Power is On 1 : Indicate Power is Off
 *     STRAP_MACSEC_ING_BYP_EN MACSEC ingress bypass
 *     STRAP_MACSEC_EGR_BYP_EN MACSEC egress bypass
 */
#define TOP_STRAP_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TOP_STRAP_STATUS.
 */
typedef union TOP_STRAP_STATUSr_s {
	uint32 v[1];
	uint32 top_strap_status[1];
	uint32 _top_strap_status;
} TOP_STRAP_STATUSr_t;

#define TOP_STRAP_STATUSr_CLR(r) (r).top_strap_status[0] = 0
#define TOP_STRAP_STATUSr_SET(r,d) (r).top_strap_status[0] = d
#define TOP_STRAP_STATUSr_GET(r) (r).top_strap_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_STRAP_STATUSr_STRAP_BOOT_DEVf_GET(r) (((r).top_strap_status[0]) & 0x7)
#define TOP_STRAP_STATUSr_STRAP_BOOT_DEVf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define TOP_STRAP_STATUSr_STRAP_IPROC_MHOST1_BOOT_DEVf_GET(r) ((((r).top_strap_status[0]) >> 3) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_IPROC_MHOST1_BOOT_DEVf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define TOP_STRAP_STATUSr_STRAP_IPROC_MHOST0_BOOT_DEVf_GET(r) ((((r).top_strap_status[0]) >> 4) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_IPROC_MHOST0_BOOT_DEVf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define TOP_STRAP_STATUSr_STRAP_IPROC_DISABLE_MHOST1f_GET(r) ((((r).top_strap_status[0]) >> 5) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_IPROC_DISABLE_MHOST1f_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define TOP_STRAP_STATUSr_STRAP_IPROC_DISABLE_MHOST0f_GET(r) ((((r).top_strap_status[0]) >> 6) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_IPROC_DISABLE_MHOST0f_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define TOP_STRAP_STATUSr_STRAP_IPROC_I2C2_SAf_GET(r) ((((r).top_strap_status[0]) >> 7) & 0x3)
#define TOP_STRAP_STATUSr_STRAP_IPROC_I2C2_SAf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define TOP_STRAP_STATUSr_STRAP_IPROC_SPI_CHIPIDf_GET(r) ((((r).top_strap_status[0]) >> 9) & 0x7)
#define TOP_STRAP_STATUSr_STRAP_IPROC_SPI_CHIPIDf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define TOP_STRAP_STATUSr_STRAP_QSPI_QUAD_LANEf_GET(r) ((((r).top_strap_status[0]) >> 12) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_QSPI_QUAD_LANEf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define TOP_STRAP_STATUSr_STRAP_QSPI_DUAL_LANEf_GET(r) ((((r).top_strap_status[0]) >> 13) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_QSPI_DUAL_LANEf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define TOP_STRAP_STATUSr_STRAP_QSPI_ADDR_BPC_MODEf_GET(r) ((((r).top_strap_status[0]) >> 14) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_QSPI_ADDR_BPC_MODEf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define TOP_STRAP_STATUSr_STRAP_QSPI_4BYTE_ADDRf_GET(r) ((((r).top_strap_status[0]) >> 15) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_QSPI_4BYTE_ADDRf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define TOP_STRAP_STATUSr_STRAP_PCIE_FORCE_GENf_GET(r) ((((r).top_strap_status[0]) >> 16) & 0x3)
#define TOP_STRAP_STATUSr_STRAP_PCIE_FORCE_GENf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define TOP_STRAP_STATUSr_STRAP_LCPLL1_REFCLK_SELf_GET(r) ((((r).top_strap_status[0]) >> 18) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_LCPLL1_REFCLK_SELf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define TOP_STRAP_STATUSr_STRAP_XTAL_FREQ_SELf_GET(r) ((((r).top_strap_status[0]) >> 19) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_XTAL_FREQ_SELf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define TOP_STRAP_STATUSr_STRAP_XTAL_BYPASSf_GET(r) ((((r).top_strap_status[0]) >> 20) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_XTAL_BYPASSf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define TOP_STRAP_STATUSr_STRAP_XTAL_CORE_CURf_GET(r) ((((r).top_strap_status[0]) >> 21) & 0x3)
#define TOP_STRAP_STATUSr_STRAP_XTAL_CORE_CURf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define TOP_STRAP_STATUSr_STRAP_TSCQ0_PWR_OFFf_GET(r) ((((r).top_strap_status[0]) >> 23) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_TSCQ0_PWR_OFFf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define TOP_STRAP_STATUSr_STRAP_TSCQ1_PWR_OFFf_GET(r) ((((r).top_strap_status[0]) >> 24) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_TSCQ1_PWR_OFFf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define TOP_STRAP_STATUSr_STRAP_TSCQ2_PWR_OFFf_GET(r) ((((r).top_strap_status[0]) >> 25) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_TSCQ2_PWR_OFFf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define TOP_STRAP_STATUSr_STRAP_TSCF0_PWR_OFFf_GET(r) ((((r).top_strap_status[0]) >> 26) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_TSCF0_PWR_OFFf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define TOP_STRAP_STATUSr_STRAP_TSCF1_PWR_OFFf_GET(r) ((((r).top_strap_status[0]) >> 27) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_TSCF1_PWR_OFFf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define TOP_STRAP_STATUSr_STRAP_TSCF2_PWR_OFFf_GET(r) ((((r).top_strap_status[0]) >> 28) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_TSCF2_PWR_OFFf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define TOP_STRAP_STATUSr_STRAP_TSCF3_PWR_OFFf_GET(r) ((((r).top_strap_status[0]) >> 29) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_TSCF3_PWR_OFFf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define TOP_STRAP_STATUSr_STRAP_MACSEC_ING_BYP_ENf_GET(r) ((((r).top_strap_status[0]) >> 30) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_MACSEC_ING_BYP_ENf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define TOP_STRAP_STATUSr_STRAP_MACSEC_EGR_BYP_ENf_GET(r) ((((r).top_strap_status[0]) >> 31) & 0x1)
#define TOP_STRAP_STATUSr_STRAP_MACSEC_EGR_BYP_ENf_SET(r,f) (r).top_strap_status[0]=(((r).top_strap_status[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access TOP_STRAP_STATUS.
 */
#define WRITE_TOP_STRAP_STATUSr(u,r) bcm5607x_reg_set(u,R_TOP_STRAP_STATUS,(r._top_strap_status))
#define READ_TOP_STRAP_STATUSr(u,r) bcm5607x_reg_get(u,R_TOP_STRAP_STATUS,&(r._top_strap_status))

/*******************************************************************************
 * End of 'TOP_STRAP_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_STRAP_STATUS_1
 * BLOCKS:   TOP
 * DESC:     top strap pin status 1 register
 * SIZE:     32
 * FIELDS:
 *     STRAP_ENABLE_RCPU_ACCESS_FOR_ATE Bit 0: strap_enable_rcpu_access_for_ate
 *     STRAP_BYPASS_IPROC_MDIO_FOR_ATE Bit 0: strap_enable_rcpu_access_for_ate
 *     STRAP_ALL_PLL_BYPASS Bit 19: strap_all_pll_bypass 0 : Use PLL 1 : Bypass PLL
 *     STRAP_BYPASS_AUTOLOAD Bit 20: strap_bypass_autoload 0: No bypass 1: Bypass
 *     STRAP_DIS_LVM    Bit 10: strap_dis_lvm 0 : Enable LVM 1 : Disable LVM
 *     STRAP_BURN_IN    Bit 26:strap_burm_in 0 : normal mode 1 : burn-in mode
 *     RSVD             Reserved
 */
#define TOP_STRAP_STATUS_1r_SIZE 4

/*
 * This structure should be used to declare and program TOP_STRAP_STATUS_1.
 */
typedef union TOP_STRAP_STATUS_1r_s {
	uint32 v[1];
	uint32 top_strap_status_1[1];
	uint32 _top_strap_status_1;
} TOP_STRAP_STATUS_1r_t;

#define TOP_STRAP_STATUS_1r_CLR(r) (r).top_strap_status_1[0] = 0
#define TOP_STRAP_STATUS_1r_SET(r,d) (r).top_strap_status_1[0] = d
#define TOP_STRAP_STATUS_1r_GET(r) (r).top_strap_status_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_STRAP_STATUS_1r_STRAP_ENABLE_RCPU_ACCESS_FOR_ATEf_GET(r) (((r).top_strap_status_1[0]) & 0x1)
#define TOP_STRAP_STATUS_1r_STRAP_ENABLE_RCPU_ACCESS_FOR_ATEf_SET(r,f) (r).top_strap_status_1[0]=(((r).top_strap_status_1[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_STRAP_STATUS_1r_STRAP_BYPASS_IPROC_MDIO_FOR_ATEf_GET(r) ((((r).top_strap_status_1[0]) >> 1) & 0x1)
#define TOP_STRAP_STATUS_1r_STRAP_BYPASS_IPROC_MDIO_FOR_ATEf_SET(r,f) (r).top_strap_status_1[0]=(((r).top_strap_status_1[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TOP_STRAP_STATUS_1r_STRAP_ALL_PLL_BYPASSf_GET(r) ((((r).top_strap_status_1[0]) >> 3) & 0x1)
#define TOP_STRAP_STATUS_1r_STRAP_ALL_PLL_BYPASSf_SET(r,f) (r).top_strap_status_1[0]=(((r).top_strap_status_1[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define TOP_STRAP_STATUS_1r_STRAP_BYPASS_AUTOLOADf_GET(r) ((((r).top_strap_status_1[0]) >> 4) & 0x1)
#define TOP_STRAP_STATUS_1r_STRAP_BYPASS_AUTOLOADf_SET(r,f) (r).top_strap_status_1[0]=(((r).top_strap_status_1[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define TOP_STRAP_STATUS_1r_STRAP_DIS_LVMf_GET(r) ((((r).top_strap_status_1[0]) >> 5) & 0x1)
#define TOP_STRAP_STATUS_1r_STRAP_DIS_LVMf_SET(r,f) (r).top_strap_status_1[0]=(((r).top_strap_status_1[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define TOP_STRAP_STATUS_1r_STRAP_BURN_INf_GET(r) ((((r).top_strap_status_1[0]) >> 6) & 0x1)
#define TOP_STRAP_STATUS_1r_STRAP_BURN_INf_SET(r,f) (r).top_strap_status_1[0]=(((r).top_strap_status_1[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define TOP_STRAP_STATUS_1r_RSVDf_GET(r) ((((r).top_strap_status_1[0]) >> 7) & 0x1ffffff)
#define TOP_STRAP_STATUS_1r_RSVDf_SET(r,f) (r).top_strap_status_1[0]=(((r).top_strap_status_1[0] & ~((uint32)0x1ffffff << 7)) | ((((uint32)f) & 0x1ffffff) << 7))

/*
 * These macros can be used to access TOP_STRAP_STATUS_1.
 */
#define WRITE_TOP_STRAP_STATUS_1r(u,r) bcm5607x_reg_set(u,R_TOP_STRAP_STATUS_1,(r._top_strap_status_1))
#define READ_TOP_STRAP_STATUS_1r(u,r) bcm5607x_reg_get(u,R_TOP_STRAP_STATUS_1,&(r._top_strap_status_1))

/*******************************************************************************
 * End of 'TOP_STRAP_STATUS_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG1_LCPLL_FBDIV_CTRL_0
 * BLOCKS:   TOP
 * DESC:     XG1 LCPLL feedback divider control register 0
 * SIZE:     32
 * FIELDS:
 *     XG1_LCPLL_FBDIV_0 Serdes LCPLL feedback div control value-0 (First 32-bits)
 */
#define TOP_XG1_LCPLL_FBDIV_CTRL_0r_SIZE 4

/* TOP_XG1_LCPLL_FBDIV_CTRL_0r is element of TOP_XG1_LCPLL_FBDIV_CTRL */

/*
 * This structure should be used to declare and program TOP_XG1_LCPLL_FBDIV_CTRL_0.
 */
typedef union TOP_XG1_LCPLL_FBDIV_CTRL_0r_s {
	uint32 v[1];
	uint32 top_xg1_lcpll_fbdiv_ctrl_0[1];
	uint32 _top_xg1_lcpll_fbdiv_ctrl_0;
} TOP_XG1_LCPLL_FBDIV_CTRL_0r_t;

#define TOP_XG1_LCPLL_FBDIV_CTRL_0r_CLR(r) (r).top_xg1_lcpll_fbdiv_ctrl_0[0] = 0
#define TOP_XG1_LCPLL_FBDIV_CTRL_0r_SET(r,d) (r).top_xg1_lcpll_fbdiv_ctrl_0[0] = d
#define TOP_XG1_LCPLL_FBDIV_CTRL_0r_GET(r) (r).top_xg1_lcpll_fbdiv_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG1_LCPLL_FBDIV_CTRL_0r_XG1_LCPLL_FBDIV_0f_GET(r) ((r).top_xg1_lcpll_fbdiv_ctrl_0[0])
#define TOP_XG1_LCPLL_FBDIV_CTRL_0r_XG1_LCPLL_FBDIV_0f_SET(r,f) (r).top_xg1_lcpll_fbdiv_ctrl_0[0]=((uint32)f)

/*
 * These macros can be used to access TOP_XG1_LCPLL_FBDIV_CTRL_0.
 */
#define WRITE_TOP_XG1_LCPLL_FBDIV_CTRL_0r(u,r) bcm5607x_reg_set(u,R_TOP_XG1_LCPLL_FBDIV_CTRL_0,(r._top_xg1_lcpll_fbdiv_ctrl_0))
#define READ_TOP_XG1_LCPLL_FBDIV_CTRL_0r(u,r) bcm5607x_reg_get(u,R_TOP_XG1_LCPLL_FBDIV_CTRL_0,&(r._top_xg1_lcpll_fbdiv_ctrl_0))

/*******************************************************************************
 * End of 'TOP_XG1_LCPLL_FBDIV_CTRL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG1_LCPLL_FBDIV_CTRL_1
 * BLOCKS:   TOP
 * DESC:     XG1 LCPLL feedback divider control register 1
 * SIZE:     32
 * FIELDS:
 *     XG1_LCPLL_FBDIV_1 Serdes LCPLL feedback div control value-1 (last 16-bits)
 *     RESERVED         Reserved
 */
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_SIZE 4

/* TOP_XG1_LCPLL_FBDIV_CTRL_1r is element of TOP_XG1_LCPLL_FBDIV_CTRL */

/*
 * This structure should be used to declare and program TOP_XG1_LCPLL_FBDIV_CTRL_1.
 */
typedef union TOP_XG1_LCPLL_FBDIV_CTRL_1r_s {
	uint32 v[1];
	uint32 top_xg1_lcpll_fbdiv_ctrl_1[1];
	uint32 _top_xg1_lcpll_fbdiv_ctrl_1;
} TOP_XG1_LCPLL_FBDIV_CTRL_1r_t;

#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_CLR(r) (r).top_xg1_lcpll_fbdiv_ctrl_1[0] = 0
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_SET(r,d) (r).top_xg1_lcpll_fbdiv_ctrl_1[0] = d
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_GET(r) (r).top_xg1_lcpll_fbdiv_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_XG1_LCPLL_FBDIV_1f_GET(r) (((r).top_xg1_lcpll_fbdiv_ctrl_1[0]) & 0xffff)
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_XG1_LCPLL_FBDIV_1f_SET(r,f) (r).top_xg1_lcpll_fbdiv_ctrl_1[0]=(((r).top_xg1_lcpll_fbdiv_ctrl_1[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_RESERVEDf_GET(r) ((((r).top_xg1_lcpll_fbdiv_ctrl_1[0]) >> 16) & 0xffff)
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_RESERVEDf_SET(r,f) (r).top_xg1_lcpll_fbdiv_ctrl_1[0]=(((r).top_xg1_lcpll_fbdiv_ctrl_1[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access TOP_XG1_LCPLL_FBDIV_CTRL_1.
 */
#define WRITE_TOP_XG1_LCPLL_FBDIV_CTRL_1r(u,r) bcm5607x_reg_set(u,R_TOP_XG1_LCPLL_FBDIV_CTRL_1,(r._top_xg1_lcpll_fbdiv_ctrl_1))
#define READ_TOP_XG1_LCPLL_FBDIV_CTRL_1r(u,r) bcm5607x_reg_get(u,R_TOP_XG1_LCPLL_FBDIV_CTRL_1,&(r._top_xg1_lcpll_fbdiv_ctrl_1))

/*******************************************************************************
 * End of 'TOP_XG1_LCPLL_FBDIV_CTRL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL0_CTRL_0
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL0 Control register 0
 * SIZE:     32
 * FIELDS:
 *     CH0_MDIV         channel 0 post divider
 *     CH0_MDEL         Programmable delay for post-divider channel 0 (half of VCO period steps)
 *     CH1_MDIV         obsolete. channel 1 post divider
 *     CH1_MDEL         Programmable delay for post-divider channel 1 (half of VCO period steps)
 *     CH2_MDIV         obsolete. channel 2 post divider
 *     CH2_MDEL         Programmable delay for post-divider channel 2 (half of VCO period steps)
 */
#define TOP_XG_PLL0_CTRL_0r_SIZE 4

/* TOP_XG_PLL0_CTRL_0r is element of TOP_XG_PLL_CTRL_0 */

/*
 * This structure should be used to declare and program TOP_XG_PLL0_CTRL_0.
 */
typedef union TOP_XG_PLL0_CTRL_0r_s {
	uint32 v[1];
	uint32 top_xg_pll0_ctrl_0[1];
	uint32 _top_xg_pll0_ctrl_0;
} TOP_XG_PLL0_CTRL_0r_t;

#define TOP_XG_PLL0_CTRL_0r_CLR(r) (r).top_xg_pll0_ctrl_0[0] = 0
#define TOP_XG_PLL0_CTRL_0r_SET(r,d) (r).top_xg_pll0_ctrl_0[0] = d
#define TOP_XG_PLL0_CTRL_0r_GET(r) (r).top_xg_pll0_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL0_CTRL_0r_CH0_MDIVf_GET(r) (((r).top_xg_pll0_ctrl_0[0]) & 0x1ff)
#define TOP_XG_PLL0_CTRL_0r_CH0_MDIVf_SET(r,f) (r).top_xg_pll0_ctrl_0[0]=(((r).top_xg_pll0_ctrl_0[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define TOP_XG_PLL0_CTRL_0r_CH0_MDELf_GET(r) ((((r).top_xg_pll0_ctrl_0[0]) >> 9) & 0x1)
#define TOP_XG_PLL0_CTRL_0r_CH0_MDELf_SET(r,f) (r).top_xg_pll0_ctrl_0[0]=(((r).top_xg_pll0_ctrl_0[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_XG_PLL0_CTRL_0r_CH1_MDIVf_GET(r) ((((r).top_xg_pll0_ctrl_0[0]) >> 10) & 0x1ff)
#define TOP_XG_PLL0_CTRL_0r_CH1_MDIVf_SET(r,f) (r).top_xg_pll0_ctrl_0[0]=(((r).top_xg_pll0_ctrl_0[0] & ~((uint32)0x1ff << 10)) | ((((uint32)f) & 0x1ff) << 10))
#define TOP_XG_PLL0_CTRL_0r_CH1_MDELf_GET(r) ((((r).top_xg_pll0_ctrl_0[0]) >> 19) & 0x1)
#define TOP_XG_PLL0_CTRL_0r_CH1_MDELf_SET(r,f) (r).top_xg_pll0_ctrl_0[0]=(((r).top_xg_pll0_ctrl_0[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define TOP_XG_PLL0_CTRL_0r_CH2_MDIVf_GET(r) ((((r).top_xg_pll0_ctrl_0[0]) >> 20) & 0x1ff)
#define TOP_XG_PLL0_CTRL_0r_CH2_MDIVf_SET(r,f) (r).top_xg_pll0_ctrl_0[0]=(((r).top_xg_pll0_ctrl_0[0] & ~((uint32)0x1ff << 20)) | ((((uint32)f) & 0x1ff) << 20))
#define TOP_XG_PLL0_CTRL_0r_CH2_MDELf_GET(r) ((((r).top_xg_pll0_ctrl_0[0]) >> 29) & 0x1)
#define TOP_XG_PLL0_CTRL_0r_CH2_MDELf_SET(r,f) (r).top_xg_pll0_ctrl_0[0]=(((r).top_xg_pll0_ctrl_0[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))

/*
 * These macros can be used to access TOP_XG_PLL0_CTRL_0.
 */
#define WRITE_TOP_XG_PLL0_CTRL_0r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL0_CTRL_0,(r._top_xg_pll0_ctrl_0))
#define READ_TOP_XG_PLL0_CTRL_0r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL0_CTRL_0,&(r._top_xg_pll0_ctrl_0))

/*******************************************************************************
 * End of 'TOP_XG_PLL0_CTRL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL0_CTRL_1
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL0 Control register 1
 * SIZE:     32
 * FIELDS:
 *     HOLD_CH          Hold Enable for post-divider channel 0-5. when de-asserted(logic 0) clock will start syn to VCO clock
 *     LOAD_EN_CH       LOAD enable for post-divider channel 0-5. Allows "on-the-fly" divider reporgramming (glitch free)
 *     PDIV             input reference clock pre-divider control.
 *     FREFEFF_INFO     default XG PLL0 fref effective = 50MHz (after pdiv) 
 *     AUTO_CNFG_DSBL   Disable of auto-configuration function for each control groupauto_cnfg_dsbl<0> disables CP related control: icp and icp_bleedauto_cnfg_dsbl<1> disables LF primary control: rz, cz, and cpauto_cnfg_dsbl<2> disables LF secondary control: rp1 and cp1auto_cnfg_dsbl<3> disables VCO calibration related control:vco_gainauto_cnfg_dsbl<4> disables VCO calibration related control:code_vcocal and hold_delayauto_cnfg_dsbl<5> disables controller related control:lock_cnt and wdt_cntauto_cnfg_dsbl<6> N/Aauto_cnfg_dsbl<7> disables pll_resetb
 */
#define TOP_XG_PLL0_CTRL_1r_SIZE 4

/* TOP_XG_PLL0_CTRL_1r is element of TOP_XG_PLL_CTRL_1 */

/*
 * This structure should be used to declare and program TOP_XG_PLL0_CTRL_1.
 */
typedef union TOP_XG_PLL0_CTRL_1r_s {
	uint32 v[1];
	uint32 top_xg_pll0_ctrl_1[1];
	uint32 _top_xg_pll0_ctrl_1;
} TOP_XG_PLL0_CTRL_1r_t;

#define TOP_XG_PLL0_CTRL_1r_CLR(r) (r).top_xg_pll0_ctrl_1[0] = 0
#define TOP_XG_PLL0_CTRL_1r_SET(r,d) (r).top_xg_pll0_ctrl_1[0] = d
#define TOP_XG_PLL0_CTRL_1r_GET(r) (r).top_xg_pll0_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL0_CTRL_1r_HOLD_CHf_GET(r) (((r).top_xg_pll0_ctrl_1[0]) & 0x3f)
#define TOP_XG_PLL0_CTRL_1r_HOLD_CHf_SET(r,f) (r).top_xg_pll0_ctrl_1[0]=(((r).top_xg_pll0_ctrl_1[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define TOP_XG_PLL0_CTRL_1r_LOAD_EN_CHf_GET(r) ((((r).top_xg_pll0_ctrl_1[0]) >> 6) & 0x3f)
#define TOP_XG_PLL0_CTRL_1r_LOAD_EN_CHf_SET(r,f) (r).top_xg_pll0_ctrl_1[0]=(((r).top_xg_pll0_ctrl_1[0] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define TOP_XG_PLL0_CTRL_1r_PDIVf_GET(r) ((((r).top_xg_pll0_ctrl_1[0]) >> 12) & 0xf)
#define TOP_XG_PLL0_CTRL_1r_PDIVf_SET(r,f) (r).top_xg_pll0_ctrl_1[0]=(((r).top_xg_pll0_ctrl_1[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define TOP_XG_PLL0_CTRL_1r_FREFEFF_INFOf_GET(r) ((((r).top_xg_pll0_ctrl_1[0]) >> 16) & 0xff)
#define TOP_XG_PLL0_CTRL_1r_FREFEFF_INFOf_SET(r,f) (r).top_xg_pll0_ctrl_1[0]=(((r).top_xg_pll0_ctrl_1[0] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define TOP_XG_PLL0_CTRL_1r_AUTO_CNFG_DSBLf_GET(r) ((((r).top_xg_pll0_ctrl_1[0]) >> 24) & 0xff)
#define TOP_XG_PLL0_CTRL_1r_AUTO_CNFG_DSBLf_SET(r,f) (r).top_xg_pll0_ctrl_1[0]=(((r).top_xg_pll0_ctrl_1[0] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))

/*
 * These macros can be used to access TOP_XG_PLL0_CTRL_1.
 */
#define WRITE_TOP_XG_PLL0_CTRL_1r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL0_CTRL_1,(r._top_xg_pll0_ctrl_1))
#define READ_TOP_XG_PLL0_CTRL_1r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL0_CTRL_1,&(r._top_xg_pll0_ctrl_1))

/*******************************************************************************
 * End of 'TOP_XG_PLL0_CTRL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL0_CTRL_10
 * BLOCKS:   TOP
 * DESC:     TOP XG PLL0 Control Register 10
 * SIZE:     32
 * FIELDS:
 *     PLL_CTRL         i_pll_ctrl : VCO and PFD configuration options[2:0] : VCO_CTRL<2:0> (spare, not connected)[5:3] : vco current[8:6] : PFD Bit_Delay_Ctrl <2:0>[10:9] : Frequency doubler delay [23:11] : spare
 *     RSVD             Reserved
 */
#define TOP_XG_PLL0_CTRL_10r_SIZE 4

/* TOP_XG_PLL0_CTRL_10r is element of TOP_XG_PLL_CTRL_10 */

/*
 * This structure should be used to declare and program TOP_XG_PLL0_CTRL_10.
 */
typedef union TOP_XG_PLL0_CTRL_10r_s {
	uint32 v[1];
	uint32 top_xg_pll0_ctrl_10[1];
	uint32 _top_xg_pll0_ctrl_10;
} TOP_XG_PLL0_CTRL_10r_t;

#define TOP_XG_PLL0_CTRL_10r_CLR(r) (r).top_xg_pll0_ctrl_10[0] = 0
#define TOP_XG_PLL0_CTRL_10r_SET(r,d) (r).top_xg_pll0_ctrl_10[0] = d
#define TOP_XG_PLL0_CTRL_10r_GET(r) (r).top_xg_pll0_ctrl_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL0_CTRL_10r_PLL_CTRLf_GET(r) (((r).top_xg_pll0_ctrl_10[0]) & 0xffffff)
#define TOP_XG_PLL0_CTRL_10r_PLL_CTRLf_SET(r,f) (r).top_xg_pll0_ctrl_10[0]=(((r).top_xg_pll0_ctrl_10[0] & ~((uint32)0xffffff)) | (((uint32)f) & 0xffffff))
#define TOP_XG_PLL0_CTRL_10r_RSVDf_GET(r) ((((r).top_xg_pll0_ctrl_10[0]) >> 24) & 0xff)
#define TOP_XG_PLL0_CTRL_10r_RSVDf_SET(r,f) (r).top_xg_pll0_ctrl_10[0]=(((r).top_xg_pll0_ctrl_10[0] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))

/*
 * These macros can be used to access TOP_XG_PLL0_CTRL_10.
 */
#define WRITE_TOP_XG_PLL0_CTRL_10r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL0_CTRL_10,(r._top_xg_pll0_ctrl_10))
#define READ_TOP_XG_PLL0_CTRL_10r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL0_CTRL_10,&(r._top_xg_pll0_ctrl_10))

/*******************************************************************************
 * End of 'TOP_XG_PLL0_CTRL_10r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL0_CTRL_2
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL0 Control register 2
 * SIZE:     32
 * FIELDS:
 *     CH3_MDIV         Obsolette.channel 3 post divider
 *     CH3_MDEL         Obsolette.Programmable delay for post-divider channel 3 (half of VCO period steps)
 *     CH4_MDIV         Obsolette.channel 4 post divider
 *     CH4_MDEL         obsolete. Programmable delay for post-divider channel 4 (half of VCO period steps)
 *     CH5_MDIV         Obsolete. channel 5 post divider
 *     CH5_MDEL         obsolete. Programmable delay for post-divider channel 5 (half of VCO period steps)
 */
#define TOP_XG_PLL0_CTRL_2r_SIZE 4

/* TOP_XG_PLL0_CTRL_2r is element of TOP_XG_PLL_CTRL_2 */

/*
 * This structure should be used to declare and program TOP_XG_PLL0_CTRL_2.
 */
typedef union TOP_XG_PLL0_CTRL_2r_s {
	uint32 v[1];
	uint32 top_xg_pll0_ctrl_2[1];
	uint32 _top_xg_pll0_ctrl_2;
} TOP_XG_PLL0_CTRL_2r_t;

#define TOP_XG_PLL0_CTRL_2r_CLR(r) (r).top_xg_pll0_ctrl_2[0] = 0
#define TOP_XG_PLL0_CTRL_2r_SET(r,d) (r).top_xg_pll0_ctrl_2[0] = d
#define TOP_XG_PLL0_CTRL_2r_GET(r) (r).top_xg_pll0_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL0_CTRL_2r_CH3_MDIVf_GET(r) (((r).top_xg_pll0_ctrl_2[0]) & 0x1ff)
#define TOP_XG_PLL0_CTRL_2r_CH3_MDIVf_SET(r,f) (r).top_xg_pll0_ctrl_2[0]=(((r).top_xg_pll0_ctrl_2[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define TOP_XG_PLL0_CTRL_2r_CH3_MDELf_GET(r) ((((r).top_xg_pll0_ctrl_2[0]) >> 9) & 0x1)
#define TOP_XG_PLL0_CTRL_2r_CH3_MDELf_SET(r,f) (r).top_xg_pll0_ctrl_2[0]=(((r).top_xg_pll0_ctrl_2[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_XG_PLL0_CTRL_2r_CH4_MDIVf_GET(r) ((((r).top_xg_pll0_ctrl_2[0]) >> 10) & 0x1ff)
#define TOP_XG_PLL0_CTRL_2r_CH4_MDIVf_SET(r,f) (r).top_xg_pll0_ctrl_2[0]=(((r).top_xg_pll0_ctrl_2[0] & ~((uint32)0x1ff << 10)) | ((((uint32)f) & 0x1ff) << 10))
#define TOP_XG_PLL0_CTRL_2r_CH4_MDELf_GET(r) ((((r).top_xg_pll0_ctrl_2[0]) >> 19) & 0x1)
#define TOP_XG_PLL0_CTRL_2r_CH4_MDELf_SET(r,f) (r).top_xg_pll0_ctrl_2[0]=(((r).top_xg_pll0_ctrl_2[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define TOP_XG_PLL0_CTRL_2r_CH5_MDIVf_GET(r) ((((r).top_xg_pll0_ctrl_2[0]) >> 20) & 0x1ff)
#define TOP_XG_PLL0_CTRL_2r_CH5_MDIVf_SET(r,f) (r).top_xg_pll0_ctrl_2[0]=(((r).top_xg_pll0_ctrl_2[0] & ~((uint32)0x1ff << 20)) | ((((uint32)f) & 0x1ff) << 20))
#define TOP_XG_PLL0_CTRL_2r_CH5_MDELf_GET(r) ((((r).top_xg_pll0_ctrl_2[0]) >> 29) & 0x1)
#define TOP_XG_PLL0_CTRL_2r_CH5_MDELf_SET(r,f) (r).top_xg_pll0_ctrl_2[0]=(((r).top_xg_pll0_ctrl_2[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))

/*
 * These macros can be used to access TOP_XG_PLL0_CTRL_2.
 */
#define WRITE_TOP_XG_PLL0_CTRL_2r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL0_CTRL_2,(r._top_xg_pll0_ctrl_2))
#define READ_TOP_XG_PLL0_CTRL_2r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL0_CTRL_2,&(r._top_xg_pll0_ctrl_2))

/*******************************************************************************
 * End of 'TOP_XG_PLL0_CTRL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL0_CTRL_3
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL0 Control register 3
 * SIZE:     32
 * FIELDS:
 *     ROUTE_CTRL       XG PLL0 ROUTE_CTRL:[0] Select between internal and external differential clock inputs, 0-ext 1-int[1] Select o_REF_CLK source, 0- diff clock mux out  1- refclk input    [3:2] Select CML output pad source, 00-ch[0] 01-o_REF_CLK 1x-ch[1] [5:4] Select o_cml1p/n source, 00-ch[0] 01-ch[1] 1x- o_REF_CLK[7:6] Select o_cml2p/n source, 00-ch[0] 01-ch[1] 1x- o_REF_CLK[8]   Select o_clk25_out, 0- refclk_out, 1- byp25 (channel 4 bypass)
 *     WDT_ENB          XG PLL0 watchdog timer enable 
 *     WDT_CNT          XG PLL0 watchdog timer count select 
 *     MASH11_MODE      
 *     RATE_MNGR_MODE                      enable or disable for the post channel
 *     CODE_VCOCAL                         Programmable VCO Calibration time                      00: refclk counter counts 1024 refclk cyles                       01: refclk counter counts 512 refclk cyles                       10: refclk counter counts 256refclk cyles                       11: refclk counter counts 128 refclk cyles
 *     HOLD_DELAY                          Programmable delay for analog voltage to settle                      000: delay 1 refclk cycle                      001: delay 3 refclk cycles                      010: delay 7 refclk cycles                      011: delay 15 refclk cycles                      100: delay 31 refclk cycles                      101: delay 63 refclk cycles                      110: delay 127 refclk cycles                      111: delay 255 refclk cycles
 *     BYPASS_MODE                         enable for manual VCO tuning                      0: auto tuning                      1: manual tuning
 *     BYPASS_DAC                          Bypass DAC value can use to control VCO frequency when bypass_mode is set to 1
 *     PQ_MODE          Ratio based frequency divider mode
 */
#define TOP_XG_PLL0_CTRL_3r_SIZE 4

/* TOP_XG_PLL0_CTRL_3r is element of TOP_XG_PLL_CTRL_3 */

/*
 * This structure should be used to declare and program TOP_XG_PLL0_CTRL_3.
 */
typedef union TOP_XG_PLL0_CTRL_3r_s {
	uint32 v[1];
	uint32 top_xg_pll0_ctrl_3[1];
	uint32 _top_xg_pll0_ctrl_3;
} TOP_XG_PLL0_CTRL_3r_t;

#define TOP_XG_PLL0_CTRL_3r_CLR(r) (r).top_xg_pll0_ctrl_3[0] = 0
#define TOP_XG_PLL0_CTRL_3r_SET(r,d) (r).top_xg_pll0_ctrl_3[0] = d
#define TOP_XG_PLL0_CTRL_3r_GET(r) (r).top_xg_pll0_ctrl_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL0_CTRL_3r_ROUTE_CTRLf_GET(r) (((r).top_xg_pll0_ctrl_3[0]) & 0x1ff)
#define TOP_XG_PLL0_CTRL_3r_ROUTE_CTRLf_SET(r,f) (r).top_xg_pll0_ctrl_3[0]=(((r).top_xg_pll0_ctrl_3[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define TOP_XG_PLL0_CTRL_3r_WDT_ENBf_GET(r) ((((r).top_xg_pll0_ctrl_3[0]) >> 9) & 0x1)
#define TOP_XG_PLL0_CTRL_3r_WDT_ENBf_SET(r,f) (r).top_xg_pll0_ctrl_3[0]=(((r).top_xg_pll0_ctrl_3[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_XG_PLL0_CTRL_3r_WDT_CNTf_GET(r) ((((r).top_xg_pll0_ctrl_3[0]) >> 10) & 0x3)
#define TOP_XG_PLL0_CTRL_3r_WDT_CNTf_SET(r,f) (r).top_xg_pll0_ctrl_3[0]=(((r).top_xg_pll0_ctrl_3[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define TOP_XG_PLL0_CTRL_3r_MASH11_MODEf_GET(r) ((((r).top_xg_pll0_ctrl_3[0]) >> 13) & 0x1)
#define TOP_XG_PLL0_CTRL_3r_MASH11_MODEf_SET(r,f) (r).top_xg_pll0_ctrl_3[0]=(((r).top_xg_pll0_ctrl_3[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define TOP_XG_PLL0_CTRL_3r_RATE_MNGR_MODEf_GET(r) ((((r).top_xg_pll0_ctrl_3[0]) >> 14) & 0x1)
#define TOP_XG_PLL0_CTRL_3r_RATE_MNGR_MODEf_SET(r,f) (r).top_xg_pll0_ctrl_3[0]=(((r).top_xg_pll0_ctrl_3[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define TOP_XG_PLL0_CTRL_3r_CODE_VCOCALf_GET(r) ((((r).top_xg_pll0_ctrl_3[0]) >> 15) & 0x3)
#define TOP_XG_PLL0_CTRL_3r_CODE_VCOCALf_SET(r,f) (r).top_xg_pll0_ctrl_3[0]=(((r).top_xg_pll0_ctrl_3[0] & ~((uint32)0x3 << 15)) | ((((uint32)f) & 0x3) << 15))
#define TOP_XG_PLL0_CTRL_3r_HOLD_DELAYf_GET(r) ((((r).top_xg_pll0_ctrl_3[0]) >> 17) & 0x7)
#define TOP_XG_PLL0_CTRL_3r_HOLD_DELAYf_SET(r,f) (r).top_xg_pll0_ctrl_3[0]=(((r).top_xg_pll0_ctrl_3[0] & ~((uint32)0x7 << 17)) | ((((uint32)f) & 0x7) << 17))
#define TOP_XG_PLL0_CTRL_3r_BYPASS_MODEf_GET(r) ((((r).top_xg_pll0_ctrl_3[0]) >> 20) & 0x1)
#define TOP_XG_PLL0_CTRL_3r_BYPASS_MODEf_SET(r,f) (r).top_xg_pll0_ctrl_3[0]=(((r).top_xg_pll0_ctrl_3[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define TOP_XG_PLL0_CTRL_3r_BYPASS_DACf_GET(r) ((((r).top_xg_pll0_ctrl_3[0]) >> 21) & 0x1ff)
#define TOP_XG_PLL0_CTRL_3r_BYPASS_DACf_SET(r,f) (r).top_xg_pll0_ctrl_3[0]=(((r).top_xg_pll0_ctrl_3[0] & ~((uint32)0x1ff << 21)) | ((((uint32)f) & 0x1ff) << 21))
#define TOP_XG_PLL0_CTRL_3r_PQ_MODEf_GET(r) ((((r).top_xg_pll0_ctrl_3[0]) >> 31) & 0x1)
#define TOP_XG_PLL0_CTRL_3r_PQ_MODEf_SET(r,f) (r).top_xg_pll0_ctrl_3[0]=(((r).top_xg_pll0_ctrl_3[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access TOP_XG_PLL0_CTRL_3.
 */
#define WRITE_TOP_XG_PLL0_CTRL_3r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL0_CTRL_3,(r._top_xg_pll0_ctrl_3))
#define READ_TOP_XG_PLL0_CTRL_3r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL0_CTRL_3,&(r._top_xg_pll0_ctrl_3))

/*******************************************************************************
 * End of 'TOP_XG_PLL0_CTRL_3r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL0_CTRL_4
 * BLOCKS:   TOP
 * DESC:     Obsolette. NDIV value is controlled by holdover_logic.TOP XG_PLL0 Control register 4
 * SIZE:     32
 * FIELDS:
 *     NDIV_INT                         Feedback divider control (Code = divider ratio). Default is 125 (decimal).                    0000000000= divide-by-1024                    0000000001= XXX                    0000000010= XXX                    :                    0000000111= XXX                    0000001000= divide-by-8                    0000001001= divide-by-9                    0000001010= divide-by-10                    :                    1111111110= divide-by-1022                    1111111111= divide-by-1023
 *     NDIV_FRAC                        Fractional part of Feedback Divider Rate (N).Default is 0 (decimal).                This value, divided by 2^20, is added to i_ndiv_int to determine the                 effective feedback divider rate N.                Concatinating these busses {i_ndiv_int, i_ndiv_frac} creates a 30-bit number                sometimes referred to as the Frequency Control Word (fcw), with 10 integer                 bits and 20 fractional bits.
 */
#define TOP_XG_PLL0_CTRL_4r_SIZE 4

/* TOP_XG_PLL0_CTRL_4r is element of TOP_XG_PLL_CTRL_4 */

/*
 * This structure should be used to declare and program TOP_XG_PLL0_CTRL_4.
 */
typedef union TOP_XG_PLL0_CTRL_4r_s {
	uint32 v[1];
	uint32 top_xg_pll0_ctrl_4[1];
	uint32 _top_xg_pll0_ctrl_4;
} TOP_XG_PLL0_CTRL_4r_t;

#define TOP_XG_PLL0_CTRL_4r_CLR(r) (r).top_xg_pll0_ctrl_4[0] = 0
#define TOP_XG_PLL0_CTRL_4r_SET(r,d) (r).top_xg_pll0_ctrl_4[0] = d
#define TOP_XG_PLL0_CTRL_4r_GET(r) (r).top_xg_pll0_ctrl_4[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL0_CTRL_4r_NDIV_INTf_GET(r) (((r).top_xg_pll0_ctrl_4[0]) & 0x3ff)
#define TOP_XG_PLL0_CTRL_4r_NDIV_INTf_SET(r,f) (r).top_xg_pll0_ctrl_4[0]=(((r).top_xg_pll0_ctrl_4[0] & ~((uint32)0x3ff)) | (((uint32)f) & 0x3ff))
#define TOP_XG_PLL0_CTRL_4r_NDIV_FRACf_GET(r) ((((r).top_xg_pll0_ctrl_4[0]) >> 10) & 0x3fffff)
#define TOP_XG_PLL0_CTRL_4r_NDIV_FRACf_SET(r,f) (r).top_xg_pll0_ctrl_4[0]=(((r).top_xg_pll0_ctrl_4[0] & ~((uint32)0x3fffff << 10)) | ((((uint32)f) & 0x3fffff) << 10))

/*
 * These macros can be used to access TOP_XG_PLL0_CTRL_4.
 */
#define WRITE_TOP_XG_PLL0_CTRL_4r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL0_CTRL_4,(r._top_xg_pll0_ctrl_4))
#define READ_TOP_XG_PLL0_CTRL_4r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL0_CTRL_4,&(r._top_xg_pll0_ctrl_4))

/*******************************************************************************
 * End of 'TOP_XG_PLL0_CTRL_4r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL0_CTRL_5
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL0 Control register 5
 * SIZE:     32
 * FIELDS:
 *     VCO_GAIN                         Controlling VCO gain for VCO1 and VCO2
 *     RZ                               Control Rz                 Rz=(1+code*2)Kohm                    00000: 2kohm                    00001: 4kohm                    00010: 6kohm                    00100: 8kohm                    ...                   11111: 18kohm
 *     RP                               Control Rp                 Rp=(1+code*1)Kohm                    000: 1kohm                    001: 24kohm                    010: 4kohm                    100: 5kohm                    ...                   111: 8kohm
 *     ICP                              Control CP current control                    Max CP current --> 600uA                    Min CP current --> 10uA
 *     CZ                               control Cz value                 code=(50+code*16)pF                    00: 50pF                    01: 66pF                    10: 82pF                    11: 100pF
 *     CP                               control Cp value                 code=(1+code*1)pF                    00: 1pF                    01: 2pF                    10: 3pF                    11: 4pF
 *     CP1                              control Cp1 value                 code=(1+code*1)pF                    00: 1pF                    01: 2pF                    10: 3pF                    11: 4pF
 *     RSVD             reserved
 */
#define TOP_XG_PLL0_CTRL_5r_SIZE 4

/* TOP_XG_PLL0_CTRL_5r is element of TOP_XG_PLL_CTRL_5 */

/*
 * This structure should be used to declare and program TOP_XG_PLL0_CTRL_5.
 */
typedef union TOP_XG_PLL0_CTRL_5r_s {
	uint32 v[1];
	uint32 top_xg_pll0_ctrl_5[1];
	uint32 _top_xg_pll0_ctrl_5;
} TOP_XG_PLL0_CTRL_5r_t;

#define TOP_XG_PLL0_CTRL_5r_CLR(r) (r).top_xg_pll0_ctrl_5[0] = 0
#define TOP_XG_PLL0_CTRL_5r_SET(r,d) (r).top_xg_pll0_ctrl_5[0] = d
#define TOP_XG_PLL0_CTRL_5r_GET(r) (r).top_xg_pll0_ctrl_5[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL0_CTRL_5r_VCO_GAINf_GET(r) (((r).top_xg_pll0_ctrl_5[0]) & 0xf)
#define TOP_XG_PLL0_CTRL_5r_VCO_GAINf_SET(r,f) (r).top_xg_pll0_ctrl_5[0]=(((r).top_xg_pll0_ctrl_5[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define TOP_XG_PLL0_CTRL_5r_RZf_GET(r) ((((r).top_xg_pll0_ctrl_5[0]) >> 4) & 0x1f)
#define TOP_XG_PLL0_CTRL_5r_RZf_SET(r,f) (r).top_xg_pll0_ctrl_5[0]=(((r).top_xg_pll0_ctrl_5[0] & ~((uint32)0x1f << 4)) | ((((uint32)f) & 0x1f) << 4))
#define TOP_XG_PLL0_CTRL_5r_RPf_GET(r) ((((r).top_xg_pll0_ctrl_5[0]) >> 9) & 0xf)
#define TOP_XG_PLL0_CTRL_5r_RPf_SET(r,f) (r).top_xg_pll0_ctrl_5[0]=(((r).top_xg_pll0_ctrl_5[0] & ~((uint32)0xf << 9)) | ((((uint32)f) & 0xf) << 9))
#define TOP_XG_PLL0_CTRL_5r_ICPf_GET(r) ((((r).top_xg_pll0_ctrl_5[0]) >> 13) & 0x3f)
#define TOP_XG_PLL0_CTRL_5r_ICPf_SET(r,f) (r).top_xg_pll0_ctrl_5[0]=(((r).top_xg_pll0_ctrl_5[0] & ~((uint32)0x3f << 13)) | ((((uint32)f) & 0x3f) << 13))
#define TOP_XG_PLL0_CTRL_5r_CZf_GET(r) ((((r).top_xg_pll0_ctrl_5[0]) >> 19) & 0x7)
#define TOP_XG_PLL0_CTRL_5r_CZf_SET(r,f) (r).top_xg_pll0_ctrl_5[0]=(((r).top_xg_pll0_ctrl_5[0] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define TOP_XG_PLL0_CTRL_5r_CPf_GET(r) ((((r).top_xg_pll0_ctrl_5[0]) >> 22) & 0x7)
#define TOP_XG_PLL0_CTRL_5r_CPf_SET(r,f) (r).top_xg_pll0_ctrl_5[0]=(((r).top_xg_pll0_ctrl_5[0] & ~((uint32)0x7 << 22)) | ((((uint32)f) & 0x7) << 22))
#define TOP_XG_PLL0_CTRL_5r_CP1f_GET(r) ((((r).top_xg_pll0_ctrl_5[0]) >> 25) & 0x7)
#define TOP_XG_PLL0_CTRL_5r_CP1f_SET(r,f) (r).top_xg_pll0_ctrl_5[0]=(((r).top_xg_pll0_ctrl_5[0] & ~((uint32)0x7 << 25)) | ((((uint32)f) & 0x7) << 25))
#define TOP_XG_PLL0_CTRL_5r_RSVDf_GET(r) ((((r).top_xg_pll0_ctrl_5[0]) >> 28) & 0xf)
#define TOP_XG_PLL0_CTRL_5r_RSVDf_SET(r,f) (r).top_xg_pll0_ctrl_5[0]=(((r).top_xg_pll0_ctrl_5[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access TOP_XG_PLL0_CTRL_5.
 */
#define WRITE_TOP_XG_PLL0_CTRL_5r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL0_CTRL_5,(r._top_xg_pll0_ctrl_5))
#define READ_TOP_XG_PLL0_CTRL_5r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL0_CTRL_5,&(r._top_xg_pll0_ctrl_5))

/*******************************************************************************
 * End of 'TOP_XG_PLL0_CTRL_5r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL0_CTRL_6
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL0 Control register 6
 * SIZE:     32
 * FIELDS:
 *     EN_CTRL          LC_pll EN_CTRL:[0] Enable External differential clock D2C, 1-enable[1] Enable Internal differential clock D2C, 1-enable[2] Enable CML output pad buffer, 1-enable[3] Enable o_cml1p/n, 1-enable[4] Enable o_cml2p/n, 1-enable[5] Enable Frequency doubler, 1-enable[6] Enable ref clock bypass, 1-enable[7] Reserved
 *     DITH_EN          XG PLL0 enable feedback divider SDM dithering 
 *     DITH_ORDER       XG PLL0 SDM dither order 
 *     NOREF_CHK_ENB    XG PLL0 no reference clock check enable
 *     LOCK_LOST_CLR    XG PLL0 lock lost clear
 *     LOCK_CNT         Lock detector counter length. This control is onlyeffective when auto_cnfg_dsbl<4> is set to 0 or whenauto_cnfg_dsbl<5> is set to 1111: 7680110: 6144101: 4096100: 2048011: 1024010: 512001: 256000: 128
 *     LDO_CTRL                         ldo Control bits
 */
#define TOP_XG_PLL0_CTRL_6r_SIZE 4

/* TOP_XG_PLL0_CTRL_6r is element of TOP_XG_PLL_CTRL_6 */

/*
 * This structure should be used to declare and program TOP_XG_PLL0_CTRL_6.
 */
typedef union TOP_XG_PLL0_CTRL_6r_s {
	uint32 v[1];
	uint32 top_xg_pll0_ctrl_6[1];
	uint32 _top_xg_pll0_ctrl_6;
} TOP_XG_PLL0_CTRL_6r_t;

#define TOP_XG_PLL0_CTRL_6r_CLR(r) (r).top_xg_pll0_ctrl_6[0] = 0
#define TOP_XG_PLL0_CTRL_6r_SET(r,d) (r).top_xg_pll0_ctrl_6[0] = d
#define TOP_XG_PLL0_CTRL_6r_GET(r) (r).top_xg_pll0_ctrl_6[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL0_CTRL_6r_EN_CTRLf_GET(r) (((r).top_xg_pll0_ctrl_6[0]) & 0xff)
#define TOP_XG_PLL0_CTRL_6r_EN_CTRLf_SET(r,f) (r).top_xg_pll0_ctrl_6[0]=(((r).top_xg_pll0_ctrl_6[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define TOP_XG_PLL0_CTRL_6r_DITH_ENf_GET(r) ((((r).top_xg_pll0_ctrl_6[0]) >> 8) & 0x1)
#define TOP_XG_PLL0_CTRL_6r_DITH_ENf_SET(r,f) (r).top_xg_pll0_ctrl_6[0]=(((r).top_xg_pll0_ctrl_6[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define TOP_XG_PLL0_CTRL_6r_DITH_ORDERf_GET(r) ((((r).top_xg_pll0_ctrl_6[0]) >> 9) & 0x3)
#define TOP_XG_PLL0_CTRL_6r_DITH_ORDERf_SET(r,f) (r).top_xg_pll0_ctrl_6[0]=(((r).top_xg_pll0_ctrl_6[0] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define TOP_XG_PLL0_CTRL_6r_NOREF_CHK_ENBf_GET(r) ((((r).top_xg_pll0_ctrl_6[0]) >> 11) & 0x1)
#define TOP_XG_PLL0_CTRL_6r_NOREF_CHK_ENBf_SET(r,f) (r).top_xg_pll0_ctrl_6[0]=(((r).top_xg_pll0_ctrl_6[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define TOP_XG_PLL0_CTRL_6r_LOCK_LOST_CLRf_GET(r) ((((r).top_xg_pll0_ctrl_6[0]) >> 12) & 0x1)
#define TOP_XG_PLL0_CTRL_6r_LOCK_LOST_CLRf_SET(r,f) (r).top_xg_pll0_ctrl_6[0]=(((r).top_xg_pll0_ctrl_6[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define TOP_XG_PLL0_CTRL_6r_LOCK_CNTf_GET(r) ((((r).top_xg_pll0_ctrl_6[0]) >> 13) & 0x7)
#define TOP_XG_PLL0_CTRL_6r_LOCK_CNTf_SET(r,f) (r).top_xg_pll0_ctrl_6[0]=(((r).top_xg_pll0_ctrl_6[0] & ~((uint32)0x7 << 13)) | ((((uint32)f) & 0x7) << 13))
#define TOP_XG_PLL0_CTRL_6r_LDO_CTRLf_GET(r) ((((r).top_xg_pll0_ctrl_6[0]) >> 16) & 0xffff)
#define TOP_XG_PLL0_CTRL_6r_LDO_CTRLf_SET(r,f) (r).top_xg_pll0_ctrl_6[0]=(((r).top_xg_pll0_ctrl_6[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access TOP_XG_PLL0_CTRL_6.
 */
#define WRITE_TOP_XG_PLL0_CTRL_6r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL0_CTRL_6,(r._top_xg_pll0_ctrl_6))
#define READ_TOP_XG_PLL0_CTRL_6r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL0_CTRL_6,&(r._top_xg_pll0_ctrl_6))

/*******************************************************************************
 * End of 'TOP_XG_PLL0_CTRL_6r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL0_CTRL_7
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL0 Control register 7
 * SIZE:     32
 * FIELDS:
 *     STAT_MODE                        Statistics mode:                   00 = disabled                   01 = Phase error                   10 = period                   11 = feedback phase error
 *     STAT_RESET                       Reset of phase error measurement:                   0=normal mode                   1=reset
 *     STAT_SELECT                      select of test output (stat_out[11:0])                   000 = 000000000000                   001 = 000000000000                   010 = 000000000000                   011 = 000000000000                   100 = {0, lock, lock_lost, cal_dac[8:0]}                   101 = 000000000000                   110 = 000000000000                   111 = 000000000000
 *     STAT_UPDATE                      on the synchronized rising edge of this control signal the value selected by stat_select<2:0> is clocked into o_statout.
 *     POST_RSTB_SEL    Post divider control selector00: controller has no control over post divider01: post divider is synchronously enabled and asynchronously disabled by the lock bit10: post divider resetb is controlled also by controller's resetb11: post divider is synchronously enabled/disabled by the lock bit
 *     ICP_BLEED        XG PLL0 ICP bleed : Controls CP bleeding current, applicable for fractional mode only 
 *     ENABLEB_CH       Channel enable 0: enable, 1: disable 
 *     HOLD_ALL         i_hold_all 
 *     SPARE_DIG        i_spare_dig<7:0> bits for debug
 *     RSVD             Reserved 
 */
#define TOP_XG_PLL0_CTRL_7r_SIZE 4

/* TOP_XG_PLL0_CTRL_7r is element of TOP_XG_PLL_CTRL_7 */

/*
 * This structure should be used to declare and program TOP_XG_PLL0_CTRL_7.
 */
typedef union TOP_XG_PLL0_CTRL_7r_s {
	uint32 v[1];
	uint32 top_xg_pll0_ctrl_7[1];
	uint32 _top_xg_pll0_ctrl_7;
} TOP_XG_PLL0_CTRL_7r_t;

#define TOP_XG_PLL0_CTRL_7r_CLR(r) (r).top_xg_pll0_ctrl_7[0] = 0
#define TOP_XG_PLL0_CTRL_7r_SET(r,d) (r).top_xg_pll0_ctrl_7[0] = d
#define TOP_XG_PLL0_CTRL_7r_GET(r) (r).top_xg_pll0_ctrl_7[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL0_CTRL_7r_STAT_MODEf_GET(r) (((r).top_xg_pll0_ctrl_7[0]) & 0x3)
#define TOP_XG_PLL0_CTRL_7r_STAT_MODEf_SET(r,f) (r).top_xg_pll0_ctrl_7[0]=(((r).top_xg_pll0_ctrl_7[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define TOP_XG_PLL0_CTRL_7r_STAT_RESETf_GET(r) ((((r).top_xg_pll0_ctrl_7[0]) >> 2) & 0x1)
#define TOP_XG_PLL0_CTRL_7r_STAT_RESETf_SET(r,f) (r).top_xg_pll0_ctrl_7[0]=(((r).top_xg_pll0_ctrl_7[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define TOP_XG_PLL0_CTRL_7r_STAT_SELECTf_GET(r) ((((r).top_xg_pll0_ctrl_7[0]) >> 3) & 0x7)
#define TOP_XG_PLL0_CTRL_7r_STAT_SELECTf_SET(r,f) (r).top_xg_pll0_ctrl_7[0]=(((r).top_xg_pll0_ctrl_7[0] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define TOP_XG_PLL0_CTRL_7r_STAT_UPDATEf_GET(r) ((((r).top_xg_pll0_ctrl_7[0]) >> 6) & 0x1)
#define TOP_XG_PLL0_CTRL_7r_STAT_UPDATEf_SET(r,f) (r).top_xg_pll0_ctrl_7[0]=(((r).top_xg_pll0_ctrl_7[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define TOP_XG_PLL0_CTRL_7r_POST_RSTB_SELf_GET(r) ((((r).top_xg_pll0_ctrl_7[0]) >> 7) & 0x3)
#define TOP_XG_PLL0_CTRL_7r_POST_RSTB_SELf_SET(r,f) (r).top_xg_pll0_ctrl_7[0]=(((r).top_xg_pll0_ctrl_7[0] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define TOP_XG_PLL0_CTRL_7r_ICP_BLEEDf_GET(r) ((((r).top_xg_pll0_ctrl_7[0]) >> 9) & 0x1f)
#define TOP_XG_PLL0_CTRL_7r_ICP_BLEEDf_SET(r,f) (r).top_xg_pll0_ctrl_7[0]=(((r).top_xg_pll0_ctrl_7[0] & ~((uint32)0x1f << 9)) | ((((uint32)f) & 0x1f) << 9))
#define TOP_XG_PLL0_CTRL_7r_ENABLEB_CHf_GET(r) ((((r).top_xg_pll0_ctrl_7[0]) >> 14) & 0x3f)
#define TOP_XG_PLL0_CTRL_7r_ENABLEB_CHf_SET(r,f) (r).top_xg_pll0_ctrl_7[0]=(((r).top_xg_pll0_ctrl_7[0] & ~((uint32)0x3f << 14)) | ((((uint32)f) & 0x3f) << 14))
#define TOP_XG_PLL0_CTRL_7r_HOLD_ALLf_GET(r) ((((r).top_xg_pll0_ctrl_7[0]) >> 20) & 0x1)
#define TOP_XG_PLL0_CTRL_7r_HOLD_ALLf_SET(r,f) (r).top_xg_pll0_ctrl_7[0]=(((r).top_xg_pll0_ctrl_7[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define TOP_XG_PLL0_CTRL_7r_SPARE_DIGf_GET(r) ((((r).top_xg_pll0_ctrl_7[0]) >> 21) & 0xff)
#define TOP_XG_PLL0_CTRL_7r_SPARE_DIGf_SET(r,f) (r).top_xg_pll0_ctrl_7[0]=(((r).top_xg_pll0_ctrl_7[0] & ~((uint32)0xff << 21)) | ((((uint32)f) & 0xff) << 21))
#define TOP_XG_PLL0_CTRL_7r_RSVDf_GET(r) ((((r).top_xg_pll0_ctrl_7[0]) >> 29) & 0x7)
#define TOP_XG_PLL0_CTRL_7r_RSVDf_SET(r,f) (r).top_xg_pll0_ctrl_7[0]=(((r).top_xg_pll0_ctrl_7[0] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))

/*
 * These macros can be used to access TOP_XG_PLL0_CTRL_7.
 */
#define WRITE_TOP_XG_PLL0_CTRL_7r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL0_CTRL_7,(r._top_xg_pll0_ctrl_7))
#define READ_TOP_XG_PLL0_CTRL_7r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL0_CTRL_7,&(r._top_xg_pll0_ctrl_7))

/*******************************************************************************
 * End of 'TOP_XG_PLL0_CTRL_7r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL0_CTRL_8
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL0 Control register 8
 * SIZE:     32
 * FIELDS:
 *     BUF_CTRL         LC_PLL i_buf_ctrl : Pad driver and internal CML buffers bias and output load options
 *     CP_CTRL          LC_PLL i_cp_ctrl : CP bias options[1:0]  :  Bc_scale<1:0>[2]    :  cp_down_en[6:3]  :  CP_CTL<3:0>
 *     D2C1_CTRL        LC_PLL i_d2c1_ctrl[2:0] : D2C tail_res         000- 950 Ohm         001- 760 Ohm         010- 630 Ohm         011- 545 Ohm         100- open         101- 3.8  kOhm         110- 1.9  kOhm         111- 1.24 kOhm[4:3] : gate_bias         000- 950 Ohm         001- 760 Ohm         010- 630 Ohm         011- 545 Ohm         100- open         101- 3.8  kOhm         110- 1.9  kOhm         111- 1.24 kOhm[7:5] : term_en         000-      100 Ohm         001, 010  133 Ohm         011-      200 Ohm         101, 110  400 Ohm         111-      no termination       
 *     D2C2_CTRL        LC_PLL i_d2c1_ctrl[2:0] : D2C tail_res         000- 950 Ohm         001- 760 Ohm         010- 630 Ohm         011- 545 Ohm         100- open         101- 3.8  kOhm         110- 1.9  kOhm         111- 1.24 kOhm[4:3] : gate_bias         000- 950 Ohm         001- 760 Ohm         010- 630 Ohm         011- 545 Ohm         100- open         101- 3.8  kOhm         110- 1.9  kOhm         111- 1.24 kOhm[7:5] : term_en         000-      100 Ohm         001, 010  133 Ohm         011-      200 Ohm         101, 110  400 Ohm         111-      no termination       
 */
#define TOP_XG_PLL0_CTRL_8r_SIZE 4

/* TOP_XG_PLL0_CTRL_8r is element of TOP_XG_PLL_CTRL_8 */

/*
 * This structure should be used to declare and program TOP_XG_PLL0_CTRL_8.
 */
typedef union TOP_XG_PLL0_CTRL_8r_s {
	uint32 v[1];
	uint32 top_xg_pll0_ctrl_8[1];
	uint32 _top_xg_pll0_ctrl_8;
} TOP_XG_PLL0_CTRL_8r_t;

#define TOP_XG_PLL0_CTRL_8r_CLR(r) (r).top_xg_pll0_ctrl_8[0] = 0
#define TOP_XG_PLL0_CTRL_8r_SET(r,d) (r).top_xg_pll0_ctrl_8[0] = d
#define TOP_XG_PLL0_CTRL_8r_GET(r) (r).top_xg_pll0_ctrl_8[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL0_CTRL_8r_BUF_CTRLf_GET(r) (((r).top_xg_pll0_ctrl_8[0]) & 0xff)
#define TOP_XG_PLL0_CTRL_8r_BUF_CTRLf_SET(r,f) (r).top_xg_pll0_ctrl_8[0]=(((r).top_xg_pll0_ctrl_8[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define TOP_XG_PLL0_CTRL_8r_CP_CTRLf_GET(r) ((((r).top_xg_pll0_ctrl_8[0]) >> 8) & 0xff)
#define TOP_XG_PLL0_CTRL_8r_CP_CTRLf_SET(r,f) (r).top_xg_pll0_ctrl_8[0]=(((r).top_xg_pll0_ctrl_8[0] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define TOP_XG_PLL0_CTRL_8r_D2C1_CTRLf_GET(r) ((((r).top_xg_pll0_ctrl_8[0]) >> 16) & 0xff)
#define TOP_XG_PLL0_CTRL_8r_D2C1_CTRLf_SET(r,f) (r).top_xg_pll0_ctrl_8[0]=(((r).top_xg_pll0_ctrl_8[0] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define TOP_XG_PLL0_CTRL_8r_D2C2_CTRLf_GET(r) ((((r).top_xg_pll0_ctrl_8[0]) >> 24) & 0xff)
#define TOP_XG_PLL0_CTRL_8r_D2C2_CTRLf_SET(r,f) (r).top_xg_pll0_ctrl_8[0]=(((r).top_xg_pll0_ctrl_8[0] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))

/*
 * These macros can be used to access TOP_XG_PLL0_CTRL_8.
 */
#define WRITE_TOP_XG_PLL0_CTRL_8r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL0_CTRL_8,(r._top_xg_pll0_ctrl_8))
#define READ_TOP_XG_PLL0_CTRL_8r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL0_CTRL_8,&(r._top_xg_pll0_ctrl_8))

/*******************************************************************************
 * End of 'TOP_XG_PLL0_CTRL_8r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL0_CTRL_9
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL0 Control register 9
 * SIZE:     32
 * FIELDS:
 *     BG_CTRL          LC_PLL i_bg_ctrl : BG configuration options
 *     STAYS_LOCKED     LC_PLL i_stays_locked : debugging option to keep lock detector from resetting while unlocked.0= normal operation1= prevents reset when PLL is unlocked
 *     DC_COMP_OPT      LC_PLL i_dc_comp_opt :When reference clock doubler is used, these control pins enable reference duty cycle compensation with different options.000= compensation disabled. When doubler is disabled, compensation technique should be disabled as well.001= compensation enabled. Coarse compensation precision with coarse duty cycle error measurement precision010= compensation enabled. Coarse compensation precision with fine duty cycle error measurement precision.011= compensation enabled. Fine compensation precision with fine duty cycle error measurement precision1xx= not allowed.
 *     VCO_FB_DIV2      XG PLL0 VCO fb div2 
 *     VC_OVERRIDE      vc_override : VC manual setting, 0-Bit_Hold_VC defined by digital, 1-Bit_Hold_VC=1
 *     RSVD             Reserved
 */
#define TOP_XG_PLL0_CTRL_9r_SIZE 4

/* TOP_XG_PLL0_CTRL_9r is element of TOP_XG_PLL_CTRL_9 */

/*
 * This structure should be used to declare and program TOP_XG_PLL0_CTRL_9.
 */
typedef union TOP_XG_PLL0_CTRL_9r_s {
	uint32 v[1];
	uint32 top_xg_pll0_ctrl_9[1];
	uint32 _top_xg_pll0_ctrl_9;
} TOP_XG_PLL0_CTRL_9r_t;

#define TOP_XG_PLL0_CTRL_9r_CLR(r) (r).top_xg_pll0_ctrl_9[0] = 0
#define TOP_XG_PLL0_CTRL_9r_SET(r,d) (r).top_xg_pll0_ctrl_9[0] = d
#define TOP_XG_PLL0_CTRL_9r_GET(r) (r).top_xg_pll0_ctrl_9[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL0_CTRL_9r_BG_CTRLf_GET(r) (((r).top_xg_pll0_ctrl_9[0]) & 0xfffff)
#define TOP_XG_PLL0_CTRL_9r_BG_CTRLf_SET(r,f) (r).top_xg_pll0_ctrl_9[0]=(((r).top_xg_pll0_ctrl_9[0] & ~((uint32)0xfffff)) | (((uint32)f) & 0xfffff))
#define TOP_XG_PLL0_CTRL_9r_STAYS_LOCKEDf_GET(r) ((((r).top_xg_pll0_ctrl_9[0]) >> 20) & 0x1)
#define TOP_XG_PLL0_CTRL_9r_STAYS_LOCKEDf_SET(r,f) (r).top_xg_pll0_ctrl_9[0]=(((r).top_xg_pll0_ctrl_9[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define TOP_XG_PLL0_CTRL_9r_DC_COMP_OPTf_GET(r) ((((r).top_xg_pll0_ctrl_9[0]) >> 24) & 0x7)
#define TOP_XG_PLL0_CTRL_9r_DC_COMP_OPTf_SET(r,f) (r).top_xg_pll0_ctrl_9[0]=(((r).top_xg_pll0_ctrl_9[0] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define TOP_XG_PLL0_CTRL_9r_VCO_FB_DIV2f_GET(r) ((((r).top_xg_pll0_ctrl_9[0]) >> 27) & 0x1)
#define TOP_XG_PLL0_CTRL_9r_VCO_FB_DIV2f_SET(r,f) (r).top_xg_pll0_ctrl_9[0]=(((r).top_xg_pll0_ctrl_9[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define TOP_XG_PLL0_CTRL_9r_VC_OVERRIDEf_GET(r) ((((r).top_xg_pll0_ctrl_9[0]) >> 28) & 0x1)
#define TOP_XG_PLL0_CTRL_9r_VC_OVERRIDEf_SET(r,f) (r).top_xg_pll0_ctrl_9[0]=(((r).top_xg_pll0_ctrl_9[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define TOP_XG_PLL0_CTRL_9r_RSVDf_GET(r) ((((r).top_xg_pll0_ctrl_9[0]) >> 29) & 0x7)
#define TOP_XG_PLL0_CTRL_9r_RSVDf_SET(r,f) (r).top_xg_pll0_ctrl_9[0]=(((r).top_xg_pll0_ctrl_9[0] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))

/*
 * These macros can be used to access TOP_XG_PLL0_CTRL_9.
 */
#define WRITE_TOP_XG_PLL0_CTRL_9r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL0_CTRL_9,(r._top_xg_pll0_ctrl_9))
#define READ_TOP_XG_PLL0_CTRL_9r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL0_CTRL_9,&(r._top_xg_pll0_ctrl_9))

/*******************************************************************************
 * End of 'TOP_XG_PLL0_CTRL_9r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL0_STATUS
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL0 Status
 * SIZE:     32
 * FIELDS:
 *     XGPLL_STATUS     XG_PLL0 Status bits [11:0], other bits are reserved
 *     TOP_XGPLL_LOCK   XG_PLL0 Lock
 */
#define TOP_XG_PLL0_STATUSr_SIZE 4

/* TOP_XG_PLL0_STATUSr is element of TOP_XG_PLL_STATUS */

/*
 * This structure should be used to declare and program TOP_XG_PLL0_STATUS.
 */
typedef union TOP_XG_PLL0_STATUSr_s {
	uint32 v[1];
	uint32 top_xg_pll0_status[1];
	uint32 _top_xg_pll0_status;
} TOP_XG_PLL0_STATUSr_t;

#define TOP_XG_PLL0_STATUSr_CLR(r) (r).top_xg_pll0_status[0] = 0
#define TOP_XG_PLL0_STATUSr_SET(r,d) (r).top_xg_pll0_status[0] = d
#define TOP_XG_PLL0_STATUSr_GET(r) (r).top_xg_pll0_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL0_STATUSr_XGPLL_STATUSf_GET(r) (((r).top_xg_pll0_status[0]) & 0x7fffffff)
#define TOP_XG_PLL0_STATUSr_XGPLL_STATUSf_SET(r,f) (r).top_xg_pll0_status[0]=(((r).top_xg_pll0_status[0] & ~((uint32)0x7fffffff)) | (((uint32)f) & 0x7fffffff))
#define TOP_XG_PLL0_STATUSr_TOP_XGPLL_LOCKf_GET(r) ((((r).top_xg_pll0_status[0]) >> 31) & 0x1)
#define TOP_XG_PLL0_STATUSr_TOP_XGPLL_LOCKf_SET(r,f) (r).top_xg_pll0_status[0]=(((r).top_xg_pll0_status[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access TOP_XG_PLL0_STATUS.
 */
#define WRITE_TOP_XG_PLL0_STATUSr(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL0_STATUS,(r._top_xg_pll0_status))
#define READ_TOP_XG_PLL0_STATUSr(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL0_STATUS,&(r._top_xg_pll0_status))

/*******************************************************************************
 * End of 'TOP_XG_PLL0_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL1_CTRL_0
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL1 Control register 0
 * SIZE:     32
 * FIELDS:
 *     CH0_MDIV         channel 0 post divider
 *     CH0_MDEL         Programmable delay for post-divider channel 0 (half of VCO period steps)
 *     CH1_MDIV         Obsolette. channel 1 post divider
 *     CH1_MDEL         Programmable delay for post-divider channel 1 (half of VCO period steps)
 *     CH2_MDIV         Obsolette.channel 2 post divider
 *     CH2_MDEL         Programmable delay for post-divider channel 0 (half of VCO period steps)
 */
#define TOP_XG_PLL1_CTRL_0r_SIZE 4

/* TOP_XG_PLL1_CTRL_0r is element of TOP_XG_PLL_CTRL_0 */

/*
 * This structure should be used to declare and program TOP_XG_PLL1_CTRL_0.
 */
typedef union TOP_XG_PLL1_CTRL_0r_s {
	uint32 v[1];
	uint32 top_xg_pll1_ctrl_0[1];
	uint32 _top_xg_pll1_ctrl_0;
} TOP_XG_PLL1_CTRL_0r_t;

#define TOP_XG_PLL1_CTRL_0r_CLR(r) (r).top_xg_pll1_ctrl_0[0] = 0
#define TOP_XG_PLL1_CTRL_0r_SET(r,d) (r).top_xg_pll1_ctrl_0[0] = d
#define TOP_XG_PLL1_CTRL_0r_GET(r) (r).top_xg_pll1_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL1_CTRL_0r_CH0_MDIVf_GET(r) (((r).top_xg_pll1_ctrl_0[0]) & 0x1ff)
#define TOP_XG_PLL1_CTRL_0r_CH0_MDIVf_SET(r,f) (r).top_xg_pll1_ctrl_0[0]=(((r).top_xg_pll1_ctrl_0[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define TOP_XG_PLL1_CTRL_0r_CH0_MDELf_GET(r) ((((r).top_xg_pll1_ctrl_0[0]) >> 9) & 0x1)
#define TOP_XG_PLL1_CTRL_0r_CH0_MDELf_SET(r,f) (r).top_xg_pll1_ctrl_0[0]=(((r).top_xg_pll1_ctrl_0[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_XG_PLL1_CTRL_0r_CH1_MDIVf_GET(r) ((((r).top_xg_pll1_ctrl_0[0]) >> 10) & 0x1ff)
#define TOP_XG_PLL1_CTRL_0r_CH1_MDIVf_SET(r,f) (r).top_xg_pll1_ctrl_0[0]=(((r).top_xg_pll1_ctrl_0[0] & ~((uint32)0x1ff << 10)) | ((((uint32)f) & 0x1ff) << 10))
#define TOP_XG_PLL1_CTRL_0r_CH1_MDELf_GET(r) ((((r).top_xg_pll1_ctrl_0[0]) >> 19) & 0x1)
#define TOP_XG_PLL1_CTRL_0r_CH1_MDELf_SET(r,f) (r).top_xg_pll1_ctrl_0[0]=(((r).top_xg_pll1_ctrl_0[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define TOP_XG_PLL1_CTRL_0r_CH2_MDIVf_GET(r) ((((r).top_xg_pll1_ctrl_0[0]) >> 20) & 0x1ff)
#define TOP_XG_PLL1_CTRL_0r_CH2_MDIVf_SET(r,f) (r).top_xg_pll1_ctrl_0[0]=(((r).top_xg_pll1_ctrl_0[0] & ~((uint32)0x1ff << 20)) | ((((uint32)f) & 0x1ff) << 20))
#define TOP_XG_PLL1_CTRL_0r_CH2_MDELf_GET(r) ((((r).top_xg_pll1_ctrl_0[0]) >> 29) & 0x1)
#define TOP_XG_PLL1_CTRL_0r_CH2_MDELf_SET(r,f) (r).top_xg_pll1_ctrl_0[0]=(((r).top_xg_pll1_ctrl_0[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))

/*
 * These macros can be used to access TOP_XG_PLL1_CTRL_0.
 */
#define WRITE_TOP_XG_PLL1_CTRL_0r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL1_CTRL_0,(r._top_xg_pll1_ctrl_0))
#define READ_TOP_XG_PLL1_CTRL_0r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL1_CTRL_0,&(r._top_xg_pll1_ctrl_0))

/*******************************************************************************
 * End of 'TOP_XG_PLL1_CTRL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL1_CTRL_1
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL1 Control register 1
 * SIZE:     32
 * FIELDS:
 *     HOLD_CH          Hold Enable for post-divider channel 0-5. when de-asserted(logic 0) clock will start syn to VCO clock
 *     LOAD_EN_CH       LOAD enable for post-divider channel 0-5. Allows "on-the-fly" divider reporgramming (glitch free)
 *     PDIV             input reference clock pre-divider control.
 *     FREFEFF_INFO     default XG PLL1 fref effective = 50MHz (after pdiv) 
 *     AUTO_CNFG_DSBL   Disable of auto-configuration function for each control groupauto_cnfg_dsbl<0> disables CP related control: icp and icp_bleedauto_cnfg_dsbl<1> disables LF primary control: rz, cz, and cpauto_cnfg_dsbl<2> disables LF secondary control: rp1 and cp1auto_cnfg_dsbl<3> disables VCO calibration related control:vco_gainauto_cnfg_dsbl<4> disables VCO calibration related control:code_vcocal and hold_delayauto_cnfg_dsbl<5> disables controller related control:lock_cnt and wdt_cntauto_cnfg_dsbl<6> N/Aauto_cnfg_dsbl<7> disables pll_resetb
 */
#define TOP_XG_PLL1_CTRL_1r_SIZE 4

/* TOP_XG_PLL1_CTRL_1r is element of TOP_XG_PLL_CTRL_1 */

/*
 * This structure should be used to declare and program TOP_XG_PLL1_CTRL_1.
 */
typedef union TOP_XG_PLL1_CTRL_1r_s {
	uint32 v[1];
	uint32 top_xg_pll1_ctrl_1[1];
	uint32 _top_xg_pll1_ctrl_1;
} TOP_XG_PLL1_CTRL_1r_t;

#define TOP_XG_PLL1_CTRL_1r_CLR(r) (r).top_xg_pll1_ctrl_1[0] = 0
#define TOP_XG_PLL1_CTRL_1r_SET(r,d) (r).top_xg_pll1_ctrl_1[0] = d
#define TOP_XG_PLL1_CTRL_1r_GET(r) (r).top_xg_pll1_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL1_CTRL_1r_HOLD_CHf_GET(r) (((r).top_xg_pll1_ctrl_1[0]) & 0x3f)
#define TOP_XG_PLL1_CTRL_1r_HOLD_CHf_SET(r,f) (r).top_xg_pll1_ctrl_1[0]=(((r).top_xg_pll1_ctrl_1[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define TOP_XG_PLL1_CTRL_1r_LOAD_EN_CHf_GET(r) ((((r).top_xg_pll1_ctrl_1[0]) >> 6) & 0x3f)
#define TOP_XG_PLL1_CTRL_1r_LOAD_EN_CHf_SET(r,f) (r).top_xg_pll1_ctrl_1[0]=(((r).top_xg_pll1_ctrl_1[0] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define TOP_XG_PLL1_CTRL_1r_PDIVf_GET(r) ((((r).top_xg_pll1_ctrl_1[0]) >> 12) & 0xf)
#define TOP_XG_PLL1_CTRL_1r_PDIVf_SET(r,f) (r).top_xg_pll1_ctrl_1[0]=(((r).top_xg_pll1_ctrl_1[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define TOP_XG_PLL1_CTRL_1r_FREFEFF_INFOf_GET(r) ((((r).top_xg_pll1_ctrl_1[0]) >> 16) & 0xff)
#define TOP_XG_PLL1_CTRL_1r_FREFEFF_INFOf_SET(r,f) (r).top_xg_pll1_ctrl_1[0]=(((r).top_xg_pll1_ctrl_1[0] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define TOP_XG_PLL1_CTRL_1r_AUTO_CNFG_DSBLf_GET(r) ((((r).top_xg_pll1_ctrl_1[0]) >> 24) & 0xff)
#define TOP_XG_PLL1_CTRL_1r_AUTO_CNFG_DSBLf_SET(r,f) (r).top_xg_pll1_ctrl_1[0]=(((r).top_xg_pll1_ctrl_1[0] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))

/*
 * These macros can be used to access TOP_XG_PLL1_CTRL_1.
 */
#define WRITE_TOP_XG_PLL1_CTRL_1r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL1_CTRL_1,(r._top_xg_pll1_ctrl_1))
#define READ_TOP_XG_PLL1_CTRL_1r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL1_CTRL_1,&(r._top_xg_pll1_ctrl_1))

/*******************************************************************************
 * End of 'TOP_XG_PLL1_CTRL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL1_CTRL_10
 * BLOCKS:   TOP
 * DESC:     TOP XG PLL1 Control Register 10
 * SIZE:     32
 * FIELDS:
 *     PLL_CTRL         i_pll_ctrl : VCO and PFD configuration options[2:0] : VCO_CTRL<2:0> (spare, not connected)[5:3] : vco current[8:6] : PFD Bit_Delay_Ctrl <2:0>[10:9] : Frequency doubler delay [23:11] : spare
 *     RSVD             Reserved
 */
#define TOP_XG_PLL1_CTRL_10r_SIZE 4

/* TOP_XG_PLL1_CTRL_10r is element of TOP_XG_PLL_CTRL_10 */

/*
 * This structure should be used to declare and program TOP_XG_PLL1_CTRL_10.
 */
typedef union TOP_XG_PLL1_CTRL_10r_s {
	uint32 v[1];
	uint32 top_xg_pll1_ctrl_10[1];
	uint32 _top_xg_pll1_ctrl_10;
} TOP_XG_PLL1_CTRL_10r_t;

#define TOP_XG_PLL1_CTRL_10r_CLR(r) (r).top_xg_pll1_ctrl_10[0] = 0
#define TOP_XG_PLL1_CTRL_10r_SET(r,d) (r).top_xg_pll1_ctrl_10[0] = d
#define TOP_XG_PLL1_CTRL_10r_GET(r) (r).top_xg_pll1_ctrl_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL1_CTRL_10r_PLL_CTRLf_GET(r) (((r).top_xg_pll1_ctrl_10[0]) & 0xffffff)
#define TOP_XG_PLL1_CTRL_10r_PLL_CTRLf_SET(r,f) (r).top_xg_pll1_ctrl_10[0]=(((r).top_xg_pll1_ctrl_10[0] & ~((uint32)0xffffff)) | (((uint32)f) & 0xffffff))
#define TOP_XG_PLL1_CTRL_10r_RSVDf_GET(r) ((((r).top_xg_pll1_ctrl_10[0]) >> 24) & 0xff)
#define TOP_XG_PLL1_CTRL_10r_RSVDf_SET(r,f) (r).top_xg_pll1_ctrl_10[0]=(((r).top_xg_pll1_ctrl_10[0] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))

/*
 * These macros can be used to access TOP_XG_PLL1_CTRL_10.
 */
#define WRITE_TOP_XG_PLL1_CTRL_10r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL1_CTRL_10,(r._top_xg_pll1_ctrl_10))
#define READ_TOP_XG_PLL1_CTRL_10r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL1_CTRL_10,&(r._top_xg_pll1_ctrl_10))

/*******************************************************************************
 * End of 'TOP_XG_PLL1_CTRL_10r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL1_CTRL_2
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL1 Control register 2
 * SIZE:     32
 * FIELDS:
 *     CH3_MDIV         Obsolette.channel 3 post divider
 *     CH3_MDEL         Obsolette.Programmable delay for post-divider channel 3 (half of VCO period steps)
 *     CH4_MDIV         Obsolette.channel 4 post divider
 *     CH4_MDEL         Obsolette.Programmable delay for post-divider channel 4 (half of VCO period steps)
 *     CH5_MDIV         Obsolette. channel 5 post divider
 *     CH5_MDEL         Obsolette.Programmable delay for post-divider channel 5 (half of VCO period steps)
 */
#define TOP_XG_PLL1_CTRL_2r_SIZE 4

/* TOP_XG_PLL1_CTRL_2r is element of TOP_XG_PLL_CTRL_2 */

/*
 * This structure should be used to declare and program TOP_XG_PLL1_CTRL_2.
 */
typedef union TOP_XG_PLL1_CTRL_2r_s {
	uint32 v[1];
	uint32 top_xg_pll1_ctrl_2[1];
	uint32 _top_xg_pll1_ctrl_2;
} TOP_XG_PLL1_CTRL_2r_t;

#define TOP_XG_PLL1_CTRL_2r_CLR(r) (r).top_xg_pll1_ctrl_2[0] = 0
#define TOP_XG_PLL1_CTRL_2r_SET(r,d) (r).top_xg_pll1_ctrl_2[0] = d
#define TOP_XG_PLL1_CTRL_2r_GET(r) (r).top_xg_pll1_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL1_CTRL_2r_CH3_MDIVf_GET(r) (((r).top_xg_pll1_ctrl_2[0]) & 0x1ff)
#define TOP_XG_PLL1_CTRL_2r_CH3_MDIVf_SET(r,f) (r).top_xg_pll1_ctrl_2[0]=(((r).top_xg_pll1_ctrl_2[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define TOP_XG_PLL1_CTRL_2r_CH3_MDELf_GET(r) ((((r).top_xg_pll1_ctrl_2[0]) >> 9) & 0x1)
#define TOP_XG_PLL1_CTRL_2r_CH3_MDELf_SET(r,f) (r).top_xg_pll1_ctrl_2[0]=(((r).top_xg_pll1_ctrl_2[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_XG_PLL1_CTRL_2r_CH4_MDIVf_GET(r) ((((r).top_xg_pll1_ctrl_2[0]) >> 10) & 0x1ff)
#define TOP_XG_PLL1_CTRL_2r_CH4_MDIVf_SET(r,f) (r).top_xg_pll1_ctrl_2[0]=(((r).top_xg_pll1_ctrl_2[0] & ~((uint32)0x1ff << 10)) | ((((uint32)f) & 0x1ff) << 10))
#define TOP_XG_PLL1_CTRL_2r_CH4_MDELf_GET(r) ((((r).top_xg_pll1_ctrl_2[0]) >> 19) & 0x1)
#define TOP_XG_PLL1_CTRL_2r_CH4_MDELf_SET(r,f) (r).top_xg_pll1_ctrl_2[0]=(((r).top_xg_pll1_ctrl_2[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define TOP_XG_PLL1_CTRL_2r_CH5_MDIVf_GET(r) ((((r).top_xg_pll1_ctrl_2[0]) >> 20) & 0x1ff)
#define TOP_XG_PLL1_CTRL_2r_CH5_MDIVf_SET(r,f) (r).top_xg_pll1_ctrl_2[0]=(((r).top_xg_pll1_ctrl_2[0] & ~((uint32)0x1ff << 20)) | ((((uint32)f) & 0x1ff) << 20))
#define TOP_XG_PLL1_CTRL_2r_CH5_MDELf_GET(r) ((((r).top_xg_pll1_ctrl_2[0]) >> 29) & 0x1)
#define TOP_XG_PLL1_CTRL_2r_CH5_MDELf_SET(r,f) (r).top_xg_pll1_ctrl_2[0]=(((r).top_xg_pll1_ctrl_2[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))

/*
 * These macros can be used to access TOP_XG_PLL1_CTRL_2.
 */
#define WRITE_TOP_XG_PLL1_CTRL_2r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL1_CTRL_2,(r._top_xg_pll1_ctrl_2))
#define READ_TOP_XG_PLL1_CTRL_2r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL1_CTRL_2,&(r._top_xg_pll1_ctrl_2))

/*******************************************************************************
 * End of 'TOP_XG_PLL1_CTRL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL1_CTRL_3
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL1 Control register 3
 * SIZE:     32
 * FIELDS:
 *     ROUTE_CTRL       XG PLL1 ROUTE_CTRL:[0] Select between internal and external differential clock inputs, 0-ext 1-int[1] Select o_REF_CLK source, 0- diff clock mux out  1- refclk input    [3:2] Select CML output pad source, 00-ch[0] 01-o_REF_CLK 1x-ch[1] [5:4] Select o_cml1p/n source, 00-ch[0] 01-ch[1] 1x- o_REF_CLK[7:6] Select o_cml2p/n source, 00-ch[0] 01-ch[1] 1x- o_REF_CLK[8]   Select o_clk25_out, 0- refclk_out, 1- byp25 (channel 4 bypass)
 *     WDT_ENB          XG PLL1 watchdog timer enable 
 *     WDT_CNT          XG PLL1 watchdog timer count select 
 *     MASH11_MODE      
 *     RATE_MNGR_MODE                      enable or disable for the post channel
 *     CODE_VCOCAL                         Programmable VCO Calibration time                      00: refclk counter counts 1024 refclk cyles                       01: refclk counter counts 512 refclk cyles                       10: refclk counter counts 256refclk cyles                       11: refclk counter counts 128 refclk cyles
 *     HOLD_DELAY                          Programmable delay for analog voltage to settle                      000: delay 1 refclk cycle                      001: delay 3 refclk cycles                      010: delay 7 refclk cycles                      011: delay 15 refclk cycles                      100: delay 31 refclk cycles                      101: delay 63 refclk cycles                      110: delay 127 refclk cycles                      111: delay 255 refclk cycles
 *     BYPASS_MODE                         enable for manual VCO tuning                      0: auto tuning                      1: manual tuning
 *     BYPASS_DAC                          Bypass DAC value can use to control VCO frequency when bypass_mode is set to 1
 *     PQ_MODE          Ratio based frequency divider mode
 */
#define TOP_XG_PLL1_CTRL_3r_SIZE 4

/* TOP_XG_PLL1_CTRL_3r is element of TOP_XG_PLL_CTRL_3 */

/*
 * This structure should be used to declare and program TOP_XG_PLL1_CTRL_3.
 */
typedef union TOP_XG_PLL1_CTRL_3r_s {
	uint32 v[1];
	uint32 top_xg_pll1_ctrl_3[1];
	uint32 _top_xg_pll1_ctrl_3;
} TOP_XG_PLL1_CTRL_3r_t;

#define TOP_XG_PLL1_CTRL_3r_CLR(r) (r).top_xg_pll1_ctrl_3[0] = 0
#define TOP_XG_PLL1_CTRL_3r_SET(r,d) (r).top_xg_pll1_ctrl_3[0] = d
#define TOP_XG_PLL1_CTRL_3r_GET(r) (r).top_xg_pll1_ctrl_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL1_CTRL_3r_ROUTE_CTRLf_GET(r) (((r).top_xg_pll1_ctrl_3[0]) & 0x1ff)
#define TOP_XG_PLL1_CTRL_3r_ROUTE_CTRLf_SET(r,f) (r).top_xg_pll1_ctrl_3[0]=(((r).top_xg_pll1_ctrl_3[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define TOP_XG_PLL1_CTRL_3r_WDT_ENBf_GET(r) ((((r).top_xg_pll1_ctrl_3[0]) >> 9) & 0x1)
#define TOP_XG_PLL1_CTRL_3r_WDT_ENBf_SET(r,f) (r).top_xg_pll1_ctrl_3[0]=(((r).top_xg_pll1_ctrl_3[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_XG_PLL1_CTRL_3r_WDT_CNTf_GET(r) ((((r).top_xg_pll1_ctrl_3[0]) >> 10) & 0x3)
#define TOP_XG_PLL1_CTRL_3r_WDT_CNTf_SET(r,f) (r).top_xg_pll1_ctrl_3[0]=(((r).top_xg_pll1_ctrl_3[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define TOP_XG_PLL1_CTRL_3r_MASH11_MODEf_GET(r) ((((r).top_xg_pll1_ctrl_3[0]) >> 13) & 0x1)
#define TOP_XG_PLL1_CTRL_3r_MASH11_MODEf_SET(r,f) (r).top_xg_pll1_ctrl_3[0]=(((r).top_xg_pll1_ctrl_3[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define TOP_XG_PLL1_CTRL_3r_RATE_MNGR_MODEf_GET(r) ((((r).top_xg_pll1_ctrl_3[0]) >> 14) & 0x1)
#define TOP_XG_PLL1_CTRL_3r_RATE_MNGR_MODEf_SET(r,f) (r).top_xg_pll1_ctrl_3[0]=(((r).top_xg_pll1_ctrl_3[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define TOP_XG_PLL1_CTRL_3r_CODE_VCOCALf_GET(r) ((((r).top_xg_pll1_ctrl_3[0]) >> 15) & 0x3)
#define TOP_XG_PLL1_CTRL_3r_CODE_VCOCALf_SET(r,f) (r).top_xg_pll1_ctrl_3[0]=(((r).top_xg_pll1_ctrl_3[0] & ~((uint32)0x3 << 15)) | ((((uint32)f) & 0x3) << 15))
#define TOP_XG_PLL1_CTRL_3r_HOLD_DELAYf_GET(r) ((((r).top_xg_pll1_ctrl_3[0]) >> 17) & 0x7)
#define TOP_XG_PLL1_CTRL_3r_HOLD_DELAYf_SET(r,f) (r).top_xg_pll1_ctrl_3[0]=(((r).top_xg_pll1_ctrl_3[0] & ~((uint32)0x7 << 17)) | ((((uint32)f) & 0x7) << 17))
#define TOP_XG_PLL1_CTRL_3r_BYPASS_MODEf_GET(r) ((((r).top_xg_pll1_ctrl_3[0]) >> 20) & 0x1)
#define TOP_XG_PLL1_CTRL_3r_BYPASS_MODEf_SET(r,f) (r).top_xg_pll1_ctrl_3[0]=(((r).top_xg_pll1_ctrl_3[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define TOP_XG_PLL1_CTRL_3r_BYPASS_DACf_GET(r) ((((r).top_xg_pll1_ctrl_3[0]) >> 21) & 0x1ff)
#define TOP_XG_PLL1_CTRL_3r_BYPASS_DACf_SET(r,f) (r).top_xg_pll1_ctrl_3[0]=(((r).top_xg_pll1_ctrl_3[0] & ~((uint32)0x1ff << 21)) | ((((uint32)f) & 0x1ff) << 21))
#define TOP_XG_PLL1_CTRL_3r_PQ_MODEf_GET(r) ((((r).top_xg_pll1_ctrl_3[0]) >> 31) & 0x1)
#define TOP_XG_PLL1_CTRL_3r_PQ_MODEf_SET(r,f) (r).top_xg_pll1_ctrl_3[0]=(((r).top_xg_pll1_ctrl_3[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access TOP_XG_PLL1_CTRL_3.
 */
#define WRITE_TOP_XG_PLL1_CTRL_3r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL1_CTRL_3,(r._top_xg_pll1_ctrl_3))
#define READ_TOP_XG_PLL1_CTRL_3r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL1_CTRL_3,&(r._top_xg_pll1_ctrl_3))

/*******************************************************************************
 * End of 'TOP_XG_PLL1_CTRL_3r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL1_CTRL_4
 * BLOCKS:   TOP
 * DESC:     Obsolette. NDIV value is controlled by holdover_logic.TOP XG_PLL1 Control register 4
 * SIZE:     32
 * FIELDS:
 *     NDIV_INT                         Feedback divider control (Code = divider ratio). Default is 125 (decimal).                    0000000000= divide-by-1024                    0000000001= XXX                    0000000010= XXX                    :                    0000000111= XXX                    0000001000= divide-by-8                    0000001001= divide-by-9                    0000001010= divide-by-10                    :                    1111111110= divide-by-1022                    1111111111= divide-by-1023
 *     NDIV_FRAC                        Fractional part of Feedback Divider Rate (N).Default is 0 (decimal).                This value, divided by 2^20, is added to i_ndiv_int to determine the                 effective feedback divider rate N.                Concatinating these busses {i_ndiv_int, i_ndiv_frac} creates a 30-bit number                sometimes referred to as the Frequency Control Word (fcw), with 10 integer                 bits and 20 fractional bits.
 */
#define TOP_XG_PLL1_CTRL_4r_SIZE 4

/* TOP_XG_PLL1_CTRL_4r is element of TOP_XG_PLL_CTRL_4 */

/*
 * This structure should be used to declare and program TOP_XG_PLL1_CTRL_4.
 */
typedef union TOP_XG_PLL1_CTRL_4r_s {
	uint32 v[1];
	uint32 top_xg_pll1_ctrl_4[1];
	uint32 _top_xg_pll1_ctrl_4;
} TOP_XG_PLL1_CTRL_4r_t;

#define TOP_XG_PLL1_CTRL_4r_CLR(r) (r).top_xg_pll1_ctrl_4[0] = 0
#define TOP_XG_PLL1_CTRL_4r_SET(r,d) (r).top_xg_pll1_ctrl_4[0] = d
#define TOP_XG_PLL1_CTRL_4r_GET(r) (r).top_xg_pll1_ctrl_4[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL1_CTRL_4r_NDIV_INTf_GET(r) (((r).top_xg_pll1_ctrl_4[0]) & 0x3ff)
#define TOP_XG_PLL1_CTRL_4r_NDIV_INTf_SET(r,f) (r).top_xg_pll1_ctrl_4[0]=(((r).top_xg_pll1_ctrl_4[0] & ~((uint32)0x3ff)) | (((uint32)f) & 0x3ff))
#define TOP_XG_PLL1_CTRL_4r_NDIV_FRACf_GET(r) ((((r).top_xg_pll1_ctrl_4[0]) >> 10) & 0x3fffff)
#define TOP_XG_PLL1_CTRL_4r_NDIV_FRACf_SET(r,f) (r).top_xg_pll1_ctrl_4[0]=(((r).top_xg_pll1_ctrl_4[0] & ~((uint32)0x3fffff << 10)) | ((((uint32)f) & 0x3fffff) << 10))

/*
 * These macros can be used to access TOP_XG_PLL1_CTRL_4.
 */
#define WRITE_TOP_XG_PLL1_CTRL_4r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL1_CTRL_4,(r._top_xg_pll1_ctrl_4))
#define READ_TOP_XG_PLL1_CTRL_4r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL1_CTRL_4,&(r._top_xg_pll1_ctrl_4))

/*******************************************************************************
 * End of 'TOP_XG_PLL1_CTRL_4r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL1_CTRL_5
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL1 Control register 5
 * SIZE:     32
 * FIELDS:
 *     VCO_GAIN                         Controlling VCO gain for VCO1 and VCO2
 *     RZ                               Control Rz                 Rz=(1+code*2)Kohm                    00000: 2kohm                    00001: 4kohm                    00010: 6kohm                    00100: 8kohm                    ...                   11111: 18kohm
 *     RP                               Control Rp                 Rp=(1+code*1)Kohm                    000: 1kohm                    001: 24kohm                    010: 4kohm                    100: 5kohm                    ...                   111: 8kohm
 *     ICP                              Control CP current control                    Max CP current --> 600uA                    Min CP current --> 10uA
 *     CZ                               control Cz value                 code=(50+code*16)pF                    00: 50pF                    01: 66pF                    10: 82pF                    11: 100pF
 *     CP                               control Cp value                 code=(1+code*1)pF                    00: 1pF                    01: 2pF                    10: 3pF                    11: 4pF
 *     CP1                              control Cp1 value                 code=(1+code*1)pF                    00: 1pF                    01: 2pF                    10: 3pF                    11: 4pF
 *     RSVD             reserved
 */
#define TOP_XG_PLL1_CTRL_5r_SIZE 4

/* TOP_XG_PLL1_CTRL_5r is element of TOP_XG_PLL_CTRL_5 */

/*
 * This structure should be used to declare and program TOP_XG_PLL1_CTRL_5.
 */
typedef union TOP_XG_PLL1_CTRL_5r_s {
	uint32 v[1];
	uint32 top_xg_pll1_ctrl_5[1];
	uint32 _top_xg_pll1_ctrl_5;
} TOP_XG_PLL1_CTRL_5r_t;

#define TOP_XG_PLL1_CTRL_5r_CLR(r) (r).top_xg_pll1_ctrl_5[0] = 0
#define TOP_XG_PLL1_CTRL_5r_SET(r,d) (r).top_xg_pll1_ctrl_5[0] = d
#define TOP_XG_PLL1_CTRL_5r_GET(r) (r).top_xg_pll1_ctrl_5[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL1_CTRL_5r_VCO_GAINf_GET(r) (((r).top_xg_pll1_ctrl_5[0]) & 0xf)
#define TOP_XG_PLL1_CTRL_5r_VCO_GAINf_SET(r,f) (r).top_xg_pll1_ctrl_5[0]=(((r).top_xg_pll1_ctrl_5[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define TOP_XG_PLL1_CTRL_5r_RZf_GET(r) ((((r).top_xg_pll1_ctrl_5[0]) >> 4) & 0x1f)
#define TOP_XG_PLL1_CTRL_5r_RZf_SET(r,f) (r).top_xg_pll1_ctrl_5[0]=(((r).top_xg_pll1_ctrl_5[0] & ~((uint32)0x1f << 4)) | ((((uint32)f) & 0x1f) << 4))
#define TOP_XG_PLL1_CTRL_5r_RPf_GET(r) ((((r).top_xg_pll1_ctrl_5[0]) >> 9) & 0xf)
#define TOP_XG_PLL1_CTRL_5r_RPf_SET(r,f) (r).top_xg_pll1_ctrl_5[0]=(((r).top_xg_pll1_ctrl_5[0] & ~((uint32)0xf << 9)) | ((((uint32)f) & 0xf) << 9))
#define TOP_XG_PLL1_CTRL_5r_ICPf_GET(r) ((((r).top_xg_pll1_ctrl_5[0]) >> 13) & 0x3f)
#define TOP_XG_PLL1_CTRL_5r_ICPf_SET(r,f) (r).top_xg_pll1_ctrl_5[0]=(((r).top_xg_pll1_ctrl_5[0] & ~((uint32)0x3f << 13)) | ((((uint32)f) & 0x3f) << 13))
#define TOP_XG_PLL1_CTRL_5r_CZf_GET(r) ((((r).top_xg_pll1_ctrl_5[0]) >> 19) & 0x7)
#define TOP_XG_PLL1_CTRL_5r_CZf_SET(r,f) (r).top_xg_pll1_ctrl_5[0]=(((r).top_xg_pll1_ctrl_5[0] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define TOP_XG_PLL1_CTRL_5r_CPf_GET(r) ((((r).top_xg_pll1_ctrl_5[0]) >> 22) & 0x7)
#define TOP_XG_PLL1_CTRL_5r_CPf_SET(r,f) (r).top_xg_pll1_ctrl_5[0]=(((r).top_xg_pll1_ctrl_5[0] & ~((uint32)0x7 << 22)) | ((((uint32)f) & 0x7) << 22))
#define TOP_XG_PLL1_CTRL_5r_CP1f_GET(r) ((((r).top_xg_pll1_ctrl_5[0]) >> 25) & 0x7)
#define TOP_XG_PLL1_CTRL_5r_CP1f_SET(r,f) (r).top_xg_pll1_ctrl_5[0]=(((r).top_xg_pll1_ctrl_5[0] & ~((uint32)0x7 << 25)) | ((((uint32)f) & 0x7) << 25))
#define TOP_XG_PLL1_CTRL_5r_RSVDf_GET(r) ((((r).top_xg_pll1_ctrl_5[0]) >> 28) & 0xf)
#define TOP_XG_PLL1_CTRL_5r_RSVDf_SET(r,f) (r).top_xg_pll1_ctrl_5[0]=(((r).top_xg_pll1_ctrl_5[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access TOP_XG_PLL1_CTRL_5.
 */
#define WRITE_TOP_XG_PLL1_CTRL_5r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL1_CTRL_5,(r._top_xg_pll1_ctrl_5))
#define READ_TOP_XG_PLL1_CTRL_5r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL1_CTRL_5,&(r._top_xg_pll1_ctrl_5))

/*******************************************************************************
 * End of 'TOP_XG_PLL1_CTRL_5r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL1_CTRL_6
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL1 Control register 6
 * SIZE:     32
 * FIELDS:
 *     EN_CTRL          LC_pll EN_CTRL:[0] Enable External differential clock D2C, 1-enable[1] Enable Internal differential clock D2C, 1-enable[2] Enable CML output pad buffer, 1-enable[3] Enable o_cml1p/n, 1-enable[4] Enable o_cml2p/n, 1-enable[5] Enable Frequency doubler, 1-enable[6] Enable ref clock bypass, 1-enable[7] Reserved
 *     DITH_EN          XG PLL1 enable feedback divider SDM dithering 
 *     DITH_ORDER       XG PLL1 SDM dither order 
 *     NOREF_CHK_ENB    XG PLL1 no reference clock check enable
 *     LOCK_LOST_CLR    XG PLL1 lock lost clear
 *     LOCK_CNT         Lock detector counter length. This control is onlyeffective when auto_cnfg_dsbl<4> is set to 0 or whenauto_cnfg_dsbl<5> is set to 1111: 7680110: 6144101: 4096100: 2048011: 1024010: 512001: 256000: 128
 *     LDO_CTRL                         ldo Control bits
 */
#define TOP_XG_PLL1_CTRL_6r_SIZE 4

/* TOP_XG_PLL1_CTRL_6r is element of TOP_XG_PLL_CTRL_6 */

/*
 * This structure should be used to declare and program TOP_XG_PLL1_CTRL_6.
 */
typedef union TOP_XG_PLL1_CTRL_6r_s {
	uint32 v[1];
	uint32 top_xg_pll1_ctrl_6[1];
	uint32 _top_xg_pll1_ctrl_6;
} TOP_XG_PLL1_CTRL_6r_t;

#define TOP_XG_PLL1_CTRL_6r_CLR(r) (r).top_xg_pll1_ctrl_6[0] = 0
#define TOP_XG_PLL1_CTRL_6r_SET(r,d) (r).top_xg_pll1_ctrl_6[0] = d
#define TOP_XG_PLL1_CTRL_6r_GET(r) (r).top_xg_pll1_ctrl_6[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL1_CTRL_6r_EN_CTRLf_GET(r) (((r).top_xg_pll1_ctrl_6[0]) & 0xff)
#define TOP_XG_PLL1_CTRL_6r_EN_CTRLf_SET(r,f) (r).top_xg_pll1_ctrl_6[0]=(((r).top_xg_pll1_ctrl_6[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define TOP_XG_PLL1_CTRL_6r_DITH_ENf_GET(r) ((((r).top_xg_pll1_ctrl_6[0]) >> 8) & 0x1)
#define TOP_XG_PLL1_CTRL_6r_DITH_ENf_SET(r,f) (r).top_xg_pll1_ctrl_6[0]=(((r).top_xg_pll1_ctrl_6[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define TOP_XG_PLL1_CTRL_6r_DITH_ORDERf_GET(r) ((((r).top_xg_pll1_ctrl_6[0]) >> 9) & 0x3)
#define TOP_XG_PLL1_CTRL_6r_DITH_ORDERf_SET(r,f) (r).top_xg_pll1_ctrl_6[0]=(((r).top_xg_pll1_ctrl_6[0] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define TOP_XG_PLL1_CTRL_6r_NOREF_CHK_ENBf_GET(r) ((((r).top_xg_pll1_ctrl_6[0]) >> 11) & 0x1)
#define TOP_XG_PLL1_CTRL_6r_NOREF_CHK_ENBf_SET(r,f) (r).top_xg_pll1_ctrl_6[0]=(((r).top_xg_pll1_ctrl_6[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define TOP_XG_PLL1_CTRL_6r_LOCK_LOST_CLRf_GET(r) ((((r).top_xg_pll1_ctrl_6[0]) >> 12) & 0x1)
#define TOP_XG_PLL1_CTRL_6r_LOCK_LOST_CLRf_SET(r,f) (r).top_xg_pll1_ctrl_6[0]=(((r).top_xg_pll1_ctrl_6[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define TOP_XG_PLL1_CTRL_6r_LOCK_CNTf_GET(r) ((((r).top_xg_pll1_ctrl_6[0]) >> 13) & 0x7)
#define TOP_XG_PLL1_CTRL_6r_LOCK_CNTf_SET(r,f) (r).top_xg_pll1_ctrl_6[0]=(((r).top_xg_pll1_ctrl_6[0] & ~((uint32)0x7 << 13)) | ((((uint32)f) & 0x7) << 13))
#define TOP_XG_PLL1_CTRL_6r_LDO_CTRLf_GET(r) ((((r).top_xg_pll1_ctrl_6[0]) >> 16) & 0xffff)
#define TOP_XG_PLL1_CTRL_6r_LDO_CTRLf_SET(r,f) (r).top_xg_pll1_ctrl_6[0]=(((r).top_xg_pll1_ctrl_6[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access TOP_XG_PLL1_CTRL_6.
 */
#define WRITE_TOP_XG_PLL1_CTRL_6r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL1_CTRL_6,(r._top_xg_pll1_ctrl_6))
#define READ_TOP_XG_PLL1_CTRL_6r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL1_CTRL_6,&(r._top_xg_pll1_ctrl_6))

/*******************************************************************************
 * End of 'TOP_XG_PLL1_CTRL_6r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL1_CTRL_7
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL1 Control register 7
 * SIZE:     32
 * FIELDS:
 *     STAT_MODE                        Statistics mode:                   00 = disabled                   01 = Phase error                   10 = period                   11 = feedback phase error
 *     STAT_RESET                       Reset of phase error measurement:                   0=normal mode                   1=reset
 *     STAT_SELECT                      select of test output (stat_out[11:0])                   000 = 000000000000                   001 = 000000000000                   010 = 000000000000                   011 = 000000000000                   100 = {0, lock, lock_lost, cal_dac[8:0]}                   101 = 000000000000                   110 = 000000000000                   111 = 000000000000
 *     STAT_UPDATE                      on the synchronized rising edge of this control signal the value selected by stat_select<2:0> is clocked into o_statout.
 *     POST_RSTB_SEL    Post divider control selector00: controller has no control over post divider01: post divider is synchronously enabled and asynchronously disabled by the lock bit10: post divider resetb is controlled also by controller's resetb11: post divider is synchronously enabled/disabled by the lock bit
 *     ICP_BLEED        XG PLL0 ICP bleed : Controls CP bleeding current, applicable for fractional mode only 
 *     ENABLEB_CH       Channel enable 0: enable, 1: disable 
 *     HOLD_ALL         i_hold_all 
 *     SPARE_DIG        i_spare_dig<7:0> bits for debug
 *     RSVD             Reserved 
 */
#define TOP_XG_PLL1_CTRL_7r_SIZE 4

/* TOP_XG_PLL1_CTRL_7r is element of TOP_XG_PLL_CTRL_7 */

/*
 * This structure should be used to declare and program TOP_XG_PLL1_CTRL_7.
 */
typedef union TOP_XG_PLL1_CTRL_7r_s {
	uint32 v[1];
	uint32 top_xg_pll1_ctrl_7[1];
	uint32 _top_xg_pll1_ctrl_7;
} TOP_XG_PLL1_CTRL_7r_t;

#define TOP_XG_PLL1_CTRL_7r_CLR(r) (r).top_xg_pll1_ctrl_7[0] = 0
#define TOP_XG_PLL1_CTRL_7r_SET(r,d) (r).top_xg_pll1_ctrl_7[0] = d
#define TOP_XG_PLL1_CTRL_7r_GET(r) (r).top_xg_pll1_ctrl_7[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL1_CTRL_7r_STAT_MODEf_GET(r) (((r).top_xg_pll1_ctrl_7[0]) & 0x3)
#define TOP_XG_PLL1_CTRL_7r_STAT_MODEf_SET(r,f) (r).top_xg_pll1_ctrl_7[0]=(((r).top_xg_pll1_ctrl_7[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define TOP_XG_PLL1_CTRL_7r_STAT_RESETf_GET(r) ((((r).top_xg_pll1_ctrl_7[0]) >> 2) & 0x1)
#define TOP_XG_PLL1_CTRL_7r_STAT_RESETf_SET(r,f) (r).top_xg_pll1_ctrl_7[0]=(((r).top_xg_pll1_ctrl_7[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define TOP_XG_PLL1_CTRL_7r_STAT_SELECTf_GET(r) ((((r).top_xg_pll1_ctrl_7[0]) >> 3) & 0x7)
#define TOP_XG_PLL1_CTRL_7r_STAT_SELECTf_SET(r,f) (r).top_xg_pll1_ctrl_7[0]=(((r).top_xg_pll1_ctrl_7[0] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define TOP_XG_PLL1_CTRL_7r_STAT_UPDATEf_GET(r) ((((r).top_xg_pll1_ctrl_7[0]) >> 6) & 0x1)
#define TOP_XG_PLL1_CTRL_7r_STAT_UPDATEf_SET(r,f) (r).top_xg_pll1_ctrl_7[0]=(((r).top_xg_pll1_ctrl_7[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define TOP_XG_PLL1_CTRL_7r_POST_RSTB_SELf_GET(r) ((((r).top_xg_pll1_ctrl_7[0]) >> 7) & 0x3)
#define TOP_XG_PLL1_CTRL_7r_POST_RSTB_SELf_SET(r,f) (r).top_xg_pll1_ctrl_7[0]=(((r).top_xg_pll1_ctrl_7[0] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define TOP_XG_PLL1_CTRL_7r_ICP_BLEEDf_GET(r) ((((r).top_xg_pll1_ctrl_7[0]) >> 9) & 0x1f)
#define TOP_XG_PLL1_CTRL_7r_ICP_BLEEDf_SET(r,f) (r).top_xg_pll1_ctrl_7[0]=(((r).top_xg_pll1_ctrl_7[0] & ~((uint32)0x1f << 9)) | ((((uint32)f) & 0x1f) << 9))
#define TOP_XG_PLL1_CTRL_7r_ENABLEB_CHf_GET(r) ((((r).top_xg_pll1_ctrl_7[0]) >> 14) & 0x3f)
#define TOP_XG_PLL1_CTRL_7r_ENABLEB_CHf_SET(r,f) (r).top_xg_pll1_ctrl_7[0]=(((r).top_xg_pll1_ctrl_7[0] & ~((uint32)0x3f << 14)) | ((((uint32)f) & 0x3f) << 14))
#define TOP_XG_PLL1_CTRL_7r_HOLD_ALLf_GET(r) ((((r).top_xg_pll1_ctrl_7[0]) >> 20) & 0x1)
#define TOP_XG_PLL1_CTRL_7r_HOLD_ALLf_SET(r,f) (r).top_xg_pll1_ctrl_7[0]=(((r).top_xg_pll1_ctrl_7[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define TOP_XG_PLL1_CTRL_7r_SPARE_DIGf_GET(r) ((((r).top_xg_pll1_ctrl_7[0]) >> 21) & 0xff)
#define TOP_XG_PLL1_CTRL_7r_SPARE_DIGf_SET(r,f) (r).top_xg_pll1_ctrl_7[0]=(((r).top_xg_pll1_ctrl_7[0] & ~((uint32)0xff << 21)) | ((((uint32)f) & 0xff) << 21))
#define TOP_XG_PLL1_CTRL_7r_RSVDf_GET(r) ((((r).top_xg_pll1_ctrl_7[0]) >> 29) & 0x7)
#define TOP_XG_PLL1_CTRL_7r_RSVDf_SET(r,f) (r).top_xg_pll1_ctrl_7[0]=(((r).top_xg_pll1_ctrl_7[0] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))

/*
 * These macros can be used to access TOP_XG_PLL1_CTRL_7.
 */
#define WRITE_TOP_XG_PLL1_CTRL_7r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL1_CTRL_7,(r._top_xg_pll1_ctrl_7))
#define READ_TOP_XG_PLL1_CTRL_7r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL1_CTRL_7,&(r._top_xg_pll1_ctrl_7))

/*******************************************************************************
 * End of 'TOP_XG_PLL1_CTRL_7r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL1_CTRL_8
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL1 Control register 8
 * SIZE:     32
 * FIELDS:
 *     BUF_CTRL         LC_PLL i_buf_ctrl : Pad driver and internal CML buffers bias and output load options
 *     CP_CTRL          LC_PLL i_cp_ctrl : CP bias options[1:0]  :  Bc_scale<1:0>[2]    :  cp_down_en[6:3]  :  CP_CTL<3:0>
 *     D2C1_CTRL        LC_PLL i_d2c1_ctrl[2:0] : D2C tail_res         000- 950 Ohm         001- 760 Ohm         010- 630 Ohm         011- 545 Ohm         100- open         101- 3.8  kOhm         110- 1.9  kOhm         111- 1.24 kOhm[4:3] : gate_bias         000- 950 Ohm         001- 760 Ohm         010- 630 Ohm         011- 545 Ohm         100- open         101- 3.8  kOhm         110- 1.9  kOhm         111- 1.24 kOhm[7:5] : term_en         000-      100 Ohm         001, 010  133 Ohm         011-      200 Ohm         101, 110  400 Ohm         111-      no termination       
 *     D2C2_CTRL        LC_PLL i_d2c1_ctrl[2:0] : D2C tail_res         000- 950 Ohm         001- 760 Ohm         010- 630 Ohm         011- 545 Ohm         100- open         101- 3.8  kOhm         110- 1.9  kOhm         111- 1.24 kOhm[4:3] : gate_bias         000- 950 Ohm         001- 760 Ohm         010- 630 Ohm         011- 545 Ohm         100- open         101- 3.8  kOhm         110- 1.9  kOhm         111- 1.24 kOhm[7:5] : term_en         000-      100 Ohm         001, 010  133 Ohm         011-      200 Ohm         101, 110  400 Ohm         111-      no termination       
 */
#define TOP_XG_PLL1_CTRL_8r_SIZE 4

/* TOP_XG_PLL1_CTRL_8r is element of TOP_XG_PLL_CTRL_8 */

/*
 * This structure should be used to declare and program TOP_XG_PLL1_CTRL_8.
 */
typedef union TOP_XG_PLL1_CTRL_8r_s {
	uint32 v[1];
	uint32 top_xg_pll1_ctrl_8[1];
	uint32 _top_xg_pll1_ctrl_8;
} TOP_XG_PLL1_CTRL_8r_t;

#define TOP_XG_PLL1_CTRL_8r_CLR(r) (r).top_xg_pll1_ctrl_8[0] = 0
#define TOP_XG_PLL1_CTRL_8r_SET(r,d) (r).top_xg_pll1_ctrl_8[0] = d
#define TOP_XG_PLL1_CTRL_8r_GET(r) (r).top_xg_pll1_ctrl_8[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL1_CTRL_8r_BUF_CTRLf_GET(r) (((r).top_xg_pll1_ctrl_8[0]) & 0xff)
#define TOP_XG_PLL1_CTRL_8r_BUF_CTRLf_SET(r,f) (r).top_xg_pll1_ctrl_8[0]=(((r).top_xg_pll1_ctrl_8[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define TOP_XG_PLL1_CTRL_8r_CP_CTRLf_GET(r) ((((r).top_xg_pll1_ctrl_8[0]) >> 8) & 0xff)
#define TOP_XG_PLL1_CTRL_8r_CP_CTRLf_SET(r,f) (r).top_xg_pll1_ctrl_8[0]=(((r).top_xg_pll1_ctrl_8[0] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define TOP_XG_PLL1_CTRL_8r_D2C1_CTRLf_GET(r) ((((r).top_xg_pll1_ctrl_8[0]) >> 16) & 0xff)
#define TOP_XG_PLL1_CTRL_8r_D2C1_CTRLf_SET(r,f) (r).top_xg_pll1_ctrl_8[0]=(((r).top_xg_pll1_ctrl_8[0] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define TOP_XG_PLL1_CTRL_8r_D2C2_CTRLf_GET(r) ((((r).top_xg_pll1_ctrl_8[0]) >> 24) & 0xff)
#define TOP_XG_PLL1_CTRL_8r_D2C2_CTRLf_SET(r,f) (r).top_xg_pll1_ctrl_8[0]=(((r).top_xg_pll1_ctrl_8[0] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))

/*
 * These macros can be used to access TOP_XG_PLL1_CTRL_8.
 */
#define WRITE_TOP_XG_PLL1_CTRL_8r(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL1_CTRL_8,(r._top_xg_pll1_ctrl_8))
#define READ_TOP_XG_PLL1_CTRL_8r(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL1_CTRL_8,&(r._top_xg_pll1_ctrl_8))

/*******************************************************************************
 * End of 'TOP_XG_PLL1_CTRL_8r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOP_XG_PLL1_STATUS
 * BLOCKS:   TOP
 * DESC:     TOP XG_PLL1 Status
 * SIZE:     32
 * FIELDS:
 *     XGPLL_STATUS     XG_PLL1 Status bits [11:0], other bits are reserved
 *     TOP_XGPLL_LOCK   XG_PLL1 Lock
 */
#define TOP_XG_PLL1_STATUSr_SIZE 4

/* TOP_XG_PLL1_STATUSr is element of TOP_XG_PLL_STATUS */

/*
 * This structure should be used to declare and program TOP_XG_PLL1_STATUS.
 */
typedef union TOP_XG_PLL1_STATUSr_s {
	uint32 v[1];
	uint32 top_xg_pll1_status[1];
	uint32 _top_xg_pll1_status;
} TOP_XG_PLL1_STATUSr_t;

#define TOP_XG_PLL1_STATUSr_CLR(r) (r).top_xg_pll1_status[0] = 0
#define TOP_XG_PLL1_STATUSr_SET(r,d) (r).top_xg_pll1_status[0] = d
#define TOP_XG_PLL1_STATUSr_GET(r) (r).top_xg_pll1_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG_PLL1_STATUSr_XGPLL_STATUSf_GET(r) (((r).top_xg_pll1_status[0]) & 0x7fffffff)
#define TOP_XG_PLL1_STATUSr_XGPLL_STATUSf_SET(r,f) (r).top_xg_pll1_status[0]=(((r).top_xg_pll1_status[0] & ~((uint32)0x7fffffff)) | (((uint32)f) & 0x7fffffff))
#define TOP_XG_PLL1_STATUSr_TOP_XGPLL_LOCKf_GET(r) ((((r).top_xg_pll1_status[0]) >> 31) & 0x1)
#define TOP_XG_PLL1_STATUSr_TOP_XGPLL_LOCKf_SET(r,f) (r).top_xg_pll1_status[0]=(((r).top_xg_pll1_status[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access TOP_XG_PLL1_STATUS.
 */
#define WRITE_TOP_XG_PLL1_STATUSr(u,r) bcm5607x_reg_set(u,R_TOP_XG_PLL1_STATUS,(r._top_xg_pll1_status))
#define READ_TOP_XG_PLL1_STATUSr(u,r) bcm5607x_reg_get(u,R_TOP_XG_PLL1_STATUS,&(r._top_xg_pll1_status))

/*******************************************************************************
 * End of 'TOP_XG_PLL1_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOTALDYNCELLRESETLIMIT
 * BLOCKS:   MMU
 * DESC:     Cell based dynamic (shared buffer pool) memory usage resume threshold When MISCCONFIG.DYNAMIC_MEMORY_EN=0, this register is not used.

 * SIZE:     32
 * FIELDS:
 *     TOTALDYNCELLRESETLIMIT To reset a cos queue's HOL status, it must meet following conditions:((DYNCELLCOUNT(port) < DYNCELLLIMIT.RESETLIMIT(port))AND(TOTALDYNCELLLUSED < TOTALDYNCELLRESETLIMIT.TOTALDYNCELLRESETLIMIT))OR(COSLCCOUNT(port,cos) <LWMCOSCELLSETLIMIT.CELLRESETLIMIT(port,cos)) 
 */
#define TOTALDYNCELLRESETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program TOTALDYNCELLRESETLIMIT.
 */
typedef union TOTALDYNCELLRESETLIMITr_s {
	uint32 v[1];
	uint32 totaldyncellresetlimit[1];
	uint32 _totaldyncellresetlimit;
} TOTALDYNCELLRESETLIMITr_t;

#define TOTALDYNCELLRESETLIMITr_CLR(r) (r).totaldyncellresetlimit[0] = 0
#define TOTALDYNCELLRESETLIMITr_SET(r,d) (r).totaldyncellresetlimit[0] = d
#define TOTALDYNCELLRESETLIMITr_GET(r) (r).totaldyncellresetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_GET(r) (((r).totaldyncellresetlimit[0]) & 0x1fffff)
#define TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_SET(r,f) (r).totaldyncellresetlimit[0]=(((r).totaldyncellresetlimit[0] & ~((uint32)0x1fffff)) | (((uint32)f) & 0x1fffff))

/*
 * These macros can be used to access TOTALDYNCELLRESETLIMIT.
 */
#define WRITE_TOTALDYNCELLRESETLIMITr(u,r) bcm5607x_reg_set(u,R_TOTALDYNCELLRESETLIMIT,(r._totaldyncellresetlimit))
#define READ_TOTALDYNCELLRESETLIMITr(u,r) bcm5607x_reg_get(u,R_TOTALDYNCELLRESETLIMIT,&(r._totaldyncellresetlimit))

/*******************************************************************************
 * End of 'TOTALDYNCELLRESETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TOTALDYNCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     Cell-based dynamic (shared buffer pool) memory usage drop threshold. When MISCCONFIG.DYNAMIC_MEMORY_EN=0, this register is not used. 

 * SIZE:     32
 * FIELDS:
 *     TOTALDYNCELLSETLIMIT The TOTALDYNCELLLIMIT register limits the maximum cells in the chips global pool for use as dynamic memory.When TOTALDYNCELLUSED >= TOTALDYNCELLSETLIMIT.TOTALDYNCELLSETLIMIT ports that require dynamic memory will be set in HOL status and stop admitting any new incoming cells. The bitwidth is larger than CBP size: when MULTIPLE_ACCOUNTING_FIX_EN =0, a multicast cell will be counted multiple times.  
 */
#define TOTALDYNCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program TOTALDYNCELLSETLIMIT.
 */
typedef union TOTALDYNCELLSETLIMITr_s {
	uint32 v[1];
	uint32 totaldyncellsetlimit[1];
	uint32 _totaldyncellsetlimit;
} TOTALDYNCELLSETLIMITr_t;

#define TOTALDYNCELLSETLIMITr_CLR(r) (r).totaldyncellsetlimit[0] = 0
#define TOTALDYNCELLSETLIMITr_SET(r,d) (r).totaldyncellsetlimit[0] = d
#define TOTALDYNCELLSETLIMITr_GET(r) (r).totaldyncellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_GET(r) (((r).totaldyncellsetlimit[0]) & 0x1fffff)
#define TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_SET(r,f) (r).totaldyncellsetlimit[0]=(((r).totaldyncellsetlimit[0] & ~((uint32)0x1fffff)) | (((uint32)f) & 0x1fffff))

/*
 * These macros can be used to access TOTALDYNCELLSETLIMIT.
 */
#define WRITE_TOTALDYNCELLSETLIMITr(u,r) bcm5607x_reg_set(u,R_TOTALDYNCELLSETLIMIT,(r._totaldyncellsetlimit))
#define READ_TOTALDYNCELLSETLIMITr(u,r) bcm5607x_reg_get(u,R_TOTALDYNCELLSETLIMIT,&(r._totaldyncellsetlimit))

/*******************************************************************************
 * End of 'TOTALDYNCELLSETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  TRUNK32_CONFIG_TABLE
 * BLOCKS:   IPIPE
 * DESC:      TRUNK32_CONFIG_TABLE holds fields necessary to further parse a HiGig packet when the
source is a TrunkID \(no src_modid/port are present\).
This table is indexed via TGID[4:0]
 * SIZE:     7
 * FIELDS:
 *     OUTER_TPID_ENABLE Indicates if ING_OUTER_TPID[3] to ING_OUTER_TPID[0] are allowed outer TPID values.
 *     INNER_TPID_ENABLE .
 *     MIML_ENABLE      Enable MIML feature.
 *     CUSTOM_HEADER_ENABLE Enable CUSTOME_HEADER feature.
 */
#define TRUNK32_CONFIG_TABLEm_MIN 0
#define TRUNK32_CONFIG_TABLEm_MAX 31
#define TRUNK32_CONFIG_TABLEm_CMAX(u) 31
#define TRUNK32_CONFIG_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program TRUNK32_CONFIG_TABLE.
 */
typedef union TRUNK32_CONFIG_TABLEm_s {
	uint32 v[1];
	uint32 trunk32_config_table[1];
	uint32 _trunk32_config_table;
} TRUNK32_CONFIG_TABLEm_t;

#define TRUNK32_CONFIG_TABLEm_CLR(r) (r).trunk32_config_table[0] = 0
#define TRUNK32_CONFIG_TABLEm_SET(r,d) (r).trunk32_config_table[0] = d
#define TRUNK32_CONFIG_TABLEm_GET(r) (r).trunk32_config_table[0]

/*
 * These macros can be used to access individual fields.
 */
#define TRUNK32_CONFIG_TABLEm_OUTER_TPID_ENABLEf_GET(r) (((r).trunk32_config_table[0]) & 0xf)
#define TRUNK32_CONFIG_TABLEm_OUTER_TPID_ENABLEf_SET(r,f) (r).trunk32_config_table[0]=(((r).trunk32_config_table[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define TRUNK32_CONFIG_TABLEm_INNER_TPID_ENABLEf_GET(r) ((((r).trunk32_config_table[0]) >> 4) & 0x1)
#define TRUNK32_CONFIG_TABLEm_INNER_TPID_ENABLEf_SET(r,f) (r).trunk32_config_table[0]=(((r).trunk32_config_table[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define TRUNK32_CONFIG_TABLEm_MIML_ENABLEf_GET(r) ((((r).trunk32_config_table[0]) >> 5) & 0x1)
#define TRUNK32_CONFIG_TABLEm_MIML_ENABLEf_SET(r,f) (r).trunk32_config_table[0]=(((r).trunk32_config_table[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define TRUNK32_CONFIG_TABLEm_CUSTOM_HEADER_ENABLEf_GET(r) ((((r).trunk32_config_table[0]) >> 6) & 0x1)
#define TRUNK32_CONFIG_TABLEm_CUSTOM_HEADER_ENABLEf_SET(r,f) (r).trunk32_config_table[0]=(((r).trunk32_config_table[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))

/*
 * These macros can be used to access TRUNK32_CONFIG_TABLE.
 */
#define WRITE_TRUNK32_CONFIG_TABLEm(u,i,r) bcm5607x_mem_set(u, M_TRUNK32_CONFIG_TABLE(i), &(r._trunk32_config_table), 1)
#define READ_TRUNK32_CONFIG_TABLEm(u,i,r) bcm5607x_mem_get(u, M_TRUNK32_CONFIG_TABLE(i), &(r._trunk32_config_table), 1)

/*******************************************************************************
 * End of 'TRUNK32_CONFIG_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  TRUNK32_PORT_TABLE
 * BLOCKS:   IPIPE
 * DESC:      Trunks 32 mode Port table
This table is used when supporting 32 trunk group mode to provide port profiles for HiGig lookup based on source port
The index into this table is the TGID.
 * SIZE:     45
 * FIELDS:
 *     LPORT_PROFILE_IDX Index to LPORT PROFILE Table.
 *     CLASS_ID         Source port Class ID
 *     VLAN_RANGE_IDX   Source port vlan range table index
 *     MA_BASE_POINTER  MA_BASE_POINTER.
 *     PACKET_MODIFICATION_DISABLE .
 *     DISABLE_VLAN_CHECKS If set, then spanning tree and VLAN memberships checks are not performed.  This should be set if PORT_OPERATION is for VPWS, VPLS or L3 VPN (note: the checks should remain enabled for a GPON SVP)
 *     L3_IIF           L3 Interface.
 *     RESERVED_40      Reserved field due to the reduction of L3_IIF.
 */
#define TRUNK32_PORT_TABLEm_MIN 0
#define TRUNK32_PORT_TABLEm_MAX 31
#define TRUNK32_PORT_TABLEm_CMAX(u) 31
#define TRUNK32_PORT_TABLEm_SIZE 6

/*
 * This structure should be used to declare and program TRUNK32_PORT_TABLE.
 */
typedef union TRUNK32_PORT_TABLEm_s {
	uint32 v[2];
	uint32 trunk32_port_table[2];
	uint32 _trunk32_port_table;
} TRUNK32_PORT_TABLEm_t;

#define TRUNK32_PORT_TABLEm_CLR(r) sal_memset(&((r)._trunk32_port_table), 0, sizeof(TRUNK32_PORT_TABLEm_t))
#define TRUNK32_PORT_TABLEm_SET(r,i,d) (r).trunk32_port_table[i] = d
#define TRUNK32_PORT_TABLEm_GET(r,i) (r).trunk32_port_table[i]

/*
 * These macros can be used to access individual fields.
 */
#define TRUNK32_PORT_TABLEm_LPORT_PROFILE_IDXf_GET(r) (((r).trunk32_port_table[0]) & 0x7f)
#define TRUNK32_PORT_TABLEm_LPORT_PROFILE_IDXf_SET(r,f) (r).trunk32_port_table[0]=(((r).trunk32_port_table[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define TRUNK32_PORT_TABLEm_CLASS_IDf_GET(r) ((((r).trunk32_port_table[0]) >> 7) & 0xff)
#define TRUNK32_PORT_TABLEm_CLASS_IDf_SET(r,f) (r).trunk32_port_table[0]=(((r).trunk32_port_table[0] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define TRUNK32_PORT_TABLEm_VLAN_RANGE_IDXf_GET(r) ((((r).trunk32_port_table[0]) >> 15) & 0x7f)
#define TRUNK32_PORT_TABLEm_VLAN_RANGE_IDXf_SET(r,f) (r).trunk32_port_table[0]=(((r).trunk32_port_table[0] & ~((uint32)0x7f << 15)) | ((((uint32)f) & 0x7f) << 15))
#define TRUNK32_PORT_TABLEm_MA_BASE_POINTERf_GET(r) ((((r).trunk32_port_table[0]) >> 22) & 0x1ff)
#define TRUNK32_PORT_TABLEm_MA_BASE_POINTERf_SET(r,f) (r).trunk32_port_table[0]=(((r).trunk32_port_table[0] & ~((uint32)0x1ff << 22)) | ((((uint32)f) & 0x1ff) << 22))
#define TRUNK32_PORT_TABLEm_PACKET_MODIFICATION_DISABLEf_GET(r) ((((r).trunk32_port_table[0]) >> 31) & 0x1)
#define TRUNK32_PORT_TABLEm_PACKET_MODIFICATION_DISABLEf_SET(r,f) (r).trunk32_port_table[0]=(((r).trunk32_port_table[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define TRUNK32_PORT_TABLEm_DISABLE_VLAN_CHECKSf_GET(r) (((r).trunk32_port_table[1]) & 0x1)
#define TRUNK32_PORT_TABLEm_DISABLE_VLAN_CHECKSf_SET(r,f) (r).trunk32_port_table[1]=(((r).trunk32_port_table[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TRUNK32_PORT_TABLEm_L3_IIFf_GET(r) ((((r).trunk32_port_table[1]) >> 1) & 0x7f)
#define TRUNK32_PORT_TABLEm_L3_IIFf_SET(r,f) (r).trunk32_port_table[1]=(((r).trunk32_port_table[1] & ~((uint32)0x7f << 1)) | ((((uint32)f) & 0x7f) << 1))
#define TRUNK32_PORT_TABLEm_RESERVED_40f_GET(r) ((((r).trunk32_port_table[1]) >> 8) & 0x1f)
#define TRUNK32_PORT_TABLEm_RESERVED_40f_SET(r,f) (r).trunk32_port_table[1]=(((r).trunk32_port_table[1] & ~((uint32)0x1f << 8)) | ((((uint32)f) & 0x1f) << 8))

/*
 * These macros can be used to access TRUNK32_PORT_TABLE.
 */
#define WRITE_TRUNK32_PORT_TABLEm(u,i,r) bcm5607x_mem_set(u, M_TRUNK32_PORT_TABLE(i), &(r._trunk32_port_table), 2)
#define READ_TRUNK32_PORT_TABLEm(u,i,r) bcm5607x_mem_get(u, M_TRUNK32_PORT_TABLE(i), &(r._trunk32_port_table), 2)

/*******************************************************************************
 * End of 'TRUNK32_PORT_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  TRUNK_BITMAP
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Bitmap Table
The trunk group table is 128 entries deep and 30 bits wide, with one entry for each trunk group. Each entry consists of a port bitmap of the member ports. If the packet comes in from one of the trunk ports, the TGID is used as the index into this table to drive the trunk group.
 * SIZE:     67
 * FIELDS:
 *     TRUNK_BITMAP     Source Trunk (LAG) Bitmap Table
 *     TRUNK_BITMAP_LO  Overlay bitmap
 *     EVEN_PARITY      Even parity.
 */
#define TRUNK_BITMAPm_MIN 0
#define TRUNK_BITMAPm_MAX 127
#define TRUNK_BITMAPm_CMAX(u) 127
#define TRUNK_BITMAPm_SIZE 9

/*
 * This structure should be used to declare and program TRUNK_BITMAP.
 */
typedef union TRUNK_BITMAPm_s {
	uint32 v[3];
	uint32 trunk_bitmap[3];
	uint32 _trunk_bitmap;
} TRUNK_BITMAPm_t;

#define TRUNK_BITMAPm_CLR(r) sal_memset(&((r)._trunk_bitmap), 0, sizeof(TRUNK_BITMAPm_t))
#define TRUNK_BITMAPm_SET(r,i,d) (r).trunk_bitmap[i] = d
#define TRUNK_BITMAPm_GET(r,i) (r).trunk_bitmap[i]

/*
 * These macros can be used to access individual fields.
 */
#define TRUNK_BITMAPm_TRUNK_BITMAPf_GET(r,a) field_get((r).trunk_bitmap,0,65,a)
#define TRUNK_BITMAPm_TRUNK_BITMAPf_SET(r,a) field_set((r).trunk_bitmap,0,65,a)
#define TRUNK_BITMAPm_TRUNK_BITMAP_LOf_GET(r,a) field_get((r).trunk_bitmap,0,65,a)
#define TRUNK_BITMAPm_TRUNK_BITMAP_LOf_SET(r,a) field_set((r).trunk_bitmap,0,65,a)
#define TRUNK_BITMAPm_EVEN_PARITYf_GET(r) ((((r).trunk_bitmap[2]) >> 2) & 0x1)
#define TRUNK_BITMAPm_EVEN_PARITYf_SET(r,f) (r).trunk_bitmap[2]=(((r).trunk_bitmap[2] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))

/*
 * These macros can be used to access TRUNK_BITMAP.
 */
#define WRITE_TRUNK_BITMAPm(u,i,r) bcm5607x_mem_set(u, M_TRUNK_BITMAP(i), &(r._trunk_bitmap), 3)
#define READ_TRUNK_BITMAPm(u,i,r) bcm5607x_mem_get(u, M_TRUNK_BITMAP(i), &(r._trunk_bitmap), 3)

/*******************************************************************************
 * End of 'TRUNK_BITMAPm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  TRUNK_GROUP
 * BLOCKS:   IPIPE
 * DESC:     Trunk Group Table 
The trunk group table contains the information for up to 128 trunk groups. Each trunk group table entry contains up to eight different ports, which can be trunked together. Each entry consists of eight port addresses of the member ports. Each trunk port address consists of a 7-bit module ID and 6-bit port number. Search this table with TGID to drive the trunk group. RTAG is used as the criterion to drive a trunk port index, which points to the egress port address (TPn) in the trunk group. Trunking over stacking links is supported on this device. The trunk group table is consistently accessed using a destination trunk group, and rather than bind the source RTAG to a table used solely for destination trunking (the trunk group table), the source RTAG is bound to the table used solely for source trunking (the trunk bitmap table). The RTAGs for each entry in the trunk bitmap table must be identical to the RTAGs for each corresponding entry in the trunk group table.
 * SIZE:     128
 * FIELDS:
 *     PORT0            trunk port 0
 *     MODULE0          module id 0
 *     PORT1            trunk port 1
 *     MODULE1          module id 1
 *     PORT2            trunk port 2
 *     MODULE2          module id 2
 *     PORT3            trunk port 3
 *     MODULE3          module id 3
 *     PORT4            trunk port 4
 *     MODULE4          module id 4
 *     PORT5            trunk port 5
 *     MODULE5          module id 5
 *     PORT6            trunk port 6
 *     MODULE6          module id 6
 *     PORT7            trunk port 7
 *     MODULE7          module id 7
 *     RTAG             Supported RTAG values
 *     TG_SIZE          Trunk group size. If set to 0, size=1. If set to 1, size=2, and so on.
 *     RESERVED         reserved field.
 *     EVEN_PARITY      Even parity.
 */
#define TRUNK_GROUPm_MIN 0
#define TRUNK_GROUPm_MAX 127
#define TRUNK_GROUPm_CMAX(u) 127
#define TRUNK_GROUPm_SIZE 16

/*
 * This structure should be used to declare and program TRUNK_GROUP.
 */
typedef union TRUNK_GROUPm_s {
	uint32 v[4];
	uint32 trunk_group[4];
	uint32 _trunk_group;
} TRUNK_GROUPm_t;

#define TRUNK_GROUPm_CLR(r) sal_memset(&((r)._trunk_group), 0, sizeof(TRUNK_GROUPm_t))
#define TRUNK_GROUPm_SET(r,i,d) (r).trunk_group[i] = d
#define TRUNK_GROUPm_GET(r,i) (r).trunk_group[i]

/*
 * These macros can be used to access individual fields.
 */
#define TRUNK_GROUPm_PORT0f_GET(r) (((r).trunk_group[0]) & 0x7f)
#define TRUNK_GROUPm_PORT0f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define TRUNK_GROUPm_MODULE0f_GET(r) ((((r).trunk_group[0]) >> 7) & 0xff)
#define TRUNK_GROUPm_MODULE0f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define TRUNK_GROUPm_PORT1f_GET(r) ((((r).trunk_group[0]) >> 15) & 0x7f)
#define TRUNK_GROUPm_PORT1f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32)0x7f << 15)) | ((((uint32)f) & 0x7f) << 15))
#define TRUNK_GROUPm_MODULE1f_GET(r) ((((r).trunk_group[0]) >> 22) & 0xff)
#define TRUNK_GROUPm_MODULE1f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32)0xff << 22)) | ((((uint32)f) & 0xff) << 22))
#define TRUNK_GROUPm_PORT2f_GET(r) field32_get((r).trunk_group,30,36)
#define TRUNK_GROUPm_PORT2f_SET(r,f) field32_set((r).trunk_group,30,36,f)
#define TRUNK_GROUPm_MODULE2f_GET(r) ((((r).trunk_group[1]) >> 5) & 0xff)
#define TRUNK_GROUPm_MODULE2f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32)0xff << 5)) | ((((uint32)f) & 0xff) << 5))
#define TRUNK_GROUPm_PORT3f_GET(r) ((((r).trunk_group[1]) >> 13) & 0x7f)
#define TRUNK_GROUPm_PORT3f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32)0x7f << 13)) | ((((uint32)f) & 0x7f) << 13))
#define TRUNK_GROUPm_MODULE3f_GET(r) ((((r).trunk_group[1]) >> 20) & 0xff)
#define TRUNK_GROUPm_MODULE3f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32)0xff << 20)) | ((((uint32)f) & 0xff) << 20))
#define TRUNK_GROUPm_PORT4f_GET(r) field32_get((r).trunk_group,60,66)
#define TRUNK_GROUPm_PORT4f_SET(r,f) field32_set((r).trunk_group,60,66,f)
#define TRUNK_GROUPm_MODULE4f_GET(r) ((((r).trunk_group[2]) >> 3) & 0xff)
#define TRUNK_GROUPm_MODULE4f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define TRUNK_GROUPm_PORT5f_GET(r) ((((r).trunk_group[2]) >> 11) & 0x7f)
#define TRUNK_GROUPm_PORT5f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32)0x7f << 11)) | ((((uint32)f) & 0x7f) << 11))
#define TRUNK_GROUPm_MODULE5f_GET(r) ((((r).trunk_group[2]) >> 18) & 0xff)
#define TRUNK_GROUPm_MODULE5f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32)0xff << 18)) | ((((uint32)f) & 0xff) << 18))
#define TRUNK_GROUPm_PORT6f_GET(r) field32_get((r).trunk_group,90,96)
#define TRUNK_GROUPm_PORT6f_SET(r,f) field32_set((r).trunk_group,90,96,f)
#define TRUNK_GROUPm_MODULE6f_GET(r) ((((r).trunk_group[3]) >> 1) & 0xff)
#define TRUNK_GROUPm_MODULE6f_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32)0xff << 1)) | ((((uint32)f) & 0xff) << 1))
#define TRUNK_GROUPm_PORT7f_GET(r) ((((r).trunk_group[3]) >> 9) & 0x7f)
#define TRUNK_GROUPm_PORT7f_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32)0x7f << 9)) | ((((uint32)f) & 0x7f) << 9))
#define TRUNK_GROUPm_MODULE7f_GET(r) ((((r).trunk_group[3]) >> 16) & 0xff)
#define TRUNK_GROUPm_MODULE7f_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define TRUNK_GROUPm_RTAGf_GET(r) ((((r).trunk_group[3]) >> 24) & 0x7)
#define TRUNK_GROUPm_RTAGf_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define TRUNK_GROUPm_TG_SIZEf_GET(r) ((((r).trunk_group[3]) >> 27) & 0x7)
#define TRUNK_GROUPm_TG_SIZEf_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define TRUNK_GROUPm_RESERVEDf_GET(r) ((((r).trunk_group[3]) >> 30) & 0x1)
#define TRUNK_GROUPm_RESERVEDf_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define TRUNK_GROUPm_EVEN_PARITYf_GET(r) ((((r).trunk_group[3]) >> 31) & 0x1)
#define TRUNK_GROUPm_EVEN_PARITYf_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access TRUNK_GROUP.
 */
#define WRITE_TRUNK_GROUPm(u,i,r) bcm5607x_mem_set(u, M_TRUNK_GROUP(i), &(r._trunk_group), 4)
#define READ_TRUNK_GROUPm(u,i,r) bcm5607x_mem_get(u, M_TRUNK_GROUP(i), &(r._trunk_group), 4)

/*******************************************************************************
 * End of 'TRUNK_GROUPm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TS_STATUS_CNTRL
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Timestamp control/status
 * SIZE:     32
 * FIELDS:
 *     TX_TS_FIFO_FULL  Read-only field assertion shows that the transmit timestamp FIFO is full. 
 *     TX_TS_FIFO_EMPTY Read-only field assertion shows that the transmit timestamp FIFO is empty. 
 *     WORD_AVAIL       Indicates number of cells filled in the TX timestamp FIFO.
 */
#define TS_STATUS_CNTRLr_SIZE 4

/*
 * This structure should be used to declare and program TS_STATUS_CNTRL.
 */
typedef union TS_STATUS_CNTRLr_s {
	uint32 v[1];
	uint32 ts_status_cntrl[1];
	uint32 _ts_status_cntrl;
} TS_STATUS_CNTRLr_t;

#define TS_STATUS_CNTRLr_CLR(r) (r).ts_status_cntrl[0] = 0
#define TS_STATUS_CNTRLr_SET(r,d) (r).ts_status_cntrl[0] = d
#define TS_STATUS_CNTRLr_GET(r) (r).ts_status_cntrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define TS_STATUS_CNTRLr_TX_TS_FIFO_FULLf_GET(r) (((r).ts_status_cntrl[0]) & 0x1)
#define TS_STATUS_CNTRLr_TX_TS_FIFO_FULLf_SET(r,f) (r).ts_status_cntrl[0]=(((r).ts_status_cntrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TS_STATUS_CNTRLr_TX_TS_FIFO_EMPTYf_GET(r) ((((r).ts_status_cntrl[0]) >> 1) & 0x1)
#define TS_STATUS_CNTRLr_TX_TS_FIFO_EMPTYf_SET(r,f) (r).ts_status_cntrl[0]=(((r).ts_status_cntrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TS_STATUS_CNTRLr_WORD_AVAILf_GET(r) ((((r).ts_status_cntrl[0]) >> 2) & 0x7)
#define TS_STATUS_CNTRLr_WORD_AVAILf_SET(r,f) (r).ts_status_cntrl[0]=(((r).ts_status_cntrl[0] & ~((uint32)0x7 << 2)) | ((((uint32)f) & 0x7) << 2))

/*
 * These macros can be used to access TS_STATUS_CNTRL.
 */
#define WRITE_TS_STATUS_CNTRLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_TS_STATUS_CNTRL(bcm5607x_gport_lport_to_index_in_block[p]), (r._ts_status_cntrl))
#define READ_TS_STATUS_CNTRLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_TS_STATUS_CNTRL(bcm5607x_gport_lport_to_index_in_block[p]), &(r._ts_status_cntrl))

/*******************************************************************************
 * End of 'TS_STATUS_CNTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TWO_LAYER_SCH_MODE
 * BLOCKS:   MMU
 * DESC:     Two layer scheduling mode Configuration Register
 * SIZE:     32
 * FIELDS:
 *     SCH_MODE         "0": legacy 8Q mode"1": two layer 64Q mode
 */
#define TWO_LAYER_SCH_MODEr_SIZE 4

/*
 * This structure should be used to declare and program TWO_LAYER_SCH_MODE.
 */
typedef union TWO_LAYER_SCH_MODEr_s {
	uint32 v[1];
	uint32 two_layer_sch_mode[1];
	uint32 _two_layer_sch_mode;
} TWO_LAYER_SCH_MODEr_t;

#define TWO_LAYER_SCH_MODEr_CLR(r) (r).two_layer_sch_mode[0] = 0
#define TWO_LAYER_SCH_MODEr_SET(r,d) (r).two_layer_sch_mode[0] = d
#define TWO_LAYER_SCH_MODEr_GET(r) (r).two_layer_sch_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define TWO_LAYER_SCH_MODEr_SCH_MODEf_GET(r) (((r).two_layer_sch_mode[0]) & 0x1)
#define TWO_LAYER_SCH_MODEr_SCH_MODEf_SET(r,f) (r).two_layer_sch_mode[0]=(((r).two_layer_sch_mode[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access TWO_LAYER_SCH_MODE.
 */
#define WRITE_TWO_LAYER_SCH_MODEr(u,p,r) bcm5607x_reg_set(u,R_TWO_LAYER_SCH_MODE(p),(r._two_layer_sch_mode))
#define READ_TWO_LAYER_SCH_MODEr(u,p,r) bcm5607x_reg_get(u,R_TWO_LAYER_SCH_MODE(p),&(r._two_layer_sch_mode))

/*******************************************************************************
 * End of 'TWO_LAYER_SCH_MODEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * SWFORMAT:  TX_DCB
 * BLOCKS:  
 * DESC:     Packet DMA descriptor.
 * SIZE:     128
 * FIELDS:
 *     BYTES_TRANSFERRED Number of bytes transferred.
 *     DONE             Descriptor done.
 *     BYTE_COUNT       Byte count for the transfer.
 *     CHAIN            Indicates that next sequential descriptor is valid.
 *     SG               Scatter/Gather - packet continues in the next DMA descriptor.
 *     RELOAD           Load next descriptor from address in ADDR field.
 *     HG               Specifies whether the current packet is in HiGig format. 0=Regular Ethernet format, 1=HiGig format.
 *     PURGE            Set to indicate that packets should be purged.
 *     DESC_DONE_INTR   Assert descriptor done interrupt.
 *     DESC_CTRL_INTR   Assert descriptor controlled interrupt.
 *     DESC_REMAIN      Descriptors remaining.
 *     DESC_STAT_WR_DISABLE Disable descriptor status write if it is not needed.
 *     ADDR_HI          Physical memory address for the transfer bits [63:32].
 *     ADDR_LO          Physical memory address for the transfer bits [31:0].
 */
#define TX_DCB_SIZE 16

/*
 * This structure should be used to declare and program TX_DCB.
 */
typedef union TX_DCB_s {
	uint32 v[4];
	uint32 tx_dcb[4];
	uint32 _tx_dcb;
} TX_DCB_t;

#define TX_DCB_CLR(r) sal_memset(&((r)._tx_dcb), 0, sizeof(TX_DCB_t))
#define TX_DCB_SET(r,i,d) (r).tx_dcb[i] = d
#define TX_DCB_GET(r,i) (r).tx_dcb[i]

/*
 * These macros can be used to access individual fields.
 */
#define TX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).tx_dcb[3]) & 0xffff)
#define TX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define TX_DCB_DONEf_GET(r) ((((r).tx_dcb[3]) >> 31) & 0x1)
#define TX_DCB_DONEf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define TX_DCB_BYTE_COUNTf_GET(r) (((r).tx_dcb[2]) & 0xffff)
#define TX_DCB_BYTE_COUNTf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define TX_DCB_CHAINf_GET(r) ((((r).tx_dcb[2]) >> 16) & 0x1)
#define TX_DCB_CHAINf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define TX_DCB_SGf_GET(r) ((((r).tx_dcb[2]) >> 17) & 0x1)
#define TX_DCB_SGf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define TX_DCB_RELOADf_GET(r) ((((r).tx_dcb[2]) >> 18) & 0x1)
#define TX_DCB_RELOADf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define TX_DCB_HGf_GET(r) ((((r).tx_dcb[2]) >> 19) & 0x1)
#define TX_DCB_HGf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define TX_DCB_PURGEf_GET(r) ((((r).tx_dcb[2]) >> 22) & 0x1)
#define TX_DCB_PURGEf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define TX_DCB_DESC_DONE_INTRf_GET(r) ((((r).tx_dcb[2]) >> 23) & 0x1)
#define TX_DCB_DESC_DONE_INTRf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define TX_DCB_DESC_CTRL_INTRf_GET(r) ((((r).tx_dcb[2]) >> 24) & 0x1)
#define TX_DCB_DESC_CTRL_INTRf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define TX_DCB_DESC_REMAINf_GET(r) ((((r).tx_dcb[2]) >> 25) & 0xf)
#define TX_DCB_DESC_REMAINf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0xf << 25)) | ((((uint32)f) & 0xf) << 25))
#define TX_DCB_DESC_STAT_WR_DISABLEf_GET(r) ((((r).tx_dcb[2]) >> 29) & 0x1)
#define TX_DCB_DESC_STAT_WR_DISABLEf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define TX_DCB_ADDR_HIf_GET(r) ((r).tx_dcb[1])
#define TX_DCB_ADDR_HIf_SET(r,f) (r).tx_dcb[1]=((uint32)f)
#define TX_DCB_ADDR_LOf_GET(r) ((r).tx_dcb[0])
#define TX_DCB_ADDR_LOf_SET(r,f) (r).tx_dcb[0]=((uint32)f)

/*******************************************************************************
 * End of 'TX_DCB'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TX_IPG_LENGTH
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Programmable Inter-Packet-Gap (IPG).
 * SIZE:     32
 * FIELDS:
 *     TX_IPG_LENGTH_FLD Set the Transmit minimum IPG from 8 to 64 Byte-times. If a value below 8 or above 64 isprogrammed, the minimum IPG is set to 12 byte-times.
 */
#define TX_IPG_LENGTHr_SIZE 4

/*
 * This structure should be used to declare and program TX_IPG_LENGTH.
 */
typedef union TX_IPG_LENGTHr_s {
	uint32 v[1];
	uint32 tx_ipg_length[1];
	uint32 _tx_ipg_length;
} TX_IPG_LENGTHr_t;

#define TX_IPG_LENGTHr_CLR(r) (r).tx_ipg_length[0] = 0
#define TX_IPG_LENGTHr_SET(r,d) (r).tx_ipg_length[0] = d
#define TX_IPG_LENGTHr_GET(r) (r).tx_ipg_length[0]

/*
 * These macros can be used to access individual fields.
 */
#define TX_IPG_LENGTHr_TX_IPG_LENGTH_FLDf_GET(r) (((r).tx_ipg_length[0]) & 0x7f)
#define TX_IPG_LENGTHr_TX_IPG_LENGTH_FLDf_SET(r,f) (r).tx_ipg_length[0]=(((r).tx_ipg_length[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))

/*
 * These macros can be used to access TX_IPG_LENGTH.
 */
#define WRITE_TX_IPG_LENGTHr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_TX_IPG_LENGTH(bcm5607x_gport_lport_to_index_in_block[p]), (r._tx_ipg_length))
#define READ_TX_IPG_LENGTHr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_TX_IPG_LENGTH(bcm5607x_gport_lport_to_index_in_block[p]), &(r._tx_ipg_length))

/*******************************************************************************
 * End of 'TX_IPG_LENGTHr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TX_TS_DATA
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Transmit Timestamp data
 * SIZE:     32
 * FIELDS:
 *     TX_TS_DATA_FLD   Every read of this register will fetch out one timestamp value corresponding to the preceding seq_id read from the transmit FIFO.Every 49 bit, val_bit + seq_id + timestamp is read in two steps, i.e., one read from 0x10f (val_bit + seq_id) followed by another read from 0x1c7 (timestamp).Timestamp read without a preceding seq_id read will fetch stale timestamp value.
 */
#define TX_TS_DATAr_SIZE 4

/*
 * This structure should be used to declare and program TX_TS_DATA.
 */
typedef union TX_TS_DATAr_s {
	uint32 v[1];
	uint32 tx_ts_data[1];
	uint32 _tx_ts_data;
} TX_TS_DATAr_t;

#define TX_TS_DATAr_CLR(r) (r).tx_ts_data[0] = 0
#define TX_TS_DATAr_SET(r,d) (r).tx_ts_data[0] = d
#define TX_TS_DATAr_GET(r) (r).tx_ts_data[0]

/*
 * These macros can be used to access individual fields.
 */
#define TX_TS_DATAr_TX_TS_DATA_FLDf_GET(r) ((r).tx_ts_data[0])
#define TX_TS_DATAr_TX_TS_DATA_FLDf_SET(r,f) (r).tx_ts_data[0]=((uint32)f)

/*
 * These macros can be used to access TX_TS_DATA.
 */
#define WRITE_TX_TS_DATAr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_TX_TS_DATA(bcm5607x_gport_lport_to_index_in_block[p]), (r._tx_ts_data))
#define READ_TX_TS_DATAr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_TX_TS_DATA(bcm5607x_gport_lport_to_index_in_block[p]), &(r._tx_ts_data))

/*******************************************************************************
 * End of 'TX_TS_DATAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  TX_TS_SEQ_ID
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     Transmit Two Step Timestamp Sequence ID
 * SIZE:     32
 * FIELDS:
 *     TSTS_SEQ_ID      Every read of this register will fetch out one seq_id from the transmit FIFO.(One seq_id per one read command on the sbus).Every 49 bit val_bit + seq_id + timestamp is read in two steps, i.e., one read from 0x10f (val_bit + seq_id) followed by another read from 0x1c7 (timestamp).Timestamp read without a preceding seq_id read will fetch stale timestamp value.
 *     TSTS_VALID       Indicates that a timestamp was captured and is valid. if the cpu reads an empty fifo the VALID bit will be 0.
 */
#define TX_TS_SEQ_IDr_SIZE 4

/*
 * This structure should be used to declare and program TX_TS_SEQ_ID.
 */
typedef union TX_TS_SEQ_IDr_s {
	uint32 v[1];
	uint32 tx_ts_seq_id[1];
	uint32 _tx_ts_seq_id;
} TX_TS_SEQ_IDr_t;

#define TX_TS_SEQ_IDr_CLR(r) (r).tx_ts_seq_id[0] = 0
#define TX_TS_SEQ_IDr_SET(r,d) (r).tx_ts_seq_id[0] = d
#define TX_TS_SEQ_IDr_GET(r) (r).tx_ts_seq_id[0]

/*
 * These macros can be used to access individual fields.
 */
#define TX_TS_SEQ_IDr_TSTS_SEQ_IDf_GET(r) (((r).tx_ts_seq_id[0]) & 0xffff)
#define TX_TS_SEQ_IDr_TSTS_SEQ_IDf_SET(r,f) (r).tx_ts_seq_id[0]=(((r).tx_ts_seq_id[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define TX_TS_SEQ_IDr_TSTS_VALIDf_GET(r) ((((r).tx_ts_seq_id[0]) >> 16) & 0x1)
#define TX_TS_SEQ_IDr_TSTS_VALIDf_SET(r,f) (r).tx_ts_seq_id[0]=(((r).tx_ts_seq_id[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))

/*
 * These macros can be used to access TX_TS_SEQ_ID.
 */
#define WRITE_TX_TS_SEQ_IDr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_TX_TS_SEQ_ID(bcm5607x_gport_lport_to_index_in_block[p]), (r._tx_ts_seq_id))
#define READ_TX_TS_SEQ_IDr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_TX_TS_SEQ_ID(bcm5607x_gport_lport_to_index_in_block[p]), &(r._tx_ts_seq_id))

/*******************************************************************************
 * End of 'TX_TS_SEQ_IDr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  UMAC_EEE_CTRL
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     control configs for EEE feature
 * SIZE:     32
 * FIELDS:
 *     EEE_EN           If set, the TX LPI policy control engine is enabled and the MAC inserts LPI_idle codes if the link is idle. The rx_lpi_detect assertion is independent of this configuration. Reset default depends on EEE_en_strap input, which if tied to 1, defaults to enabled, otherwise if tied to 0, defaults to disabled.
 *     RX_FIFO_CHECK    If enabled, lpi_rx_detect is set whenever the LPI_IDLES are being received on the RX line and Unimac Rx FIFO is empty.By default, lpi_rx_detect is set only when whenever the LPI_IDLES are being received on the RX line.
 *     EEE_TXCLK_DIS    If enabled, UNIMAC will shut down TXCLK to PHY, when in LPI state.
 *     DIS_EEE_10M      When this bit is set and link is established at 10Mbps, LPI is not supported (saving is achieved by reduced PHY's output swing). UNIMAC ignores EEE feature on both Tx & Rx in 10Mbps.When cleared, Unimac doesn't differentiate between speeds for EEE feature.
 *     LP_IDLE_PREDICTION_MODE When set to 1, enables LP_IDLE Prediction. When set to 0, disables LP_IDLE Prediction.  
 */
#define UMAC_EEE_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program UMAC_EEE_CTRL.
 */
typedef union UMAC_EEE_CTRLr_s {
	uint32 v[1];
	uint32 umac_eee_ctrl[1];
	uint32 _umac_eee_ctrl;
} UMAC_EEE_CTRLr_t;

#define UMAC_EEE_CTRLr_CLR(r) (r).umac_eee_ctrl[0] = 0
#define UMAC_EEE_CTRLr_SET(r,d) (r).umac_eee_ctrl[0] = d
#define UMAC_EEE_CTRLr_GET(r) (r).umac_eee_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define UMAC_EEE_CTRLr_EEE_ENf_GET(r) ((((r).umac_eee_ctrl[0]) >> 3) & 0x1)
#define UMAC_EEE_CTRLr_EEE_ENf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define UMAC_EEE_CTRLr_RX_FIFO_CHECKf_GET(r) ((((r).umac_eee_ctrl[0]) >> 4) & 0x1)
#define UMAC_EEE_CTRLr_RX_FIFO_CHECKf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define UMAC_EEE_CTRLr_EEE_TXCLK_DISf_GET(r) ((((r).umac_eee_ctrl[0]) >> 5) & 0x1)
#define UMAC_EEE_CTRLr_EEE_TXCLK_DISf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define UMAC_EEE_CTRLr_DIS_EEE_10Mf_GET(r) ((((r).umac_eee_ctrl[0]) >> 6) & 0x1)
#define UMAC_EEE_CTRLr_DIS_EEE_10Mf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define UMAC_EEE_CTRLr_LP_IDLE_PREDICTION_MODEf_GET(r) ((((r).umac_eee_ctrl[0]) >> 7) & 0x1)
#define UMAC_EEE_CTRLr_LP_IDLE_PREDICTION_MODEf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access UMAC_EEE_CTRL.
 */
#define WRITE_UMAC_EEE_CTRLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_UMAC_EEE_CTRL(bcm5607x_gport_lport_to_index_in_block[p]), (r._umac_eee_ctrl))
#define READ_UMAC_EEE_CTRLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_UMAC_EEE_CTRL(bcm5607x_gport_lport_to_index_in_block[p]), &(r._umac_eee_ctrl))

/*******************************************************************************
 * End of 'UMAC_EEE_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  UMAC_EEE_REF_COUNT
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 GPORT5
 * DESC:     clock divider for 1 us quanta count in EEE 
 * SIZE:     32
 * FIELDS:
 *     EEE_REF_COUNT    This field controls clock divider used to generate ~1us reference pulses used by EEE timers. It specifies integer number of timer clock cycles contained within 1us.We may consider having 0.5us reference, as timeout values in 802.3az/D1.3 are not always integer number of 1us.
 */
#define UMAC_EEE_REF_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program UMAC_EEE_REF_COUNT.
 */
typedef union UMAC_EEE_REF_COUNTr_s {
	uint32 v[1];
	uint32 umac_eee_ref_count[1];
	uint32 _umac_eee_ref_count;
} UMAC_EEE_REF_COUNTr_t;

#define UMAC_EEE_REF_COUNTr_CLR(r) (r).umac_eee_ref_count[0] = 0
#define UMAC_EEE_REF_COUNTr_SET(r,d) (r).umac_eee_ref_count[0] = d
#define UMAC_EEE_REF_COUNTr_GET(r) (r).umac_eee_ref_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define UMAC_EEE_REF_COUNTr_EEE_REF_COUNTf_GET(r) (((r).umac_eee_ref_count[0]) & 0xffff)
#define UMAC_EEE_REF_COUNTr_EEE_REF_COUNTf_SET(r,f) (r).umac_eee_ref_count[0]=(((r).umac_eee_ref_count[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access UMAC_EEE_REF_COUNT.
 */
#define WRITE_UMAC_EEE_REF_COUNTr(u,p,r) bcm5607x_reg_set(u, bcm5607x_gport_lport_to_blockid[p], R_UMAC_EEE_REF_COUNT(bcm5607x_gport_lport_to_index_in_block[p]), (r._umac_eee_ref_count))
#define READ_UMAC_EEE_REF_COUNTr(u,p,r) bcm5607x_reg_get(u, bcm5607x_gport_lport_to_blockid[p], R_UMAC_EEE_REF_COUNT(bcm5607x_gport_lport_to_index_in_block[p]), &(r._umac_eee_ref_count))

/*******************************************************************************
 * End of 'UMAC_EEE_REF_COUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  UNKNOWN_MCAST_BLOCK_MASK_HI_64
 * BLOCKS:   IPIPE
 * DESC:     Unknown Multicast Block Mask HIGH BITs
 * SIZE:     64
 * FIELDS:
 *     OVER_LO          Used for whole regsiter default value
 *     BLK_BITMAP       Bitmap of ports to be blocked. 1=Block, 0=Allow
 *     BLK_BITMAP_0     Overlay bitmap for ports. 1=Block, 0=Allow
 *     RESERVED         Reserved.
 *     OVER_HI          Used for whole regsiter default value
 */
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_SIZE 8

/*
 * This structure should be used to declare and program UNKNOWN_MCAST_BLOCK_MASK_HI_64.
 */
typedef union UNKNOWN_MCAST_BLOCK_MASK_HI_64r_s {
	uint32 v[2];
	uint32 unknown_mcast_block_mask_hi_64[2];
	uint32 _unknown_mcast_block_mask_hi_64;
} UNKNOWN_MCAST_BLOCK_MASK_HI_64r_t;

#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_CLR(r) sal_memset(&((r)._unknown_mcast_block_mask_hi_64), 0, sizeof(UNKNOWN_MCAST_BLOCK_MASK_HI_64r_t))
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_SET(r,i,d) (r).unknown_mcast_block_mask_hi_64[i] = d
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_GET(r,i) (r).unknown_mcast_block_mask_hi_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_OVER_LOf_GET(r) ((r).unknown_mcast_block_mask_hi_64[0])
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_OVER_LOf_SET(r,f) (r).unknown_mcast_block_mask_hi_64[0]=((uint32)f)
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_BLK_BITMAPf_GET(r) (((r).unknown_mcast_block_mask_hi_64[0]) & 0x3)
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_BLK_BITMAPf_SET(r,f) (r).unknown_mcast_block_mask_hi_64[0]=(((r).unknown_mcast_block_mask_hi_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_BLK_BITMAP_0f_GET(r) (((r).unknown_mcast_block_mask_hi_64[0]) & 0x3)
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_BLK_BITMAP_0f_SET(r,f) (r).unknown_mcast_block_mask_hi_64[0]=(((r).unknown_mcast_block_mask_hi_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_RESERVEDf_GET(r,a) field_get((r).unknown_mcast_block_mask_hi_64,2,63,a)
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_RESERVEDf_SET(r,a) field_set((r).unknown_mcast_block_mask_hi_64,2,63,a)
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_OVER_HIf_GET(r) ((r).unknown_mcast_block_mask_hi_64[1])
#define UNKNOWN_MCAST_BLOCK_MASK_HI_64r_OVER_HIf_SET(r,f) (r).unknown_mcast_block_mask_hi_64[1]=((uint32)f)

/*
 * These macros can be used to access UNKNOWN_MCAST_BLOCK_MASK_HI_64.
 */
#define WRITE_UNKNOWN_MCAST_BLOCK_MASK_HI_64r(u,p,r) bcm5607x_reg64_set(u,R_UNKNOWN_MCAST_BLOCK_MASK_HI_64(p),&(r._unknown_mcast_block_mask_hi_64),2)
#define READ_UNKNOWN_MCAST_BLOCK_MASK_HI_64r(u,p,r) bcm5607x_reg64_get(u,R_UNKNOWN_MCAST_BLOCK_MASK_HI_64(p),&(r._unknown_mcast_block_mask_hi_64),2)

/*******************************************************************************
 * End of 'UNKNOWN_MCAST_BLOCK_MASK_HI_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  UNKNOWN_MCAST_BLOCK_MASK_LO_64
 * BLOCKS:   IPIPE
 * DESC:     Unknown Multicast Block Mask LOW BITs
 * SIZE:     64
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked. 1=Block, 0=Allow
 *     BLK_BITMAP_0     Overlay bitmap for ports. 1=Block, 0=Allow
 *     OVER_LO          Used for whole regsiter default value
 *     OVER_HI          Used for whole regsiter default value
 */
#define UNKNOWN_MCAST_BLOCK_MASK_LO_64r_SIZE 8

/*
 * This structure should be used to declare and program UNKNOWN_MCAST_BLOCK_MASK_LO_64.
 */
typedef union UNKNOWN_MCAST_BLOCK_MASK_LO_64r_s {
	uint32 v[2];
	uint32 unknown_mcast_block_mask_lo_64[2];
	uint32 _unknown_mcast_block_mask_lo_64;
} UNKNOWN_MCAST_BLOCK_MASK_LO_64r_t;

#define UNKNOWN_MCAST_BLOCK_MASK_LO_64r_CLR(r) sal_memset(&((r)._unknown_mcast_block_mask_lo_64), 0, sizeof(UNKNOWN_MCAST_BLOCK_MASK_LO_64r_t))
#define UNKNOWN_MCAST_BLOCK_MASK_LO_64r_SET(r,i,d) (r).unknown_mcast_block_mask_lo_64[i] = d
#define UNKNOWN_MCAST_BLOCK_MASK_LO_64r_GET(r,i) (r).unknown_mcast_block_mask_lo_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define UNKNOWN_MCAST_BLOCK_MASK_LO_64r_BLK_BITMAPf_GET(r,a) field_get((r).unknown_mcast_block_mask_lo_64,0,63,a)
#define UNKNOWN_MCAST_BLOCK_MASK_LO_64r_BLK_BITMAPf_SET(r,a) field_set((r).unknown_mcast_block_mask_lo_64,0,63,a)
#define UNKNOWN_MCAST_BLOCK_MASK_LO_64r_BLK_BITMAP_0f_GET(r,a) field_get((r).unknown_mcast_block_mask_lo_64,0,63,a)
#define UNKNOWN_MCAST_BLOCK_MASK_LO_64r_BLK_BITMAP_0f_SET(r,a) field_set((r).unknown_mcast_block_mask_lo_64,0,63,a)
#define UNKNOWN_MCAST_BLOCK_MASK_LO_64r_OVER_LOf_GET(r) ((r).unknown_mcast_block_mask_lo_64[0])
#define UNKNOWN_MCAST_BLOCK_MASK_LO_64r_OVER_LOf_SET(r,f) (r).unknown_mcast_block_mask_lo_64[0]=((uint32)f)
#define UNKNOWN_MCAST_BLOCK_MASK_LO_64r_OVER_HIf_GET(r) ((r).unknown_mcast_block_mask_lo_64[1])
#define UNKNOWN_MCAST_BLOCK_MASK_LO_64r_OVER_HIf_SET(r,f) (r).unknown_mcast_block_mask_lo_64[1]=((uint32)f)

/*
 * These macros can be used to access UNKNOWN_MCAST_BLOCK_MASK_LO_64.
 */
#define WRITE_UNKNOWN_MCAST_BLOCK_MASK_LO_64r(u,p,r) bcm5607x_reg64_set(u,R_UNKNOWN_MCAST_BLOCK_MASK_LO_64(p),&(r._unknown_mcast_block_mask_lo_64),2)
#define READ_UNKNOWN_MCAST_BLOCK_MASK_LO_64r(u,p,r) bcm5607x_reg64_get(u,R_UNKNOWN_MCAST_BLOCK_MASK_LO_64(p),&(r._unknown_mcast_block_mask_lo_64),2)

/*******************************************************************************
 * End of 'UNKNOWN_MCAST_BLOCK_MASK_LO_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  UNKNOWN_UCAST_BLOCK_MASK_HI_64
 * BLOCKS:   IPIPE
 * DESC:     Unknown Unicast Block Mask HIGH BITs
 * SIZE:     64
 * FIELDS:
 *     OVER_LO          Used for whole regsiter default value
 *     BLK_BITMAP       Bitmap of ports to be blocked. 1=Block, 0=Allow
 *     BLK_BITMAP_0     Overlay bitmap for ports. 1=Block, 0=Allow
 *     RESERVED         Reserved.
 *     OVER_HI          Used for whole regsiter default value
 */
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_SIZE 8

/*
 * This structure should be used to declare and program UNKNOWN_UCAST_BLOCK_MASK_HI_64.
 */
typedef union UNKNOWN_UCAST_BLOCK_MASK_HI_64r_s {
	uint32 v[2];
	uint32 unknown_ucast_block_mask_hi_64[2];
	uint32 _unknown_ucast_block_mask_hi_64;
} UNKNOWN_UCAST_BLOCK_MASK_HI_64r_t;

#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_CLR(r) sal_memset(&((r)._unknown_ucast_block_mask_hi_64), 0, sizeof(UNKNOWN_UCAST_BLOCK_MASK_HI_64r_t))
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_SET(r,i,d) (r).unknown_ucast_block_mask_hi_64[i] = d
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_GET(r,i) (r).unknown_ucast_block_mask_hi_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_OVER_LOf_GET(r) ((r).unknown_ucast_block_mask_hi_64[0])
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_OVER_LOf_SET(r,f) (r).unknown_ucast_block_mask_hi_64[0]=((uint32)f)
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_BLK_BITMAPf_GET(r) (((r).unknown_ucast_block_mask_hi_64[0]) & 0x3)
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_BLK_BITMAPf_SET(r,f) (r).unknown_ucast_block_mask_hi_64[0]=(((r).unknown_ucast_block_mask_hi_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_BLK_BITMAP_0f_GET(r) (((r).unknown_ucast_block_mask_hi_64[0]) & 0x3)
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_BLK_BITMAP_0f_SET(r,f) (r).unknown_ucast_block_mask_hi_64[0]=(((r).unknown_ucast_block_mask_hi_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_RESERVEDf_GET(r,a) field_get((r).unknown_ucast_block_mask_hi_64,2,63,a)
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_RESERVEDf_SET(r,a) field_set((r).unknown_ucast_block_mask_hi_64,2,63,a)
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_OVER_HIf_GET(r) ((r).unknown_ucast_block_mask_hi_64[1])
#define UNKNOWN_UCAST_BLOCK_MASK_HI_64r_OVER_HIf_SET(r,f) (r).unknown_ucast_block_mask_hi_64[1]=((uint32)f)

/*
 * These macros can be used to access UNKNOWN_UCAST_BLOCK_MASK_HI_64.
 */
#define WRITE_UNKNOWN_UCAST_BLOCK_MASK_HI_64r(u,p,r) bcm5607x_reg64_set(u,R_UNKNOWN_UCAST_BLOCK_MASK_HI_64(p),&(r._unknown_ucast_block_mask_hi_64),2)
#define READ_UNKNOWN_UCAST_BLOCK_MASK_HI_64r(u,p,r) bcm5607x_reg64_get(u,R_UNKNOWN_UCAST_BLOCK_MASK_HI_64(p),&(r._unknown_ucast_block_mask_hi_64),2)

/*******************************************************************************
 * End of 'UNKNOWN_UCAST_BLOCK_MASK_HI_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  UNKNOWN_UCAST_BLOCK_MASK_LO_64
 * BLOCKS:   IPIPE
 * DESC:     Unknown Unicast Block Mask LOW BITs
 * SIZE:     64
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked. 1=Block, 0=Allow
 *     BLK_BITMAP_0     Overlay bitmap for ports. 1=Block, 0=Allow
 *     OVER_LO          Used for whole regsiter default value
 *     OVER_HI          Used for whole regsiter default value
 */
#define UNKNOWN_UCAST_BLOCK_MASK_LO_64r_SIZE 8

/*
 * This structure should be used to declare and program UNKNOWN_UCAST_BLOCK_MASK_LO_64.
 */
typedef union UNKNOWN_UCAST_BLOCK_MASK_LO_64r_s {
	uint32 v[2];
	uint32 unknown_ucast_block_mask_lo_64[2];
	uint32 _unknown_ucast_block_mask_lo_64;
} UNKNOWN_UCAST_BLOCK_MASK_LO_64r_t;

#define UNKNOWN_UCAST_BLOCK_MASK_LO_64r_CLR(r) sal_memset(&((r)._unknown_ucast_block_mask_lo_64), 0, sizeof(UNKNOWN_UCAST_BLOCK_MASK_LO_64r_t))
#define UNKNOWN_UCAST_BLOCK_MASK_LO_64r_SET(r,i,d) (r).unknown_ucast_block_mask_lo_64[i] = d
#define UNKNOWN_UCAST_BLOCK_MASK_LO_64r_GET(r,i) (r).unknown_ucast_block_mask_lo_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define UNKNOWN_UCAST_BLOCK_MASK_LO_64r_BLK_BITMAPf_GET(r,a) field_get((r).unknown_ucast_block_mask_lo_64,0,63,a)
#define UNKNOWN_UCAST_BLOCK_MASK_LO_64r_BLK_BITMAPf_SET(r,a) field_set((r).unknown_ucast_block_mask_lo_64,0,63,a)
#define UNKNOWN_UCAST_BLOCK_MASK_LO_64r_BLK_BITMAP_0f_GET(r,a) field_get((r).unknown_ucast_block_mask_lo_64,0,63,a)
#define UNKNOWN_UCAST_BLOCK_MASK_LO_64r_BLK_BITMAP_0f_SET(r,a) field_set((r).unknown_ucast_block_mask_lo_64,0,63,a)
#define UNKNOWN_UCAST_BLOCK_MASK_LO_64r_OVER_LOf_GET(r) ((r).unknown_ucast_block_mask_lo_64[0])
#define UNKNOWN_UCAST_BLOCK_MASK_LO_64r_OVER_LOf_SET(r,f) (r).unknown_ucast_block_mask_lo_64[0]=((uint32)f)
#define UNKNOWN_UCAST_BLOCK_MASK_LO_64r_OVER_HIf_GET(r) ((r).unknown_ucast_block_mask_lo_64[1])
#define UNKNOWN_UCAST_BLOCK_MASK_LO_64r_OVER_HIf_SET(r,f) (r).unknown_ucast_block_mask_lo_64[1]=((uint32)f)

/*
 * These macros can be used to access UNKNOWN_UCAST_BLOCK_MASK_LO_64.
 */
#define WRITE_UNKNOWN_UCAST_BLOCK_MASK_LO_64r(u,p,r) bcm5607x_reg64_set(u,R_UNKNOWN_UCAST_BLOCK_MASK_LO_64(p),&(r._unknown_ucast_block_mask_lo_64),2)
#define READ_UNKNOWN_UCAST_BLOCK_MASK_LO_64r(u,p,r) bcm5607x_reg64_get(u,R_UNKNOWN_UCAST_BLOCK_MASK_LO_64(p),&(r._unknown_ucast_block_mask_lo_64),2)

/*******************************************************************************
 * End of 'UNKNOWN_UCAST_BLOCK_MASK_LO_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  VFP_CAM_CONTROL_TM_7_THRU_0
 * BLOCKS:   IPIPE
 * DESC:     VFP_CAM_CONTROL_TM_7_THRU_0
 * SIZE:     32
 * FIELDS:
 *     TM               VFP_CAM_CONTROL FOR VFP SLICE 0,1,2,3 
 */
#define VFP_CAM_CONTROL_TM_7_THRU_0r_SIZE 4

/*
 * This structure should be used to declare and program VFP_CAM_CONTROL_TM_7_THRU_0.
 */
typedef union VFP_CAM_CONTROL_TM_7_THRU_0r_s {
	uint32 v[1];
	uint32 vfp_cam_control_tm_7_thru_0[1];
	uint32 _vfp_cam_control_tm_7_thru_0;
} VFP_CAM_CONTROL_TM_7_THRU_0r_t;

#define VFP_CAM_CONTROL_TM_7_THRU_0r_CLR(r) (r).vfp_cam_control_tm_7_thru_0[0] = 0
#define VFP_CAM_CONTROL_TM_7_THRU_0r_SET(r,d) (r).vfp_cam_control_tm_7_thru_0[0] = d
#define VFP_CAM_CONTROL_TM_7_THRU_0r_GET(r) (r).vfp_cam_control_tm_7_thru_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define VFP_CAM_CONTROL_TM_7_THRU_0r_TMf_GET(r) (((r).vfp_cam_control_tm_7_thru_0[0]) & 0xff)
#define VFP_CAM_CONTROL_TM_7_THRU_0r_TMf_SET(r,f) (r).vfp_cam_control_tm_7_thru_0[0]=(((r).vfp_cam_control_tm_7_thru_0[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))

/*
 * These macros can be used to access VFP_CAM_CONTROL_TM_7_THRU_0.
 */
#define WRITE_VFP_CAM_CONTROL_TM_7_THRU_0r(u,r) bcm5607x_reg_set(u,R_VFP_CAM_CONTROL_TM_7_THRU_0,(r._vfp_cam_control_tm_7_thru_0))
#define READ_VFP_CAM_CONTROL_TM_7_THRU_0r(u,r) bcm5607x_reg_get(u,R_VFP_CAM_CONTROL_TM_7_THRU_0,&(r._vfp_cam_control_tm_7_thru_0))

/*******************************************************************************
 * End of 'VFP_CAM_CONTROL_TM_7_THRU_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  VLAN
 * BLOCKS:   IPIPE
 * DESC:     Contains controls associated with the 4K VLANs.
Identifies the VLAN membership and associated spanning tree group. Support for IEEE 802.1Q VLAN. Port Taggedness information is stored in the EGR_VLAN table. This table is indexed using the VLAN ID.
 * SIZE:     178
 * FIELDS:
 *     PORT_BITMAP      VLAN port membership bitmap
 *     PORT_BITMAP_LO   VLAN port membership bitmap
 *     HIGIG_TRUNK_OVERRIDE Add the VLAN ID
 *     VALID            Valid VLAN ID
 *     STG              Spanning Tree Group ID
 *     RESERVED1        Reserved bit due to size reduction of VLAN_STG table
 *     FID_ID           Forwarding database ID
 *     VLAN_PROFILE_PTR VLAN profile pointer to get VLAN-specific properties
 *     L3_IIF           L3 Interface for L3 routing lookups -- note that VRF and Intf CLASS_ID come from the L3_IIF table
 *     RESERVED_41      Reserved bits due to size reduction of L3_IIF table
 *     VLAN_CLASS_ID    VLAN CLass ID for IFP keys
 *     L2_ENTRY_KEY_TYPE Indicates the forwarding behavior for this VLAN ID.  This is the KEY_TYPE to the L2_ENTRY table.
 *     BC_IDX           The L3MC_IDX used to represent a broadcast into the associated VLAN.
 *     RESERVED_BC_IDX  Reserved bits due to width reduction of MC group.
 *     UUC_IDX          The L3MC_IDX used to represent an unknown unicast flood into the associated VLAN. (typically does not include AC2WTP destinations)
 *     RESERVED_UUC_IDX Reserved bits due to width reduction of MC group.
 *     UMC_IDX          The L3MC_IDX used to represent an unknown multicast flood into the associated VLAN. (typically does not include AC2WTP destinations)
 *     RESERVED_UMC_IDX Reserved bits due to width reduction of MC group.
 *     SR_LAN_ID_VALID  Indicates whether the SR_LAN_ID is valid or not. 0: ivnalid, 1: valid.
 *     SR_LAN_ID        Used for Seamless Redundancy (802.1CB) and Indicates whether this VLAN is LAN_A or LAN_B. 0: LAN_A, 1: LAN_B.
 *     SR_ENABLE        When set Indicates that Seamless Redundancy is enabled on this VLAN.  
 *     SVC_METER_OFFSET_MODE Used in generating index into offset TCAM.
 *     SVC_METER_INDEX  256 Meter Indexes.
 *     RESERVED_107     Reserved bits due to size reduction of SVM_METER_TABLE.
 *     EVEN_PARITY      Even parity for the  VLAN RAM
 */
#define VLANm_MIN 0
#define VLANm_MAX 4095
#define VLANm_CMAX(u) 4095
#define VLANm_SIZE 23

/*
 * This structure should be used to declare and program VLAN.
 */
typedef union VLANm_s {
	uint32 v[6];
	uint32 vlan[6];
	uint32 _vlan;
} VLANm_t;

#define VLANm_CLR(r) sal_memset(&((r)._vlan), 0, sizeof(VLANm_t))
#define VLANm_SET(r,i,d) (r).vlan[i] = d
#define VLANm_GET(r,i) (r).vlan[i]

/*
 * These macros can be used to access individual fields.
 */
#define VLANm_PORT_BITMAPf_GET(r,a) field_get((r).vlan,0,65,a)
#define VLANm_PORT_BITMAPf_SET(r,a) field_set((r).vlan,0,65,a)
#define VLANm_PORT_BITMAP_LOf_GET(r,a) field_get((r).vlan,0,65,a)
#define VLANm_PORT_BITMAP_LOf_SET(r,a) field_set((r).vlan,0,65,a)
#define VLANm_HIGIG_TRUNK_OVERRIDEf_GET(r) ((((r).vlan[2]) >> 2) & 0xff)
#define VLANm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).vlan[2]=(((r).vlan[2] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define VLANm_VALIDf_GET(r) ((((r).vlan[2]) >> 10) & 0x1)
#define VLANm_VALIDf_SET(r,f) (r).vlan[2]=(((r).vlan[2] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define VLANm_STGf_GET(r) ((((r).vlan[2]) >> 11) & 0x7f)
#define VLANm_STGf_SET(r,f) (r).vlan[2]=(((r).vlan[2] & ~((uint32)0x7f << 11)) | ((((uint32)f) & 0x7f) << 11))
#define VLANm_RESERVED1f_GET(r) ((((r).vlan[2]) >> 18) & 0x3)
#define VLANm_RESERVED1f_SET(r,f) (r).vlan[2]=(((r).vlan[2] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define VLANm_FID_IDf_GET(r) ((((r).vlan[2]) >> 20) & 0xfff)
#define VLANm_FID_IDf_SET(r,f) (r).vlan[2]=(((r).vlan[2] & ~((uint32)0xfff << 20)) | ((((uint32)f) & 0xfff) << 20))
#define VLANm_VLAN_PROFILE_PTRf_GET(r) (((r).vlan[3]) & 0xf)
#define VLANm_VLAN_PROFILE_PTRf_SET(r,f) (r).vlan[3]=(((r).vlan[3] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define VLANm_L3_IIFf_GET(r) ((((r).vlan[3]) >> 4) & 0x7f)
#define VLANm_L3_IIFf_SET(r,f) (r).vlan[3]=(((r).vlan[3] & ~((uint32)0x7f << 4)) | ((((uint32)f) & 0x7f) << 4))
#define VLANm_RESERVED_41f_GET(r) ((((r).vlan[3]) >> 11) & 0x1f)
#define VLANm_RESERVED_41f_SET(r,f) (r).vlan[3]=(((r).vlan[3] & ~((uint32)0x1f << 11)) | ((((uint32)f) & 0x1f) << 11))
#define VLANm_VLAN_CLASS_IDf_GET(r) ((((r).vlan[3]) >> 16) & 0xff)
#define VLANm_VLAN_CLASS_IDf_SET(r,f) (r).vlan[3]=(((r).vlan[3] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define VLANm_L2_ENTRY_KEY_TYPEf_GET(r) ((((r).vlan[3]) >> 24) & 0x7)
#define VLANm_L2_ENTRY_KEY_TYPEf_SET(r,f) (r).vlan[3]=(((r).vlan[3] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define VLANm_BC_IDXf_GET(r) field32_get((r).vlan,123,132)
#define VLANm_BC_IDXf_SET(r,f) field32_set((r).vlan,123,132,f)
#define VLANm_RESERVED_BC_IDXf_GET(r) ((((r).vlan[4]) >> 5) & 0x3)
#define VLANm_RESERVED_BC_IDXf_SET(r,f) (r).vlan[4]=(((r).vlan[4] & ~((uint32)0x3 << 5)) | ((((uint32)f) & 0x3) << 5))
#define VLANm_UUC_IDXf_GET(r) ((((r).vlan[4]) >> 7) & 0x3ff)
#define VLANm_UUC_IDXf_SET(r,f) (r).vlan[4]=(((r).vlan[4] & ~((uint32)0x3ff << 7)) | ((((uint32)f) & 0x3ff) << 7))
#define VLANm_RESERVED_UUC_IDXf_GET(r) ((((r).vlan[4]) >> 17) & 0x3)
#define VLANm_RESERVED_UUC_IDXf_SET(r,f) (r).vlan[4]=(((r).vlan[4] & ~((uint32)0x3 << 17)) | ((((uint32)f) & 0x3) << 17))
#define VLANm_UMC_IDXf_GET(r) ((((r).vlan[4]) >> 19) & 0x3ff)
#define VLANm_UMC_IDXf_SET(r,f) (r).vlan[4]=(((r).vlan[4] & ~((uint32)0x3ff << 19)) | ((((uint32)f) & 0x3ff) << 19))
#define VLANm_RESERVED_UMC_IDXf_GET(r) ((((r).vlan[4]) >> 29) & 0x3)
#define VLANm_RESERVED_UMC_IDXf_SET(r,f) (r).vlan[4]=(((r).vlan[4] & ~((uint32)0x3 << 29)) | ((((uint32)f) & 0x3) << 29))
#define VLANm_SR_LAN_ID_VALIDf_GET(r) (((r).vlan[5]) & 0x1)
#define VLANm_SR_LAN_ID_VALIDf_SET(r,f) (r).vlan[5]=(((r).vlan[5] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define VLANm_SR_LAN_IDf_GET(r) ((((r).vlan[5]) >> 1) & 0x1)
#define VLANm_SR_LAN_IDf_SET(r,f) (r).vlan[5]=(((r).vlan[5] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define VLANm_SR_ENABLEf_GET(r) ((((r).vlan[5]) >> 2) & 0x1)
#define VLANm_SR_ENABLEf_SET(r,f) (r).vlan[5]=(((r).vlan[5] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define VLANm_SVC_METER_OFFSET_MODEf_GET(r) ((((r).vlan[5]) >> 3) & 0x3)
#define VLANm_SVC_METER_OFFSET_MODEf_SET(r,f) (r).vlan[5]=(((r).vlan[5] & ~((uint32)0x3 << 3)) | ((((uint32)f) & 0x3) << 3))
#define VLANm_SVC_METER_INDEXf_GET(r) ((((r).vlan[5]) >> 5) & 0xff)
#define VLANm_SVC_METER_INDEXf_SET(r,f) (r).vlan[5]=(((r).vlan[5] & ~((uint32)0xff << 5)) | ((((uint32)f) & 0xff) << 5))
#define VLANm_RESERVED_107f_GET(r) ((((r).vlan[5]) >> 13) & 0xf)
#define VLANm_RESERVED_107f_SET(r,f) (r).vlan[5]=(((r).vlan[5] & ~((uint32)0xf << 13)) | ((((uint32)f) & 0xf) << 13))
#define VLANm_EVEN_PARITYf_GET(r) ((((r).vlan[5]) >> 17) & 0x1)
#define VLANm_EVEN_PARITYf_SET(r,f) (r).vlan[5]=(((r).vlan[5] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))

/*
 * These macros can be used to access VLAN.
 */
#define WRITE_VLANm(u,i,r) bcm5607x_mem_set(u, M_VLAN(i), &(r._vlan), 6)
#define READ_VLANm(u,i,r) bcm5607x_mem_get(u, M_VLAN(i), &(r._vlan), 6)

/*******************************************************************************
 * End of 'VLANm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  VLAN_CTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN Control Register 1
 * SIZE:     32
 * FIELDS:
 *     LEARN_VID        LEARN_VID for ARL learning
 *     USE_LEARN_VID    If set to 1, use LEARN_VID field from this register for ARL learning/lookups
 *     INNER_TPID       TPID for inner VLAN, used for double tagging modes only
 */
#define VLAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_CTRL.
 */
typedef union VLAN_CTRLr_s {
	uint32 v[1];
	uint32 vlan_ctrl[1];
	uint32 _vlan_ctrl;
} VLAN_CTRLr_t;

#define VLAN_CTRLr_CLR(r) (r).vlan_ctrl[0] = 0
#define VLAN_CTRLr_SET(r,d) (r).vlan_ctrl[0] = d
#define VLAN_CTRLr_GET(r) (r).vlan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define VLAN_CTRLr_LEARN_VIDf_GET(r) (((r).vlan_ctrl[0]) & 0xfff)
#define VLAN_CTRLr_LEARN_VIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define VLAN_CTRLr_USE_LEARN_VIDf_GET(r) ((((r).vlan_ctrl[0]) >> 12) & 0x1)
#define VLAN_CTRLr_USE_LEARN_VIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define VLAN_CTRLr_INNER_TPIDf_GET(r) ((((r).vlan_ctrl[0]) >> 13) & 0xffff)
#define VLAN_CTRLr_INNER_TPIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32)0xffff << 13)) | ((((uint32)f) & 0xffff) << 13))

/*
 * These macros can be used to access VLAN_CTRL.
 */
#define WRITE_VLAN_CTRLr(u,r) bcm5607x_reg_set(u,R_VLAN_CTRL,(r._vlan_ctrl))
#define READ_VLAN_CTRLr(u,r) bcm5607x_reg_get(u,R_VLAN_CTRL,&(r._vlan_ctrl))

/*******************************************************************************
 * End of 'VLAN_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  VLAN_DEFAULT_PBM_HI
 * BLOCKS:   IPIPE
 * DESC:     default VLAN Port Bit Map. HIGH BITs
 * SIZE:     64
 * FIELDS:
 *     PORT_BITMAP      default VLAN Port Bit Map.
 *     RESERVED         Reserved.
 */
#define VLAN_DEFAULT_PBM_HIr_SIZE 8

/*
 * This structure should be used to declare and program VLAN_DEFAULT_PBM_HI.
 */
typedef union VLAN_DEFAULT_PBM_HIr_s {
	uint32 v[2];
	uint32 vlan_default_pbm_hi[2];
	uint32 _vlan_default_pbm_hi;
} VLAN_DEFAULT_PBM_HIr_t;

#define VLAN_DEFAULT_PBM_HIr_CLR(r) sal_memset(&((r)._vlan_default_pbm_hi), 0, sizeof(VLAN_DEFAULT_PBM_HIr_t))
#define VLAN_DEFAULT_PBM_HIr_SET(r,i,d) (r).vlan_default_pbm_hi[i] = d
#define VLAN_DEFAULT_PBM_HIr_GET(r,i) (r).vlan_default_pbm_hi[i]

/*
 * These macros can be used to access individual fields.
 */
#define VLAN_DEFAULT_PBM_HIr_PORT_BITMAPf_GET(r) (((r).vlan_default_pbm_hi[0]) & 0x3)
#define VLAN_DEFAULT_PBM_HIr_PORT_BITMAPf_SET(r,f) (r).vlan_default_pbm_hi[0]=(((r).vlan_default_pbm_hi[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define VLAN_DEFAULT_PBM_HIr_RESERVEDf_GET(r,a) field_get((r).vlan_default_pbm_hi,2,63,a)
#define VLAN_DEFAULT_PBM_HIr_RESERVEDf_SET(r,a) field_set((r).vlan_default_pbm_hi,2,63,a)

/*
 * These macros can be used to access VLAN_DEFAULT_PBM_HI.
 */
#define WRITE_VLAN_DEFAULT_PBM_HIr(u,r) bcm5607x_reg64_set(u,R_VLAN_DEFAULT_PBM_HI,&(r._vlan_default_pbm_hi),2)
#define READ_VLAN_DEFAULT_PBM_HIr(u,r) bcm5607x_reg64_get(u,R_VLAN_DEFAULT_PBM_HI,&(r._vlan_default_pbm_hi),2)

/*******************************************************************************
 * End of 'VLAN_DEFAULT_PBM_HIr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  VLAN_DEFAULT_PBM_LO
 * BLOCKS:   IPIPE
 * DESC:     default VLAN Port Bit Map. LOW BITs
 * SIZE:     64
 * FIELDS:
 *     PORT_BITMAP      default VLAN Port Bit Map.
 *     OVER_LO          Used for whole regsiter default value (Non-Zero).
 *     OVER_HI          Used for whole regsiter default value (Non-Zero).
 */
#define VLAN_DEFAULT_PBM_LOr_SIZE 8

/*
 * This structure should be used to declare and program VLAN_DEFAULT_PBM_LO.
 */
typedef union VLAN_DEFAULT_PBM_LOr_s {
	uint32 v[2];
	uint32 vlan_default_pbm_lo[2];
	uint32 _vlan_default_pbm_lo;
} VLAN_DEFAULT_PBM_LOr_t;

#define VLAN_DEFAULT_PBM_LOr_CLR(r) sal_memset(&((r)._vlan_default_pbm_lo), 0, sizeof(VLAN_DEFAULT_PBM_LOr_t))
#define VLAN_DEFAULT_PBM_LOr_SET(r,i,d) (r).vlan_default_pbm_lo[i] = d
#define VLAN_DEFAULT_PBM_LOr_GET(r,i) (r).vlan_default_pbm_lo[i]

/*
 * These macros can be used to access individual fields.
 */
#define VLAN_DEFAULT_PBM_LOr_PORT_BITMAPf_GET(r,a) field_get((r).vlan_default_pbm_lo,0,63,a)
#define VLAN_DEFAULT_PBM_LOr_PORT_BITMAPf_SET(r,a) field_set((r).vlan_default_pbm_lo,0,63,a)
#define VLAN_DEFAULT_PBM_LOr_OVER_LOf_GET(r) ((r).vlan_default_pbm_lo[0])
#define VLAN_DEFAULT_PBM_LOr_OVER_LOf_SET(r,f) (r).vlan_default_pbm_lo[0]=((uint32)f)
#define VLAN_DEFAULT_PBM_LOr_OVER_HIf_GET(r) ((r).vlan_default_pbm_lo[1])
#define VLAN_DEFAULT_PBM_LOr_OVER_HIf_SET(r,f) (r).vlan_default_pbm_lo[1]=((uint32)f)

/*
 * These macros can be used to access VLAN_DEFAULT_PBM_LO.
 */
#define WRITE_VLAN_DEFAULT_PBM_LOr(u,r) bcm5607x_reg64_set(u,R_VLAN_DEFAULT_PBM_LO,&(r._vlan_default_pbm_lo),2)
#define READ_VLAN_DEFAULT_PBM_LOr(u,r) bcm5607x_reg64_get(u,R_VLAN_DEFAULT_PBM_LO,&(r._vlan_default_pbm_lo),2)

/*******************************************************************************
 * End of 'VLAN_DEFAULT_PBM_LOr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  VLAN_PROFILE
 * BLOCKS:   IPIPE
 * DESC:     VLAN profile table. 
This table provides additional controls for VLANs. The index into this table is provided by VLAN.VLAN_PROFILE_PTR.
 * SIZE:     34
 * FIELDS:
 *     L2_PFM           PFM value for L2 multicast lookups
 *     L3_IPV4_PFM      PFM value for IPv4 multicast lookups
 *     L3_IPV6_PFM      PFM value for IPv6 multicast lookups
 *     UNKNOWN_IPV4_MC_TOCPU Unknown IPMC (IPMC miss) for IPv4 packets sent to CPU enable
 *     UNKNOWN_IPV6_MC_TOCPU Unknown IPMC (IPMC miss) for IPv6 packets sent to CPU enable
 *     LEARN_DISABLE    Disable learning on this VLAN
 *     OUTER_TPID_INDEX Used when PORT_TABLE.OUTER_TPID_VERIFY is enabled and indicates which of the ING_OUTER_TPID[xx] register is expected to match for this VLAN
 *     ICMP_REDIRECT_TOCPU RESERVED.
 *     IPMCV6_ENABLE    IPMC Enable for IPV6 packets on the VLAN
 *     IPMCV4_ENABLE    IPMC Enable for IPV4 packets on the VLAN
 *     IPMCV6_L2_ENABLE Enables L2-only forwarding of IPMCv6 packets on this VLAN based on (SGV,*GV) lookups  
 *     IPMCV4_L2_ENABLE Enables L2-only forwarding of IPMCv4 packets on this VLAN based on (SGV,*GV) lookups  
 *     IPV6L3_ENABLE    L3 Enable for IPV6 packets on the VLAN
 *     IPV4L3_ENABLE    L3 Enable for IPV4 packets on the VLAN
 *     L2_MISS_TOCPU    Copy to CPU packets that miss L2 lookup.
 *     L2_MISS_DROP     Drop packets that miss L2 lookup.
 *     L2_NON_UCAST_TOCPU Copy to CPU packets that are non-unicast.
 *     L2_NON_UCAST_DROP Drop non-unicast, broadcast or multicast packets that miss L2 lookup.
 *     IPV6_ROUTING_HEADER_TYPE_0_DROP .
 *     IPMCV4_UNICAST_MACDA_ENABLE Enable Routing IPMCV4 packet with unicast MACDA.
 *     IPMCV6_UNICAST_MACDA_ENABLE Enable Routing IPMCV6 packet with unicast MACDA.
 *     CML_FLAGS_MOVE   CPU managed learning control for station moves		    What to do when a L2 station move is detected:		    bit[0] = Drop the packet		    bit[1] = Copy to CPU		    bit[2] = Set the Pending bit on HW Station Move		    bit[3] = Do HW Station Move
 *     CML_FLAGS_NEW    CPU managed learning control for new entries		    What to do when a L2 miss occurs:		    bit[0] = Drop the packet		    bit[1] = Copy to CPU		    bit[2] = Set the Pending bit on HW Learn		    bit[3] = Do HW Learn
 *     USE_VLAN_CML     Override Port based CML_FLAGS_NEW/ CML_FLAGS_MOVE.
 */
#define VLAN_PROFILEm_MIN 0
#define VLAN_PROFILEm_MAX 15
#define VLAN_PROFILEm_CMAX(u) 15
#define VLAN_PROFILEm_SIZE 5

/*
 * This structure should be used to declare and program VLAN_PROFILE.
 */
typedef union VLAN_PROFILEm_s {
	uint32 v[2];
	uint32 vlan_profile[2];
	uint32 _vlan_profile;
} VLAN_PROFILEm_t;

#define VLAN_PROFILEm_CLR(r) sal_memset(&((r)._vlan_profile), 0, sizeof(VLAN_PROFILEm_t))
#define VLAN_PROFILEm_SET(r,i,d) (r).vlan_profile[i] = d
#define VLAN_PROFILEm_GET(r,i) (r).vlan_profile[i]

/*
 * These macros can be used to access individual fields.
 */
#define VLAN_PROFILEm_L2_PFMf_GET(r) (((r).vlan_profile[0]) & 0x3)
#define VLAN_PROFILEm_L2_PFMf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define VLAN_PROFILEm_L3_IPV4_PFMf_GET(r) ((((r).vlan_profile[0]) >> 2) & 0x3)
#define VLAN_PROFILEm_L3_IPV4_PFMf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define VLAN_PROFILEm_L3_IPV6_PFMf_GET(r) ((((r).vlan_profile[0]) >> 4) & 0x3)
#define VLAN_PROFILEm_L3_IPV6_PFMf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define VLAN_PROFILEm_UNKNOWN_IPV4_MC_TOCPUf_GET(r) ((((r).vlan_profile[0]) >> 6) & 0x1)
#define VLAN_PROFILEm_UNKNOWN_IPV4_MC_TOCPUf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define VLAN_PROFILEm_UNKNOWN_IPV6_MC_TOCPUf_GET(r) ((((r).vlan_profile[0]) >> 7) & 0x1)
#define VLAN_PROFILEm_UNKNOWN_IPV6_MC_TOCPUf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define VLAN_PROFILEm_LEARN_DISABLEf_GET(r) ((((r).vlan_profile[0]) >> 8) & 0x1)
#define VLAN_PROFILEm_LEARN_DISABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define VLAN_PROFILEm_OUTER_TPID_INDEXf_GET(r) ((((r).vlan_profile[0]) >> 9) & 0x3)
#define VLAN_PROFILEm_OUTER_TPID_INDEXf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define VLAN_PROFILEm_ICMP_REDIRECT_TOCPUf_GET(r) ((((r).vlan_profile[0]) >> 11) & 0x1)
#define VLAN_PROFILEm_ICMP_REDIRECT_TOCPUf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define VLAN_PROFILEm_IPMCV6_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 12) & 0x1)
#define VLAN_PROFILEm_IPMCV6_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define VLAN_PROFILEm_IPMCV4_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 13) & 0x1)
#define VLAN_PROFILEm_IPMCV4_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define VLAN_PROFILEm_IPMCV6_L2_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 14) & 0x1)
#define VLAN_PROFILEm_IPMCV6_L2_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define VLAN_PROFILEm_IPMCV4_L2_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 15) & 0x1)
#define VLAN_PROFILEm_IPMCV4_L2_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define VLAN_PROFILEm_IPV6L3_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 16) & 0x1)
#define VLAN_PROFILEm_IPV6L3_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define VLAN_PROFILEm_IPV4L3_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 17) & 0x1)
#define VLAN_PROFILEm_IPV4L3_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define VLAN_PROFILEm_L2_MISS_TOCPUf_GET(r) ((((r).vlan_profile[0]) >> 18) & 0x1)
#define VLAN_PROFILEm_L2_MISS_TOCPUf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define VLAN_PROFILEm_L2_MISS_DROPf_GET(r) ((((r).vlan_profile[0]) >> 19) & 0x1)
#define VLAN_PROFILEm_L2_MISS_DROPf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define VLAN_PROFILEm_L2_NON_UCAST_TOCPUf_GET(r) ((((r).vlan_profile[0]) >> 20) & 0x1)
#define VLAN_PROFILEm_L2_NON_UCAST_TOCPUf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define VLAN_PROFILEm_L2_NON_UCAST_DROPf_GET(r) ((((r).vlan_profile[0]) >> 21) & 0x1)
#define VLAN_PROFILEm_L2_NON_UCAST_DROPf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define VLAN_PROFILEm_IPV6_ROUTING_HEADER_TYPE_0_DROPf_GET(r) ((((r).vlan_profile[0]) >> 22) & 0x1)
#define VLAN_PROFILEm_IPV6_ROUTING_HEADER_TYPE_0_DROPf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define VLAN_PROFILEm_IPMCV4_UNICAST_MACDA_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 23) & 0x1)
#define VLAN_PROFILEm_IPMCV4_UNICAST_MACDA_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define VLAN_PROFILEm_IPMCV6_UNICAST_MACDA_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 24) & 0x1)
#define VLAN_PROFILEm_IPMCV6_UNICAST_MACDA_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define VLAN_PROFILEm_CML_FLAGS_MOVEf_GET(r) ((((r).vlan_profile[0]) >> 25) & 0xf)
#define VLAN_PROFILEm_CML_FLAGS_MOVEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0xf << 25)) | ((((uint32)f) & 0xf) << 25))
#define VLAN_PROFILEm_CML_FLAGS_NEWf_GET(r) field32_get((r).vlan_profile,29,32)
#define VLAN_PROFILEm_CML_FLAGS_NEWf_SET(r,f) field32_set((r).vlan_profile,29,32,f)
#define VLAN_PROFILEm_USE_VLAN_CMLf_GET(r) ((((r).vlan_profile[1]) >> 1) & 0x1)
#define VLAN_PROFILEm_USE_VLAN_CMLf_SET(r,f) (r).vlan_profile[1]=(((r).vlan_profile[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access VLAN_PROFILE.
 */
#define WRITE_VLAN_PROFILEm(u,i,r) bcm5607x_mem_set(u, M_VLAN_PROFILE(i), &(r._vlan_profile), 2)
#define READ_VLAN_PROFILEm(u,i,r) bcm5607x_mem_get(u, M_VLAN_PROFILE(i), &(r._vlan_profile), 2)

/*******************************************************************************
 * End of 'VLAN_PROFILEm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  VLAN_STG
 * BLOCKS:   IPIPE
 * DESC:      Spanning Tree Group state table
This table is indexed by Spanning Tree Group from the VLAN table (VLAN.STG) and the ingress port number. It is used to get the spanning tree state of the ingress port for a particular VLAN.
The following are the spanning tree states:
0 = Disabled. All packets are dropped, including control packets, even BPDUs.
1 = Blocking. All control/BPDU packets are sent to the CPU, all other packets are dropped (no L2 address learning).
2 = Learning. All control/BPDU packets are sent to the CPU, all other packets are dropped (L2 addresses are learned).
3 = Forwarding. All control/BPDU packets are sent to the CPU, all other packets are forwarded as normal.
 * SIZE:     133
 * FIELDS:
 *     SP_TREE_PORT0    Spanning Tree State for port 0
 *     SP_TREE_PORT1    Spanning Tree State for port 1
 *     SP_TREE_PORT2    Spanning Tree State for port 2
 *     SP_TREE_PORT3    Spanning Tree State for port 3
 *     SP_TREE_PORT4    Spanning Tree State for port 4
 *     SP_TREE_PORT5    Spanning Tree State for port 5
 *     SP_TREE_PORT6    Spanning Tree State for port 6
 *     SP_TREE_PORT7    Spanning Tree State for port 7
 *     SP_TREE_PORT8    Spanning Tree State for port 8
 *     SP_TREE_PORT9    Spanning Tree State for port 9
 *     SP_TREE_PORT10   Spanning Tree State for port 10
 *     SP_TREE_PORT11   Spanning Tree State for port 11
 *     SP_TREE_PORT12   Spanning Tree State for port 12
 *     SP_TREE_PORT13   Spanning Tree State for port 13
 *     SP_TREE_PORT14   Spanning Tree State for port 14
 *     SP_TREE_PORT15   Spanning Tree State for port 15
 *     SP_TREE_PORT16   Spanning Tree State for port 16
 *     SP_TREE_PORT17   Spanning Tree State for port 17
 *     SP_TREE_PORT18   Spanning Tree State for port 18
 *     SP_TREE_PORT19   Spanning Tree State for port 19
 *     SP_TREE_PORT20   Spanning Tree State for port 20
 *     SP_TREE_PORT21   Spanning Tree State for port 21
 *     SP_TREE_PORT22   Spanning Tree State for port 22
 *     SP_TREE_PORT23   Spanning Tree State for port 23
 *     SP_TREE_PORT24   Spanning Tree State for port 24
 *     SP_TREE_PORT25   Spanning Tree State for port 25
 *     SP_TREE_PORT26   Spanning Tree State for port 26
 *     SP_TREE_PORT27   Spanning Tree State for port 27
 *     SP_TREE_PORT28   Spanning Tree State for port 28
 *     SP_TREE_PORT29   Spanning Tree State for port 29
 *     SP_TREE_PORT30   Spanning Tree State for port 30
 *     SP_TREE_PORT31   Spanning Tree State for port 31
 *     SP_TREE_PORT32   Spanning Tree State for port 32
 *     SP_TREE_PORT33   Spanning Tree State for port 33
 *     SP_TREE_PORT34   Spanning Tree State for port 34
 *     SP_TREE_PORT35   Spanning Tree State for port 35
 *     SP_TREE_PORT36   Spanning Tree State for port 36
 *     SP_TREE_PORT37   Spanning Tree State for port 37
 *     SP_TREE_PORT38   Spanning Tree State for port 38
 *     SP_TREE_PORT39   Spanning Tree State for port 39
 *     SP_TREE_PORT40   Spanning Tree State for port 40
 *     SP_TREE_PORT41   Spanning Tree State for port 41
 *     SP_TREE_PORT42   Spanning Tree State for port 42
 *     SP_TREE_PORT43   Spanning Tree State for port 43
 *     SP_TREE_PORT44   Spanning Tree State for port 44
 *     SP_TREE_PORT45   Spanning Tree State for port 45
 *     SP_TREE_PORT46   Spanning Tree State for port 46
 *     SP_TREE_PORT47   Spanning Tree State for port 47
 *     SP_TREE_PORT48   Spanning Tree State for port 48
 *     SP_TREE_PORT49   Spanning Tree State for port 49
 *     SP_TREE_PORT50   Spanning Tree State for port 50
 *     SP_TREE_PORT51   Spanning Tree State for port 51
 *     SP_TREE_PORT52   Spanning Tree State for port 52
 *     SP_TREE_PORT53   Spanning Tree State for port 53
 *     SP_TREE_PORT54   Spanning Tree State for port 54
 *     SP_TREE_PORT55   Spanning Tree State for port 55
 *     SP_TREE_PORT56   Spanning Tree State for port 56
 *     SP_TREE_PORT57   Spanning Tree State for port 57
 *     SP_TREE_PORT58   Spanning Tree State for port 58
 *     SP_TREE_PORT59   Spanning Tree State for port 59
 *     SP_TREE_PORT60   Spanning Tree State for port 60
 *     SP_TREE_PORT61   Spanning Tree State for port 61
 *     SP_TREE_PORT62   Spanning Tree State for port 62
 *     SP_TREE_PORT63   Spanning Tree State for port 63
 *     SP_TREE_PORT64   Spanning Tree State for port 64
 *     SP_TREE_PORT65   Spanning Tree State for port 65
 *     EVEN_PARITY      Even Parity for the VLAN_STG table.
 */
#define VLAN_STGm_MIN 0
#define VLAN_STGm_MAX 127
#define VLAN_STGm_CMAX(u) 127
#define VLAN_STGm_SIZE 17

/*
 * This structure should be used to declare and program VLAN_STG.
 */
typedef union VLAN_STGm_s {
	uint32 v[5];
	uint32 vlan_stg[5];
	uint32 _vlan_stg;
} VLAN_STGm_t;

#define VLAN_STGm_CLR(r) sal_memset(&((r)._vlan_stg), 0, sizeof(VLAN_STGm_t))
#define VLAN_STGm_SET(r,i,d) (r).vlan_stg[i] = d
#define VLAN_STGm_GET(r,i) (r).vlan_stg[i]

/*
 * These macros can be used to access individual fields.
 */
#define VLAN_STGm_SP_TREE_PORT0f_GET(r) (((r).vlan_stg[0]) & 0x3)
#define VLAN_STGm_SP_TREE_PORT0f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define VLAN_STGm_SP_TREE_PORT1f_GET(r) ((((r).vlan_stg[0]) >> 2) & 0x3)
#define VLAN_STGm_SP_TREE_PORT1f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define VLAN_STGm_SP_TREE_PORT2f_GET(r) ((((r).vlan_stg[0]) >> 4) & 0x3)
#define VLAN_STGm_SP_TREE_PORT2f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define VLAN_STGm_SP_TREE_PORT3f_GET(r) ((((r).vlan_stg[0]) >> 6) & 0x3)
#define VLAN_STGm_SP_TREE_PORT3f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define VLAN_STGm_SP_TREE_PORT4f_GET(r) ((((r).vlan_stg[0]) >> 8) & 0x3)
#define VLAN_STGm_SP_TREE_PORT4f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define VLAN_STGm_SP_TREE_PORT5f_GET(r) ((((r).vlan_stg[0]) >> 10) & 0x3)
#define VLAN_STGm_SP_TREE_PORT5f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define VLAN_STGm_SP_TREE_PORT6f_GET(r) ((((r).vlan_stg[0]) >> 12) & 0x3)
#define VLAN_STGm_SP_TREE_PORT6f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define VLAN_STGm_SP_TREE_PORT7f_GET(r) ((((r).vlan_stg[0]) >> 14) & 0x3)
#define VLAN_STGm_SP_TREE_PORT7f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define VLAN_STGm_SP_TREE_PORT8f_GET(r) ((((r).vlan_stg[0]) >> 16) & 0x3)
#define VLAN_STGm_SP_TREE_PORT8f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define VLAN_STGm_SP_TREE_PORT9f_GET(r) ((((r).vlan_stg[0]) >> 18) & 0x3)
#define VLAN_STGm_SP_TREE_PORT9f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define VLAN_STGm_SP_TREE_PORT10f_GET(r) ((((r).vlan_stg[0]) >> 20) & 0x3)
#define VLAN_STGm_SP_TREE_PORT10f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define VLAN_STGm_SP_TREE_PORT11f_GET(r) ((((r).vlan_stg[0]) >> 22) & 0x3)
#define VLAN_STGm_SP_TREE_PORT11f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define VLAN_STGm_SP_TREE_PORT12f_GET(r) ((((r).vlan_stg[0]) >> 24) & 0x3)
#define VLAN_STGm_SP_TREE_PORT12f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define VLAN_STGm_SP_TREE_PORT13f_GET(r) ((((r).vlan_stg[0]) >> 26) & 0x3)
#define VLAN_STGm_SP_TREE_PORT13f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define VLAN_STGm_SP_TREE_PORT14f_GET(r) ((((r).vlan_stg[0]) >> 28) & 0x3)
#define VLAN_STGm_SP_TREE_PORT14f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define VLAN_STGm_SP_TREE_PORT15f_GET(r) ((((r).vlan_stg[0]) >> 30) & 0x3)
#define VLAN_STGm_SP_TREE_PORT15f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define VLAN_STGm_SP_TREE_PORT16f_GET(r) (((r).vlan_stg[1]) & 0x3)
#define VLAN_STGm_SP_TREE_PORT16f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define VLAN_STGm_SP_TREE_PORT17f_GET(r) ((((r).vlan_stg[1]) >> 2) & 0x3)
#define VLAN_STGm_SP_TREE_PORT17f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define VLAN_STGm_SP_TREE_PORT18f_GET(r) ((((r).vlan_stg[1]) >> 4) & 0x3)
#define VLAN_STGm_SP_TREE_PORT18f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define VLAN_STGm_SP_TREE_PORT19f_GET(r) ((((r).vlan_stg[1]) >> 6) & 0x3)
#define VLAN_STGm_SP_TREE_PORT19f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define VLAN_STGm_SP_TREE_PORT20f_GET(r) ((((r).vlan_stg[1]) >> 8) & 0x3)
#define VLAN_STGm_SP_TREE_PORT20f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define VLAN_STGm_SP_TREE_PORT21f_GET(r) ((((r).vlan_stg[1]) >> 10) & 0x3)
#define VLAN_STGm_SP_TREE_PORT21f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define VLAN_STGm_SP_TREE_PORT22f_GET(r) ((((r).vlan_stg[1]) >> 12) & 0x3)
#define VLAN_STGm_SP_TREE_PORT22f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define VLAN_STGm_SP_TREE_PORT23f_GET(r) ((((r).vlan_stg[1]) >> 14) & 0x3)
#define VLAN_STGm_SP_TREE_PORT23f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define VLAN_STGm_SP_TREE_PORT24f_GET(r) ((((r).vlan_stg[1]) >> 16) & 0x3)
#define VLAN_STGm_SP_TREE_PORT24f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define VLAN_STGm_SP_TREE_PORT25f_GET(r) ((((r).vlan_stg[1]) >> 18) & 0x3)
#define VLAN_STGm_SP_TREE_PORT25f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define VLAN_STGm_SP_TREE_PORT26f_GET(r) ((((r).vlan_stg[1]) >> 20) & 0x3)
#define VLAN_STGm_SP_TREE_PORT26f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define VLAN_STGm_SP_TREE_PORT27f_GET(r) ((((r).vlan_stg[1]) >> 22) & 0x3)
#define VLAN_STGm_SP_TREE_PORT27f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define VLAN_STGm_SP_TREE_PORT28f_GET(r) ((((r).vlan_stg[1]) >> 24) & 0x3)
#define VLAN_STGm_SP_TREE_PORT28f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define VLAN_STGm_SP_TREE_PORT29f_GET(r) ((((r).vlan_stg[1]) >> 26) & 0x3)
#define VLAN_STGm_SP_TREE_PORT29f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define VLAN_STGm_SP_TREE_PORT30f_GET(r) ((((r).vlan_stg[1]) >> 28) & 0x3)
#define VLAN_STGm_SP_TREE_PORT30f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define VLAN_STGm_SP_TREE_PORT31f_GET(r) ((((r).vlan_stg[1]) >> 30) & 0x3)
#define VLAN_STGm_SP_TREE_PORT31f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define VLAN_STGm_SP_TREE_PORT32f_GET(r) (((r).vlan_stg[2]) & 0x3)
#define VLAN_STGm_SP_TREE_PORT32f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define VLAN_STGm_SP_TREE_PORT33f_GET(r) ((((r).vlan_stg[2]) >> 2) & 0x3)
#define VLAN_STGm_SP_TREE_PORT33f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define VLAN_STGm_SP_TREE_PORT34f_GET(r) ((((r).vlan_stg[2]) >> 4) & 0x3)
#define VLAN_STGm_SP_TREE_PORT34f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define VLAN_STGm_SP_TREE_PORT35f_GET(r) ((((r).vlan_stg[2]) >> 6) & 0x3)
#define VLAN_STGm_SP_TREE_PORT35f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define VLAN_STGm_SP_TREE_PORT36f_GET(r) ((((r).vlan_stg[2]) >> 8) & 0x3)
#define VLAN_STGm_SP_TREE_PORT36f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define VLAN_STGm_SP_TREE_PORT37f_GET(r) ((((r).vlan_stg[2]) >> 10) & 0x3)
#define VLAN_STGm_SP_TREE_PORT37f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define VLAN_STGm_SP_TREE_PORT38f_GET(r) ((((r).vlan_stg[2]) >> 12) & 0x3)
#define VLAN_STGm_SP_TREE_PORT38f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define VLAN_STGm_SP_TREE_PORT39f_GET(r) ((((r).vlan_stg[2]) >> 14) & 0x3)
#define VLAN_STGm_SP_TREE_PORT39f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define VLAN_STGm_SP_TREE_PORT40f_GET(r) ((((r).vlan_stg[2]) >> 16) & 0x3)
#define VLAN_STGm_SP_TREE_PORT40f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define VLAN_STGm_SP_TREE_PORT41f_GET(r) ((((r).vlan_stg[2]) >> 18) & 0x3)
#define VLAN_STGm_SP_TREE_PORT41f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define VLAN_STGm_SP_TREE_PORT42f_GET(r) ((((r).vlan_stg[2]) >> 20) & 0x3)
#define VLAN_STGm_SP_TREE_PORT42f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define VLAN_STGm_SP_TREE_PORT43f_GET(r) ((((r).vlan_stg[2]) >> 22) & 0x3)
#define VLAN_STGm_SP_TREE_PORT43f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define VLAN_STGm_SP_TREE_PORT44f_GET(r) ((((r).vlan_stg[2]) >> 24) & 0x3)
#define VLAN_STGm_SP_TREE_PORT44f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define VLAN_STGm_SP_TREE_PORT45f_GET(r) ((((r).vlan_stg[2]) >> 26) & 0x3)
#define VLAN_STGm_SP_TREE_PORT45f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define VLAN_STGm_SP_TREE_PORT46f_GET(r) ((((r).vlan_stg[2]) >> 28) & 0x3)
#define VLAN_STGm_SP_TREE_PORT46f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define VLAN_STGm_SP_TREE_PORT47f_GET(r) ((((r).vlan_stg[2]) >> 30) & 0x3)
#define VLAN_STGm_SP_TREE_PORT47f_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define VLAN_STGm_SP_TREE_PORT48f_GET(r) (((r).vlan_stg[3]) & 0x3)
#define VLAN_STGm_SP_TREE_PORT48f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define VLAN_STGm_SP_TREE_PORT49f_GET(r) ((((r).vlan_stg[3]) >> 2) & 0x3)
#define VLAN_STGm_SP_TREE_PORT49f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define VLAN_STGm_SP_TREE_PORT50f_GET(r) ((((r).vlan_stg[3]) >> 4) & 0x3)
#define VLAN_STGm_SP_TREE_PORT50f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define VLAN_STGm_SP_TREE_PORT51f_GET(r) ((((r).vlan_stg[3]) >> 6) & 0x3)
#define VLAN_STGm_SP_TREE_PORT51f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define VLAN_STGm_SP_TREE_PORT52f_GET(r) ((((r).vlan_stg[3]) >> 8) & 0x3)
#define VLAN_STGm_SP_TREE_PORT52f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define VLAN_STGm_SP_TREE_PORT53f_GET(r) ((((r).vlan_stg[3]) >> 10) & 0x3)
#define VLAN_STGm_SP_TREE_PORT53f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define VLAN_STGm_SP_TREE_PORT54f_GET(r) ((((r).vlan_stg[3]) >> 12) & 0x3)
#define VLAN_STGm_SP_TREE_PORT54f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define VLAN_STGm_SP_TREE_PORT55f_GET(r) ((((r).vlan_stg[3]) >> 14) & 0x3)
#define VLAN_STGm_SP_TREE_PORT55f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define VLAN_STGm_SP_TREE_PORT56f_GET(r) ((((r).vlan_stg[3]) >> 16) & 0x3)
#define VLAN_STGm_SP_TREE_PORT56f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define VLAN_STGm_SP_TREE_PORT57f_GET(r) ((((r).vlan_stg[3]) >> 18) & 0x3)
#define VLAN_STGm_SP_TREE_PORT57f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define VLAN_STGm_SP_TREE_PORT58f_GET(r) ((((r).vlan_stg[3]) >> 20) & 0x3)
#define VLAN_STGm_SP_TREE_PORT58f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define VLAN_STGm_SP_TREE_PORT59f_GET(r) ((((r).vlan_stg[3]) >> 22) & 0x3)
#define VLAN_STGm_SP_TREE_PORT59f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define VLAN_STGm_SP_TREE_PORT60f_GET(r) ((((r).vlan_stg[3]) >> 24) & 0x3)
#define VLAN_STGm_SP_TREE_PORT60f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define VLAN_STGm_SP_TREE_PORT61f_GET(r) ((((r).vlan_stg[3]) >> 26) & 0x3)
#define VLAN_STGm_SP_TREE_PORT61f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define VLAN_STGm_SP_TREE_PORT62f_GET(r) ((((r).vlan_stg[3]) >> 28) & 0x3)
#define VLAN_STGm_SP_TREE_PORT62f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define VLAN_STGm_SP_TREE_PORT63f_GET(r) ((((r).vlan_stg[3]) >> 30) & 0x3)
#define VLAN_STGm_SP_TREE_PORT63f_SET(r,f) (r).vlan_stg[3]=(((r).vlan_stg[3] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define VLAN_STGm_SP_TREE_PORT64f_GET(r) (((r).vlan_stg[4]) & 0x3)
#define VLAN_STGm_SP_TREE_PORT64f_SET(r,f) (r).vlan_stg[4]=(((r).vlan_stg[4] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define VLAN_STGm_SP_TREE_PORT65f_GET(r) ((((r).vlan_stg[4]) >> 2) & 0x3)
#define VLAN_STGm_SP_TREE_PORT65f_SET(r,f) (r).vlan_stg[4]=(((r).vlan_stg[4] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define VLAN_STGm_EVEN_PARITYf_GET(r) ((((r).vlan_stg[4]) >> 4) & 0x1)
#define VLAN_STGm_EVEN_PARITYf_SET(r,f) (r).vlan_stg[4]=(((r).vlan_stg[4] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))

/*
 * These macros can be used to access VLAN_STG.
 */
#define WRITE_VLAN_STGm(u,i,r) bcm5607x_mem_set(u, M_VLAN_STG(i), &(r._vlan_stg), 5)
#define READ_VLAN_STGm(u,i,r) bcm5607x_mem_get(u, M_VLAN_STG(i), &(r._vlan_stg), 5)

/*******************************************************************************
 * End of 'VLAN_STGm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  VLAN_SUBNET_CAM_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_CONTROL 
 * SIZE:     64
 * FIELDS:
 *     BIST_EN          BIST enable for cam engine
 *     DEBUG_EN         Set to put cam engine into debug mode
 *     TM               TM debug bits
 */
#define VLAN_SUBNET_CAM_DBGCTRLr_SIZE 8

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_DBGCTRL.
 */
typedef union VLAN_SUBNET_CAM_DBGCTRLr_s {
	uint32 v[2];
	uint32 vlan_subnet_cam_dbgctrl[2];
	uint32 _vlan_subnet_cam_dbgctrl;
} VLAN_SUBNET_CAM_DBGCTRLr_t;

#define VLAN_SUBNET_CAM_DBGCTRLr_CLR(r) sal_memset(&((r)._vlan_subnet_cam_dbgctrl), 0, sizeof(VLAN_SUBNET_CAM_DBGCTRLr_t))
#define VLAN_SUBNET_CAM_DBGCTRLr_SET(r,i,d) (r).vlan_subnet_cam_dbgctrl[i] = d
#define VLAN_SUBNET_CAM_DBGCTRLr_GET(r,i) (r).vlan_subnet_cam_dbgctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define VLAN_SUBNET_CAM_DBGCTRLr_BIST_ENf_GET(r) (((r).vlan_subnet_cam_dbgctrl[0]) & 0xffff)
#define VLAN_SUBNET_CAM_DBGCTRLr_BIST_ENf_SET(r,f) (r).vlan_subnet_cam_dbgctrl[0]=(((r).vlan_subnet_cam_dbgctrl[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define VLAN_SUBNET_CAM_DBGCTRLr_DEBUG_ENf_GET(r) ((((r).vlan_subnet_cam_dbgctrl[0]) >> 16) & 0xffff)
#define VLAN_SUBNET_CAM_DBGCTRLr_DEBUG_ENf_SET(r,f) (r).vlan_subnet_cam_dbgctrl[0]=(((r).vlan_subnet_cam_dbgctrl[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))
#define VLAN_SUBNET_CAM_DBGCTRLr_TMf_GET(r) (((r).vlan_subnet_cam_dbgctrl[1]) & 0xffff)
#define VLAN_SUBNET_CAM_DBGCTRLr_TMf_SET(r,f) (r).vlan_subnet_cam_dbgctrl[1]=(((r).vlan_subnet_cam_dbgctrl[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_DBGCTRL.
 */
#define WRITE_VLAN_SUBNET_CAM_DBGCTRLr(u,r) bcm5607x_reg64_set(u,R_VLAN_SUBNET_CAM_DBGCTRL,&(r._vlan_subnet_cam_dbgctrl),2)
#define READ_VLAN_SUBNET_CAM_DBGCTRLr(u,r) bcm5607x_reg64_get(u,R_VLAN_SUBNET_CAM_DBGCTRL,&(r._vlan_subnet_cam_dbgctrl),2)

/*******************************************************************************
 * End of 'VLAN_SUBNET_CAM_DBGCTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  WRRWEIGHT_COS0
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS0r_SIZE 4

/* WRRWEIGHT_COS0r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS0.
 */
typedef union WRRWEIGHT_COS0r_s {
	uint32 v[1];
	uint32 wrrweight_cos0[1];
	uint32 _wrrweight_cos0;
} WRRWEIGHT_COS0r_t;

#define WRRWEIGHT_COS0r_CLR(r) (r).wrrweight_cos0[0] = 0
#define WRRWEIGHT_COS0r_SET(r,d) (r).wrrweight_cos0[0] = d
#define WRRWEIGHT_COS0r_GET(r) (r).wrrweight_cos0[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS0r_WEIGHTf_GET(r) (((r).wrrweight_cos0[0]) & 0x7f)
#define WRRWEIGHT_COS0r_WEIGHTf_SET(r,f) (r).wrrweight_cos0[0]=(((r).wrrweight_cos0[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS0r_ENABLEf_GET(r) ((((r).wrrweight_cos0[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS0r_ENABLEf_SET(r,f) (r).wrrweight_cos0[0]=(((r).wrrweight_cos0[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS0.
 */
#define WRITE_WRRWEIGHT_COS0r(u,p,r) bcm5607x_reg_set(u,R_WRRWEIGHT_COS0(p),(r._wrrweight_cos0))
#define READ_WRRWEIGHT_COS0r(u,p,r) bcm5607x_reg_get(u,R_WRRWEIGHT_COS0(p),&(r._wrrweight_cos0))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS0r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  WRRWEIGHT_COS1
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS1r_SIZE 4

/* WRRWEIGHT_COS1r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS1.
 */
typedef union WRRWEIGHT_COS1r_s {
	uint32 v[1];
	uint32 wrrweight_cos1[1];
	uint32 _wrrweight_cos1;
} WRRWEIGHT_COS1r_t;

#define WRRWEIGHT_COS1r_CLR(r) (r).wrrweight_cos1[0] = 0
#define WRRWEIGHT_COS1r_SET(r,d) (r).wrrweight_cos1[0] = d
#define WRRWEIGHT_COS1r_GET(r) (r).wrrweight_cos1[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS1r_WEIGHTf_GET(r) (((r).wrrweight_cos1[0]) & 0x7f)
#define WRRWEIGHT_COS1r_WEIGHTf_SET(r,f) (r).wrrweight_cos1[0]=(((r).wrrweight_cos1[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS1r_ENABLEf_GET(r) ((((r).wrrweight_cos1[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS1r_ENABLEf_SET(r,f) (r).wrrweight_cos1[0]=(((r).wrrweight_cos1[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS1.
 */
#define WRITE_WRRWEIGHT_COS1r(u,p,r) bcm5607x_reg_set(u,R_WRRWEIGHT_COS1(p),(r._wrrweight_cos1))
#define READ_WRRWEIGHT_COS1r(u,p,r) bcm5607x_reg_get(u,R_WRRWEIGHT_COS1(p),&(r._wrrweight_cos1))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS1r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  WRRWEIGHT_COS2
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS2r_SIZE 4

/* WRRWEIGHT_COS2r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS2.
 */
typedef union WRRWEIGHT_COS2r_s {
	uint32 v[1];
	uint32 wrrweight_cos2[1];
	uint32 _wrrweight_cos2;
} WRRWEIGHT_COS2r_t;

#define WRRWEIGHT_COS2r_CLR(r) (r).wrrweight_cos2[0] = 0
#define WRRWEIGHT_COS2r_SET(r,d) (r).wrrweight_cos2[0] = d
#define WRRWEIGHT_COS2r_GET(r) (r).wrrweight_cos2[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS2r_WEIGHTf_GET(r) (((r).wrrweight_cos2[0]) & 0x7f)
#define WRRWEIGHT_COS2r_WEIGHTf_SET(r,f) (r).wrrweight_cos2[0]=(((r).wrrweight_cos2[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS2r_ENABLEf_GET(r) ((((r).wrrweight_cos2[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS2r_ENABLEf_SET(r,f) (r).wrrweight_cos2[0]=(((r).wrrweight_cos2[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS2.
 */
#define WRITE_WRRWEIGHT_COS2r(u,p,r) bcm5607x_reg_set(u,R_WRRWEIGHT_COS2(p),(r._wrrweight_cos2))
#define READ_WRRWEIGHT_COS2r(u,p,r) bcm5607x_reg_get(u,R_WRRWEIGHT_COS2(p),&(r._wrrweight_cos2))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS2r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  WRRWEIGHT_COS3
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS3r_SIZE 4

/* WRRWEIGHT_COS3r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS3.
 */
typedef union WRRWEIGHT_COS3r_s {
	uint32 v[1];
	uint32 wrrweight_cos3[1];
	uint32 _wrrweight_cos3;
} WRRWEIGHT_COS3r_t;

#define WRRWEIGHT_COS3r_CLR(r) (r).wrrweight_cos3[0] = 0
#define WRRWEIGHT_COS3r_SET(r,d) (r).wrrweight_cos3[0] = d
#define WRRWEIGHT_COS3r_GET(r) (r).wrrweight_cos3[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS3r_WEIGHTf_GET(r) (((r).wrrweight_cos3[0]) & 0x7f)
#define WRRWEIGHT_COS3r_WEIGHTf_SET(r,f) (r).wrrweight_cos3[0]=(((r).wrrweight_cos3[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS3r_ENABLEf_GET(r) ((((r).wrrweight_cos3[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS3r_ENABLEf_SET(r,f) (r).wrrweight_cos3[0]=(((r).wrrweight_cos3[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS3.
 */
#define WRITE_WRRWEIGHT_COS3r(u,p,r) bcm5607x_reg_set(u,R_WRRWEIGHT_COS3(p),(r._wrrweight_cos3))
#define READ_WRRWEIGHT_COS3r(u,p,r) bcm5607x_reg_get(u,R_WRRWEIGHT_COS3(p),&(r._wrrweight_cos3))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS3r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  WRRWEIGHT_COS4
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS4r_SIZE 4

/* WRRWEIGHT_COS4r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS4.
 */
typedef union WRRWEIGHT_COS4r_s {
	uint32 v[1];
	uint32 wrrweight_cos4[1];
	uint32 _wrrweight_cos4;
} WRRWEIGHT_COS4r_t;

#define WRRWEIGHT_COS4r_CLR(r) (r).wrrweight_cos4[0] = 0
#define WRRWEIGHT_COS4r_SET(r,d) (r).wrrweight_cos4[0] = d
#define WRRWEIGHT_COS4r_GET(r) (r).wrrweight_cos4[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS4r_WEIGHTf_GET(r) (((r).wrrweight_cos4[0]) & 0x7f)
#define WRRWEIGHT_COS4r_WEIGHTf_SET(r,f) (r).wrrweight_cos4[0]=(((r).wrrweight_cos4[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS4r_ENABLEf_GET(r) ((((r).wrrweight_cos4[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS4r_ENABLEf_SET(r,f) (r).wrrweight_cos4[0]=(((r).wrrweight_cos4[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS4.
 */
#define WRITE_WRRWEIGHT_COS4r(u,p,r) bcm5607x_reg_set(u,R_WRRWEIGHT_COS4(p),(r._wrrweight_cos4))
#define READ_WRRWEIGHT_COS4r(u,p,r) bcm5607x_reg_get(u,R_WRRWEIGHT_COS4(p),&(r._wrrweight_cos4))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS4r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  WRRWEIGHT_COS5
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS5r_SIZE 4

/* WRRWEIGHT_COS5r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS5.
 */
typedef union WRRWEIGHT_COS5r_s {
	uint32 v[1];
	uint32 wrrweight_cos5[1];
	uint32 _wrrweight_cos5;
} WRRWEIGHT_COS5r_t;

#define WRRWEIGHT_COS5r_CLR(r) (r).wrrweight_cos5[0] = 0
#define WRRWEIGHT_COS5r_SET(r,d) (r).wrrweight_cos5[0] = d
#define WRRWEIGHT_COS5r_GET(r) (r).wrrweight_cos5[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS5r_WEIGHTf_GET(r) (((r).wrrweight_cos5[0]) & 0x7f)
#define WRRWEIGHT_COS5r_WEIGHTf_SET(r,f) (r).wrrweight_cos5[0]=(((r).wrrweight_cos5[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS5r_ENABLEf_GET(r) ((((r).wrrweight_cos5[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS5r_ENABLEf_SET(r,f) (r).wrrweight_cos5[0]=(((r).wrrweight_cos5[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS5.
 */
#define WRITE_WRRWEIGHT_COS5r(u,p,r) bcm5607x_reg_set(u,R_WRRWEIGHT_COS5(p),(r._wrrweight_cos5))
#define READ_WRRWEIGHT_COS5r(u,p,r) bcm5607x_reg_get(u,R_WRRWEIGHT_COS5(p),&(r._wrrweight_cos5))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS5r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  WRRWEIGHT_COS6
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS6r_SIZE 4

/* WRRWEIGHT_COS6r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS6.
 */
typedef union WRRWEIGHT_COS6r_s {
	uint32 v[1];
	uint32 wrrweight_cos6[1];
	uint32 _wrrweight_cos6;
} WRRWEIGHT_COS6r_t;

#define WRRWEIGHT_COS6r_CLR(r) (r).wrrweight_cos6[0] = 0
#define WRRWEIGHT_COS6r_SET(r,d) (r).wrrweight_cos6[0] = d
#define WRRWEIGHT_COS6r_GET(r) (r).wrrweight_cos6[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS6r_WEIGHTf_GET(r) (((r).wrrweight_cos6[0]) & 0x7f)
#define WRRWEIGHT_COS6r_WEIGHTf_SET(r,f) (r).wrrweight_cos6[0]=(((r).wrrweight_cos6[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS6r_ENABLEf_GET(r) ((((r).wrrweight_cos6[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS6r_ENABLEf_SET(r,f) (r).wrrweight_cos6[0]=(((r).wrrweight_cos6[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS6.
 */
#define WRITE_WRRWEIGHT_COS6r(u,p,r) bcm5607x_reg_set(u,R_WRRWEIGHT_COS6(p),(r._wrrweight_cos6))
#define READ_WRRWEIGHT_COS6r(u,p,r) bcm5607x_reg_get(u,R_WRRWEIGHT_COS6(p),&(r._wrrweight_cos6))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS6r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  WRRWEIGHT_COS7
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS7r_SIZE 4

/* WRRWEIGHT_COS7r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS7.
 */
typedef union WRRWEIGHT_COS7r_s {
	uint32 v[1];
	uint32 wrrweight_cos7[1];
	uint32 _wrrweight_cos7;
} WRRWEIGHT_COS7r_t;

#define WRRWEIGHT_COS7r_CLR(r) (r).wrrweight_cos7[0] = 0
#define WRRWEIGHT_COS7r_SET(r,d) (r).wrrweight_cos7[0] = d
#define WRRWEIGHT_COS7r_GET(r) (r).wrrweight_cos7[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS7r_WEIGHTf_GET(r) (((r).wrrweight_cos7[0]) & 0x7f)
#define WRRWEIGHT_COS7r_WEIGHTf_SET(r,f) (r).wrrweight_cos7[0]=(((r).wrrweight_cos7[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS7r_ENABLEf_GET(r) ((((r).wrrweight_cos7[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS7r_ENABLEf_SET(r,f) (r).wrrweight_cos7[0]=(((r).wrrweight_cos7[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS7.
 */
#define WRITE_WRRWEIGHT_COS7r(u,p,r) bcm5607x_reg_set(u,R_WRRWEIGHT_COS7(p),(r._wrrweight_cos7))
#define READ_WRRWEIGHT_COS7r(u,p,r) bcm5607x_reg_get(u,R_WRRWEIGHT_COS7(p),&(r._wrrweight_cos7))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS7r'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  WRRWEIGHT_COS_QLAYER
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS_QLAYERr_SIZE 4

/*
 * This structure should be used to declare and program WRRWEIGHT_COS_QLAYER.
 */
typedef union WRRWEIGHT_COS_QLAYERr_s {
	uint32 v[1];
	uint32 wrrweight_cos_qlayer[1];
	uint32 _wrrweight_cos_qlayer;
} WRRWEIGHT_COS_QLAYERr_t;

#define WRRWEIGHT_COS_QLAYERr_CLR(r) (r).wrrweight_cos_qlayer[0] = 0
#define WRRWEIGHT_COS_QLAYERr_SET(r,d) (r).wrrweight_cos_qlayer[0] = d
#define WRRWEIGHT_COS_QLAYERr_GET(r) (r).wrrweight_cos_qlayer[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS_QLAYERr_WEIGHTf_GET(r) (((r).wrrweight_cos_qlayer[0]) & 0x7f)
#define WRRWEIGHT_COS_QLAYERr_WEIGHTf_SET(r,f) (r).wrrweight_cos_qlayer[0]=(((r).wrrweight_cos_qlayer[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS_QLAYERr_ENABLEf_GET(r) ((((r).wrrweight_cos_qlayer[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS_QLAYERr_ENABLEf_SET(r,f) (r).wrrweight_cos_qlayer[0]=(((r).wrrweight_cos_qlayer[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS_QLAYER.
 */
#define WRITE_WRRWEIGHT_COS_QLAYERr(u,p, cos,r) bcm5607x_reg_set(u, R_WRRWEIGHT_COS_QLAYER(cos,p), (r._wrrweight_cos_qlayer))
#define READ_WRRWEIGHT_COS_QLAYERr(u,p, cos,r) bcm5607x_reg_get(u,R_WRRWEIGHT_COS_QLAYER(cos,p),&(r._wrrweight_cos_qlayer))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS_QLAYERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_CTRL
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     MAC control.
 * SIZE:     64
 * FIELDS:
 *     TX_EN            If set, enables MAC transmit datapath and flowcontrol logic. When disabled, MAC will respond to TSC credits with IDLE codewords.
 *     RX_EN            If set, enables MAC receive datapath and flowcontrol logic.
 *     LOCAL_LPBK       If set, enables local loopback from TX to RX. This loopback is on the line side after clock domain crossing - from the last TX pipeline stage to the first RX pipeline stage. Hence, TSC clock and TSC credits must be active for loopback. LAG_FAILOVER_EN should be disabled for this bit to work. 
 *     RSVD_1            Reserved
 *     REMOVE_FAILOVER_LPBK If set, XLMAC will move from lag failover state to normal operation. This bit should be set after link is up.
 *     LAG_FAILOVER_EN  If set, enable LAG Failover. This bit has priority over LOCAL_LPBK. The lag failover kicks in when the link status selected by LINK_STATUS_SELECT transitions from 1 to 0. TSC clock and TSC credits must be active for lag failover. 
 *     SOFT_RESET       If set, disables the corresponding port logic and status registers only. Packet data and flow control logic is disabled. Fault handling is active and the MAC will continue to respond to credits from TSC. When the soft reset is cleared MAC will issue a fresh set of credits to EP in transmit side.
 *     RSVD_4           Reserved
 *     LOCAL_LPBK_LEAK_ENB If set, during the local loopback mode, the transmit packets are also sent to the transmit line interface, apart from the loopback operation
 *     RSVD_5           Reserved
 *     RS_SOFT_RESET    Resets the RS layer functionality - Fault detection and related responses are disabled and IDLEs are sent on line 
 *     XGMII_IPG_CHECK_DISABLE If set, this will override the one column idle/sequence ordered set check before SOP in XGMII mode - effectively supporting  reception of packets with 1 byte IPG in XGMII mode
 *     SW_LINK_STATUS   Link status indication from Software. If set, indicates that link is active.
 *     LINK_STATUS_SELECT This configuration chooses between link status indication from software (SW_LINK_STATUS) or the hardware link status (hw_link_status)indication from the TSC. If reset, it selects the software link status
 *     EXTENDED_HIG2_EN Extended Higig 2 header is also known as sirius header. Setting this bit to 0 will disable parsing for the extended header bit(5th bit of 8th header byte) in HG2 header and hence all the Higig 2 packets will be treated as normal Higig2 packets irrespective of extended header bit value. Default value of this field is 1 which will enable parsing extended header bit in every Higig 2 header.
 */
#define XLMAC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_CTRL.
 */
typedef union XLMAC_CTRLr_s {
	uint32 v[2];
	uint32 xlmac_ctrl[2];
	uint32 _xlmac_ctrl;
} XLMAC_CTRLr_t;

#define XLMAC_CTRLr_CLR(r) sal_memset(&((r)._xlmac_ctrl), 0, sizeof(XLMAC_CTRLr_t))
#define XLMAC_CTRLr_SET(r,i,d) (r).xlmac_ctrl[i] = d
#define XLMAC_CTRLr_GET(r,i) (r).xlmac_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_CTRLr_TX_ENf_GET(r) (((r).xlmac_ctrl[0]) & 0x1)
#define XLMAC_CTRLr_TX_ENf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLMAC_CTRLr_RX_ENf_GET(r) ((((r).xlmac_ctrl[0]) >> 1) & 0x1)
#define XLMAC_CTRLr_RX_ENf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define XLMAC_CTRLr_LOCAL_LPBKf_GET(r) ((((r).xlmac_ctrl[0]) >> 2) & 0x1)
#define XLMAC_CTRLr_LOCAL_LPBKf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define XLMAC_CTRLr_RSVD_1f_GET(r) ((((r).xlmac_ctrl[0]) >> 3) & 0x1)
#define XLMAC_CTRLr_RSVD_1f_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define XLMAC_CTRLr_REMOVE_FAILOVER_LPBKf_GET(r) ((((r).xlmac_ctrl[0]) >> 4) & 0x1)
#define XLMAC_CTRLr_REMOVE_FAILOVER_LPBKf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define XLMAC_CTRLr_LAG_FAILOVER_ENf_GET(r) ((((r).xlmac_ctrl[0]) >> 5) & 0x1)
#define XLMAC_CTRLr_LAG_FAILOVER_ENf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define XLMAC_CTRLr_SOFT_RESETf_GET(r) ((((r).xlmac_ctrl[0]) >> 6) & 0x1)
#define XLMAC_CTRLr_SOFT_RESETf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define XLMAC_CTRLr_RSVD_4f_GET(r) ((((r).xlmac_ctrl[0]) >> 7) & 0x1)
#define XLMAC_CTRLr_RSVD_4f_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define XLMAC_CTRLr_LOCAL_LPBK_LEAK_ENBf_GET(r) ((((r).xlmac_ctrl[0]) >> 8) & 0x1)
#define XLMAC_CTRLr_LOCAL_LPBK_LEAK_ENBf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define XLMAC_CTRLr_RSVD_5f_GET(r) ((((r).xlmac_ctrl[0]) >> 9) & 0x1)
#define XLMAC_CTRLr_RSVD_5f_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define XLMAC_CTRLr_RS_SOFT_RESETf_GET(r) ((((r).xlmac_ctrl[0]) >> 10) & 0x1)
#define XLMAC_CTRLr_RS_SOFT_RESETf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define XLMAC_CTRLr_XGMII_IPG_CHECK_DISABLEf_GET(r) ((((r).xlmac_ctrl[0]) >> 11) & 0x1)
#define XLMAC_CTRLr_XGMII_IPG_CHECK_DISABLEf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define XLMAC_CTRLr_SW_LINK_STATUSf_GET(r) ((((r).xlmac_ctrl[0]) >> 12) & 0x1)
#define XLMAC_CTRLr_SW_LINK_STATUSf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define XLMAC_CTRLr_LINK_STATUS_SELECTf_GET(r) ((((r).xlmac_ctrl[0]) >> 13) & 0x1)
#define XLMAC_CTRLr_LINK_STATUS_SELECTf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define XLMAC_CTRLr_EXTENDED_HIG2_ENf_GET(r) ((((r).xlmac_ctrl[0]) >> 14) & 0x1)
#define XLMAC_CTRLr_EXTENDED_HIG2_ENf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))

/*
 * These macros can be used to access XLMAC_CTRL.
 */
#define WRITE_XLMAC_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_ctrl),2)
#define READ_XLMAC_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_ctrl),2)

/*******************************************************************************
 * End of 'XLMAC_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_EEE_CTRL
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Register for EEE Control 
 * SIZE:     64
 * FIELDS:
 *     EEE_EN           When set, enables EEE state machine in the transmit direction and LPI detection/prediction in the receive direction 
 *     RSVD             Reserved
 */
#define XLMAC_EEE_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_EEE_CTRL.
 */
typedef union XLMAC_EEE_CTRLr_s {
	uint32 v[2];
	uint32 xlmac_eee_ctrl[2];
	uint32 _xlmac_eee_ctrl;
} XLMAC_EEE_CTRLr_t;

#define XLMAC_EEE_CTRLr_CLR(r) sal_memset(&((r)._xlmac_eee_ctrl), 0, sizeof(XLMAC_EEE_CTRLr_t))
#define XLMAC_EEE_CTRLr_SET(r,i,d) (r).xlmac_eee_ctrl[i] = d
#define XLMAC_EEE_CTRLr_GET(r,i) (r).xlmac_eee_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_EEE_CTRLr_EEE_ENf_GET(r) (((r).xlmac_eee_ctrl[0]) & 0x1)
#define XLMAC_EEE_CTRLr_EEE_ENf_SET(r,f) (r).xlmac_eee_ctrl[0]=(((r).xlmac_eee_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLMAC_EEE_CTRLr_RSVDf_GET(r) ((((r).xlmac_eee_ctrl[0]) >> 1) & 0x1)
#define XLMAC_EEE_CTRLr_RSVDf_SET(r,f) (r).xlmac_eee_ctrl[0]=(((r).xlmac_eee_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access XLMAC_EEE_CTRL.
 */
#define WRITE_XLMAC_EEE_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_EEE_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_eee_ctrl),2)
#define READ_XLMAC_EEE_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_EEE_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_eee_ctrl),2)

/*******************************************************************************
 * End of 'XLMAC_EEE_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_EEE_TIMERS
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     EEE Timers
 * SIZE:     64
 * FIELDS:
 *     EEE_DELAY_ENTRY_TIMER This is the duration for which the MAC must wait in EMPTY state before transitioning to LPI state. Unit is micro seconds 
 *     XLMAC_EEE_TIMERS_LO 32 lower bits of the EEE Timer
 *     XLMAC_EEE_TIMERS_HI 32 upper bits of the EEE timer register  
 *     EEE_WAKE_TIMER   This is the duration for which MAC must wait to go back to ACTIVE state from LPI state when it receives packet/flow-control frames for transmission. Unit is micro seconds 
 *     EEE_REF_COUNT    This field controls clock divider used to generate ~1us reference pulses used by EEE timers. It specifies integer number of clock cycles for 1us reference using tsc_clk
 */
#define XLMAC_EEE_TIMERSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_EEE_TIMERS.
 */
typedef union XLMAC_EEE_TIMERSr_s {
	uint32 v[2];
	uint32 xlmac_eee_timers[2];
	uint32 _xlmac_eee_timers;
} XLMAC_EEE_TIMERSr_t;

#define XLMAC_EEE_TIMERSr_CLR(r) sal_memset(&((r)._xlmac_eee_timers), 0, sizeof(XLMAC_EEE_TIMERSr_t))
#define XLMAC_EEE_TIMERSr_SET(r,i,d) (r).xlmac_eee_timers[i] = d
#define XLMAC_EEE_TIMERSr_GET(r,i) (r).xlmac_eee_timers[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_EEE_TIMERSr_EEE_DELAY_ENTRY_TIMERf_GET(r) ((r).xlmac_eee_timers[0])
#define XLMAC_EEE_TIMERSr_EEE_DELAY_ENTRY_TIMERf_SET(r,f) (r).xlmac_eee_timers[0]=((uint32)f)
#define XLMAC_EEE_TIMERSr_XLMAC_EEE_TIMERS_LOf_GET(r) ((r).xlmac_eee_timers[0])
#define XLMAC_EEE_TIMERSr_XLMAC_EEE_TIMERS_LOf_SET(r,f) (r).xlmac_eee_timers[0]=((uint32)f)
#define XLMAC_EEE_TIMERSr_XLMAC_EEE_TIMERS_HIf_GET(r) ((r).xlmac_eee_timers[1])
#define XLMAC_EEE_TIMERSr_XLMAC_EEE_TIMERS_HIf_SET(r,f) (r).xlmac_eee_timers[1]=((uint32)f)
#define XLMAC_EEE_TIMERSr_EEE_WAKE_TIMERf_GET(r) (((r).xlmac_eee_timers[1]) & 0xffff)
#define XLMAC_EEE_TIMERSr_EEE_WAKE_TIMERf_SET(r,f) (r).xlmac_eee_timers[1]=(((r).xlmac_eee_timers[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define XLMAC_EEE_TIMERSr_EEE_REF_COUNTf_GET(r) ((((r).xlmac_eee_timers[1]) >> 16) & 0xffff)
#define XLMAC_EEE_TIMERSr_EEE_REF_COUNTf_SET(r,f) (r).xlmac_eee_timers[1]=(((r).xlmac_eee_timers[1] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access XLMAC_EEE_TIMERS.
 */
#define WRITE_XLMAC_EEE_TIMERSr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_EEE_TIMERS(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_eee_timers),2)
#define READ_XLMAC_EEE_TIMERSr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_EEE_TIMERS(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_eee_timers),2)

/*******************************************************************************
 * End of 'XLMAC_EEE_TIMERSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_LLFC_CTRL
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     LLFC Control Register
 * SIZE:     64
 * FIELDS:
 *     TX_LLFC_EN       When set, enables the generation and transmission of LLFC frames in the transmit direction
 *     RX_LLFC_EN       When set, enables processing of LLFC frames in the receive direction and generation of COSMAPs to MMU
 *     LLFC_IN_IPG_ONLY When set, all LLFC messages are transmitted during IPGWhen reset, the mode of insertion of LLFC messages is controlled by LLFC_CUT_THROUGH_MODE
 *     LLFC_CUT_THROUGH_MODE When LLFC_IN_IPG_ONLY is reset, the mode of transmission of LLFC messages is controlled by this bit depending upon whether the LLFC message is XON or XOFFWhen LLFC_CUT_THROUGH_MODE is reset, all LLFC messages are transmitted pre-emptively (within a packet)When LLFC_CUT_THROUGH_MODE is set, only XOFF LLFC messages are transmitted pre-emptively, XON LLFC messages are transmitted during IPG
 *     LLFC_CRC_IGNORE  When set, disables the CRC check for LLFC messages in the receive direction
 *     NO_SOM_FOR_CRC_LLFC When set, LLFC CRC computation does not include the SOM character
 *     LLFC_IMG         This field indicates the minimum Inter Message Gap that is enforced by the MAC between 2 LLFC messages in the transmit direction (unit is 1 credit)
 */
#define XLMAC_LLFC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_LLFC_CTRL.
 */
typedef union XLMAC_LLFC_CTRLr_s {
	uint32 v[2];
	uint32 xlmac_llfc_ctrl[2];
	uint32 _xlmac_llfc_ctrl;
} XLMAC_LLFC_CTRLr_t;

#define XLMAC_LLFC_CTRLr_CLR(r) sal_memset(&((r)._xlmac_llfc_ctrl), 0, sizeof(XLMAC_LLFC_CTRLr_t))
#define XLMAC_LLFC_CTRLr_SET(r,i,d) (r).xlmac_llfc_ctrl[i] = d
#define XLMAC_LLFC_CTRLr_GET(r,i) (r).xlmac_llfc_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_LLFC_CTRLr_TX_LLFC_ENf_GET(r) (((r).xlmac_llfc_ctrl[0]) & 0x1)
#define XLMAC_LLFC_CTRLr_TX_LLFC_ENf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLMAC_LLFC_CTRLr_RX_LLFC_ENf_GET(r) ((((r).xlmac_llfc_ctrl[0]) >> 1) & 0x1)
#define XLMAC_LLFC_CTRLr_RX_LLFC_ENf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define XLMAC_LLFC_CTRLr_LLFC_IN_IPG_ONLYf_GET(r) ((((r).xlmac_llfc_ctrl[0]) >> 2) & 0x1)
#define XLMAC_LLFC_CTRLr_LLFC_IN_IPG_ONLYf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define XLMAC_LLFC_CTRLr_LLFC_CUT_THROUGH_MODEf_GET(r) ((((r).xlmac_llfc_ctrl[0]) >> 3) & 0x1)
#define XLMAC_LLFC_CTRLr_LLFC_CUT_THROUGH_MODEf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define XLMAC_LLFC_CTRLr_LLFC_CRC_IGNOREf_GET(r) ((((r).xlmac_llfc_ctrl[0]) >> 4) & 0x1)
#define XLMAC_LLFC_CTRLr_LLFC_CRC_IGNOREf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define XLMAC_LLFC_CTRLr_NO_SOM_FOR_CRC_LLFCf_GET(r) ((((r).xlmac_llfc_ctrl[0]) >> 5) & 0x1)
#define XLMAC_LLFC_CTRLr_NO_SOM_FOR_CRC_LLFCf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define XLMAC_LLFC_CTRLr_LLFC_IMGf_GET(r) ((((r).xlmac_llfc_ctrl[0]) >> 6) & 0xff)
#define XLMAC_LLFC_CTRLr_LLFC_IMGf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))

/*
 * These macros can be used to access XLMAC_LLFC_CTRL.
 */
#define WRITE_XLMAC_LLFC_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_LLFC_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_llfc_ctrl),2)
#define READ_XLMAC_LLFC_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_LLFC_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_llfc_ctrl),2)

/*******************************************************************************
 * End of 'XLMAC_LLFC_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_MODE
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     XLMAC Mode register
 * SIZE:     64
 * FIELDS:
 *     HDR_MODE         Packet Header mode.
 *     NO_SOP_FOR_CRC_HG If set, excludes the SOP byte for CRC calculation in HIGIG modes
 *     SPEED_MODE       Port Speed, used for LED indications and internal buffer sizing.
 */
#define XLMAC_MODEr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_MODE.
 */
typedef union XLMAC_MODEr_s {
	uint32 v[2];
	uint32 xlmac_mode[2];
	uint32 _xlmac_mode;
} XLMAC_MODEr_t;

#define XLMAC_MODEr_CLR(r) sal_memset(&((r)._xlmac_mode), 0, sizeof(XLMAC_MODEr_t))
#define XLMAC_MODEr_SET(r,i,d) (r).xlmac_mode[i] = d
#define XLMAC_MODEr_GET(r,i) (r).xlmac_mode[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_MODEr_HDR_MODEf_GET(r) (((r).xlmac_mode[0]) & 0x7)
#define XLMAC_MODEr_HDR_MODEf_SET(r,f) (r).xlmac_mode[0]=(((r).xlmac_mode[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define XLMAC_MODEr_NO_SOP_FOR_CRC_HGf_GET(r) ((((r).xlmac_mode[0]) >> 3) & 0x1)
#define XLMAC_MODEr_NO_SOP_FOR_CRC_HGf_SET(r,f) (r).xlmac_mode[0]=(((r).xlmac_mode[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define XLMAC_MODEr_SPEED_MODEf_GET(r) ((((r).xlmac_mode[0]) >> 4) & 0x7)
#define XLMAC_MODEr_SPEED_MODEf_SET(r,f) (r).xlmac_mode[0]=(((r).xlmac_mode[0] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))

/*
 * These macros can be used to access XLMAC_MODE.
 */
#define WRITE_XLMAC_MODEr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_MODE(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_mode),2)
#define READ_XLMAC_MODEr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_MODE(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_mode),2)

/*******************************************************************************
 * End of 'XLMAC_MODEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_PAUSE_CTRL
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     PAUSE control register
 * SIZE:     64
 * FIELDS:
 *     XLMAC_PAUSE_CTRL_LO 32 lower bits of the XLMAC Pause CTRL register
 *     PAUSE_REFRESH_TIMER This field specifies the interval at which pause frames are re-generated during XOFF state, provided PAUSE_REFRESH_EN is set (unit is 512 bit-times)
 *     PAUSE_REFRESH_EN When set, enables the periodic re-generation of XOFF pause frames based on the interval specified in PAUSE_REFRESH_TIMER
 *     TX_PAUSE_EN      When set, enables the transmission of pause frames whenever there is a transition on txbkp input to MAC from MMU
 *     RX_PAUSE_EN      When set, enables detection of pause frames in the receive direction and pause/resume the transmit data path
 *     RSVD_1           Reserved
 *     RSVD_2           Reserved
 *     PAUSE_XOFF_TIMER Pause time value sent in the timer field for XOFF state (unit is 512 bit-times)
 *     XLMAC_PAUSE_CTRL_HI 5 upper bits of the XLMAC Pause CTRL register
 */
#define XLMAC_PAUSE_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_PAUSE_CTRL.
 */
typedef union XLMAC_PAUSE_CTRLr_s {
	uint32 v[2];
	uint32 xlmac_pause_ctrl[2];
	uint32 _xlmac_pause_ctrl;
} XLMAC_PAUSE_CTRLr_t;

#define XLMAC_PAUSE_CTRLr_CLR(r) sal_memset(&((r)._xlmac_pause_ctrl), 0, sizeof(XLMAC_PAUSE_CTRLr_t))
#define XLMAC_PAUSE_CTRLr_SET(r,i,d) (r).xlmac_pause_ctrl[i] = d
#define XLMAC_PAUSE_CTRLr_GET(r,i) (r).xlmac_pause_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_PAUSE_CTRLr_XLMAC_PAUSE_CTRL_LOf_GET(r) ((r).xlmac_pause_ctrl[0])
#define XLMAC_PAUSE_CTRLr_XLMAC_PAUSE_CTRL_LOf_SET(r,f) (r).xlmac_pause_ctrl[0]=((uint32)f)
#define XLMAC_PAUSE_CTRLr_PAUSE_REFRESH_TIMERf_GET(r) (((r).xlmac_pause_ctrl[0]) & 0xffff)
#define XLMAC_PAUSE_CTRLr_PAUSE_REFRESH_TIMERf_SET(r,f) (r).xlmac_pause_ctrl[0]=(((r).xlmac_pause_ctrl[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define XLMAC_PAUSE_CTRLr_PAUSE_REFRESH_ENf_GET(r) ((((r).xlmac_pause_ctrl[0]) >> 16) & 0x1)
#define XLMAC_PAUSE_CTRLr_PAUSE_REFRESH_ENf_SET(r,f) (r).xlmac_pause_ctrl[0]=(((r).xlmac_pause_ctrl[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define XLMAC_PAUSE_CTRLr_TX_PAUSE_ENf_GET(r) ((((r).xlmac_pause_ctrl[0]) >> 17) & 0x1)
#define XLMAC_PAUSE_CTRLr_TX_PAUSE_ENf_SET(r,f) (r).xlmac_pause_ctrl[0]=(((r).xlmac_pause_ctrl[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define XLMAC_PAUSE_CTRLr_RX_PAUSE_ENf_GET(r) ((((r).xlmac_pause_ctrl[0]) >> 18) & 0x1)
#define XLMAC_PAUSE_CTRLr_RX_PAUSE_ENf_SET(r,f) (r).xlmac_pause_ctrl[0]=(((r).xlmac_pause_ctrl[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define XLMAC_PAUSE_CTRLr_RSVD_1f_GET(r) ((((r).xlmac_pause_ctrl[0]) >> 19) & 0x1)
#define XLMAC_PAUSE_CTRLr_RSVD_1f_SET(r,f) (r).xlmac_pause_ctrl[0]=(((r).xlmac_pause_ctrl[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define XLMAC_PAUSE_CTRLr_RSVD_2f_GET(r) ((((r).xlmac_pause_ctrl[0]) >> 20) & 0x1)
#define XLMAC_PAUSE_CTRLr_RSVD_2f_SET(r,f) (r).xlmac_pause_ctrl[0]=(((r).xlmac_pause_ctrl[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define XLMAC_PAUSE_CTRLr_PAUSE_XOFF_TIMERf_GET(r) field32_get((r).xlmac_pause_ctrl,21,36)
#define XLMAC_PAUSE_CTRLr_PAUSE_XOFF_TIMERf_SET(r,f) field32_set((r).xlmac_pause_ctrl,21,36,f)
#define XLMAC_PAUSE_CTRLr_XLMAC_PAUSE_CTRL_HIf_GET(r) (((r).xlmac_pause_ctrl[1]) & 0x1f)
#define XLMAC_PAUSE_CTRLr_XLMAC_PAUSE_CTRL_HIf_SET(r,f) (r).xlmac_pause_ctrl[1]=(((r).xlmac_pause_ctrl[1] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))

/*
 * These macros can be used to access XLMAC_PAUSE_CTRL.
 */
#define WRITE_XLMAC_PAUSE_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_PAUSE_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_pause_ctrl),2)
#define READ_XLMAC_PAUSE_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_PAUSE_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_pause_ctrl),2)

/*******************************************************************************
 * End of 'XLMAC_PAUSE_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_PFC_CTRL
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     PFC control register
 * SIZE:     64
 * FIELDS:
 *     LLFC_REFRESH_TIMER This field specifies the interval at which LLFC frames are re-generated for a class of service in XOFF state, provided LLFC_REFRESH_EN is set (unit is 512 bit-times)
 *     PFC_REFRESH_TIMER This field specifies the interval at which PFC frames are re-generated for a class of service in XOFF state, provided PFC_REFRESH_EN is set (unit is 512 bit-times)
 *     PFC_XOFF_TIMER   Pause time value sent in the timer field for classes in XOFF state (unit is 512 bit-times)
 *     LLFC_REFRESH_EN  When set, enables the periodic re-generation of LLFC frames based on the interval specified in LLFC_REFRESH_TIMER
 *     PFC_REFRESH_EN   When set, enables the periodic re-generation of PFC frames based on the interval specified in PFC_REFRESH_TIMER
 *     FORCE_PFC_XON    When set, forces the MAC to generate an XON indication to the MMU for all classes of service in the receive direction
 *     RSVD             Reserved
 *     PFC_STATS_EN     When set, enables the generation of receive and transmit PFC events into the corresponding statistics vectors (RSV and TSV)
 *     RX_PFC_EN        When set, enables detection of PFC frames in the receive direction and generation of COSMAPs to MMU based on incoming timer values
 *     TX_PFC_EN        When set, enables the transmission of PFC frames
 */
#define XLMAC_PFC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_PFC_CTRL.
 */
typedef union XLMAC_PFC_CTRLr_s {
	uint32 v[2];
	uint32 xlmac_pfc_ctrl[2];
	uint32 _xlmac_pfc_ctrl;
} XLMAC_PFC_CTRLr_t;

#define XLMAC_PFC_CTRLr_CLR(r) sal_memset(&((r)._xlmac_pfc_ctrl), 0, sizeof(XLMAC_PFC_CTRLr_t))
#define XLMAC_PFC_CTRLr_SET(r,i,d) (r).xlmac_pfc_ctrl[i] = d
#define XLMAC_PFC_CTRLr_GET(r,i) (r).xlmac_pfc_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_PFC_CTRLr_LLFC_REFRESH_TIMERf_GET(r) (((r).xlmac_pfc_ctrl[0]) & 0xffff)
#define XLMAC_PFC_CTRLr_LLFC_REFRESH_TIMERf_SET(r,f) (r).xlmac_pfc_ctrl[0]=(((r).xlmac_pfc_ctrl[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define XLMAC_PFC_CTRLr_PFC_REFRESH_TIMERf_GET(r) (((r).xlmac_pfc_ctrl[0]) & 0xffff)
#define XLMAC_PFC_CTRLr_PFC_REFRESH_TIMERf_SET(r,f) (r).xlmac_pfc_ctrl[0]=(((r).xlmac_pfc_ctrl[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define XLMAC_PFC_CTRLr_PFC_XOFF_TIMERf_GET(r) ((((r).xlmac_pfc_ctrl[0]) >> 16) & 0xffff)
#define XLMAC_PFC_CTRLr_PFC_XOFF_TIMERf_SET(r,f) (r).xlmac_pfc_ctrl[0]=(((r).xlmac_pfc_ctrl[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))
#define XLMAC_PFC_CTRLr_LLFC_REFRESH_ENf_GET(r) (((r).xlmac_pfc_ctrl[1]) & 0x1)
#define XLMAC_PFC_CTRLr_LLFC_REFRESH_ENf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLMAC_PFC_CTRLr_PFC_REFRESH_ENf_GET(r) (((r).xlmac_pfc_ctrl[1]) & 0x1)
#define XLMAC_PFC_CTRLr_PFC_REFRESH_ENf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLMAC_PFC_CTRLr_FORCE_PFC_XONf_GET(r) ((((r).xlmac_pfc_ctrl[1]) >> 1) & 0x1)
#define XLMAC_PFC_CTRLr_FORCE_PFC_XONf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define XLMAC_PFC_CTRLr_RSVDf_GET(r) ((((r).xlmac_pfc_ctrl[1]) >> 2) & 0x1)
#define XLMAC_PFC_CTRLr_RSVDf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define XLMAC_PFC_CTRLr_PFC_STATS_ENf_GET(r) ((((r).xlmac_pfc_ctrl[1]) >> 3) & 0x1)
#define XLMAC_PFC_CTRLr_PFC_STATS_ENf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define XLMAC_PFC_CTRLr_RX_PFC_ENf_GET(r) ((((r).xlmac_pfc_ctrl[1]) >> 4) & 0x1)
#define XLMAC_PFC_CTRLr_RX_PFC_ENf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define XLMAC_PFC_CTRLr_TX_PFC_ENf_GET(r) ((((r).xlmac_pfc_ctrl[1]) >> 5) & 0x1)
#define XLMAC_PFC_CTRLr_TX_PFC_ENf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))

/*
 * These macros can be used to access XLMAC_PFC_CTRL.
 */
#define WRITE_XLMAC_PFC_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_PFC_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_pfc_ctrl),2)
#define READ_XLMAC_PFC_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_PFC_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_pfc_ctrl),2)

/*******************************************************************************
 * End of 'XLMAC_PFC_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_PFC_DA
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     PFC Destination Address.
 * SIZE:     64
 * FIELDS:
 *     PFC_MACDA        This field is used in the destination-address field of the PFC frame that is generated and transmitted by the MAC and also used for detection in the receive direction
 *     PFC_MACDA_LO     32 lower bits of the PFC DA 
 *     PFC_MACDA_HI     16 upper bits of the PFC DA 
 */
#define XLMAC_PFC_DAr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_PFC_DA.
 */
typedef union XLMAC_PFC_DAr_s {
	uint32 v[2];
	uint32 xlmac_pfc_da[2];
	uint32 _xlmac_pfc_da;
} XLMAC_PFC_DAr_t;

#define XLMAC_PFC_DAr_CLR(r) sal_memset(&((r)._xlmac_pfc_da), 0, sizeof(XLMAC_PFC_DAr_t))
#define XLMAC_PFC_DAr_SET(r,i,d) (r).xlmac_pfc_da[i] = d
#define XLMAC_PFC_DAr_GET(r,i) (r).xlmac_pfc_da[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_PFC_DAr_PFC_MACDAf_GET(r,a) field_get((r).xlmac_pfc_da,0,47,a)
#define XLMAC_PFC_DAr_PFC_MACDAf_SET(r,a) field_set((r).xlmac_pfc_da,0,47,a)
#define XLMAC_PFC_DAr_PFC_MACDA_LOf_GET(r) ((r).xlmac_pfc_da[0])
#define XLMAC_PFC_DAr_PFC_MACDA_LOf_SET(r,f) (r).xlmac_pfc_da[0]=((uint32)f)
#define XLMAC_PFC_DAr_PFC_MACDA_HIf_GET(r) (((r).xlmac_pfc_da[1]) & 0xffff)
#define XLMAC_PFC_DAr_PFC_MACDA_HIf_SET(r,f) (r).xlmac_pfc_da[1]=(((r).xlmac_pfc_da[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access XLMAC_PFC_DA.
 */
#define WRITE_XLMAC_PFC_DAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_PFC_DA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_pfc_da),2)
#define READ_XLMAC_PFC_DAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_PFC_DA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_pfc_da),2)

/*******************************************************************************
 * End of 'XLMAC_PFC_DAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_PFC_OPCODE
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     PFC Opcode
 * SIZE:     64
 * FIELDS:
 *     PFC_OPCODE       This field is used in the OPCODE field of the PFC frame that is generated and transmitted by the MAC and also used for detection in the receive direction
 */
#define XLMAC_PFC_OPCODEr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_PFC_OPCODE.
 */
typedef union XLMAC_PFC_OPCODEr_s {
	uint32 v[2];
	uint32 xlmac_pfc_opcode[2];
	uint32 _xlmac_pfc_opcode;
} XLMAC_PFC_OPCODEr_t;

#define XLMAC_PFC_OPCODEr_CLR(r) sal_memset(&((r)._xlmac_pfc_opcode), 0, sizeof(XLMAC_PFC_OPCODEr_t))
#define XLMAC_PFC_OPCODEr_SET(r,i,d) (r).xlmac_pfc_opcode[i] = d
#define XLMAC_PFC_OPCODEr_GET(r,i) (r).xlmac_pfc_opcode[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_PFC_OPCODEr_PFC_OPCODEf_GET(r) (((r).xlmac_pfc_opcode[0]) & 0xffff)
#define XLMAC_PFC_OPCODEr_PFC_OPCODEf_SET(r,f) (r).xlmac_pfc_opcode[0]=(((r).xlmac_pfc_opcode[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access XLMAC_PFC_OPCODE.
 */
#define WRITE_XLMAC_PFC_OPCODEr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_PFC_OPCODE(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_pfc_opcode),2)
#define READ_XLMAC_PFC_OPCODEr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_PFC_OPCODE(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_pfc_opcode),2)

/*******************************************************************************
 * End of 'XLMAC_PFC_OPCODEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_PFC_TYPE
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     PFC Ethertype
 * SIZE:     64
 * FIELDS:
 *     PFC_ETH_TYPE     This field is used in the ETHERTYPE field of the PFC frame that is generated and transmitted by the MAC and also used for detection in the receive direction
 */
#define XLMAC_PFC_TYPEr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_PFC_TYPE.
 */
typedef union XLMAC_PFC_TYPEr_s {
	uint32 v[2];
	uint32 xlmac_pfc_type[2];
	uint32 _xlmac_pfc_type;
} XLMAC_PFC_TYPEr_t;

#define XLMAC_PFC_TYPEr_CLR(r) sal_memset(&((r)._xlmac_pfc_type), 0, sizeof(XLMAC_PFC_TYPEr_t))
#define XLMAC_PFC_TYPEr_SET(r,i,d) (r).xlmac_pfc_type[i] = d
#define XLMAC_PFC_TYPEr_GET(r,i) (r).xlmac_pfc_type[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_PFC_TYPEr_PFC_ETH_TYPEf_GET(r) (((r).xlmac_pfc_type[0]) & 0xffff)
#define XLMAC_PFC_TYPEr_PFC_ETH_TYPEf_SET(r,f) (r).xlmac_pfc_type[0]=(((r).xlmac_pfc_type[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access XLMAC_PFC_TYPE.
 */
#define WRITE_XLMAC_PFC_TYPEr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_PFC_TYPE(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_pfc_type),2)
#define READ_XLMAC_PFC_TYPEr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_PFC_TYPE(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_pfc_type),2)

/*******************************************************************************
 * End of 'XLMAC_PFC_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_RX_CTRL
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Receive control.
 * SIZE:     64
 * FIELDS:
 *     RSVD_1            Reserved
 *     RX_ANY_START     If set, MAC allows any undefined control character to start a packet
 *     STRIP_CRC        If set, CRC is stripped from the received packet 
 *     STRICT_PREAMBLE  If set, MAC checks for IEEE Ethernet preamble - K.SOP +  6 "0x55" preamble bytes + "0xD5" SFD character - if this sequence is missing it is treated as an errored packet
 *     RUNT_THRESHOLD   The runt threshold, below which the packets are dropped (CDC mode) or marked as runt (Low latency mode). Should be programmed < 96 bytes (decimal)
 *     RSVD_2            Reserved
 *     RSVD_3            Reserved
 *     RX_PASS_CTRL     This configuration is used to drop or pass all control frames (with ether type 0x8808) except pause packets.If set, all control frames are passed to system side. Otherwise, control frames (including pfc frames wih ether type 0x8808) are dropped in XLMAC.This configuration is used in Rx CDC mode only.
 *     RX_PASS_PAUSE    If set, PAUSE frames are passed to sytem side. Otherwise, PAUSE frames are dropped in XLMAC This configuration is used in Rx CDC mode only.
 *     RX_PASS_PFC      This configuration is used to pass or drop pfc packetw when pfc_ether_type is not equal to 0x8808.              If set, PFC frames are passed to system side. Otherwise, PFC frames are dropped in XLMAC.This configuration is used in Rx CDC mode only.
 */
#define XLMAC_RX_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_CTRL.
 */
typedef union XLMAC_RX_CTRLr_s {
	uint32 v[2];
	uint32 xlmac_rx_ctrl[2];
	uint32 _xlmac_rx_ctrl;
} XLMAC_RX_CTRLr_t;

#define XLMAC_RX_CTRLr_CLR(r) sal_memset(&((r)._xlmac_rx_ctrl), 0, sizeof(XLMAC_RX_CTRLr_t))
#define XLMAC_RX_CTRLr_SET(r,i,d) (r).xlmac_rx_ctrl[i] = d
#define XLMAC_RX_CTRLr_GET(r,i) (r).xlmac_rx_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_CTRLr_RSVD_1f_GET(r) (((r).xlmac_rx_ctrl[0]) & 0x1)
#define XLMAC_RX_CTRLr_RSVD_1f_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLMAC_RX_CTRLr_RX_ANY_STARTf_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 1) & 0x1)
#define XLMAC_RX_CTRLr_RX_ANY_STARTf_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define XLMAC_RX_CTRLr_STRIP_CRCf_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 2) & 0x1)
#define XLMAC_RX_CTRLr_STRIP_CRCf_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define XLMAC_RX_CTRLr_STRICT_PREAMBLEf_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 3) & 0x1)
#define XLMAC_RX_CTRLr_STRICT_PREAMBLEf_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define XLMAC_RX_CTRLr_RUNT_THRESHOLDf_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 4) & 0x7f)
#define XLMAC_RX_CTRLr_RUNT_THRESHOLDf_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32)0x7f << 4)) | ((((uint32)f) & 0x7f) << 4))
#define XLMAC_RX_CTRLr_RSVD_2f_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 11) & 0x1)
#define XLMAC_RX_CTRLr_RSVD_2f_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define XLMAC_RX_CTRLr_RSVD_3f_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 12) & 0x1)
#define XLMAC_RX_CTRLr_RSVD_3f_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define XLMAC_RX_CTRLr_RX_PASS_CTRLf_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 13) & 0x1)
#define XLMAC_RX_CTRLr_RX_PASS_CTRLf_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define XLMAC_RX_CTRLr_RX_PASS_PAUSEf_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 14) & 0x1)
#define XLMAC_RX_CTRLr_RX_PASS_PAUSEf_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define XLMAC_RX_CTRLr_RX_PASS_PFCf_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 15) & 0x1)
#define XLMAC_RX_CTRLr_RX_PASS_PFCf_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))

/*
 * These macros can be used to access XLMAC_RX_CTRL.
 */
#define WRITE_XLMAC_RX_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_RX_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_rx_ctrl),2)
#define READ_XLMAC_RX_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_RX_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_rx_ctrl),2)

/*******************************************************************************
 * End of 'XLMAC_RX_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_RX_LSS_CTRL
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Control for LSS (ordered set) messages
 * SIZE:     64
 * FIELDS:
 *     LOCAL_FAULT_DISABLE This bit determines the transmit response during local fault state. The LOCAL_FAULT_STATUS bit is always updated irrespective of this configuration.If set, MAC will continue to transmit data irrespective of LOCAL_FAULT_STATUS.If reset, MAC transmit behavior is governed by DROP_TX_DATA_ON_LOCAL_FAULT configuration.
 *     REMOTE_FAULT_DISABLE This bit determines the transmit response during remote fault state. The REMOTE_FAULT_STATUS bit is always updated irrespective of this configuration.If set, MAC will continue to transmit data irrespective of REMOTE_FAULT_STATUS.If reset, MAC transmit behavior is governed by DROP_TX_DATA_ON_REMOTE_FAULT configuration.
 *     USE_EXTERNAL_FAULTS_FOR_TX If set, the transmit fault responses are determined from input pins rather than internal receive status. In this mode, input fault from pins (from a peer MAC) is directly relayed on the transmit side of this MAC.See specification document for more details.
 *     LINK_INTERRUPTION_DISABLE This bit determines the transmit response during link interruption state. The LINK_INTERRUPTION_STATUS bit is always updated irrespective of this configuration.If set, MAC will continue to transmit data irrespective of LINK_INTERRUPTION_STATUS.If reset, MAC transmit behavior is governed by DROP_TX_DATA_ON_LINK_INTERRUPT configuration.
 *     DROP_TX_DATA_ON_LOCAL_FAULT This bit determines the way MAC handles data during local fault state, if LOCAL_FAULT_DISABLE is reset.If set, during local fault state, MAC drops transmit-data (statistics are updated) and sends remote faults on the wire.If reset, transmit data is stalled in the internal FIFO under local fault state.
 *     DROP_TX_DATA_ON_REMOTE_FAULT This bit determines the way MAC handles data during remote fault state, if REMOTE_FAULT_DISABLE is reset.If set, during remote fault state, MAC drops transmit-data (statistics are updated) and sends IDLEs on the wire.If reset, transmit data is stalled in the internal FIFO under remote fault state.
 *     DROP_TX_DATA_ON_LINK_INTERRUPT This bit determines the way MAC handles data during link interruption state, if LINK_INTERRUPTION_DISABLE is reset.If set, during link interruption state, MAC drops transmit-data (statistics are updated) and sends IDLEs on the wire.If reset, transmit data is stalled in the internal FIFO under link interruption state.
 *     RESET_FLOW_CONTROL_TIMERS_ON_LINK_DOWN If set, the Receive Pause, PFC & LLFC timers are reset whenever the link status is down, or local or remote faults are received. 
 */
#define XLMAC_RX_LSS_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_LSS_CTRL.
 */
typedef union XLMAC_RX_LSS_CTRLr_s {
	uint32 v[2];
	uint32 xlmac_rx_lss_ctrl[2];
	uint32 _xlmac_rx_lss_ctrl;
} XLMAC_RX_LSS_CTRLr_t;

#define XLMAC_RX_LSS_CTRLr_CLR(r) sal_memset(&((r)._xlmac_rx_lss_ctrl), 0, sizeof(XLMAC_RX_LSS_CTRLr_t))
#define XLMAC_RX_LSS_CTRLr_SET(r,i,d) (r).xlmac_rx_lss_ctrl[i] = d
#define XLMAC_RX_LSS_CTRLr_GET(r,i) (r).xlmac_rx_lss_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_LSS_CTRLr_LOCAL_FAULT_DISABLEf_GET(r) (((r).xlmac_rx_lss_ctrl[0]) & 0x1)
#define XLMAC_RX_LSS_CTRLr_LOCAL_FAULT_DISABLEf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLMAC_RX_LSS_CTRLr_REMOTE_FAULT_DISABLEf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 1) & 0x1)
#define XLMAC_RX_LSS_CTRLr_REMOTE_FAULT_DISABLEf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define XLMAC_RX_LSS_CTRLr_USE_EXTERNAL_FAULTS_FOR_TXf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 2) & 0x1)
#define XLMAC_RX_LSS_CTRLr_USE_EXTERNAL_FAULTS_FOR_TXf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define XLMAC_RX_LSS_CTRLr_LINK_INTERRUPTION_DISABLEf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 3) & 0x1)
#define XLMAC_RX_LSS_CTRLr_LINK_INTERRUPTION_DISABLEf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define XLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LOCAL_FAULTf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 4) & 0x1)
#define XLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LOCAL_FAULTf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define XLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_REMOTE_FAULTf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 5) & 0x1)
#define XLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_REMOTE_FAULTf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define XLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LINK_INTERRUPTf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 6) & 0x1)
#define XLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LINK_INTERRUPTf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define XLMAC_RX_LSS_CTRLr_RESET_FLOW_CONTROL_TIMERS_ON_LINK_DOWNf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 7) & 0x1)
#define XLMAC_RX_LSS_CTRLr_RESET_FLOW_CONTROL_TIMERS_ON_LINK_DOWNf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access XLMAC_RX_LSS_CTRL.
 */
#define WRITE_XLMAC_RX_LSS_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_RX_LSS_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_rx_lss_ctrl),2)
#define READ_XLMAC_RX_LSS_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_RX_LSS_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_rx_lss_ctrl),2)

/*******************************************************************************
 * End of 'XLMAC_RX_LSS_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_RX_LSS_STATUS
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Status for RS layer. These bits are sticky by nature, and can be cleared by writing to the clear register
 * SIZE:     64
 * FIELDS:
 *     LOCAL_FAULT_STATUS True when local fault state is detected as per RS layer state machine. Sticky bit is cleared by CLEAR_LOCAL_FAULT_STATUS
 *     REMOTE_FAULT_STATUS True when remote fault state is detected as per RS layer state machine. Sticky bit is cleared by CLEAR_REMOTE_FAULT_STATUS.
 *     LINK_INTERRUPTION_STATUS True when link interruption state is detected as per RS layer state machine. Sticky bit is cleared by CLEAR_LINK_INTERRUPTION_STATUS.
 */
#define XLMAC_RX_LSS_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_LSS_STATUS.
 */
typedef union XLMAC_RX_LSS_STATUSr_s {
	uint32 v[2];
	uint32 xlmac_rx_lss_status[2];
	uint32 _xlmac_rx_lss_status;
} XLMAC_RX_LSS_STATUSr_t;

#define XLMAC_RX_LSS_STATUSr_CLR(r) sal_memset(&((r)._xlmac_rx_lss_status), 0, sizeof(XLMAC_RX_LSS_STATUSr_t))
#define XLMAC_RX_LSS_STATUSr_SET(r,i,d) (r).xlmac_rx_lss_status[i] = d
#define XLMAC_RX_LSS_STATUSr_GET(r,i) (r).xlmac_rx_lss_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_LSS_STATUSr_LOCAL_FAULT_STATUSf_GET(r) (((r).xlmac_rx_lss_status[0]) & 0x1)
#define XLMAC_RX_LSS_STATUSr_LOCAL_FAULT_STATUSf_SET(r,f) (r).xlmac_rx_lss_status[0]=(((r).xlmac_rx_lss_status[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLMAC_RX_LSS_STATUSr_REMOTE_FAULT_STATUSf_GET(r) ((((r).xlmac_rx_lss_status[0]) >> 1) & 0x1)
#define XLMAC_RX_LSS_STATUSr_REMOTE_FAULT_STATUSf_SET(r,f) (r).xlmac_rx_lss_status[0]=(((r).xlmac_rx_lss_status[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define XLMAC_RX_LSS_STATUSr_LINK_INTERRUPTION_STATUSf_GET(r) ((((r).xlmac_rx_lss_status[0]) >> 2) & 0x1)
#define XLMAC_RX_LSS_STATUSr_LINK_INTERRUPTION_STATUSf_SET(r,f) (r).xlmac_rx_lss_status[0]=(((r).xlmac_rx_lss_status[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))

/*
 * These macros can be used to access XLMAC_RX_LSS_STATUS.
 */
#define WRITE_XLMAC_RX_LSS_STATUSr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_RX_LSS_STATUS(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_rx_lss_status),2)
#define READ_XLMAC_RX_LSS_STATUSr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_RX_LSS_STATUS(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_rx_lss_status),2)

/*******************************************************************************
 * End of 'XLMAC_RX_LSS_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_RX_MAC_SA
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Receive source address.
 * SIZE:     64
 * FIELDS:
 *     RX_SA            Source Address recognized for MAC control packets in addition to the standard 0x0180C2000001 
 *     SA_LO            32 lower bits of the receive SA 
 *     SA_HI            16 upper bits of the receive SA 
 */
#define XLMAC_RX_MAC_SAr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_MAC_SA.
 */
typedef union XLMAC_RX_MAC_SAr_s {
	uint32 v[2];
	uint32 xlmac_rx_mac_sa[2];
	uint32 _xlmac_rx_mac_sa;
} XLMAC_RX_MAC_SAr_t;

#define XLMAC_RX_MAC_SAr_CLR(r) sal_memset(&((r)._xlmac_rx_mac_sa), 0, sizeof(XLMAC_RX_MAC_SAr_t))
#define XLMAC_RX_MAC_SAr_SET(r,i,d) (r).xlmac_rx_mac_sa[i] = d
#define XLMAC_RX_MAC_SAr_GET(r,i) (r).xlmac_rx_mac_sa[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_MAC_SAr_RX_SAf_GET(r,a) field_get((r).xlmac_rx_mac_sa,0,47,a)
#define XLMAC_RX_MAC_SAr_RX_SAf_SET(r,a) field_set((r).xlmac_rx_mac_sa,0,47,a)
#define XLMAC_RX_MAC_SAr_SA_LOf_GET(r) ((r).xlmac_rx_mac_sa[0])
#define XLMAC_RX_MAC_SAr_SA_LOf_SET(r,f) (r).xlmac_rx_mac_sa[0]=((uint32)f)
#define XLMAC_RX_MAC_SAr_SA_HIf_GET(r) (((r).xlmac_rx_mac_sa[1]) & 0xffff)
#define XLMAC_RX_MAC_SAr_SA_HIf_SET(r,f) (r).xlmac_rx_mac_sa[1]=(((r).xlmac_rx_mac_sa[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access XLMAC_RX_MAC_SA.
 */
#define WRITE_XLMAC_RX_MAC_SAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_RX_MAC_SA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_rx_mac_sa),2)
#define READ_XLMAC_RX_MAC_SAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_RX_MAC_SA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_rx_mac_sa),2)

/*******************************************************************************
 * End of 'XLMAC_RX_MAC_SAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_RX_MAX_SIZE
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Receive maximum packet size.
 * SIZE:     64
 * FIELDS:
 *     RX_MAX_SIZE      Maximum packet size in receive direction, exclusive of preamble & CRC in strip mode. Packets greater than this size are truncated to this value.
 */
#define XLMAC_RX_MAX_SIZEr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_MAX_SIZE.
 */
typedef union XLMAC_RX_MAX_SIZEr_s {
	uint32 v[2];
	uint32 xlmac_rx_max_size[2];
	uint32 _xlmac_rx_max_size;
} XLMAC_RX_MAX_SIZEr_t;

#define XLMAC_RX_MAX_SIZEr_CLR(r) sal_memset(&((r)._xlmac_rx_max_size), 0, sizeof(XLMAC_RX_MAX_SIZEr_t))
#define XLMAC_RX_MAX_SIZEr_SET(r,i,d) (r).xlmac_rx_max_size[i] = d
#define XLMAC_RX_MAX_SIZEr_GET(r,i) (r).xlmac_rx_max_size[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_MAX_SIZEr_RX_MAX_SIZEf_GET(r) (((r).xlmac_rx_max_size[0]) & 0x3fff)
#define XLMAC_RX_MAX_SIZEr_RX_MAX_SIZEf_SET(r,f) (r).xlmac_rx_max_size[0]=(((r).xlmac_rx_max_size[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))

/*
 * These macros can be used to access XLMAC_RX_MAX_SIZE.
 */
#define WRITE_XLMAC_RX_MAX_SIZEr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_RX_MAX_SIZE(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_rx_max_size),2)
#define READ_XLMAC_RX_MAX_SIZEr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_RX_MAX_SIZE(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_rx_max_size),2)

/*******************************************************************************
 * End of 'XLMAC_RX_MAX_SIZEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_RX_VLAN_TAG
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Inner and Outer VLAN tag fields
 * SIZE:     64
 * FIELDS:
 *     INNER_VLAN_TAG   TPID field for Inner VLAN tag 
 *     OUTER_VLAN_TAG   TPID field for Outer VLAN tag 
 *     INNER_VLAN_TAG_ENABLE If set, MAC enables VLAN tag detection using the INNER_VLAN_TAG 
 *     OUTER_VLAN_TAG_ENABLE If set, MAC enables VLAN tag detection using the OUTER_VLAN_TAG 
 */
#define XLMAC_RX_VLAN_TAGr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_VLAN_TAG.
 */
typedef union XLMAC_RX_VLAN_TAGr_s {
	uint32 v[2];
	uint32 xlmac_rx_vlan_tag[2];
	uint32 _xlmac_rx_vlan_tag;
} XLMAC_RX_VLAN_TAGr_t;

#define XLMAC_RX_VLAN_TAGr_CLR(r) sal_memset(&((r)._xlmac_rx_vlan_tag), 0, sizeof(XLMAC_RX_VLAN_TAGr_t))
#define XLMAC_RX_VLAN_TAGr_SET(r,i,d) (r).xlmac_rx_vlan_tag[i] = d
#define XLMAC_RX_VLAN_TAGr_GET(r,i) (r).xlmac_rx_vlan_tag[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_VLAN_TAGr_INNER_VLAN_TAGf_GET(r) (((r).xlmac_rx_vlan_tag[0]) & 0xffff)
#define XLMAC_RX_VLAN_TAGr_INNER_VLAN_TAGf_SET(r,f) (r).xlmac_rx_vlan_tag[0]=(((r).xlmac_rx_vlan_tag[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define XLMAC_RX_VLAN_TAGr_OUTER_VLAN_TAGf_GET(r) ((((r).xlmac_rx_vlan_tag[0]) >> 16) & 0xffff)
#define XLMAC_RX_VLAN_TAGr_OUTER_VLAN_TAGf_SET(r,f) (r).xlmac_rx_vlan_tag[0]=(((r).xlmac_rx_vlan_tag[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))
#define XLMAC_RX_VLAN_TAGr_INNER_VLAN_TAG_ENABLEf_GET(r) (((r).xlmac_rx_vlan_tag[1]) & 0x1)
#define XLMAC_RX_VLAN_TAGr_INNER_VLAN_TAG_ENABLEf_SET(r,f) (r).xlmac_rx_vlan_tag[1]=(((r).xlmac_rx_vlan_tag[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLMAC_RX_VLAN_TAGr_OUTER_VLAN_TAG_ENABLEf_GET(r) ((((r).xlmac_rx_vlan_tag[1]) >> 1) & 0x1)
#define XLMAC_RX_VLAN_TAGr_OUTER_VLAN_TAG_ENABLEf_SET(r,f) (r).xlmac_rx_vlan_tag[1]=(((r).xlmac_rx_vlan_tag[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access XLMAC_RX_VLAN_TAG.
 */
#define WRITE_XLMAC_RX_VLAN_TAGr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_RX_VLAN_TAG(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_rx_vlan_tag),2)
#define READ_XLMAC_RX_VLAN_TAGr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_RX_VLAN_TAG(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_rx_vlan_tag),2)

/*******************************************************************************
 * End of 'XLMAC_RX_VLAN_TAGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_TIMESTAMP_ADJUST
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Timestamp Adjust register. Refer specification document for more details
 * SIZE:     64
 * FIELDS:
 *     TS_OSTS_ADJUST   This is a signed value which is 2s complement added to synchronized timestamp to account for MAC pipeline delay in OSTS. Unit is 1nsThe latency is [6 TSC_CLK period + 1 TS_CLK period ].
 *     TS_TSTS_ADJUST   This is an unsigned value to account for synchronization delay of TS timer from TS clk to TSC_CLK domain. Unit is 1ns.The latency is [2.5 TSC_CLK period + 1 TS_CLK period].
 *     TS_USE_CS_OFFSET When set, indicates that the checksum offset is referenced by input port checksumoffset, else checksum offset is referenced by txtsoffset
 */
#define XLMAC_TIMESTAMP_ADJUSTr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TIMESTAMP_ADJUST.
 */
typedef union XLMAC_TIMESTAMP_ADJUSTr_s {
	uint32 v[2];
	uint32 xlmac_timestamp_adjust[2];
	uint32 _xlmac_timestamp_adjust;
} XLMAC_TIMESTAMP_ADJUSTr_t;

#define XLMAC_TIMESTAMP_ADJUSTr_CLR(r) sal_memset(&((r)._xlmac_timestamp_adjust), 0, sizeof(XLMAC_TIMESTAMP_ADJUSTr_t))
#define XLMAC_TIMESTAMP_ADJUSTr_SET(r,i,d) (r).xlmac_timestamp_adjust[i] = d
#define XLMAC_TIMESTAMP_ADJUSTr_GET(r,i) (r).xlmac_timestamp_adjust[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TIMESTAMP_ADJUSTr_TS_OSTS_ADJUSTf_GET(r) (((r).xlmac_timestamp_adjust[0]) & 0x1ff)
#define XLMAC_TIMESTAMP_ADJUSTr_TS_OSTS_ADJUSTf_SET(r,f) (r).xlmac_timestamp_adjust[0]=(((r).xlmac_timestamp_adjust[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define XLMAC_TIMESTAMP_ADJUSTr_TS_TSTS_ADJUSTf_GET(r) ((((r).xlmac_timestamp_adjust[0]) >> 9) & 0x3f)
#define XLMAC_TIMESTAMP_ADJUSTr_TS_TSTS_ADJUSTf_SET(r,f) (r).xlmac_timestamp_adjust[0]=(((r).xlmac_timestamp_adjust[0] & ~((uint32)0x3f << 9)) | ((((uint32)f) & 0x3f) << 9))
#define XLMAC_TIMESTAMP_ADJUSTr_TS_USE_CS_OFFSETf_GET(r) ((((r).xlmac_timestamp_adjust[0]) >> 15) & 0x1)
#define XLMAC_TIMESTAMP_ADJUSTr_TS_USE_CS_OFFSETf_SET(r,f) (r).xlmac_timestamp_adjust[0]=(((r).xlmac_timestamp_adjust[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))

/*
 * These macros can be used to access XLMAC_TIMESTAMP_ADJUST.
 */
#define WRITE_XLMAC_TIMESTAMP_ADJUSTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TIMESTAMP_ADJUST(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_timestamp_adjust),2)
#define READ_XLMAC_TIMESTAMP_ADJUSTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TIMESTAMP_ADJUST(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_timestamp_adjust),2)

/*******************************************************************************
 * End of 'XLMAC_TIMESTAMP_ADJUSTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_TIMESTAMP_BYTE_ADJUST
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Timestamp Byte Adjust register. Refer specification document for more details
 * SIZE:     64
 * FIELDS:
 *     TX_TIMER_BYTE_ADJUST This is a per byte unsigned value which is added to sampled timestamp to account for timestamp jitter due to wider MSBUS interface. Unit is 1ns
 *     TX_TIMER_BYTE_ADJUST_EN When set, enables byte based adjustment for transmit timestamp capture (OSTS and TSTS). This should be enabled in GMII/MII modes only.
 *     RX_TIMER_BYTE_ADJUST This is a per byte unsigned value which is subtracted from sampled timestamp to account for timestamp jitter due to wider MSBUS interface. Unit is 1ns
 *     RX_TIMER_BYTE_ADJUST_EN When set, enables byte based adjustment for receive timestamp capture. This should be enabled in GMII/MII modes only.
 */
#define XLMAC_TIMESTAMP_BYTE_ADJUSTr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TIMESTAMP_BYTE_ADJUST.
 */
typedef union XLMAC_TIMESTAMP_BYTE_ADJUSTr_s {
	uint32 v[2];
	uint32 xlmac_timestamp_byte_adjust[2];
	uint32 _xlmac_timestamp_byte_adjust;
} XLMAC_TIMESTAMP_BYTE_ADJUSTr_t;

#define XLMAC_TIMESTAMP_BYTE_ADJUSTr_CLR(r) sal_memset(&((r)._xlmac_timestamp_byte_adjust), 0, sizeof(XLMAC_TIMESTAMP_BYTE_ADJUSTr_t))
#define XLMAC_TIMESTAMP_BYTE_ADJUSTr_SET(r,i,d) (r).xlmac_timestamp_byte_adjust[i] = d
#define XLMAC_TIMESTAMP_BYTE_ADJUSTr_GET(r,i) (r).xlmac_timestamp_byte_adjust[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TIMESTAMP_BYTE_ADJUSTr_TX_TIMER_BYTE_ADJUSTf_GET(r) (((r).xlmac_timestamp_byte_adjust[0]) & 0x3ff)
#define XLMAC_TIMESTAMP_BYTE_ADJUSTr_TX_TIMER_BYTE_ADJUSTf_SET(r,f) (r).xlmac_timestamp_byte_adjust[0]=(((r).xlmac_timestamp_byte_adjust[0] & ~((uint32)0x3ff)) | (((uint32)f) & 0x3ff))
#define XLMAC_TIMESTAMP_BYTE_ADJUSTr_TX_TIMER_BYTE_ADJUST_ENf_GET(r) ((((r).xlmac_timestamp_byte_adjust[0]) >> 10) & 0x1)
#define XLMAC_TIMESTAMP_BYTE_ADJUSTr_TX_TIMER_BYTE_ADJUST_ENf_SET(r,f) (r).xlmac_timestamp_byte_adjust[0]=(((r).xlmac_timestamp_byte_adjust[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define XLMAC_TIMESTAMP_BYTE_ADJUSTr_RX_TIMER_BYTE_ADJUSTf_GET(r) ((((r).xlmac_timestamp_byte_adjust[0]) >> 11) & 0x3ff)
#define XLMAC_TIMESTAMP_BYTE_ADJUSTr_RX_TIMER_BYTE_ADJUSTf_SET(r,f) (r).xlmac_timestamp_byte_adjust[0]=(((r).xlmac_timestamp_byte_adjust[0] & ~((uint32)0x3ff << 11)) | ((((uint32)f) & 0x3ff) << 11))
#define XLMAC_TIMESTAMP_BYTE_ADJUSTr_RX_TIMER_BYTE_ADJUST_ENf_GET(r) ((((r).xlmac_timestamp_byte_adjust[0]) >> 21) & 0x1)
#define XLMAC_TIMESTAMP_BYTE_ADJUSTr_RX_TIMER_BYTE_ADJUST_ENf_SET(r,f) (r).xlmac_timestamp_byte_adjust[0]=(((r).xlmac_timestamp_byte_adjust[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))

/*
 * These macros can be used to access XLMAC_TIMESTAMP_BYTE_ADJUST.
 */
#define WRITE_XLMAC_TIMESTAMP_BYTE_ADJUSTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TIMESTAMP_BYTE_ADJUST(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_timestamp_byte_adjust),2)
#define READ_XLMAC_TIMESTAMP_BYTE_ADJUSTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TIMESTAMP_BYTE_ADJUST(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_timestamp_byte_adjust),2)

/*******************************************************************************
 * End of 'XLMAC_TIMESTAMP_BYTE_ADJUSTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_TXFIFO_CELL_CNT
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     XLMAC TX FIFO Cell Count register
 * SIZE:     64
 * FIELDS:
 *     CELL_CNT         Number of cell counts in XLMAC TX FIFO.Should range from 0 to 32 for XLMAC core in single port mode, or 0 to 16 if XLMAC core is in dual port mode, or 0 to 8 if XLMAC core is in quad port mode during traffic.This should reset to 0 after the traffic has stopped for all port modes.
 */
#define XLMAC_TXFIFO_CELL_CNTr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TXFIFO_CELL_CNT.
 */
typedef union XLMAC_TXFIFO_CELL_CNTr_s {
	uint32 v[2];
	uint32 xlmac_txfifo_cell_cnt[2];
	uint32 _xlmac_txfifo_cell_cnt;
} XLMAC_TXFIFO_CELL_CNTr_t;

#define XLMAC_TXFIFO_CELL_CNTr_CLR(r) sal_memset(&((r)._xlmac_txfifo_cell_cnt), 0, sizeof(XLMAC_TXFIFO_CELL_CNTr_t))
#define XLMAC_TXFIFO_CELL_CNTr_SET(r,i,d) (r).xlmac_txfifo_cell_cnt[i] = d
#define XLMAC_TXFIFO_CELL_CNTr_GET(r,i) (r).xlmac_txfifo_cell_cnt[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TXFIFO_CELL_CNTr_CELL_CNTf_GET(r) (((r).xlmac_txfifo_cell_cnt[0]) & 0x3f)
#define XLMAC_TXFIFO_CELL_CNTr_CELL_CNTf_SET(r,f) (r).xlmac_txfifo_cell_cnt[0]=(((r).xlmac_txfifo_cell_cnt[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))

/*
 * These macros can be used to access XLMAC_TXFIFO_CELL_CNT.
 */
#define WRITE_XLMAC_TXFIFO_CELL_CNTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TXFIFO_CELL_CNT(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_txfifo_cell_cnt),2)
#define READ_XLMAC_TXFIFO_CELL_CNTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TXFIFO_CELL_CNT(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_txfifo_cell_cnt),2)

/*******************************************************************************
 * End of 'XLMAC_TXFIFO_CELL_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_TXFIFO_CELL_REQ_CNT
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     XLMAC TX FIFO Cell Request Count Register
 * SIZE:     64
 * FIELDS:
 *     REQ_CNT          Number of cell requests made to Egress Pipeline. Should range from 0 to 32 for XLMAC core in single port mode, or 0 to 16 if XLMAC core is in dual port mode, or 0 to 8 if XLMAC core is in quad port mode during traffic.This should saturate at the maximum value for the corresponding port mode after traffic has stopped.
 */
#define XLMAC_TXFIFO_CELL_REQ_CNTr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TXFIFO_CELL_REQ_CNT.
 */
typedef union XLMAC_TXFIFO_CELL_REQ_CNTr_s {
	uint32 v[2];
	uint32 xlmac_txfifo_cell_req_cnt[2];
	uint32 _xlmac_txfifo_cell_req_cnt;
} XLMAC_TXFIFO_CELL_REQ_CNTr_t;

#define XLMAC_TXFIFO_CELL_REQ_CNTr_CLR(r) sal_memset(&((r)._xlmac_txfifo_cell_req_cnt), 0, sizeof(XLMAC_TXFIFO_CELL_REQ_CNTr_t))
#define XLMAC_TXFIFO_CELL_REQ_CNTr_SET(r,i,d) (r).xlmac_txfifo_cell_req_cnt[i] = d
#define XLMAC_TXFIFO_CELL_REQ_CNTr_GET(r,i) (r).xlmac_txfifo_cell_req_cnt[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TXFIFO_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).xlmac_txfifo_cell_req_cnt[0]) & 0x3f)
#define XLMAC_TXFIFO_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).xlmac_txfifo_cell_req_cnt[0]=(((r).xlmac_txfifo_cell_req_cnt[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))

/*
 * These macros can be used to access XLMAC_TXFIFO_CELL_REQ_CNT.
 */
#define WRITE_XLMAC_TXFIFO_CELL_REQ_CNTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TXFIFO_CELL_REQ_CNT(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_txfifo_cell_req_cnt),2)
#define READ_XLMAC_TXFIFO_CELL_REQ_CNTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TXFIFO_CELL_REQ_CNT(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_txfifo_cell_req_cnt),2)

/*******************************************************************************
 * End of 'XLMAC_TXFIFO_CELL_REQ_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_TX_CTRL
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Transmit control.
 * SIZE:     64
 * FIELDS:
 *     XLMAC_TX_CTRL_LO 32 lower bits of the TX CTRL register
 *     CRC_MODE         CRC mode for Transmit Side
 *     DISCARD          If set, MAC accepts packets from the EP and discards them on the line side.  The statistics are updated.
 *     TX_ANY_START     In GMII mode, this may be used to enable DIC compensation of +/-1 byte, irrespective of speed.In non-GMII modes, if reset, MAC forces the first byte of a packet to be /S/ character (0xFB) irrespective of incoming EP data at SOP location in HIGIG modes
 *     PAD_EN           If set, enable XLMAC to pad packets smaller than PAD_THRESHOLD on the Tx
 *     PAD_THRESHOLD    If padding is enabled, packets smaller than PAD_THRESHOLD are padded to this size. This must be set to a value >= 17 (decimal)
 *     AVERAGE_IPG      Average interpacket gap. Must be programmed >= 8. Per packet IPG will vary based on DIC for 10G+ speeds.
 *     THROT_NUM        Number of bytes of extra IPG added whenever THROT_DENOM bytes have been transmitted. This configuration is used for WAN IPG throttling. Refer MAC specs for more details.
 *     THROT_DENOM      Number of bytes to transmit before adding THROT_NUM bytes to the IPG.  This configuration is used for WAN IPG throttling. Refer MAC specs for more details.
 *     XLMAC_TX_CTRL_HI 10 upper bits of the TX CTRL Register 
 *     TX_PREAMBLE_LENGTH Number of preamble bytes for transmit IEEE packets, this value should include the K.SOP & SFD character as well 
 *     EP_DISCARD       If set, MAC accepts packets from the EP but does not write to the CDC FIFO and discards them on the core side without updating the statistics.
 *     TX_THRESHOLD     Indicates the number of 16-byte cells that are buffered per packet in the Tx CDC FIFO, before starting transmission of the packet on the line side.                               This setting is useful to prevent underflow issues if the EP logic pumps in data at port rate, rather than bursting at full rate.                               This mode will increase the overall latency.                               In quad port mode, this field should be set >= 1 and <= 4 for each port.                               In single port mode, this field should be set >= 1 and <= 16 for the four lane port (port0).                               In dual port mode, this field should be set >= 1 and <= 8 for each two lane port (port0 and port2).                               In tri1/tri2, this field should be set >= 1 and <= 4 for each single lane port, and >= 1 and <= 8 for the two lane port.
 */
#define XLMAC_TX_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TX_CTRL.
 */
typedef union XLMAC_TX_CTRLr_s {
	uint32 v[2];
	uint32 xlmac_tx_ctrl[2];
	uint32 _xlmac_tx_ctrl;
} XLMAC_TX_CTRLr_t;

#define XLMAC_TX_CTRLr_CLR(r) sal_memset(&((r)._xlmac_tx_ctrl), 0, sizeof(XLMAC_TX_CTRLr_t))
#define XLMAC_TX_CTRLr_SET(r,i,d) (r).xlmac_tx_ctrl[i] = d
#define XLMAC_TX_CTRLr_GET(r,i) (r).xlmac_tx_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TX_CTRLr_XLMAC_TX_CTRL_LOf_GET(r) ((r).xlmac_tx_ctrl[0])
#define XLMAC_TX_CTRLr_XLMAC_TX_CTRL_LOf_SET(r,f) (r).xlmac_tx_ctrl[0]=((uint32)f)
#define XLMAC_TX_CTRLr_CRC_MODEf_GET(r) (((r).xlmac_tx_ctrl[0]) & 0x3)
#define XLMAC_TX_CTRLr_CRC_MODEf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define XLMAC_TX_CTRLr_DISCARDf_GET(r) ((((r).xlmac_tx_ctrl[0]) >> 2) & 0x1)
#define XLMAC_TX_CTRLr_DISCARDf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define XLMAC_TX_CTRLr_TX_ANY_STARTf_GET(r) ((((r).xlmac_tx_ctrl[0]) >> 3) & 0x1)
#define XLMAC_TX_CTRLr_TX_ANY_STARTf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define XLMAC_TX_CTRLr_PAD_ENf_GET(r) ((((r).xlmac_tx_ctrl[0]) >> 4) & 0x1)
#define XLMAC_TX_CTRLr_PAD_ENf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define XLMAC_TX_CTRLr_PAD_THRESHOLDf_GET(r) ((((r).xlmac_tx_ctrl[0]) >> 5) & 0x7f)
#define XLMAC_TX_CTRLr_PAD_THRESHOLDf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32)0x7f << 5)) | ((((uint32)f) & 0x7f) << 5))
#define XLMAC_TX_CTRLr_AVERAGE_IPGf_GET(r) ((((r).xlmac_tx_ctrl[0]) >> 12) & 0x7f)
#define XLMAC_TX_CTRLr_AVERAGE_IPGf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32)0x7f << 12)) | ((((uint32)f) & 0x7f) << 12))
#define XLMAC_TX_CTRLr_THROT_NUMf_GET(r) ((((r).xlmac_tx_ctrl[0]) >> 19) & 0x3f)
#define XLMAC_TX_CTRLr_THROT_NUMf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32)0x3f << 19)) | ((((uint32)f) & 0x3f) << 19))
#define XLMAC_TX_CTRLr_THROT_DENOMf_GET(r) field32_get((r).xlmac_tx_ctrl,25,32)
#define XLMAC_TX_CTRLr_THROT_DENOMf_SET(r,f) field32_set((r).xlmac_tx_ctrl,25,32,f)
#define XLMAC_TX_CTRLr_XLMAC_TX_CTRL_HIf_GET(r) (((r).xlmac_tx_ctrl[1]) & 0x3ff)
#define XLMAC_TX_CTRLr_XLMAC_TX_CTRL_HIf_SET(r,f) (r).xlmac_tx_ctrl[1]=(((r).xlmac_tx_ctrl[1] & ~((uint32)0x3ff)) | (((uint32)f) & 0x3ff))
#define XLMAC_TX_CTRLr_TX_PREAMBLE_LENGTHf_GET(r) ((((r).xlmac_tx_ctrl[1]) >> 1) & 0xf)
#define XLMAC_TX_CTRLr_TX_PREAMBLE_LENGTHf_SET(r,f) (r).xlmac_tx_ctrl[1]=(((r).xlmac_tx_ctrl[1] & ~((uint32)0xf << 1)) | ((((uint32)f) & 0xf) << 1))
#define XLMAC_TX_CTRLr_EP_DISCARDf_GET(r) ((((r).xlmac_tx_ctrl[1]) >> 5) & 0x1)
#define XLMAC_TX_CTRLr_EP_DISCARDf_SET(r,f) (r).xlmac_tx_ctrl[1]=(((r).xlmac_tx_ctrl[1] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define XLMAC_TX_CTRLr_TX_THRESHOLDf_GET(r) ((((r).xlmac_tx_ctrl[1]) >> 6) & 0xf)
#define XLMAC_TX_CTRLr_TX_THRESHOLDf_SET(r,f) (r).xlmac_tx_ctrl[1]=(((r).xlmac_tx_ctrl[1] & ~((uint32)0xf << 6)) | ((((uint32)f) & 0xf) << 6))

/*
 * These macros can be used to access XLMAC_TX_CTRL.
 */
#define WRITE_XLMAC_TX_CTRLr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TX_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_tx_ctrl),2)
#define READ_XLMAC_TX_CTRLr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TX_CTRL(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_tx_ctrl),2)

/*******************************************************************************
 * End of 'XLMAC_TX_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_TX_MAC_SA
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Transmit Source Address.
 * SIZE:     64
 * FIELDS:
 *     CTRL_SA          Source Address for PAUSE/PFC packets generated by the MAC 
 *     SA_LO            32 lower bits of the SA
 *     SA_HI            16 upper bits of the SA
 */
#define XLMAC_TX_MAC_SAr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TX_MAC_SA.
 */
typedef union XLMAC_TX_MAC_SAr_s {
	uint32 v[2];
	uint32 xlmac_tx_mac_sa[2];
	uint32 _xlmac_tx_mac_sa;
} XLMAC_TX_MAC_SAr_t;

#define XLMAC_TX_MAC_SAr_CLR(r) sal_memset(&((r)._xlmac_tx_mac_sa), 0, sizeof(XLMAC_TX_MAC_SAr_t))
#define XLMAC_TX_MAC_SAr_SET(r,i,d) (r).xlmac_tx_mac_sa[i] = d
#define XLMAC_TX_MAC_SAr_GET(r,i) (r).xlmac_tx_mac_sa[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TX_MAC_SAr_CTRL_SAf_GET(r,a) field_get((r).xlmac_tx_mac_sa,0,47,a)
#define XLMAC_TX_MAC_SAr_CTRL_SAf_SET(r,a) field_set((r).xlmac_tx_mac_sa,0,47,a)
#define XLMAC_TX_MAC_SAr_SA_LOf_GET(r) ((r).xlmac_tx_mac_sa[0])
#define XLMAC_TX_MAC_SAr_SA_LOf_SET(r,f) (r).xlmac_tx_mac_sa[0]=((uint32)f)
#define XLMAC_TX_MAC_SAr_SA_HIf_GET(r) (((r).xlmac_tx_mac_sa[1]) & 0xffff)
#define XLMAC_TX_MAC_SAr_SA_HIf_SET(r,f) (r).xlmac_tx_mac_sa[1]=(((r).xlmac_tx_mac_sa[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access XLMAC_TX_MAC_SA.
 */
#define WRITE_XLMAC_TX_MAC_SAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TX_MAC_SA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_tx_mac_sa),2)
#define READ_XLMAC_TX_MAC_SAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TX_MAC_SA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_tx_mac_sa),2)

/*******************************************************************************
 * End of 'XLMAC_TX_MAC_SAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_TX_TIMESTAMP_FIFO_DATA
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     The TimeStamp value of the Tx two-step packets.
 * SIZE:     64
 * FIELDS:
 *     TIME_STAMP       The TimeStamp value of the Tx two-step enabled packet.
 *     SEQUENCE_ID      The Sequence Identifier extracted from the Timesync packet based on the header offset 
 *     TS_ENTRY_VALID   Active high qualifier for the TimeStamp & SEQUENCE_ID fields.
 */
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TX_TIMESTAMP_FIFO_DATA.
 */
typedef union XLMAC_TX_TIMESTAMP_FIFO_DATAr_s {
	uint32 v[2];
	uint32 xlmac_tx_timestamp_fifo_data[2];
	uint32 _xlmac_tx_timestamp_fifo_data;
} XLMAC_TX_TIMESTAMP_FIFO_DATAr_t;

#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_CLR(r) sal_memset(&((r)._xlmac_tx_timestamp_fifo_data), 0, sizeof(XLMAC_TX_TIMESTAMP_FIFO_DATAr_t))
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_SET(r,i,d) (r).xlmac_tx_timestamp_fifo_data[i] = d
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_GET(r,i) (r).xlmac_tx_timestamp_fifo_data[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_TIME_STAMPf_GET(r) ((r).xlmac_tx_timestamp_fifo_data[0])
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_TIME_STAMPf_SET(r,f) (r).xlmac_tx_timestamp_fifo_data[0]=((uint32)f)
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_SEQUENCE_IDf_GET(r) (((r).xlmac_tx_timestamp_fifo_data[1]) & 0xffff)
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_SEQUENCE_IDf_SET(r,f) (r).xlmac_tx_timestamp_fifo_data[1]=(((r).xlmac_tx_timestamp_fifo_data[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_TS_ENTRY_VALIDf_GET(r) ((((r).xlmac_tx_timestamp_fifo_data[1]) >> 16) & 0x1)
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_TS_ENTRY_VALIDf_SET(r,f) (r).xlmac_tx_timestamp_fifo_data[1]=(((r).xlmac_tx_timestamp_fifo_data[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))

/*
 * These macros can be used to access XLMAC_TX_TIMESTAMP_FIFO_DATA.
 */
#define WRITE_XLMAC_TX_TIMESTAMP_FIFO_DATAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TX_TIMESTAMP_FIFO_DATA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_tx_timestamp_fifo_data),2)
#define READ_XLMAC_TX_TIMESTAMP_FIFO_DATAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TX_TIMESTAMP_FIFO_DATA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_tx_timestamp_fifo_data),2)

/*******************************************************************************
 * End of 'XLMAC_TX_TIMESTAMP_FIFO_DATAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMAC_TX_TIMESTAMP_FIFO_STATUS
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Tx TimeStamp FIFO Status.
 * SIZE:     64
 * FIELDS:
 *     ENTRY_COUNT      Number of TX time stamps currently buffered in TX Time Stamp FIFO. A valid entry is popped out whenever XLMAC_TX_TIMESTMAP_FIFO_DATA is read
 */
#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TX_TIMESTAMP_FIFO_STATUS.
 */
typedef union XLMAC_TX_TIMESTAMP_FIFO_STATUSr_s {
	uint32 v[2];
	uint32 xlmac_tx_timestamp_fifo_status[2];
	uint32 _xlmac_tx_timestamp_fifo_status;
} XLMAC_TX_TIMESTAMP_FIFO_STATUSr_t;

#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_CLR(r) sal_memset(&((r)._xlmac_tx_timestamp_fifo_status), 0, sizeof(XLMAC_TX_TIMESTAMP_FIFO_STATUSr_t))
#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_SET(r,i,d) (r).xlmac_tx_timestamp_fifo_status[i] = d
#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_GET(r,i) (r).xlmac_tx_timestamp_fifo_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_ENTRY_COUNTf_GET(r) (((r).xlmac_tx_timestamp_fifo_status[0]) & 0x7)
#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_ENTRY_COUNTf_SET(r,f) (r).xlmac_tx_timestamp_fifo_status[0]=(((r).xlmac_tx_timestamp_fifo_status[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))

/*
 * These macros can be used to access XLMAC_TX_TIMESTAMP_FIFO_STATUS.
 */
#define WRITE_XLMAC_TX_TIMESTAMP_FIFO_STATUSr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TX_TIMESTAMP_FIFO_STATUS(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_tx_timestamp_fifo_status),2)
#define READ_XLMAC_TX_TIMESTAMP_FIFO_STATUSr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMAC_TX_TIMESTAMP_FIFO_STATUS(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmac_tx_timestamp_fifo_status),2)

/*******************************************************************************
 * End of 'XLMAC_TX_TIMESTAMP_FIFO_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_RBCA
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Receive Broadcast Frame Counter
 * SIZE:     64
 */
#define XLMIB_RBCAr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_RBCA.
 */
typedef union XLMIB_RBCAr_s {
	uint32 v[2];
	uint32 xlmib_rbca[2];
	uint32 _xlmib_rbca;
} XLMIB_RBCAr_t;

#define XLMIB_RBCAr_CLR(r) sal_memset(&((r)._xlmib_rbca), 0, sizeof(XLMIB_RBCAr_t))
#define XLMIB_RBCAr_SET(r,i,d) (r).xlmib_rbca[i] = d
#define XLMIB_RBCAr_GET(r,i) (r).xlmib_rbca[i]


/*
 * These macros can be used to access XLMIB_RBCA.
 */
#define WRITE_XLMIB_RBCAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RBCA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rbca),2)
#define READ_XLMIB_RBCAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RBCA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rbca),2)

/*******************************************************************************
 * End of 'XLMIB_RBCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_RBYT
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Receive Byte Counter
 * SIZE:     64
 */
#define XLMIB_RBYTr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_RBYT.
 */
typedef union XLMIB_RBYTr_s {
	uint32 v[2];
	uint32 xlmib_rbyt[2];
	uint32 _xlmib_rbyt;
} XLMIB_RBYTr_t;

#define XLMIB_RBYTr_CLR(r) sal_memset(&((r)._xlmib_rbyt), 0, sizeof(XLMIB_RBYTr_t))
#define XLMIB_RBYTr_SET(r,i,d) (r).xlmib_rbyt[i] = d
#define XLMIB_RBYTr_GET(r,i) (r).xlmib_rbyt[i]


/*
 * These macros can be used to access XLMIB_RBYT.
 */
#define WRITE_XLMIB_RBYTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RBYT(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rbyt),2)
#define READ_XLMIB_RBYTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RBYT(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rbyt),2)

/*******************************************************************************
 * End of 'XLMIB_RBYTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_RFCS
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Receive FCS Error Frame Counter
 * SIZE:     64
 */
#define XLMIB_RFCSr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_RFCS.
 */
typedef union XLMIB_RFCSr_s {
	uint32 v[2];
	uint32 xlmib_rfcs[2];
	uint32 _xlmib_rfcs;
} XLMIB_RFCSr_t;

#define XLMIB_RFCSr_CLR(r) sal_memset(&((r)._xlmib_rfcs), 0, sizeof(XLMIB_RFCSr_t))
#define XLMIB_RFCSr_SET(r,i,d) (r).xlmib_rfcs[i] = d
#define XLMIB_RFCSr_GET(r,i) (r).xlmib_rfcs[i]


/*
 * These macros can be used to access XLMIB_RFCS.
 */
#define WRITE_XLMIB_RFCSr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RFCS(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rfcs),2)
#define READ_XLMIB_RFCSr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RFCS(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rfcs),2)

/*******************************************************************************
 * End of 'XLMIB_RFCSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_RMCA
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Receive Multicast Frame Counter
 * SIZE:     64
 */
#define XLMIB_RMCAr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_RMCA.
 */
typedef union XLMIB_RMCAr_s {
	uint32 v[2];
	uint32 xlmib_rmca[2];
	uint32 _xlmib_rmca;
} XLMIB_RMCAr_t;

#define XLMIB_RMCAr_CLR(r) sal_memset(&((r)._xlmib_rmca), 0, sizeof(XLMIB_RMCAr_t))
#define XLMIB_RMCAr_SET(r,i,d) (r).xlmib_rmca[i] = d
#define XLMIB_RMCAr_GET(r,i) (r).xlmib_rmca[i]


/*
 * These macros can be used to access XLMIB_RMCA.
 */
#define WRITE_XLMIB_RMCAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RMCA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rmca),2)
#define READ_XLMIB_RMCAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RMCA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rmca),2)

/*******************************************************************************
 * End of 'XLMIB_RMCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_ROVR
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Receive Oversized Frame Counter
 * SIZE:     64
 */
#define XLMIB_ROVRr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_ROVR.
 */
typedef union XLMIB_ROVRr_s {
	uint32 v[2];
	uint32 xlmib_rovr[2];
	uint32 _xlmib_rovr;
} XLMIB_ROVRr_t;

#define XLMIB_ROVRr_CLR(r) sal_memset(&((r)._xlmib_rovr), 0, sizeof(XLMIB_ROVRr_t))
#define XLMIB_ROVRr_SET(r,i,d) (r).xlmib_rovr[i] = d
#define XLMIB_ROVRr_GET(r,i) (r).xlmib_rovr[i]


/*
 * These macros can be used to access XLMIB_ROVR.
 */
#define WRITE_XLMIB_ROVRr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_ROVR(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rovr),2)
#define READ_XLMIB_ROVRr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_ROVR(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rovr),2)

/*******************************************************************************
 * End of 'XLMIB_ROVRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_RPKT
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Receive frame/packet Counter
 * SIZE:     64
 */
#define XLMIB_RPKTr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_RPKT.
 */
typedef union XLMIB_RPKTr_s {
	uint32 v[2];
	uint32 xlmib_rpkt[2];
	uint32 _xlmib_rpkt;
} XLMIB_RPKTr_t;

#define XLMIB_RPKTr_CLR(r) sal_memset(&((r)._xlmib_rpkt), 0, sizeof(XLMIB_RPKTr_t))
#define XLMIB_RPKTr_SET(r,i,d) (r).xlmib_rpkt[i] = d
#define XLMIB_RPKTr_GET(r,i) (r).xlmib_rpkt[i]


/*
 * These macros can be used to access XLMIB_RPKT.
 */
#define WRITE_XLMIB_RPKTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RPKT(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rpkt),2)
#define READ_XLMIB_RPKTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RPKT(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rpkt),2)

/*******************************************************************************
 * End of 'XLMIB_RPKTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_RUCA
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Receive Unicast Frame Counter
 * SIZE:     64
 */
#define XLMIB_RUCAr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_RUCA.
 */
typedef union XLMIB_RUCAr_s {
	uint32 v[2];
	uint32 xlmib_ruca[2];
	uint32 _xlmib_ruca;
} XLMIB_RUCAr_t;

#define XLMIB_RUCAr_CLR(r) sal_memset(&((r)._xlmib_ruca), 0, sizeof(XLMIB_RUCAr_t))
#define XLMIB_RUCAr_SET(r,i,d) (r).xlmib_ruca[i] = d
#define XLMIB_RUCAr_GET(r,i) (r).xlmib_ruca[i]


/*
 * These macros can be used to access XLMIB_RUCA.
 */
#define WRITE_XLMIB_RUCAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RUCA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_ruca),2)
#define READ_XLMIB_RUCAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RUCA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_ruca),2)

/*******************************************************************************
 * End of 'XLMIB_RUCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_RXPF
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Receive PAUSE Frame Counter
 * SIZE:     64
 */
#define XLMIB_RXPFr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_RXPF.
 */
typedef union XLMIB_RXPFr_s {
	uint32 v[2];
	uint32 xlmib_rxpf[2];
	uint32 _xlmib_rxpf;
} XLMIB_RXPFr_t;

#define XLMIB_RXPFr_CLR(r) sal_memset(&((r)._xlmib_rxpf), 0, sizeof(XLMIB_RXPFr_t))
#define XLMIB_RXPFr_SET(r,i,d) (r).xlmib_rxpf[i] = d
#define XLMIB_RXPFr_GET(r,i) (r).xlmib_rxpf[i]


/*
 * These macros can be used to access XLMIB_RXPF.
 */
#define WRITE_XLMIB_RXPFr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RXPF(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rxpf),2)
#define READ_XLMIB_RXPFr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RXPF(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rxpf),2)

/*******************************************************************************
 * End of 'XLMIB_RXPFr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_RX_EEE_LPI_DURATION_COUNTER
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     RX EEE LPI Duration Counter
 * SIZE:     64
 */
#define XLMIB_RX_EEE_LPI_DURATION_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_RX_EEE_LPI_DURATION_COUNTER.
 */
typedef union XLMIB_RX_EEE_LPI_DURATION_COUNTERr_s {
	uint32 v[2];
	uint32 xlmib_rx_eee_lpi_duration_counter[2];
	uint32 _xlmib_rx_eee_lpi_duration_counter;
} XLMIB_RX_EEE_LPI_DURATION_COUNTERr_t;

#define XLMIB_RX_EEE_LPI_DURATION_COUNTERr_CLR(r) sal_memset(&((r)._xlmib_rx_eee_lpi_duration_counter), 0, sizeof(XLMIB_RX_EEE_LPI_DURATION_COUNTERr_t))
#define XLMIB_RX_EEE_LPI_DURATION_COUNTERr_SET(r,i,d) (r).xlmib_rx_eee_lpi_duration_counter[i] = d
#define XLMIB_RX_EEE_LPI_DURATION_COUNTERr_GET(r,i) (r).xlmib_rx_eee_lpi_duration_counter[i]


/*
 * These macros can be used to access XLMIB_RX_EEE_LPI_DURATION_COUNTER.
 */
#define WRITE_XLMIB_RX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RX_EEE_LPI_DURATION_COUNTER(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rx_eee_lpi_duration_counter),2)
#define READ_XLMIB_RX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RX_EEE_LPI_DURATION_COUNTER(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rx_eee_lpi_duration_counter),2)

/*******************************************************************************
 * End of 'XLMIB_RX_EEE_LPI_DURATION_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_RX_EEE_LPI_EVENT_COUNTER
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     RX EEE LPI Event Counter
 * SIZE:     64
 */
#define XLMIB_RX_EEE_LPI_EVENT_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_RX_EEE_LPI_EVENT_COUNTER.
 */
typedef union XLMIB_RX_EEE_LPI_EVENT_COUNTERr_s {
	uint32 v[2];
	uint32 xlmib_rx_eee_lpi_event_counter[2];
	uint32 _xlmib_rx_eee_lpi_event_counter;
} XLMIB_RX_EEE_LPI_EVENT_COUNTERr_t;

#define XLMIB_RX_EEE_LPI_EVENT_COUNTERr_CLR(r) sal_memset(&((r)._xlmib_rx_eee_lpi_event_counter), 0, sizeof(XLMIB_RX_EEE_LPI_EVENT_COUNTERr_t))
#define XLMIB_RX_EEE_LPI_EVENT_COUNTERr_SET(r,i,d) (r).xlmib_rx_eee_lpi_event_counter[i] = d
#define XLMIB_RX_EEE_LPI_EVENT_COUNTERr_GET(r,i) (r).xlmib_rx_eee_lpi_event_counter[i]


/*
 * These macros can be used to access XLMIB_RX_EEE_LPI_EVENT_COUNTER.
 */
#define WRITE_XLMIB_RX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RX_EEE_LPI_EVENT_COUNTER(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rx_eee_lpi_event_counter),2)
#define READ_XLMIB_RX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_RX_EEE_LPI_EVENT_COUNTER(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_rx_eee_lpi_event_counter),2)

/*******************************************************************************
 * End of 'XLMIB_RX_EEE_LPI_EVENT_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_TBCA
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Transmit Broadcast Frame Counter
 * SIZE:     64
 */
#define XLMIB_TBCAr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_TBCA.
 */
typedef union XLMIB_TBCAr_s {
	uint32 v[2];
	uint32 xlmib_tbca[2];
	uint32 _xlmib_tbca;
} XLMIB_TBCAr_t;

#define XLMIB_TBCAr_CLR(r) sal_memset(&((r)._xlmib_tbca), 0, sizeof(XLMIB_TBCAr_t))
#define XLMIB_TBCAr_SET(r,i,d) (r).xlmib_tbca[i] = d
#define XLMIB_TBCAr_GET(r,i) (r).xlmib_tbca[i]


/*
 * These macros can be used to access XLMIB_TBCA.
 */
#define WRITE_XLMIB_TBCAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TBCA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tbca),2)
#define READ_XLMIB_TBCAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TBCA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tbca),2)

/*******************************************************************************
 * End of 'XLMIB_TBCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_TBYT
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Transmit Byte Counter
 * SIZE:     64
 */
#define XLMIB_TBYTr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_TBYT.
 */
typedef union XLMIB_TBYTr_s {
	uint32 v[2];
	uint32 xlmib_tbyt[2];
	uint32 _xlmib_tbyt;
} XLMIB_TBYTr_t;

#define XLMIB_TBYTr_CLR(r) sal_memset(&((r)._xlmib_tbyt), 0, sizeof(XLMIB_TBYTr_t))
#define XLMIB_TBYTr_SET(r,i,d) (r).xlmib_tbyt[i] = d
#define XLMIB_TBYTr_GET(r,i) (r).xlmib_tbyt[i]


/*
 * These macros can be used to access XLMIB_TBYT.
 */
#define WRITE_XLMIB_TBYTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TBYT(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tbyt),2)
#define READ_XLMIB_TBYTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TBYT(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tbyt),2)

/*******************************************************************************
 * End of 'XLMIB_TBYTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_TFCS
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Transmit FCS Error Counter
 * SIZE:     64
 */
#define XLMIB_TFCSr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_TFCS.
 */
typedef union XLMIB_TFCSr_s {
	uint32 v[2];
	uint32 xlmib_tfcs[2];
	uint32 _xlmib_tfcs;
} XLMIB_TFCSr_t;

#define XLMIB_TFCSr_CLR(r) sal_memset(&((r)._xlmib_tfcs), 0, sizeof(XLMIB_TFCSr_t))
#define XLMIB_TFCSr_SET(r,i,d) (r).xlmib_tfcs[i] = d
#define XLMIB_TFCSr_GET(r,i) (r).xlmib_tfcs[i]


/*
 * These macros can be used to access XLMIB_TFCS.
 */
#define WRITE_XLMIB_TFCSr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TFCS(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tfcs),2)
#define READ_XLMIB_TFCSr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TFCS(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tfcs),2)

/*******************************************************************************
 * End of 'XLMIB_TFCSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_TMCA
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Transmit Multicast Frame Counter
 * SIZE:     64
 */
#define XLMIB_TMCAr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_TMCA.
 */
typedef union XLMIB_TMCAr_s {
	uint32 v[2];
	uint32 xlmib_tmca[2];
	uint32 _xlmib_tmca;
} XLMIB_TMCAr_t;

#define XLMIB_TMCAr_CLR(r) sal_memset(&((r)._xlmib_tmca), 0, sizeof(XLMIB_TMCAr_t))
#define XLMIB_TMCAr_SET(r,i,d) (r).xlmib_tmca[i] = d
#define XLMIB_TMCAr_GET(r,i) (r).xlmib_tmca[i]


/*
 * These macros can be used to access XLMIB_TMCA.
 */
#define WRITE_XLMIB_TMCAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TMCA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tmca),2)
#define READ_XLMIB_TMCAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TMCA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tmca),2)

/*******************************************************************************
 * End of 'XLMIB_TMCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_TOVR
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Transmit Oversize Packet Counter
 * SIZE:     64
 */
#define XLMIB_TOVRr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_TOVR.
 */
typedef union XLMIB_TOVRr_s {
	uint32 v[2];
	uint32 xlmib_tovr[2];
	uint32 _xlmib_tovr;
} XLMIB_TOVRr_t;

#define XLMIB_TOVRr_CLR(r) sal_memset(&((r)._xlmib_tovr), 0, sizeof(XLMIB_TOVRr_t))
#define XLMIB_TOVRr_SET(r,i,d) (r).xlmib_tovr[i] = d
#define XLMIB_TOVRr_GET(r,i) (r).xlmib_tovr[i]


/*
 * These macros can be used to access XLMIB_TOVR.
 */
#define WRITE_XLMIB_TOVRr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TOVR(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tovr),2)
#define READ_XLMIB_TOVRr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TOVR(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tovr),2)

/*******************************************************************************
 * End of 'XLMIB_TOVRr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_TPKT
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Transmit Packet/Frame Counter
 * SIZE:     64
 */
#define XLMIB_TPKTr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_TPKT.
 */
typedef union XLMIB_TPKTr_s {
	uint32 v[2];
	uint32 xlmib_tpkt[2];
	uint32 _xlmib_tpkt;
} XLMIB_TPKTr_t;

#define XLMIB_TPKTr_CLR(r) sal_memset(&((r)._xlmib_tpkt), 0, sizeof(XLMIB_TPKTr_t))
#define XLMIB_TPKTr_SET(r,i,d) (r).xlmib_tpkt[i] = d
#define XLMIB_TPKTr_GET(r,i) (r).xlmib_tpkt[i]


/*
 * These macros can be used to access XLMIB_TPKT.
 */
#define WRITE_XLMIB_TPKTr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TPKT(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tpkt),2)
#define READ_XLMIB_TPKTr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TPKT(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tpkt),2)

/*******************************************************************************
 * End of 'XLMIB_TPKTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_TUCA
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Transmit Unicast Frame Counter
 * SIZE:     64
 */
#define XLMIB_TUCAr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_TUCA.
 */
typedef union XLMIB_TUCAr_s {
	uint32 v[2];
	uint32 xlmib_tuca[2];
	uint32 _xlmib_tuca;
} XLMIB_TUCAr_t;

#define XLMIB_TUCAr_CLR(r) sal_memset(&((r)._xlmib_tuca), 0, sizeof(XLMIB_TUCAr_t))
#define XLMIB_TUCAr_SET(r,i,d) (r).xlmib_tuca[i] = d
#define XLMIB_TUCAr_GET(r,i) (r).xlmib_tuca[i]


/*
 * These macros can be used to access XLMIB_TUCA.
 */
#define WRITE_XLMIB_TUCAr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TUCA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tuca),2)
#define READ_XLMIB_TUCAr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TUCA(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tuca),2)

/*******************************************************************************
 * End of 'XLMIB_TUCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_TXPF
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Transmit Pause Control Frame Counter
 * SIZE:     64
 */
#define XLMIB_TXPFr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_TXPF.
 */
typedef union XLMIB_TXPFr_s {
	uint32 v[2];
	uint32 xlmib_txpf[2];
	uint32 _xlmib_txpf;
} XLMIB_TXPFr_t;

#define XLMIB_TXPFr_CLR(r) sal_memset(&((r)._xlmib_txpf), 0, sizeof(XLMIB_TXPFr_t))
#define XLMIB_TXPFr_SET(r,i,d) (r).xlmib_txpf[i] = d
#define XLMIB_TXPFr_GET(r,i) (r).xlmib_txpf[i]


/*
 * These macros can be used to access XLMIB_TXPF.
 */
#define WRITE_XLMIB_TXPFr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TXPF(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_txpf),2)
#define READ_XLMIB_TXPFr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TXPF(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_txpf),2)

/*******************************************************************************
 * End of 'XLMIB_TXPFr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_TX_EEE_LPI_DURATION_COUNTER
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     TX EEE LPI Duration Counter
 * SIZE:     64
 */
#define XLMIB_TX_EEE_LPI_DURATION_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_TX_EEE_LPI_DURATION_COUNTER.
 */
typedef union XLMIB_TX_EEE_LPI_DURATION_COUNTERr_s {
	uint32 v[2];
	uint32 xlmib_tx_eee_lpi_duration_counter[2];
	uint32 _xlmib_tx_eee_lpi_duration_counter;
} XLMIB_TX_EEE_LPI_DURATION_COUNTERr_t;

#define XLMIB_TX_EEE_LPI_DURATION_COUNTERr_CLR(r) sal_memset(&((r)._xlmib_tx_eee_lpi_duration_counter), 0, sizeof(XLMIB_TX_EEE_LPI_DURATION_COUNTERr_t))
#define XLMIB_TX_EEE_LPI_DURATION_COUNTERr_SET(r,i,d) (r).xlmib_tx_eee_lpi_duration_counter[i] = d
#define XLMIB_TX_EEE_LPI_DURATION_COUNTERr_GET(r,i) (r).xlmib_tx_eee_lpi_duration_counter[i]


/*
 * These macros can be used to access XLMIB_TX_EEE_LPI_DURATION_COUNTER.
 */
#define WRITE_XLMIB_TX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TX_EEE_LPI_DURATION_COUNTER(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tx_eee_lpi_duration_counter),2)
#define READ_XLMIB_TX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TX_EEE_LPI_DURATION_COUNTER(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tx_eee_lpi_duration_counter),2)

/*******************************************************************************
 * End of 'XLMIB_TX_EEE_LPI_DURATION_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLMIB_TX_EEE_LPI_EVENT_COUNTER
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     TX EEE LPI Event Counter
 * SIZE:     64
 */
#define XLMIB_TX_EEE_LPI_EVENT_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program XLMIB_TX_EEE_LPI_EVENT_COUNTER.
 */
typedef union XLMIB_TX_EEE_LPI_EVENT_COUNTERr_s {
	uint32 v[2];
	uint32 xlmib_tx_eee_lpi_event_counter[2];
	uint32 _xlmib_tx_eee_lpi_event_counter;
} XLMIB_TX_EEE_LPI_EVENT_COUNTERr_t;

#define XLMIB_TX_EEE_LPI_EVENT_COUNTERr_CLR(r) sal_memset(&((r)._xlmib_tx_eee_lpi_event_counter), 0, sizeof(XLMIB_TX_EEE_LPI_EVENT_COUNTERr_t))
#define XLMIB_TX_EEE_LPI_EVENT_COUNTERr_SET(r,i,d) (r).xlmib_tx_eee_lpi_event_counter[i] = d
#define XLMIB_TX_EEE_LPI_EVENT_COUNTERr_GET(r,i) (r).xlmib_tx_eee_lpi_event_counter[i]


/*
 * These macros can be used to access XLMIB_TX_EEE_LPI_EVENT_COUNTER.
 */
#define WRITE_XLMIB_TX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5607x_reg64_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TX_EEE_LPI_EVENT_COUNTER(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tx_eee_lpi_event_counter),2)
#define READ_XLMIB_TX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5607x_reg64_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLMIB_TX_EEE_LPI_EVENT_COUNTER(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlmib_tx_eee_lpi_event_counter),2)

/*******************************************************************************
 * End of 'XLMIB_TX_EEE_LPI_EVENT_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLPORT_CNTMAXSIZE
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     PORT MIB logic CNTMAXSIZE register
 * SIZE:     32
 * FIELDS:
 *     CNTMAXSIZE       The max packet size that is used in statistic counter update. Default to 1518.
 */
#define XLPORT_CNTMAXSIZEr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_CNTMAXSIZE.
 */
typedef union XLPORT_CNTMAXSIZEr_s {
	uint32 v[1];
	uint32 xlport_cntmaxsize[1];
	uint32 _xlport_cntmaxsize;
} XLPORT_CNTMAXSIZEr_t;

#define XLPORT_CNTMAXSIZEr_CLR(r) (r).xlport_cntmaxsize[0] = 0
#define XLPORT_CNTMAXSIZEr_SET(r,d) (r).xlport_cntmaxsize[0] = d
#define XLPORT_CNTMAXSIZEr_GET(r) (r).xlport_cntmaxsize[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET(r) (((r).xlport_cntmaxsize[0]) & 0x3fff)
#define XLPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET(r,f) (r).xlport_cntmaxsize[0]=(((r).xlport_cntmaxsize[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))

/*
 * These macros can be used to access XLPORT_CNTMAXSIZE.
 */
#define WRITE_XLPORT_CNTMAXSIZEr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_CNTMAXSIZE(bcm5607x_xlport_lport_to_index_in_block[p]), (r._xlport_cntmaxsize))
#define READ_XLPORT_CNTMAXSIZEr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_CNTMAXSIZE(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlport_cntmaxsize))

/*******************************************************************************
 * End of 'XLPORT_CNTMAXSIZEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLPORT_ENABLE_REG
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     XLPORT Enable Register.  In an XLPORT instance, enables subports 0..3 
 * SIZE:     32
 * FIELDS:
 *     PORT0            Enable Sub-Port 0.  
 *     PORT1            Enable Sub-Port 1.  
 *     PORT2            Enable Sub-Port 2.  
 *     PORT3            Enable Sub-Port 3.  
 */
#define XLPORT_ENABLE_REGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_ENABLE_REG.
 */
typedef union XLPORT_ENABLE_REGr_s {
	uint32 v[1];
	uint32 xlport_enable_reg[1];
	uint32 _xlport_enable_reg;
} XLPORT_ENABLE_REGr_t;

#define XLPORT_ENABLE_REGr_CLR(r) (r).xlport_enable_reg[0] = 0
#define XLPORT_ENABLE_REGr_SET(r,d) (r).xlport_enable_reg[0] = d
#define XLPORT_ENABLE_REGr_GET(r) (r).xlport_enable_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_ENABLE_REGr_PORT0f_GET(r) (((r).xlport_enable_reg[0]) & 0x1)
#define XLPORT_ENABLE_REGr_PORT0f_SET(r,f) (r).xlport_enable_reg[0]=(((r).xlport_enable_reg[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLPORT_ENABLE_REGr_PORT1f_GET(r) ((((r).xlport_enable_reg[0]) >> 1) & 0x1)
#define XLPORT_ENABLE_REGr_PORT1f_SET(r,f) (r).xlport_enable_reg[0]=(((r).xlport_enable_reg[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define XLPORT_ENABLE_REGr_PORT2f_GET(r) ((((r).xlport_enable_reg[0]) >> 2) & 0x1)
#define XLPORT_ENABLE_REGr_PORT2f_SET(r,f) (r).xlport_enable_reg[0]=(((r).xlport_enable_reg[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define XLPORT_ENABLE_REGr_PORT3f_GET(r) ((((r).xlport_enable_reg[0]) >> 3) & 0x1)
#define XLPORT_ENABLE_REGr_PORT3f_SET(r,f) (r).xlport_enable_reg[0]=(((r).xlport_enable_reg[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))

/*
 * These macros can be used to access XLPORT_ENABLE_REG.
 */
#define WRITE_XLPORT_ENABLE_REGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_ENABLE_REG, (r._xlport_enable_reg))
#define READ_XLPORT_ENABLE_REGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_ENABLE_REG, &(r._xlport_enable_reg))

/*******************************************************************************
 * End of 'XLPORT_ENABLE_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLPORT_FAULT_LINK_STATUS
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Config to use Fault to gate external Link Status signals to CMIC
 * SIZE:     32
 * FIELDS:
 *     REMOTE_FAULT     If enabled, allows external Remote Fault signal to indicate link is down to CMIC.
 *     LOCAL_FAULT      If enabled, allows Local Fault signal to indicate link is down to CMIC.
 */
#define XLPORT_FAULT_LINK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_FAULT_LINK_STATUS.
 */
typedef union XLPORT_FAULT_LINK_STATUSr_s {
	uint32 v[1];
	uint32 xlport_fault_link_status[1];
	uint32 _xlport_fault_link_status;
} XLPORT_FAULT_LINK_STATUSr_t;

#define XLPORT_FAULT_LINK_STATUSr_CLR(r) (r).xlport_fault_link_status[0] = 0
#define XLPORT_FAULT_LINK_STATUSr_SET(r,d) (r).xlport_fault_link_status[0] = d
#define XLPORT_FAULT_LINK_STATUSr_GET(r) (r).xlport_fault_link_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_FAULT_LINK_STATUSr_REMOTE_FAULTf_GET(r) (((r).xlport_fault_link_status[0]) & 0x1)
#define XLPORT_FAULT_LINK_STATUSr_REMOTE_FAULTf_SET(r,f) (r).xlport_fault_link_status[0]=(((r).xlport_fault_link_status[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLPORT_FAULT_LINK_STATUSr_LOCAL_FAULTf_GET(r) ((((r).xlport_fault_link_status[0]) >> 1) & 0x1)
#define XLPORT_FAULT_LINK_STATUSr_LOCAL_FAULTf_SET(r,f) (r).xlport_fault_link_status[0]=(((r).xlport_fault_link_status[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access XLPORT_FAULT_LINK_STATUS.
 */
#define WRITE_XLPORT_FAULT_LINK_STATUSr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_FAULT_LINK_STATUS(bcm5607x_xlport_lport_to_index_in_block[p]), (r._xlport_fault_link_status))
#define READ_XLPORT_FAULT_LINK_STATUSr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_FAULT_LINK_STATUS(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlport_fault_link_status))

/*******************************************************************************
 * End of 'XLPORT_FAULT_LINK_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLPORT_LED_CHAIN_CONFIG
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     PORT LED Chain stagging flop config register
 * SIZE:     32
 * FIELDS:
 *     INTRA_DELAY      Select Intra-Port delay for each subports in PORT block.  (In core clock cycles based on Inter PORT block stagging delay at chip level).  Valid range is 0 to 10 clock delay.
 */
#define XLPORT_LED_CHAIN_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_LED_CHAIN_CONFIG.
 */
typedef union XLPORT_LED_CHAIN_CONFIGr_s {
	uint32 v[1];
	uint32 xlport_led_chain_config[1];
	uint32 _xlport_led_chain_config;
} XLPORT_LED_CHAIN_CONFIGr_t;

#define XLPORT_LED_CHAIN_CONFIGr_CLR(r) (r).xlport_led_chain_config[0] = 0
#define XLPORT_LED_CHAIN_CONFIGr_SET(r,d) (r).xlport_led_chain_config[0] = d
#define XLPORT_LED_CHAIN_CONFIGr_GET(r) (r).xlport_led_chain_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_LED_CHAIN_CONFIGr_INTRA_DELAYf_GET(r) (((r).xlport_led_chain_config[0]) & 0xf)
#define XLPORT_LED_CHAIN_CONFIGr_INTRA_DELAYf_SET(r,f) (r).xlport_led_chain_config[0]=(((r).xlport_led_chain_config[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))

/*
 * These macros can be used to access XLPORT_LED_CHAIN_CONFIG.
 */
#define WRITE_XLPORT_LED_CHAIN_CONFIGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_LED_CHAIN_CONFIG, (r._xlport_led_chain_config))
#define READ_XLPORT_LED_CHAIN_CONFIGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_LED_CHAIN_CONFIG, &(r._xlport_led_chain_config))

/*******************************************************************************
 * End of 'XLPORT_LED_CHAIN_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLPORT_MAC_CONTROL
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     XLPORT MAC Control Register
 * SIZE:     32
 * FIELDS:
 *     XMAC0_RESET      Software control XLMAC in XLPORT reset (active High).
 *     XMAC0_BYPASS_OSTS Bypass OSTS path in XLMAC to improve latency.
 *     RX_FLEX_TDM_ENABLE Enable XLMAC flexible tdm for less latency.
 *     RX_NON_LINEAR_QUAD_TDM_EN Enable CLMAC non-linear tdm order 0-2-1-3.
 *     RESERVED_4       reserved
 *     RX_DUAL_CYCLE_TDM_EN When set, RX CDC FIFO port ID read TDM order will change only on even cycles, ie each port is valid for 2 consecutive cycles.ie When set, order is 0 -> 0 -> 1 -> 1 -> 2 -> 2 -> 3 -> 3. Else, order is 0 -> 1 -> 2 -> 3 -> 0 -> 1 -> 2 -> 3.
 */
#define XLPORT_MAC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_MAC_CONTROL.
 */
typedef union XLPORT_MAC_CONTROLr_s {
	uint32 v[1];
	uint32 xlport_mac_control[1];
	uint32 _xlport_mac_control;
} XLPORT_MAC_CONTROLr_t;

#define XLPORT_MAC_CONTROLr_CLR(r) (r).xlport_mac_control[0] = 0
#define XLPORT_MAC_CONTROLr_SET(r,d) (r).xlport_mac_control[0] = d
#define XLPORT_MAC_CONTROLr_GET(r) (r).xlport_mac_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_MAC_CONTROLr_XMAC0_RESETf_GET(r) (((r).xlport_mac_control[0]) & 0x1)
#define XLPORT_MAC_CONTROLr_XMAC0_RESETf_SET(r,f) (r).xlport_mac_control[0]=(((r).xlport_mac_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLPORT_MAC_CONTROLr_XMAC0_BYPASS_OSTSf_GET(r) ((((r).xlport_mac_control[0]) >> 1) & 0x1)
#define XLPORT_MAC_CONTROLr_XMAC0_BYPASS_OSTSf_SET(r,f) (r).xlport_mac_control[0]=(((r).xlport_mac_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define XLPORT_MAC_CONTROLr_RX_FLEX_TDM_ENABLEf_GET(r) ((((r).xlport_mac_control[0]) >> 2) & 0x1)
#define XLPORT_MAC_CONTROLr_RX_FLEX_TDM_ENABLEf_SET(r,f) (r).xlport_mac_control[0]=(((r).xlport_mac_control[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define XLPORT_MAC_CONTROLr_RX_NON_LINEAR_QUAD_TDM_ENf_GET(r) ((((r).xlport_mac_control[0]) >> 3) & 0x1)
#define XLPORT_MAC_CONTROLr_RX_NON_LINEAR_QUAD_TDM_ENf_SET(r,f) (r).xlport_mac_control[0]=(((r).xlport_mac_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define XLPORT_MAC_CONTROLr_RESERVED_4f_GET(r) ((((r).xlport_mac_control[0]) >> 4) & 0x1)
#define XLPORT_MAC_CONTROLr_RESERVED_4f_SET(r,f) (r).xlport_mac_control[0]=(((r).xlport_mac_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define XLPORT_MAC_CONTROLr_RX_DUAL_CYCLE_TDM_ENf_GET(r) ((((r).xlport_mac_control[0]) >> 5) & 0x1)
#define XLPORT_MAC_CONTROLr_RX_DUAL_CYCLE_TDM_ENf_SET(r,f) (r).xlport_mac_control[0]=(((r).xlport_mac_control[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))

/*
 * These macros can be used to access XLPORT_MAC_CONTROL.
 */
#define WRITE_XLPORT_MAC_CONTROLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_MAC_CONTROL, (r._xlport_mac_control))
#define READ_XLPORT_MAC_CONTROLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_MAC_CONTROL, &(r._xlport_mac_control))

/*******************************************************************************
 * End of 'XLPORT_MAC_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLPORT_MAC_RSV_MASK
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     MAC RSV MASK Register
 * SIZE:     32
 * FIELDS:
 *     MASK             Control which RSV event cause "purge" event that triggers RXERR to be set for the packet by the MAC.Valid for XLMAC.  Drives rsv_err_mask[37:16] for XLMAC.These bits are used to mask RSV[37:16] for XLMAC.Below is one snapshot of how MASK bits are mapped to each MAC.  Please refer to XLMAC spec for latest RSV bit definitions.bit[31:22]            --> Reservedbit[21] masks RSV[37] --> Dribble Nibble Error detectedbit[20] masks RSV[36] --> MACSEC CRC Match detectedbit[19] masks RSV[35] --> SCH CRC Error detectedbit[18] masks RSV[34] --> PFC frame detectedbit[17] masks RSV[33] --> RUNT detectedbit[16] masks RSV[32] --> RX FIFO fullbit[15] masks RSV[31] --> Unicast detectedbit[14] masks RSV[30] --> VLAN tag detectedbit[13] masks RSV[29] --> Unsupported opcode detectedbit[12] masks RSV[28] --> Pause frame receivedbit[11] masks RSV[27] --> Control frame receivedbit[10] masks RSV[26] --> Promiscuous packet detectedbit[ 9] masks RSV[25] --> Broadcast detectedbit[ 8] masks RSV[24] --> Multicast detectedbit[ 7] masks RSV[23] --> Receive OKbit[ 6] masks RSV[22] --> Truncated/Frame out of Rangebit[ 5] masks RSV[21] --> Frame length not out of range, but incorrect -- IEEE length check failedbit[ 4] masks RSV[20] --> CRC errorbit[ 3] masks RSV[19] --> Receive terminate/code errorbit[ 2] masks RSV[18] --> Unsupported DA for pause/PFC packets detectedbit[ 1] masks RSV[17] --> Stack VLAN detectedbit[ 0] masks RSV[16] --> Wrong SA
 */
#define XLPORT_MAC_RSV_MASKr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_MAC_RSV_MASK.
 */
typedef union XLPORT_MAC_RSV_MASKr_s {
	uint32 v[1];
	uint32 xlport_mac_rsv_mask[1];
	uint32 _xlport_mac_rsv_mask;
} XLPORT_MAC_RSV_MASKr_t;

#define XLPORT_MAC_RSV_MASKr_CLR(r) (r).xlport_mac_rsv_mask[0] = 0
#define XLPORT_MAC_RSV_MASKr_SET(r,d) (r).xlport_mac_rsv_mask[0] = d
#define XLPORT_MAC_RSV_MASKr_GET(r) (r).xlport_mac_rsv_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_MAC_RSV_MASKr_MASKf_GET(r) ((r).xlport_mac_rsv_mask[0])
#define XLPORT_MAC_RSV_MASKr_MASKf_SET(r,f) (r).xlport_mac_rsv_mask[0]=((uint32)f)

/*
 * These macros can be used to access XLPORT_MAC_RSV_MASK.
 */
#define WRITE_XLPORT_MAC_RSV_MASKr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_MAC_RSV_MASK(bcm5607x_xlport_lport_to_index_in_block[p]), (r._xlport_mac_rsv_mask))
#define READ_XLPORT_MAC_RSV_MASKr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_MAC_RSV_MASK(bcm5607x_xlport_lport_to_index_in_block[p]), &(r._xlport_mac_rsv_mask))

/*******************************************************************************
 * End of 'XLPORT_MAC_RSV_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLPORT_MIB_RESET
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     XLPORT MIB Counters Reset
 * SIZE:     32
 * FIELDS:
 *     CLR_CNT          Reset for XLPORT per subport MIB Statistic Countersbit[3]  = Port 3 MIB all counters resetbit[2]  = Port 2 MIB all counters resetbit[1]  = Port 1 MIB all counters resetbit[0]  = Port 0 MIB all counters reset
 */
#define XLPORT_MIB_RESETr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_MIB_RESET.
 */
typedef union XLPORT_MIB_RESETr_s {
	uint32 v[1];
	uint32 xlport_mib_reset[1];
	uint32 _xlport_mib_reset;
} XLPORT_MIB_RESETr_t;

#define XLPORT_MIB_RESETr_CLR(r) (r).xlport_mib_reset[0] = 0
#define XLPORT_MIB_RESETr_SET(r,d) (r).xlport_mib_reset[0] = d
#define XLPORT_MIB_RESETr_GET(r) (r).xlport_mib_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_MIB_RESETr_CLR_CNTf_GET(r) (((r).xlport_mib_reset[0]) & 0xf)
#define XLPORT_MIB_RESETr_CLR_CNTf_SET(r,f) (r).xlport_mib_reset[0]=(((r).xlport_mib_reset[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))

/*
 * These macros can be used to access XLPORT_MIB_RESET.
 */
#define WRITE_XLPORT_MIB_RESETr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_MIB_RESET, (r._xlport_mib_reset))
#define READ_XLPORT_MIB_RESETr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_MIB_RESET, &(r._xlport_mib_reset))

/*******************************************************************************
 * End of 'XLPORT_MIB_RESETr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLPORT_MODE_REG
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     PORT Mode Register
 * SIZE:     32
 * FIELDS:
 *     XPORT0_PHY_PORT_MODE XLPort PHY Side Port Mode.  Applies to one of xlport0..3 depending on sbus block id. This has no effect in CPORT
 *     XPORT0_CORE_PORT_MODE XLPort Core CORE Side Port Mode.  Applies to one of xlport0..3 depending on sbus block id.
 *     EGR_1588_TIMESTAMPING_MODE enables legacy sign-extension of 32-bit timestamp or enables 48-bit time-stamping. default is 32-bit.
 *     OSTS_TIMER_DISABLE This active high signal is used to disable the OSTS time-stamping function in the MAC when asserted during the time the CPU Is initializing the local counters
 *     TS_TIMER_OVERRIDE write 1 to select TS_TIMER_OVERRIDE_VALUE[31:0] to XLMAC, instead of TS_TIMER_VALUE from CMIC, the ts_counter loads TS_TIMER_OVERRIDE_VALUE when setting this bit to 1, ts_counter continue to incremet with ts_clk, set this bit to 0 to use original TS_TIMER_VALUE[31:0] from CMIC
 *     EGR_1588_TIMESTAMPING_CMIC_48_EN write 1 to select CMIC's TS_TIMER_OVERRIDE_VALUE[47:0] to XLMAC. When set to 1, it will override TS_TIMER_OVERRIDE function.
 */
#define XLPORT_MODE_REGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_MODE_REG.
 */
typedef union XLPORT_MODE_REGr_s {
	uint32 v[1];
	uint32 xlport_mode_reg[1];
	uint32 _xlport_mode_reg;
} XLPORT_MODE_REGr_t;

#define XLPORT_MODE_REGr_CLR(r) (r).xlport_mode_reg[0] = 0
#define XLPORT_MODE_REGr_SET(r,d) (r).xlport_mode_reg[0] = d
#define XLPORT_MODE_REGr_GET(r) (r).xlport_mode_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_MODE_REGr_XPORT0_PHY_PORT_MODEf_GET(r) (((r).xlport_mode_reg[0]) & 0x7)
#define XLPORT_MODE_REGr_XPORT0_PHY_PORT_MODEf_SET(r,f) (r).xlport_mode_reg[0]=(((r).xlport_mode_reg[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define XLPORT_MODE_REGr_XPORT0_CORE_PORT_MODEf_GET(r) ((((r).xlport_mode_reg[0]) >> 3) & 0x7)
#define XLPORT_MODE_REGr_XPORT0_CORE_PORT_MODEf_SET(r,f) (r).xlport_mode_reg[0]=(((r).xlport_mode_reg[0] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define XLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_MODEf_GET(r) ((((r).xlport_mode_reg[0]) >> 6) & 0x1)
#define XLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_MODEf_SET(r,f) (r).xlport_mode_reg[0]=(((r).xlport_mode_reg[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define XLPORT_MODE_REGr_OSTS_TIMER_DISABLEf_GET(r) ((((r).xlport_mode_reg[0]) >> 7) & 0x1)
#define XLPORT_MODE_REGr_OSTS_TIMER_DISABLEf_SET(r,f) (r).xlport_mode_reg[0]=(((r).xlport_mode_reg[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define XLPORT_MODE_REGr_TS_TIMER_OVERRIDEf_GET(r) ((((r).xlport_mode_reg[0]) >> 8) & 0x1)
#define XLPORT_MODE_REGr_TS_TIMER_OVERRIDEf_SET(r,f) (r).xlport_mode_reg[0]=(((r).xlport_mode_reg[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define XLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_CMIC_48_ENf_GET(r) ((((r).xlport_mode_reg[0]) >> 9) & 0x1)
#define XLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_CMIC_48_ENf_SET(r,f) (r).xlport_mode_reg[0]=(((r).xlport_mode_reg[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))

/*
 * These macros can be used to access XLPORT_MODE_REG.
 */
#define WRITE_XLPORT_MODE_REGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_MODE_REG, (r._xlport_mode_reg))
#define READ_XLPORT_MODE_REGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_MODE_REG, &(r._xlport_mode_reg))

/*******************************************************************************
 * End of 'XLPORT_MODE_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLPORT_SOFT_RESET
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Deprecated. PORT Soft Reset per subport XLPORT CORE block.  Active high signal. 
 * SIZE:     32
 * FIELDS:
 *     PORT0            Reset Sub-Port 0.  
 *     PORT1            Reset Sub-Port 1.  
 *     PORT2            Reset Sub-Port 2.  
 *     PORT3            Reset Sub-Port 3.  
 *     RESERVED4        Reserved.
 */
#define XLPORT_SOFT_RESETr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_SOFT_RESET.
 */
typedef union XLPORT_SOFT_RESETr_s {
	uint32 v[1];
	uint32 xlport_soft_reset[1];
	uint32 _xlport_soft_reset;
} XLPORT_SOFT_RESETr_t;

#define XLPORT_SOFT_RESETr_CLR(r) (r).xlport_soft_reset[0] = 0
#define XLPORT_SOFT_RESETr_SET(r,d) (r).xlport_soft_reset[0] = d
#define XLPORT_SOFT_RESETr_GET(r) (r).xlport_soft_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_SOFT_RESETr_PORT0f_GET(r) (((r).xlport_soft_reset[0]) & 0x1)
#define XLPORT_SOFT_RESETr_PORT0f_SET(r,f) (r).xlport_soft_reset[0]=(((r).xlport_soft_reset[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLPORT_SOFT_RESETr_PORT1f_GET(r) ((((r).xlport_soft_reset[0]) >> 1) & 0x1)
#define XLPORT_SOFT_RESETr_PORT1f_SET(r,f) (r).xlport_soft_reset[0]=(((r).xlport_soft_reset[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define XLPORT_SOFT_RESETr_PORT2f_GET(r) ((((r).xlport_soft_reset[0]) >> 2) & 0x1)
#define XLPORT_SOFT_RESETr_PORT2f_SET(r,f) (r).xlport_soft_reset[0]=(((r).xlport_soft_reset[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define XLPORT_SOFT_RESETr_PORT3f_GET(r) ((((r).xlport_soft_reset[0]) >> 3) & 0x1)
#define XLPORT_SOFT_RESETr_PORT3f_SET(r,f) (r).xlport_soft_reset[0]=(((r).xlport_soft_reset[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define XLPORT_SOFT_RESETr_RESERVED4f_GET(r) ((((r).xlport_soft_reset[0]) >> 4) & 0x1)
#define XLPORT_SOFT_RESETr_RESERVED4f_SET(r,f) (r).xlport_soft_reset[0]=(((r).xlport_soft_reset[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))

/*
 * These macros can be used to access XLPORT_SOFT_RESET.
 */
#define WRITE_XLPORT_SOFT_RESETr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_SOFT_RESET, (r._xlport_soft_reset))
#define READ_XLPORT_SOFT_RESETr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_SOFT_RESET, &(r._xlport_soft_reset))

/*******************************************************************************
 * End of 'XLPORT_SOFT_RESETr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLPORT_WC_UCMEM_CTRL
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     PORT to TSC micro-controller Memory (extmem) Control Register.  Configures FSM in Port.
 * SIZE:     32
 * FIELDS:
 *     ACCESS_MODE      External Memory Controls Access   1'b0 - access registers in TSC   1'b1 - access ucode memory in TSC
 *     RSVD3_1          reserved
 */
#define XLPORT_WC_UCMEM_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_WC_UCMEM_CTRL.
 */
typedef union XLPORT_WC_UCMEM_CTRLr_s {
	uint32 v[1];
	uint32 xlport_wc_ucmem_ctrl[1];
	uint32 _xlport_wc_ucmem_ctrl;
} XLPORT_WC_UCMEM_CTRLr_t;

#define XLPORT_WC_UCMEM_CTRLr_CLR(r) (r).xlport_wc_ucmem_ctrl[0] = 0
#define XLPORT_WC_UCMEM_CTRLr_SET(r,d) (r).xlport_wc_ucmem_ctrl[0] = d
#define XLPORT_WC_UCMEM_CTRLr_GET(r) (r).xlport_wc_ucmem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_WC_UCMEM_CTRLr_ACCESS_MODEf_GET(r) (((r).xlport_wc_ucmem_ctrl[0]) & 0x1)
#define XLPORT_WC_UCMEM_CTRLr_ACCESS_MODEf_SET(r,f) (r).xlport_wc_ucmem_ctrl[0]=(((r).xlport_wc_ucmem_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLPORT_WC_UCMEM_CTRLr_RSVD3_1f_GET(r) ((((r).xlport_wc_ucmem_ctrl[0]) >> 1) & 0x7)
#define XLPORT_WC_UCMEM_CTRLr_RSVD3_1f_SET(r,f) (r).xlport_wc_ucmem_ctrl[0]=(((r).xlport_wc_ucmem_ctrl[0] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))

/*
 * These macros can be used to access XLPORT_WC_UCMEM_CTRL.
 */
#define WRITE_XLPORT_WC_UCMEM_CTRLr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_WC_UCMEM_CTRL, (r._xlport_wc_ucmem_ctrl))
#define READ_XLPORT_WC_UCMEM_CTRLr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_WC_UCMEM_CTRL, &(r._xlport_wc_ucmem_ctrl))

/*******************************************************************************
 * End of 'XLPORT_WC_UCMEM_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * MEMORY:  XLPORT_WC_UCMEM_DATA
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Warpcore External Memory Interface to program micro-controller memory
 * SIZE:     128
 * FIELDS:
 *     UC_DATA           16-Bytes of data for TSC uC memory or TSC registers. In TSC ucode mem access mode (XLPORT_WC_UCMEM_CTRL == 1), the 16-Bytes of data are written to TSC on sbus writes or saved to this IDX on sbus reads. The TSC ucode mem address is part of the sbus address and forwarded to TSC accordingly. TSC regsiter mode accesses (XLPORT_WC_UCMEM_CTRL == 0) do not use the sbus address, so extra steps must be taken to perform TSC reg reads.  Another difference from ucode mem accesses is that rd/wr data is only 2B. TSC register reads are indirect and must be done in two steps:  write followed by read.  The write is used to save the needed TSC register address for the subsequent TSC reg read. TSC register writes are done in one step. While in TSC reg mode ( XLPORT_WC_UCMEM_CTRL == 0), an sbus write to this memory, with bit [64] == 1 indicates single step TSC reg write. If  bit [64] == 0, a two-step read is indicated, and the address in bits[31:0] is saved. A subsequent sbus read will perform the TSC reg read using the saved address.  The read data will be stored in bits [47:32].
 */
#define XLPORT_WC_UCMEM_DATAm_MIN 0
#define XLPORT_WC_UCMEM_DATAm_MAX 2047
#define XLPORT_WC_UCMEM_DATAm_CMAX(u) 2047
#define XLPORT_WC_UCMEM_DATAm_SIZE 16

/*
 * This structure should be used to declare and program XLPORT_WC_UCMEM_DATA.
 */
typedef union XLPORT_WC_UCMEM_DATAm_s {
	uint32 v[4];
	uint32 xlport_wc_ucmem_data[4];
	uint32 _xlport_wc_ucmem_data;
} XLPORT_WC_UCMEM_DATAm_t;

#define XLPORT_WC_UCMEM_DATAm_CLR(r) sal_memset(&((r)._xlport_wc_ucmem_data), 0, sizeof(XLPORT_WC_UCMEM_DATAm_t))
#define XLPORT_WC_UCMEM_DATAm_SET(r,i,d) (r).xlport_wc_ucmem_data[i] = d
#define XLPORT_WC_UCMEM_DATAm_GET(r,i) (r).xlport_wc_ucmem_data[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_WC_UCMEM_DATAm_UC_DATAf_GET(r,a) field_get((r).xlport_wc_ucmem_data,0,127,a)
#define XLPORT_WC_UCMEM_DATAm_UC_DATAf_SET(r,a) field_set((r).xlport_wc_ucmem_data,0,127,a)

/*
 * These macros can be used to access XLPORT_WC_UCMEM_DATA.
 */
#define WRITE_XLPORT_WC_UCMEM_DATAm(u,p,i,r) bcm5607x_mem_set(u, bcm5607x_xlport_lport_to_blockid[p], M_XLPORT_WC_UCMEM_DATA(i), &(r._xlport_wc_ucmem_data), 4)
#define READ_XLPORT_WC_UCMEM_DATAm(u,p,i,r) bcm5607x_mem_get(u, bcm5607x_xlport_lport_to_blockid[p], M_XLPORT_WC_UCMEM_DATA(i), &(r._xlport_wc_ucmem_data), 4)

/*******************************************************************************
 * End of 'XLPORT_WC_UCMEM_DATAm'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XLPORT_XGXS0_CTRL_REG
 * BLOCKS:   XLPORT0 XLPORT1 XLPORT2
 * DESC:     Controls for TSC.  XLPORT_XGXS0_CTRL_REG exists on a per port macro basis to control each TSC4.
 * SIZE:     32
 * FIELDS:
 *     RSTB_HW          Hard reset (active low).  Resets everything.
 *     REFOUT_EN        Enables LCREFOUT to be driven by this TSC. (Valid only for 28nm, don't care for 16nm)
 *     REFIN_EN         Selects between pad and LCREF as source of refclk into this TSC PLL. (Valid only for 28nm, don't care for 16nm)
 *     PWRDWN           TSC Power Down. Powers down TSC analog circuits.
 *     IDDQ             Shutdown analog clocks but leave analog section powered.
 *     PWRDWN_CML       0: Normal operation. 1: Power down the CML reference output buffer. (Valid only for 16nm, don't care for 28nm)
 *     PWRDWN_CML_LC    0: Normal operation. 1: Power down the CML LC reference output buffer. (Valid only for 16nm, don't care for 28nm)
 *     REFCMOS          0: Drive the CMOS Clock Channel. 1: CMOS Clock Channel is off. (Valid only for 16nm, don't care for 28nm)
 *     REFSEL           Reference clock select.101: Internal LC Reference Input (default for A0).011: XTAL bypass / External REFCLK with on-chip termination. Refclock is provided by host chip externally at pad_i_refclkp/pad_i_refclkn.There is input resistor termination. The load resistance is calibrated (See i_pll_ctrl<85:84>) (default for B0)See documentation for other values. (Valid only for 16nm, don't care for 28nm)"
 */
#define XLPORT_XGXS0_CTRL_REGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_XGXS0_CTRL_REG.
 */
typedef union XLPORT_XGXS0_CTRL_REGr_s {
	uint32 v[1];
	uint32 xlport_xgxs0_ctrl_reg[1];
	uint32 _xlport_xgxs0_ctrl_reg;
} XLPORT_XGXS0_CTRL_REGr_t;

#define XLPORT_XGXS0_CTRL_REGr_CLR(r) (r).xlport_xgxs0_ctrl_reg[0] = 0
#define XLPORT_XGXS0_CTRL_REGr_SET(r,d) (r).xlport_xgxs0_ctrl_reg[0] = d
#define XLPORT_XGXS0_CTRL_REGr_GET(r) (r).xlport_xgxs0_ctrl_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_XGXS0_CTRL_REGr_RSTB_HWf_GET(r) (((r).xlport_xgxs0_ctrl_reg[0]) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_RSTB_HWf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XLPORT_XGXS0_CTRL_REGr_REFOUT_ENf_GET(r) ((((r).xlport_xgxs0_ctrl_reg[0]) >> 1) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_REFOUT_ENf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define XLPORT_XGXS0_CTRL_REGr_REFIN_ENf_GET(r) ((((r).xlport_xgxs0_ctrl_reg[0]) >> 2) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_REFIN_ENf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define XLPORT_XGXS0_CTRL_REGr_PWRDWNf_GET(r) ((((r).xlport_xgxs0_ctrl_reg[0]) >> 3) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_PWRDWNf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define XLPORT_XGXS0_CTRL_REGr_IDDQf_GET(r) ((((r).xlport_xgxs0_ctrl_reg[0]) >> 4) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_IDDQf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define XLPORT_XGXS0_CTRL_REGr_PWRDWN_CMLf_GET(r) ((((r).xlport_xgxs0_ctrl_reg[0]) >> 5) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_PWRDWN_CMLf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define XLPORT_XGXS0_CTRL_REGr_PWRDWN_CML_LCf_GET(r) ((((r).xlport_xgxs0_ctrl_reg[0]) >> 6) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_PWRDWN_CML_LCf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define XLPORT_XGXS0_CTRL_REGr_REFCMOSf_GET(r) ((((r).xlport_xgxs0_ctrl_reg[0]) >> 7) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_REFCMOSf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define XLPORT_XGXS0_CTRL_REGr_REFSELf_GET(r) ((((r).xlport_xgxs0_ctrl_reg[0]) >> 8) & 0x7)
#define XLPORT_XGXS0_CTRL_REGr_REFSELf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32)0x7 << 8)) | ((((uint32)f) & 0x7) << 8))

/*
 * These macros can be used to access XLPORT_XGXS0_CTRL_REG.
 */
#define WRITE_XLPORT_XGXS0_CTRL_REGr(u,p,r) bcm5607x_reg_set(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_XGXS0_CTRL_REG, (r._xlport_xgxs0_ctrl_reg))
#define READ_XLPORT_XGXS0_CTRL_REGr(u,p,r) bcm5607x_reg_get(u, bcm5607x_xlport_lport_to_blockid[p], R_XLPORT_XGXS0_CTRL_REG, &(r._xlport_xgxs0_ctrl_reg))

/*******************************************************************************
 * End of 'XLPORT_XGXS0_CTRL_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XQCOSARBSEL
 * BLOCKS:   MMU
 * DESC:     Scheduler Control Selection
 * SIZE:     32
 * FIELDS:
 *     COSARB           Scheduler Control Options as cosArb value: 0: Strict priority among valid COSs. (default value)1: Round Robin Queueing among valid COSs.2: Weightd Round Robin Queueing, WRR, scheduling according to WRRWEIGHT_COS.3: Weighted Deficit Round Robin Queueing, WDRR, scheduling according to WRRWEIGHT_COS.
 *     MTU_QUANTA_SELECT Selected MTU_QUANTA when in Weighted Deficit Round Robin mode:0: MTU Quanta is 2048 bytes. 1: MTU Quanta is 4096 bytes.2: MTU Quanta is 8192 bytes.3: MTU Quanta is 16384 bytes (default value)
 */
#define XQCOSARBSELr_SIZE 4

/*
 * This structure should be used to declare and program XQCOSARBSEL.
 */
typedef union XQCOSARBSELr_s {
	uint32 v[1];
	uint32 xqcosarbsel[1];
	uint32 _xqcosarbsel;
} XQCOSARBSELr_t;

#define XQCOSARBSELr_CLR(r) (r).xqcosarbsel[0] = 0
#define XQCOSARBSELr_SET(r,d) (r).xqcosarbsel[0] = d
#define XQCOSARBSELr_GET(r) (r).xqcosarbsel[0]

/*
 * These macros can be used to access individual fields.
 */
#define XQCOSARBSELr_COSARBf_GET(r) (((r).xqcosarbsel[0]) & 0x3)
#define XQCOSARBSELr_COSARBf_SET(r,f) (r).xqcosarbsel[0]=(((r).xqcosarbsel[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define XQCOSARBSELr_MTU_QUANTA_SELECTf_GET(r) ((((r).xqcosarbsel[0]) >> 2) & 0x3)
#define XQCOSARBSELr_MTU_QUANTA_SELECTf_SET(r,f) (r).xqcosarbsel[0]=(((r).xqcosarbsel[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))

/*
 * These macros can be used to access XQCOSARBSEL.
 */
#define WRITE_XQCOSARBSELr(u,p,r) bcm5607x_reg_set(u,R_XQCOSARBSEL(p),(r._xqcosarbsel))
#define READ_XQCOSARBSELr(u,p,r) bcm5607x_reg_get(u,R_XQCOSARBSEL(p),&(r._xqcosarbsel))

/*******************************************************************************
 * End of 'XQCOSARBSELr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  XQCOSARBSEL_QLAYER
 * BLOCKS:   MMU
 * DESC:     Scheduler Control Selection, for Q layer 8 schedulers.
 * SIZE:     32
 * FIELDS:
 *     COSARB           Scheduler Control Options as cosArb value: 0: Strict priority among valid COSs. (default value)1: Round Robin Queueing among valid COSs.2: Weightd Round Robin Queueing, WRR, scheduling according to WRRWEIGHT_COS.3: Weighted Deficit Round Robin Queueing, WDRR, scheduling according to WRRWEIGHT_COS.
 *     MTU_QUANTA_SELECT Selected MTU_QUANTA when in Weighted Deficit Round Robin mode:0: MTU Quanta is 2048 bytes. 1: MTU Quanta is 4096 bytes.2: MTU Quanta is 8192 bytes.3: MTU Quanta is 16384 bytes (default value)
 */
#define XQCOSARBSEL_QLAYERr_SIZE 4

/*
 * This structure should be used to declare and program XQCOSARBSEL_QLAYER.
 */
typedef union XQCOSARBSEL_QLAYERr_s {
	uint32 v[1];
	uint32 xqcosarbsel_qlayer[1];
	uint32 _xqcosarbsel_qlayer;
} XQCOSARBSEL_QLAYERr_t;

#define XQCOSARBSEL_QLAYERr_CLR(r) (r).xqcosarbsel_qlayer[0] = 0
#define XQCOSARBSEL_QLAYERr_SET(r,d) (r).xqcosarbsel_qlayer[0] = d
#define XQCOSARBSEL_QLAYERr_GET(r) (r).xqcosarbsel_qlayer[0]

/*
 * These macros can be used to access individual fields.
 */
#define XQCOSARBSEL_QLAYERr_COSARBf_GET(r) (((r).xqcosarbsel_qlayer[0]) & 0x3)
#define XQCOSARBSEL_QLAYERr_COSARBf_SET(r,f) (r).xqcosarbsel_qlayer[0]=(((r).xqcosarbsel_qlayer[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define XQCOSARBSEL_QLAYERr_MTU_QUANTA_SELECTf_GET(r) ((((r).xqcosarbsel_qlayer[0]) >> 2) & 0x3)
#define XQCOSARBSEL_QLAYERr_MTU_QUANTA_SELECTf_SET(r,f) (r).xqcosarbsel_qlayer[0]=(((r).xqcosarbsel_qlayer[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))

/*
 * These macros can be used to access XQCOSARBSEL_QLAYER.
 */
#define WRITE_XQCOSARBSEL_QLAYERr(u,p, i,r) bcm5607x_reg_set(u, R_XQCOSARBSEL_QLAYER(i,p), (r._xqcosarbsel_qlayer))
#define READ_XQCOSARBSEL_QLAYERr(u,p, i,r) bcm5607x_reg_get(u,R_XQCOSARBSEL_QLAYER(i,p),&(r._xqcosarbsel_qlayer))

/*******************************************************************************
 * End of 'XQCOSARBSEL_QLAYERr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  mhost_0_cr5_rst_ctrl
 * BLOCKS:   IPROC
 * DESC:     Control register for Cortex R5 Reset and Halt inputs.
 * SIZE:     32
 * FIELDS:
 *     SYS_PORESET_N    Power-on reset. Resets the entire processor group including all implemented CPUs, debug logic and ACP. Active Low.
 *     RESET_N          Main CPU reset. Resets the non-debug CPU logic. Active Low.
 *     DBG_RESET_N      CPU debug reset. Resets core-domain debug logic. This includes breakpoints, watchpoints and the DCC registers. Active Low 
 *     PRESET_DBG_N     CPU debug reset. Resets debug-domain debug logic and the APB interface of the CPU. Active Low 
 *     CPU_HALT_N       This signal, when asserted, stops the CPU from fetching instructions out of reset. Active Low 
 */
#define MHOST_0_CR5_RST_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program mhost_0_cr5_rst_ctrl.
 */
typedef union MHOST_0_CR5_RST_CTRLr_s {
	uint32 v[1];
	uint32 mhost_0_cr5_rst_ctrl[1];
	uint32 _mhost_0_cr5_rst_ctrl;
} MHOST_0_CR5_RST_CTRLr_t;

#define MHOST_0_CR5_RST_CTRLr_CLR(r) (r).mhost_0_cr5_rst_ctrl[0] = 0
#define MHOST_0_CR5_RST_CTRLr_SET(r,d) (r).mhost_0_cr5_rst_ctrl[0] = d
#define MHOST_0_CR5_RST_CTRLr_GET(r) (r).mhost_0_cr5_rst_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define MHOST_0_CR5_RST_CTRLr_SYS_PORESET_Nf_GET(r) (((r).mhost_0_cr5_rst_ctrl[0]) & 0x1)
#define MHOST_0_CR5_RST_CTRLr_SYS_PORESET_Nf_SET(r,f) (r).mhost_0_cr5_rst_ctrl[0]=(((r).mhost_0_cr5_rst_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define MHOST_0_CR5_RST_CTRLr_RESET_Nf_GET(r) ((((r).mhost_0_cr5_rst_ctrl[0]) >> 1) & 0x1)
#define MHOST_0_CR5_RST_CTRLr_RESET_Nf_SET(r,f) (r).mhost_0_cr5_rst_ctrl[0]=(((r).mhost_0_cr5_rst_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define MHOST_0_CR5_RST_CTRLr_DBG_RESET_Nf_GET(r) ((((r).mhost_0_cr5_rst_ctrl[0]) >> 2) & 0x1)
#define MHOST_0_CR5_RST_CTRLr_DBG_RESET_Nf_SET(r,f) (r).mhost_0_cr5_rst_ctrl[0]=(((r).mhost_0_cr5_rst_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define MHOST_0_CR5_RST_CTRLr_PRESET_DBG_Nf_GET(r) ((((r).mhost_0_cr5_rst_ctrl[0]) >> 3) & 0x1)
#define MHOST_0_CR5_RST_CTRLr_PRESET_DBG_Nf_SET(r,f) (r).mhost_0_cr5_rst_ctrl[0]=(((r).mhost_0_cr5_rst_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define MHOST_0_CR5_RST_CTRLr_CPU_HALT_Nf_GET(r) ((((r).mhost_0_cr5_rst_ctrl[0]) >> 4) & 0x1)
#define MHOST_0_CR5_RST_CTRLr_CPU_HALT_Nf_SET(r,f) (r).mhost_0_cr5_rst_ctrl[0]=(((r).mhost_0_cr5_rst_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))

/*
 * These macros can be used to access mhost_0_cr5_rst_ctrl.
 */
#define READ_MHOST_0_CR5_RST_CTRLr(u,r) bcm5607x_read32(u, R_MHOST_0_CR5_RST_CTRL, &(r._mhost_0_cr5_rst_ctrl))
#define WRITE_MHOST_0_CR5_RST_CTRLr(u,r) bcm5607x_write32(u, R_MHOST_0_CR5_RST_CTRL, (r._mhost_0_cr5_rst_ctrl))

/*******************************************************************************
 * End of 'MHOST_0_CR5_RST_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  mhost_0_mhost_debug_ctrl
 * BLOCKS:   IPROC
 * DESC:     Control register for various Debug inputs
 * SIZE:     32
 * FIELDS:
 *     AXI_M_TRACE_NIDEN NIDEN for AXI Master Trace
 *     AXI_M_TRACE_DBGEN DBGEN for AXI Master Trace
 *     AXI_M_TRACE_SPNIDEN SPNIDEN for AXI Master Trace 
 *     AXI_M_TRACE_SPIDEN SPIDEN for AXI Master Trace
 *     AXI_S_TRACE_NIDEN NIDEN for AXI Slave Trace
 *     AXI_S_TRACE_DBGEN DBGEN for AXI Slave Trace
 *     AXI_S_TRACE_SPNIDEN SPNIDEN for AXI Slave Trace 
 *     AXI_S_TRACE_SPIDEN SPIDEN for AXI Slave Trace
 *     AXI_PP_M_TRACE_NIDEN NIDEN for AXI PP Master Trace
 *     AXI_PP_M_TRACE_DBGEN DBGEN for AXI PP Master Trace
 *     AXI_PP_M_TRACE_SPNIDEN SPNIDEN for AXI PP Master Trace 
 *     AXI_PP_M_TRACE_SPIDEN SPIDEN for AXI PP Master Trace
 *     ETMR5_NIDEN      NIDEN for ETMR5
 *     ETMR5_DBGEN      DBGEN for ETMR5
 */
#define MHOST_0_MHOST_DEBUG_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program mhost_0_mhost_debug_ctrl.
 */
typedef union MHOST_0_MHOST_DEBUG_CTRLr_s {
	uint32 v[1];
	uint32 mhost_0_mhost_debug_ctrl[1];
	uint32 _mhost_0_mhost_debug_ctrl;
} MHOST_0_MHOST_DEBUG_CTRLr_t;

#define MHOST_0_MHOST_DEBUG_CTRLr_CLR(r) (r).mhost_0_mhost_debug_ctrl[0] = 0
#define MHOST_0_MHOST_DEBUG_CTRLr_SET(r,d) (r).mhost_0_mhost_debug_ctrl[0] = d
#define MHOST_0_MHOST_DEBUG_CTRLr_GET(r) (r).mhost_0_mhost_debug_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_M_TRACE_NIDENf_GET(r) (((r).mhost_0_mhost_debug_ctrl[0]) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_M_TRACE_NIDENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_M_TRACE_DBGENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 1) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_M_TRACE_DBGENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_M_TRACE_SPNIDENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 2) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_M_TRACE_SPNIDENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_M_TRACE_SPIDENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 3) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_M_TRACE_SPIDENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_S_TRACE_NIDENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 4) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_S_TRACE_NIDENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_S_TRACE_DBGENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 5) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_S_TRACE_DBGENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_S_TRACE_SPNIDENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 6) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_S_TRACE_SPNIDENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_S_TRACE_SPIDENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 7) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_S_TRACE_SPIDENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_PP_M_TRACE_NIDENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 8) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_PP_M_TRACE_NIDENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_PP_M_TRACE_DBGENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 9) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_PP_M_TRACE_DBGENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_PP_M_TRACE_SPNIDENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 10) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_PP_M_TRACE_SPNIDENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_PP_M_TRACE_SPIDENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 11) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_AXI_PP_M_TRACE_SPIDENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define MHOST_0_MHOST_DEBUG_CTRLr_ETMR5_NIDENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 12) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_ETMR5_NIDENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define MHOST_0_MHOST_DEBUG_CTRLr_ETMR5_DBGENf_GET(r) ((((r).mhost_0_mhost_debug_ctrl[0]) >> 13) & 0x1)
#define MHOST_0_MHOST_DEBUG_CTRLr_ETMR5_DBGENf_SET(r,f) (r).mhost_0_mhost_debug_ctrl[0]=(((r).mhost_0_mhost_debug_ctrl[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))

/*
 * These macros can be used to access mhost_0_mhost_debug_ctrl.
 */
#define READ_MHOST_0_MHOST_DEBUG_CTRLr(u,r) bcm5607x_read32(u, R_MHOST_0_MHOST_DEBUG_CTRL, &(r._mhost_0_mhost_debug_ctrl))
#define WRITE_MHOST_0_MHOST_DEBUG_CTRLr(u,r) bcm5607x_write32(u, R_MHOST_0_MHOST_DEBUG_CTRL, (r._mhost_0_mhost_debug_ctrl))

/*******************************************************************************
 * End of 'MHOST_0_MHOST_DEBUG_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  mhost_0_mhost_intr_mask
 * BLOCKS:   IPROC
 * DESC:     Mask register to mask mhost_raw_intr[31:0]
 * SIZE:     32
 * FIELDS:
 *     MHOST_INTR_MASK_31_0 Mask for mHost raw interrupts 31:0
 */
#define MHOST_0_MHOST_INTR_MASKr_SIZE 4

/*
 * This structure should be used to declare and program mhost_0_mhost_intr_mask.
 */
typedef union MHOST_0_MHOST_INTR_MASKr_s {
	uint32 v[1];
	uint32 mhost_0_mhost_intr_mask[1];
	uint32 _mhost_0_mhost_intr_mask;
} MHOST_0_MHOST_INTR_MASKr_t;

#define MHOST_0_MHOST_INTR_MASKr_CLR(r) (r).mhost_0_mhost_intr_mask[0] = 0
#define MHOST_0_MHOST_INTR_MASKr_SET(r,d) (r).mhost_0_mhost_intr_mask[0] = d
#define MHOST_0_MHOST_INTR_MASKr_GET(r) (r).mhost_0_mhost_intr_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define MHOST_0_MHOST_INTR_MASKr_MHOST_INTR_MASK_31_0f_GET(r) ((r).mhost_0_mhost_intr_mask[0])
#define MHOST_0_MHOST_INTR_MASKr_MHOST_INTR_MASK_31_0f_SET(r,f) (r).mhost_0_mhost_intr_mask[0]=((uint32)f)

/*
 * These macros can be used to access mhost_0_mhost_intr_mask.
 */
#define READ_MHOST_0_MHOST_INTR_MASKr(u,i,r) bcm5607x_read32(u, R_MHOST_0_MHOST_INTR_MASK(i), &(r._mhost_0_mhost_intr_mask))
#define WRITE_MHOST_0_MHOST_INTR_MASKr(u,i,r) bcm5607x_write32(u, R_MHOST_0_MHOST_INTR_MASK(i), (r._mhost_0_mhost_intr_mask))

/*******************************************************************************
 * End of 'MHOST_0_MHOST_INTR_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  mhost_0_mhost_intr_status
 * BLOCKS:   IPROC
 * DESC:     Status register that caputres mhost_intr[31:0] after masking
 * SIZE:     32
 * FIELDS:
 *     MHOST_INTR_31_0  mHost  interrupts 31:0 after masking
 */
#define MHOST_0_MHOST_INTR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program mhost_0_mhost_intr_status.
 */
typedef union MHOST_0_MHOST_INTR_STATUSr_s {
	uint32 v[1];
	uint32 mhost_0_mhost_intr_status[1];
	uint32 _mhost_0_mhost_intr_status;
} MHOST_0_MHOST_INTR_STATUSr_t;

#define MHOST_0_MHOST_INTR_STATUSr_CLR(r) (r).mhost_0_mhost_intr_status[0] = 0
#define MHOST_0_MHOST_INTR_STATUSr_SET(r,d) (r).mhost_0_mhost_intr_status[0] = d
#define MHOST_0_MHOST_INTR_STATUSr_GET(r) (r).mhost_0_mhost_intr_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define MHOST_0_MHOST_INTR_STATUSr_MHOST_INTR_31_0f_GET(r) ((r).mhost_0_mhost_intr_status[0])
#define MHOST_0_MHOST_INTR_STATUSr_MHOST_INTR_31_0f_SET(r,f) (r).mhost_0_mhost_intr_status[0]=((uint32)f)

/*
 * These macros can be used to access mhost_0_mhost_intr_status.
 */
#define READ_MHOST_0_MHOST_INTR_STATUSr(u,i,r) bcm5607x_read32(u, R_MHOST_0_MHOST_INTR_STATUS(i), &(r._mhost_0_mhost_intr_status))
#define WRITE_MHOST_0_MHOST_INTR_STATUSr(u,i,r) bcm5607x_write32(u, R_MHOST_0_MHOST_INTR_STATUS(i), (r._mhost_0_mhost_intr_status))

/*******************************************************************************
 * End of 'MHOST_0_MHOST_INTR_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  mhost_0_mhost_raw_intr_status
 * BLOCKS:   IPROC
 * DESC:     Status register that caputres mhost_raw_intr[31:0]
 * SIZE:     32
 * FIELDS:
 *     MHOST_RAW_INTR_31_0 mHost raw interrupts 31:0
 */
#define MHOST_0_MHOST_RAW_INTR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program mhost_0_mhost_raw_intr_status.
 */
typedef union MHOST_0_MHOST_RAW_INTR_STATUSr_s {
	uint32 v[1];
	uint32 mhost_0_mhost_raw_intr_status[1];
	uint32 _mhost_0_mhost_raw_intr_status;
} MHOST_0_MHOST_RAW_INTR_STATUSr_t;

#define MHOST_0_MHOST_RAW_INTR_STATUSr_CLR(r) (r).mhost_0_mhost_raw_intr_status[0] = 0
#define MHOST_0_MHOST_RAW_INTR_STATUSr_SET(r,d) (r).mhost_0_mhost_raw_intr_status[0] = d
#define MHOST_0_MHOST_RAW_INTR_STATUSr_GET(r) (r).mhost_0_mhost_raw_intr_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define MHOST_0_MHOST_RAW_INTR_STATUSr_MHOST_RAW_INTR_31_0f_GET(r) ((r).mhost_0_mhost_raw_intr_status[0])
#define MHOST_0_MHOST_RAW_INTR_STATUSr_MHOST_RAW_INTR_31_0f_SET(r,f) (r).mhost_0_mhost_raw_intr_status[0]=((uint32)f)

/*
 * These macros can be used to access mhost_0_mhost_raw_intr_status.
 */
#define READ_MHOST_0_MHOST_RAW_INTR_STATUSr(u,i,r) bcm5607x_read32(u, R_MHOST_0_MHOST_RAW_INTR_STATUS(i), &(r._mhost_0_mhost_raw_intr_status))
#define WRITE_MHOST_0_MHOST_RAW_INTR_STATUSr(u,i,r) bcm5607x_write32(u, R_MHOST_0_MHOST_RAW_INTR_STATUS(i), (r._mhost_0_mhost_raw_intr_status))

/*******************************************************************************
 * End of 'MHOST_0_MHOST_RAW_INTR_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  mhost_VICADDRESS
 * BLOCKS:   IPROC
 * DESC:     Vector Address Register
 * SIZE:     32
 * FIELDS:
 *     VECTADDR         Contains the address of the currently active ISR, with reset value 0x00000000.                   A read of this register returns the address of the ISR and sets the current                    interrupt as being serviced. A read must only be performed while there is an                    active interrupt.                   A write of any value to this register clears the current interrupt. A write must                   only be performed at the end of an interrupt service routine
 */
#define MHOST_VICADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program mhost_VICADDRESS.
 */
typedef union MHOST_VICADDRESSr_s {
	uint32 v[1];
	uint32 mhost_vicaddress[1];
	uint32 _mhost_vicaddress;
} MHOST_VICADDRESSr_t;

#define MHOST_VICADDRESSr_CLR(r) (r).mhost_vicaddress[0] = 0
#define MHOST_VICADDRESSr_SET(r,d) (r).mhost_vicaddress[0] = d
#define MHOST_VICADDRESSr_GET(r) (r).mhost_vicaddress[0]

/*
 * These macros can be used to access individual fields.
 */
#define MHOST_VICADDRESSr_VECTADDRf_GET(r) ((r).mhost_vicaddress[0])
#define MHOST_VICADDRESSr_VECTADDRf_SET(r,f) (r).mhost_vicaddress[0]=((uint32)f)

/*
 * These macros can be used to access mhost_VICADDRESS.
 */
#define READ_MHOST_VICADDRESSr(u,r) bcm5607x_read32(u, R_MHOST_VICADDRESS, &(r._mhost_vicaddress))
#define WRITE_MHOST_VICADDRESSr(u,r) bcm5607x_write32(u, R_MHOST_VICADDRESS, (r._mhost_vicaddress))

/*******************************************************************************
 * End of 'MHOST_VICADDRESSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  mhost_VICFIQSTATUS
 * BLOCKS:   IPROC
 * DESC:     FIQ Status Register
 * SIZE:     32
 * FIELDS:
 *     FIQSTATUS        Shows the status of the FIQ interrupts after masking by the VICINTENABLE and                   VICINTSELECT Registers:                   0 = interrupt is inactive (reset)                   1 = interrupt is active.                   There is one bit of the register for each interrupt source
 */
#define MHOST_VICFIQSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program mhost_VICFIQSTATUS.
 */
typedef union MHOST_VICFIQSTATUSr_s {
	uint32 v[1];
	uint32 mhost_vicfiqstatus[1];
	uint32 _mhost_vicfiqstatus;
} MHOST_VICFIQSTATUSr_t;

#define MHOST_VICFIQSTATUSr_CLR(r) (r).mhost_vicfiqstatus[0] = 0
#define MHOST_VICFIQSTATUSr_SET(r,d) (r).mhost_vicfiqstatus[0] = d
#define MHOST_VICFIQSTATUSr_GET(r) (r).mhost_vicfiqstatus[0]

/*
 * These macros can be used to access individual fields.
 */
#define MHOST_VICFIQSTATUSr_FIQSTATUSf_GET(r) ((r).mhost_vicfiqstatus[0])
#define MHOST_VICFIQSTATUSr_FIQSTATUSf_SET(r,f) (r).mhost_vicfiqstatus[0]=((uint32)f)

/*
 * These macros can be used to access mhost_VICFIQSTATUS.
 */
#define READ_MHOST_VICFIQSTATUSr(u,r) bcm5607x_read32(u, R_MHOST_VICFIQSTATUS, &(r._mhost_vicfiqstatus))
#define WRITE_MHOST_VICFIQSTATUSr(u,r) bcm5607x_write32(u, R_MHOST_VICFIQSTATUS, (r._mhost_vicfiqstatus))

/*******************************************************************************
 * End of 'MHOST_VICFIQSTATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  mhost_VICINTENABLE
 * BLOCKS:   IPROC
 * DESC:     Interrupt Enable Register
 * SIZE:     32
 * FIELDS:
 *     INTENABLE        Enables the interrupt request lines, which allow the interrupts to reach the                    processor.                   Read:                   0 = interrupt disabled (reset)                   1 = interrupt enabled.                                      The interrupt enable can only be set using this register. The VICINTENCLEAR                   Register must be used to disable the interrupt enable.                                      Write:                   0 = no effect                   1 = interrupt enabled.                   On reset, all interrupts are disabled.                   There is one bit of the register for each interrupt source.
 */
#define MHOST_VICINTENABLEr_SIZE 4

/*
 * This structure should be used to declare and program mhost_VICINTENABLE.
 */
typedef union MHOST_VICINTENABLEr_s {
	uint32 v[1];
	uint32 mhost_vicintenable[1];
	uint32 _mhost_vicintenable;
} MHOST_VICINTENABLEr_t;

#define MHOST_VICINTENABLEr_CLR(r) (r).mhost_vicintenable[0] = 0
#define MHOST_VICINTENABLEr_SET(r,d) (r).mhost_vicintenable[0] = d
#define MHOST_VICINTENABLEr_GET(r) (r).mhost_vicintenable[0]

/*
 * These macros can be used to access individual fields.
 */
#define MHOST_VICINTENABLEr_INTENABLEf_GET(r) ((r).mhost_vicintenable[0])
#define MHOST_VICINTENABLEr_INTENABLEf_SET(r,f) (r).mhost_vicintenable[0]=((uint32)f)

/*
 * These macros can be used to access mhost_VICINTENABLE.
 */
#define READ_MHOST_VICINTENABLEr(u,r) bcm5607x_read32(u, R_MHOST_VICINTENABLE, &(r._mhost_vicintenable))
#define WRITE_MHOST_VICINTENABLEr(u,r) bcm5607x_write32(u, R_MHOST_VICINTENABLE, (r._mhost_vicintenable))

/*******************************************************************************
 * End of 'MHOST_VICINTENABLEr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  mhost_VICINTENCLEAR
 * BLOCKS:   IPROC
 * DESC:     Interrupt Enable Clear Register
 * SIZE:     32
 * FIELDS:
 *     INTENABLECLEAR   Clears corresponding bits in the VICINTENABLE Register:                   0 = no effect                   1 = interrupt disabled in VICINTENABLE Register.                   There is one bit of the register for each interrupt source.   RESETVAL is not defined in VIC TRM
 */
#define MHOST_VICINTENCLEARr_SIZE 4

/*
 * This structure should be used to declare and program mhost_VICINTENCLEAR.
 */
typedef union MHOST_VICINTENCLEARr_s {
	uint32 v[1];
	uint32 mhost_vicintenclear[1];
	uint32 _mhost_vicintenclear;
} MHOST_VICINTENCLEARr_t;

#define MHOST_VICINTENCLEARr_CLR(r) (r).mhost_vicintenclear[0] = 0
#define MHOST_VICINTENCLEARr_SET(r,d) (r).mhost_vicintenclear[0] = d
#define MHOST_VICINTENCLEARr_GET(r) (r).mhost_vicintenclear[0]

/*
 * These macros can be used to access individual fields.
 */
#define MHOST_VICINTENCLEARr_INTENABLECLEARf_GET(r) ((r).mhost_vicintenclear[0])
#define MHOST_VICINTENCLEARr_INTENABLECLEARf_SET(r,f) (r).mhost_vicintenclear[0]=((uint32)f)

/*
 * These macros can be used to access mhost_VICINTENCLEAR.
 */
#define READ_MHOST_VICINTENCLEARr(u,r) bcm5607x_read32(u, R_MHOST_VICINTENCLEAR, &(r._mhost_vicintenclear))
#define WRITE_MHOST_VICINTENCLEARr(u,r) bcm5607x_write32(u, R_MHOST_VICINTENCLEAR, (r._mhost_vicintenclear))

/*******************************************************************************
 * End of 'MHOST_VICINTENCLEARr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  mhost_VICINTSELECT
 * BLOCKS:   IPROC
 * DESC:     Interrupt Select Register
 * SIZE:     32
 * FIELDS:
 *     INTSELECT        Selects type of interrupt for interrupt request:                   0 = IRQ interrupt (reset)                   1 = FIQ interrupt.                   There is one bit of the register for each interrupt source.
 */
#define MHOST_VICINTSELECTr_SIZE 4

/*
 * This structure should be used to declare and program mhost_VICINTSELECT.
 */
typedef union MHOST_VICINTSELECTr_s {
	uint32 v[1];
	uint32 mhost_vicintselect[1];
	uint32 _mhost_vicintselect;
} MHOST_VICINTSELECTr_t;

#define MHOST_VICINTSELECTr_CLR(r) (r).mhost_vicintselect[0] = 0
#define MHOST_VICINTSELECTr_SET(r,d) (r).mhost_vicintselect[0] = d
#define MHOST_VICINTSELECTr_GET(r) (r).mhost_vicintselect[0]

/*
 * These macros can be used to access individual fields.
 */
#define MHOST_VICINTSELECTr_INTSELECTf_GET(r) ((r).mhost_vicintselect[0])
#define MHOST_VICINTSELECTr_INTSELECTf_SET(r,f) (r).mhost_vicintselect[0]=((uint32)f)

/*
 * These macros can be used to access mhost_VICINTSELECT.
 */
#define READ_MHOST_VICINTSELECTr(u,r) bcm5607x_read32(u, R_MHOST_VICINTSELECT, &(r._mhost_vicintselect))
#define WRITE_MHOST_VICINTSELECTr(u,r) bcm5607x_write32(u, R_MHOST_VICINTSELECT, (r._mhost_vicintselect))

/*******************************************************************************
 * End of 'MHOST_VICINTSELECTr'
 */




/*******************************************************************************
 * CHIP:  BCM5607X
 * REGISTER:  mhost_VICIRQSTATUS
 * BLOCKS:   IPROC
 * DESC:     IRQ Status Register
 * SIZE:     32
 * FIELDS:
 *     IRQSTATUS        Shows the status of the interrupts after masking by the VICINTENABLE and                   VICINTSELECT Registers:                                     0 = interrupt is inactive (reset)                   1 = interrupt is active.                   There is one bit of the register for each interrupt source.
 */
#define MHOST_VICIRQSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program mhost_VICIRQSTATUS.
 */
typedef union MHOST_VICIRQSTATUSr_s {
	uint32 v[1];
	uint32 mhost_vicirqstatus[1];
	uint32 _mhost_vicirqstatus;
} MHOST_VICIRQSTATUSr_t;

#define MHOST_VICIRQSTATUSr_CLR(r) (r).mhost_vicirqstatus[0] = 0
#define MHOST_VICIRQSTATUSr_SET(r,d) (r).mhost_vicirqstatus[0] = d
#define MHOST_VICIRQSTATUSr_GET(r) (r).mhost_vicirqstatus[0]

/*
 * These macros can be used to access individual fields.
 */
#define MHOST_VICIRQSTATUSr_IRQSTATUSf_GET(r) ((r).mhost_vicirqstatus[0])
#define MHOST_VICIRQSTATUSr_IRQSTATUSf_SET(r,f) (r).mhost_vicirqstatus[0]=((uint32)f)

/*
 * These macros can be used to access mhost_VICIRQSTATUS.
 */
#define READ_MHOST_VICIRQSTATUSr(u,r) bcm5607x_read32(u, R_MHOST_VICIRQSTATUS, &(r._mhost_vicirqstatus))
#define WRITE_MHOST_VICIRQSTATUSr(u,r) bcm5607x_write32(u, R_MHOST_VICIRQSTATUS, (r._mhost_vicirqstatus))

/*******************************************************************************
 * End of 'MHOST_VICIRQSTATUSr'
 */




#endif /* __BCM5607X_REGS_H__ */
