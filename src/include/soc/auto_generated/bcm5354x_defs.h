/*
 * $Id: chipman.pm,v 1.4 2016/06/14 03:52:11 justinch Exp n *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenUM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 */
#ifndef __BCM5354X_REGS_H__
#define __BCM5354X_REGS_H__

/* Blocks */
#define IPIPE_BLOCK_ID                  10
#define EPIPE_BLOCK_ID                  11
#define MMU_BLOCK_ID                    12
#define OTPC_BLOCK_ID                   13
#define CMIC_BLOCK_ID                   14
#define IPROC_BLOCK_ID                  15
#define TOP_BLOCK_ID                    16
#define AVS_BLOCK_ID                    17
#define SER_BLOCK_ID                    19
#define PGW_GE0_BLOCK_ID                32
#define GPORT0_BLOCK_ID                 33
#define GPORT1_BLOCK_ID                 34
#define PMQ0_BLOCK_ID                   35
#define PGW_GE1_BLOCK_ID                36
#define GPORT2_BLOCK_ID                 37
#define GPORT3_BLOCK_ID                 38
#define PMQ1_BLOCK_ID                   39
#define PGW_GE2_BLOCK_ID                40
#define GPORT4_BLOCK_ID                 41
#define PMQ2_BLOCK_ID                   42

/* Physical Port */
#define PHY_GPORT0_BASE                     2 /* physical port 2 ~ 9 */
#define PHY_GPORT1_BASE                     10 /* physical port 10 ~ 17 */
#define PHY_GPORT2_BASE                     18 /* physical port 18 ~ 25 */
#define PHY_GPORT3_BASE                     26 /* physical port 26 ~ 33 */
#define PHY_GPORT4_BASE                     34 /* physical port 34 ~ 41 */

/* Low level register/memory access function */ 
extern uint32 *field_get(const uint32 *entbuf, int sbit, int ebit, uint32 *fbuf); 
extern void field_set(uint32 *entbuf, int sbit, int ebit, uint32 *fbuf); 
extern uint32 field32_get(const uint32 *entbuf, int sbit, int ebit); 
extern void field32_set(uint32 *entbuf, int sbit, int ebit, uint32 fval); 
extern sys_error_t bcm5354x_read32(uint8 unit, uint32 addr, uint32 *val); 
extern sys_error_t bcm5354x_write32(uint8 unit, uint32 addr, uint32 val);  
extern sys_error_t bcm5354x_reg_get(uint8 unit, uint8 block_id, uint32 addr, uint32 *val); 
extern sys_error_t bcm5354x_reg_set(uint8 unit, uint8 block_id, uint32 addr, uint32 val);  
extern sys_error_t bcm5354x_reg64_get(uint8 unit, uint8 block_id, uint32 addr, uint32 *val, int len); 
extern sys_error_t bcm5354x_reg64_set(uint8 unit, uint8 block_id, uint32 addr, uint32 *val, int len); 
extern sys_error_t bcm5354x_mem_get(uint8 unit, uint8 block_id, uint32 addr, uint32 *val, int len); 
extern sys_error_t bcm5354x_mem_set(uint8 unit, uint8 block_id, uint32 addr, uint32 *val, int len); 
extern sys_error_t bcm5354x_tcam_mem_get(uint8 unit, uint8 block_id, uint32 addr,  uint32 *val, int len, uint32 key_sp, uint32 mask_sp, int key_len); 
extern sys_error_t bcm5354x_tcam_mem_set(uint8 unit, uint8 block_id, uint32 addr, uint32 *val, int len, uint32 key_sp, uint32 mask_sp, int key_len); 
/* Port block mapping structure */ 
extern const char bcm5354x_pmq_pport_to_blockid[];
extern const char bcm5354x_pmq_pport_to_index_in_block[];
extern char bcm5354x_pmq_lport_to_blockid[];
extern char bcm5354x_pmq_lport_to_index_in_block[];
extern const char bcm5354x_gport_pport_to_blockid[];
extern const char bcm5354x_gport_pport_to_index_in_block[];
extern char bcm5354x_gport_lport_to_blockid[];
extern char bcm5354x_gport_lport_to_index_in_block[];
extern const char bcm5354x_pgw_ge_pport_to_blockid[];
extern const char bcm5354x_pgw_ge_pport_to_index_in_block[];
extern char bcm5354x_pgw_ge_lport_to_blockid[];
extern char bcm5354x_pgw_ge_lport_to_index_in_block[];

extern void bcm5354x_init_port_block_map(uint16 devid, uint16 revid);
/* PMQ0 PMQ1 PMQ2 */
#define R_CHIP_CONFIG                          (0x02010100)
#define R_CHIP_INDACC_CTLSTS                   (0x02010400)
#define R_CHIP_INDACC_RDATA                    (0x02010600)
#define R_CHIP_INDACC_WDATA                    (0x02010500)
#define R_CHIP_SBUS_CFG                        (0x02010200)
#define R_CHIP_SWRST                           (0x02010300)
#define R_CHIP_UMACSPEED                       (0x02010700)
#define R_GPORT_SGMII0_CTRL_REG                (0x02020600)
#define R_GPORT_WC_UCMEM_CTRL                  (0x02020500)
#define M_GPORT_WC_UCMEM_DATA(idx)             (0x00000000+(idx))
#define R_GPORT_XGXS0_CTRL_REG                 (0x02020000)
/* TOP */
#define R_PGW_CTRL_0                           TOP_BLOCK_ID, (0x02058000)
#define R_RESCAL_STATUS_0                      TOP_BLOCK_ID, (0x02057a00)
#define R_TOP_CLOCKING_ENFORCE_PSG             TOP_BLOCK_ID, (0x02032400)
#define R_TOP_CORE_PLL_CTRL4                   TOP_BLOCK_ID, (0x02039000)
#define R_TOP_MISC_CONTROL_1                   TOP_BLOCK_ID, (0x02031400)
#define R_TOP_MISC_CONTROL_3                   TOP_BLOCK_ID, (0x02079a00)
#define R_TOP_MISC_STATUS                      TOP_BLOCK_ID, (0x02031800)
#define R_TOP_PVTMON_CTRL_0                    TOP_BLOCK_ID, (0x02050000)
#define R_TOP_QGPHY_CTRL_0                     TOP_BLOCK_ID, (0x02033800)
#define R_TOP_QGPHY_CTRL_2                     TOP_BLOCK_ID, (0x02033400)
#define R_TOP_SGMII_CTRL_REG                   TOP_BLOCK_ID, (0x0207e800)
#define R_TOP_SGMII_STATUS1_REG                TOP_BLOCK_ID, (0x0207ea00)
#define R_TOP_SOFT_RESET_REG                   TOP_BLOCK_ID, (0x02030400)
#define R_TOP_SOFT_RESET_REG_2                 TOP_BLOCK_ID, (0x02030800)
#define R_TOP_STRAP_STATUS                     TOP_BLOCK_ID, (0x0207d400)
#define R_TOP_STRAP_STATUS_1                   TOP_BLOCK_ID, (0x0207d800)
#define R_TOP_SW_BOND_OVERRIDE_CODE_REG        TOP_BLOCK_ID, (0x02074000)
#define R_TOP_SW_BOND_OVERRIDE_REG(idx)        TOP_BLOCK_ID, (0x02070000 + (((idx) * 4) << 8))
#define R_TOP_SW_BOND_OVERRIDE_REG_0           TOP_BLOCK_ID, (0x02070000)
#define R_TOP_SW_BOND_OVERRIDE_REG_1           TOP_BLOCK_ID, (0x02070400)
#define R_TOP_TOP_CORE_PLL_STATUS_1            TOP_BLOCK_ID, (0x02040800)
#define R_TOP_XG1_LCPLL_FBDIV_CTRL_0           TOP_BLOCK_ID, (0x0207ac00)
#define R_TOP_XG1_LCPLL_FBDIV_CTRL_1           TOP_BLOCK_ID, (0x0207b000)
/* AVS */
#define R_AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTR   AVS_BLOCK_ID, (0x02003c00)
/* MMU */
#define R_CFAPCONFIG                           MMU_BLOCK_ID, (0x02025000)
#define R_CFAPFULLTHRESHOLD                    MMU_BLOCK_ID, (0x02026000)
#define R_CNGCOSPKTLIMIT0(cos, port)           MMU_BLOCK_ID, (0x00004000 + ((cos) << 8) + (port))
#define R_CNGCOSPKTLIMIT1(cos, port)           MMU_BLOCK_ID, (0x00004800 + ((cos) << 8) + (port))
#define R_CNGPORTPKTLIMIT0(port)               MMU_BLOCK_ID, (0x0000c800 + (port))
#define R_CNGPORTPKTLIMIT1(port)               MMU_BLOCK_ID, (0x0000d000 + (port))
#define R_COLOR_DROP_EN(port)                  MMU_BLOCK_ID, (0x00018000 + (port))
#define R_COSLCCOUNT(cos, port)                MMU_BLOCK_ID, (0x00013800 + ((cos) << 8) + (port))
#define R_DYNCELLLIMIT(port)                   MMU_BLOCK_ID, (0x00017800 + (port))
#define R_DYNRESETLIMPORT(port)                MMU_BLOCK_ID, (0x0000e000 + (port))
#define R_DYNXQCNTPORT(port)                   MMU_BLOCK_ID, (0x0000d800 + (port))
#define R_EGRMETERINGBUCKET(port)              MMU_BLOCK_ID, (0x0001d000 + (port))
#define R_EGRMETERINGCONFIG(port)              MMU_BLOCK_ID, (0x0001c800 + (port))
#define R_GBLLIMITRESETLIMIT                   MMU_BLOCK_ID, (0x0208c800)
#define R_GBLLIMITSETLIMIT                     MMU_BLOCK_ID, (0x0208c000)
#define R_HOLCOSCELLMAXLIMIT(cos, port)        MMU_BLOCK_ID, (0x0000f800 + ((cos) << 8) + (port))
#define R_HOLCOSMINXQCNT(cos, port)            MMU_BLOCK_ID, (0x00003800 + ((cos) << 8) + (port))
#define R_HOLCOSPKTRESETLIMIT(cos, port)       MMU_BLOCK_ID, (0x00003000 + ((cos) << 8) + (port))
#define R_HOLCOSPKTSETLIMIT(cos, port)         MMU_BLOCK_ID, (0x00002800 + ((cos) << 8) + (port))
#define R_IBPPKTSETLIMIT(port)                 MMU_BLOCK_ID, (0x00000000 + (port))
#define R_LOG_TO_PHY_PORT_MAPPING(port)        MMU_BLOCK_ID, (0x0005e000 + (port))
#define R_LWMCOSCELLSETLIMIT(cos, port)        MMU_BLOCK_ID, (0x0000f000 + ((cos) << 8) + (port))
#define R_MAXBUCKETCONFIG(cos, port)           MMU_BLOCK_ID, (0x00020800 + ((cos) << 8) + (port))
#define R_MISCCONFIG                           MMU_BLOCK_ID, (0x02027800)
#define R_MMUFLUSHCONTROL                      MMU_BLOCK_ID, (0x02038800)
#define R_MMUPORTENABLE                        MMU_BLOCK_ID, (0x02029800)
#define R_MMUPORTTXENABLE                      MMU_BLOCK_ID, (0x02035000)
#define M_MMU_ARB_TDM_TABLE(idx)               MMU_BLOCK_ID, (0x2c080000+(idx))
#define R_MMU_FC_RX_EN(port)                   MMU_BLOCK_ID, (0x00088000 + (port))
#define R_MMU_FC_TX_EN(port)                   MMU_BLOCK_ID, (0x00088800 + (port))
#define M_MMU_IPMC_GROUP_TBL(aidx, idx)        MMU_BLOCK_ID, (0x280a0000+(((aidx)-2) * 0x4000)+(idx))
#define R_PG2TC(idx, port)                     MMU_BLOCK_ID, (0x00086800 + ((idx) << 8) + (port))
#define R_PGCELLLIMIT(idx, port)               MMU_BLOCK_ID, (0x0008a000 + ((idx) << 8) + (port))
#define R_PGDISCARDSETLIMIT(idx, port)         MMU_BLOCK_ID, (0x0008a800 + ((idx) << 8) + (port))
#define R_PG_CTRL0(port)                       MMU_BLOCK_ID, (0x00085800 + (port))
#define R_PG_CTRL1(port)                       MMU_BLOCK_ID, (0x00086000 + (port))
#define R_SHARED_POOL_CTRL(port)               MMU_BLOCK_ID, (0x00089000 + (port))
#define R_TOTALDYNCELLRESETLIMIT               MMU_BLOCK_ID, (0x02035800)
#define R_TOTALDYNCELLSETLIMIT                 MMU_BLOCK_ID, (0x02028000)
#define R_WRRWEIGHT_COS0(port)                 MMU_BLOCK_ID, (0x0001b000 + (port))
#define R_WRRWEIGHT_COS1(port)                 MMU_BLOCK_ID, (0x0001b100 + (port))
#define R_WRRWEIGHT_COS2(port)                 MMU_BLOCK_ID, (0x0001b200 + (port))
#define R_WRRWEIGHT_COS3(port)                 MMU_BLOCK_ID, (0x0001b300 + (port))
#define R_WRRWEIGHT_COS4(port)                 MMU_BLOCK_ID, (0x0001b400 + (port))
#define R_WRRWEIGHT_COS5(port)                 MMU_BLOCK_ID, (0x0001b500 + (port))
#define R_WRRWEIGHT_COS6(port)                 MMU_BLOCK_ID, (0x0001b600 + (port))
#define R_WRRWEIGHT_COS7(port)                 MMU_BLOCK_ID, (0x0001b700 + (port))
#define R_XQCOSARBSEL(port)                    MMU_BLOCK_ID, (0x0001a800 + (port))
#define R_XQEMPTY(port)                        MMU_BLOCK_ID, (0x00019000 + (port))
/* GPORT0 GPORT1 GPORT2 GPORT3 GPORT4 */
#define R_COMMAND_CONFIG(port)                 (0x00010200 + (port))
#define R_FLUSH_CONTROL(port)                  (0x0001cd00 + (port))
#define R_FRM_LENGTH(port)                     (0x00010500 + (port))
#define R_GMII_EEE_DELAY_ENTRY_TIMER(port)     (0x00011b00 + (port))
#define R_GMII_EEE_WAKE_TIMER(port)            (0x00012100 + (port))
#define R_GPORT_CONFIG                         (0x02020000)
#define R_GPORT_LINK_STATUS_TO_CMIC            (0x02020500)
#define R_GPORT_RSV_MASK                       (0x02020600)
#define R_GPORT_STAT_UPDATE_MASK               (0x02020700)
#define R_GRALN(port)                          (0x00000400 + (port))
#define R_GRBCA(port)                          (0x00001000 + (port))
#define R_GRBYT(port)                          (0x00001c00 + (port))
#define R_GRFCS(port)                          (0x00000000 + (port))
#define R_GRMCA(port)                          (0x00000f00 + (port))
#define R_GROVR(port)                          (0x00000800 + (port))
#define R_GRPKT(port)                          (0x00001b00 + (port))
#define R_GRUC(port)                           (0x00001d00 + (port))
#define R_GRXPF(port)                          (0x00000200 + (port))
#define R_GRX_EEE_LPI_DURATION_COUNTER(port)   (0x00005700 + (port))
#define R_GRX_EEE_LPI_EVENT_COUNTER(port)      (0x00005600 + (port))
#define R_GTBCA(port)                          (0x00003e00 + (port))
#define R_GTBYT(port)                          (0x00004a00 + (port))
#define R_GTFCS(port)                          (0x00003200 + (port))
#define R_GTMCA(port)                          (0x00003d00 + (port))
#define R_GTOVR(port)                          (0x00003400 + (port))
#define R_GTPKT(port)                          (0x00004900 + (port))
#define R_GTUC(port)                           (0x00004b00 + (port))
#define R_GTXPF(port)                          (0x00003000 + (port))
#define R_GTX_EEE_LPI_DURATION_COUNTER(port)   (0x00005900 + (port))
#define R_GTX_EEE_LPI_EVENT_COUNTER(port)      (0x00005800 + (port))
#define R_MAC_0(port)                          (0x00010300 + (port))
#define R_MAC_1(port)                          (0x00010400 + (port))
#define R_MAC_PFC_CTRL(port)                   (0x0001d000 + (port))
#define R_MAC_PFC_DA_0(port)                   (0x0001c200 + (port))
#define R_MAC_PFC_DA_1(port)                   (0x0001c300 + (port))
#define R_MAC_PFC_OPCODE(port)                 (0x0001c100 + (port))
#define R_MAC_PFC_REFRESH_CTRL(port)           (0x0001d100 + (port))
#define R_MAC_PFC_TYPE(port)                   (0x0001c000 + (port))
#define R_MII_EEE_DELAY_ENTRY_TIMER(port)      (0x00011a00 + (port))
#define R_MII_EEE_WAKE_TIMER(port)             (0x00012000 + (port))
#define R_PFC_XOFF_TIMER(port)                 (0x00011800 + (port))
#define R_TS_STATUS_CNTRL(port)                (0x0001c600 + (port))
#define R_TX_IPG_LENGTH(port)                  (0x00011700 + (port))
#define R_TX_TS_DATA(port)                     (0x0001c700 + (port))
#define R_TX_TS_SEQ_ID(port)                   (0x00010f00 + (port))
#define R_UMAC_EEE_CTRL(port)                  (0x00011900 + (port))
#define R_UMAC_EEE_REF_COUNT(port)             (0x00011c00 + (port))
/* IPIPE */
#define R_AUX_ARB_CONTROL                      IPIPE_BLOCK_ID, (0x02000000)
#define R_AUX_ARB_CONTROL_2                    IPIPE_BLOCK_ID, (0x02000100)
#define M_COS_MAP(idx)                         IPIPE_BLOCK_ID, (0x404c0000+(idx))
#define R_DOS_CONTROL                          IPIPE_BLOCK_ID, (0x06000100)
#define R_DOS_CONTROL2                         IPIPE_BLOCK_ID, (0x06000200)
#define M_DSCP_TB(idx)                         IPIPE_BLOCK_ID, (0x24000000+(idx))
#define M_EGR_MASK(idx)                        IPIPE_BLOCK_ID, (0x40040000+(idx))
#define R_EMIRROR_CONTROL_64(port)             IPIPE_BLOCK_ID, (0x40000800 + (port))
#define M_EM_MTP_INDEX(idx)                    IPIPE_BLOCK_ID, (0x40340000+(idx))
#define R_EPC_LINK_BMAP_64                     IPIPE_BLOCK_ID, (0x42002700)
#define M_FP_COUNTER_TABLE(idx)                IPIPE_BLOCK_ID, (0x38140000+(idx))
#define M_FP_GLOBAL_MASK_TCAM(idx)             IPIPE_BLOCK_ID, (0x38180000+(idx))
#define M_FP_METER_TABLE(idx)                  IPIPE_BLOCK_ID, (0x38100000+(idx))
#define M_FP_POLICY_TABLE(idx)                 IPIPE_BLOCK_ID, (0x380c0000+(idx))
#define M_FP_PORT_FIELD_SEL(idx)               IPIPE_BLOCK_ID, (0x34000000+(idx))
#define R_FP_SLICE_ENABLE                      IPIPE_BLOCK_ID, (0x3a000000)
#define M_FP_SLICE_MAP                         IPIPE_BLOCK_ID, (0x38080000)
#define M_FP_STORM_CONTROL_METERS(idx)         IPIPE_BLOCK_ID, (0x381c0000+(idx))
#define M_FP_TCAM(idx)                         IPIPE_BLOCK_ID, (0x38040000+(idx))
#define M_FP_UDF_OFFSET(idx)                   IPIPE_BLOCK_ID, (0x08080000+(idx))
#define R_HASH_CONTROL                         IPIPE_BLOCK_ID, (0x06000400)
#define R_HOLD_COS(idx)                        IPIPE_BLOCK_ID, (0x42005b00 + ((idx) << 8))
#define R_HOLD_COS0                            IPIPE_BLOCK_ID, (0x42005b00)
#define R_HOLD_COS1                            IPIPE_BLOCK_ID, (0x42005c00)
#define R_HOLD_COS2                            IPIPE_BLOCK_ID, (0x42005d00)
#define R_HOLD_COS3                            IPIPE_BLOCK_ID, (0x42005e00)
#define R_HOLD_COS4                            IPIPE_BLOCK_ID, (0x42005f00)
#define R_HOLD_COS5                            IPIPE_BLOCK_ID, (0x42006000)
#define R_HOLD_COS6                            IPIPE_BLOCK_ID, (0x42006100)
#define R_HOLD_COS7                            IPIPE_BLOCK_ID, (0x42006200)
#define R_HOLD_COS_PORT_SELECT                 IPIPE_BLOCK_ID, (0x42006800)
#define R_IARB_TDM_CONTROL                     IPIPE_BLOCK_ID, (0x02000900)
#define M_IARB_TDM_TABLE(idx)                  IPIPE_BLOCK_ID, (0x00080000+(idx))
#define M_IFP_REDIRECTION_PROFILE(idx)         IPIPE_BLOCK_ID, (0x3c040000+(idx))
#define R_IGMP_MLD_PKT_CONTROL(port)           IPIPE_BLOCK_ID, (0x1c000500 + (port))
#define R_IING_EGRMSKBMAP_64(port)             IPIPE_BLOCK_ID, (0x40000f00 + (port))
#define M_IM_MTP_INDEX(idx)                    IPIPE_BLOCK_ID, (0x40300000+(idx))
#define R_ING_CONFIG_64                        IPIPE_BLOCK_ID, (0x06000000)
#define R_ING_EGRMSKBMAP_64(port)              IPIPE_BLOCK_ID, (0x40000e00 + (port))
#define R_ING_HW_RESET_CONTROL_1               IPIPE_BLOCK_ID, (0x02000200)
#define R_ING_HW_RESET_CONTROL_2               IPIPE_BLOCK_ID, (0x02000300)
#define R_ING_MISC_CONFIG                      IPIPE_BLOCK_ID, (0x42002e00)
#define M_ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLE(idx)   IPIPE_BLOCK_ID, (0x000c0000+(idx))
#define M_ING_PRI_CNG_MAP(idx)                 IPIPE_BLOCK_ID, (0x34200000+(idx))
#define M_ING_VLAN_TAG_ACTION_PROFILE(idx)     IPIPE_BLOCK_ID, (0x0c2c0000+(idx))
#define R_IP_TO_CMICM_CREDIT_TRANSFER          IPIPE_BLOCK_ID, (0x02002300)
#define R_IUNKNOWN_MCAST_BLOCK_MASK_64(port)   IPIPE_BLOCK_ID, (0x40000300 + (port))
#define R_IUNKNOWN_UCAST_BLOCK_MASK_64(port)   IPIPE_BLOCK_ID, (0x40000100 + (port))
#define M_L2MC(idx)                            IPIPE_BLOCK_ID, (0x20000000+(idx))
#define R_L2_AGE_TIMER                         IPIPE_BLOCK_ID, (0x02000400)
#define R_L2_AUX_HASH_CONTROL                  IPIPE_BLOCK_ID, (0x1e000100)
#define M_L2_ENTRY(idx)                        IPIPE_BLOCK_ID, (0x1c000000+(idx))
#define M_L2_USER_ENTRY(idx)                   IPIPE_BLOCK_ID, (0x1c100000+(idx))
#define R_L2_USER_ENTRY_CAM_DBGCTRL            IPIPE_BLOCK_ID, (0x1e010000)
#define R_L3_AUX_HASH_CONTROL                  IPIPE_BLOCK_ID, (0x26000000)
#define R_MIRROR_CONTROL(port)                 IPIPE_BLOCK_ID, (0x40000600 + (port))
#define M_NONUCAST_TRUNK_BLOCK_MASK(idx)       IPIPE_BLOCK_ID, (0x40280000+(idx))
#define M_PORT(idx)                            IPIPE_BLOCK_ID, (0x04000000+(idx))
#define R_PROTOCOL_PKT_CONTROL(port)           IPIPE_BLOCK_ID, (0x1c000400 + (port))
#define M_SOURCE_TRUNK_MAP(idx)                IPIPE_BLOCK_ID, (0x08040000+(idx))
#define R_STORM_CONTROL_METER_CONFIG(port)     IPIPE_BLOCK_ID, (0x34000200 + (port))
#define R_SW2_FP_DST_ACTION_CONTROL            IPIPE_BLOCK_ID, (0x42003400)
#define R_SW2_RAM_CONTROL_4_64                 IPIPE_BLOCK_ID, (0x42010700)
#define M_SYSTEM_CONFIG_TABLE(idx)             IPIPE_BLOCK_ID, (0x040c0000+(idx))
#define M_TRUNK32_CONFIG_TABLE(idx)            IPIPE_BLOCK_ID, (0x04100000+(idx))
#define M_TRUNK32_PORT_TABLE(idx)              IPIPE_BLOCK_ID, (0x081c0000+(idx))
#define M_TRUNK_BITMAP(idx)                    IPIPE_BLOCK_ID, (0x40100000+(idx))
#define M_TRUNK_GROUP(idx)                     IPIPE_BLOCK_ID, (0x400c0000+(idx))
#define R_UNKNOWN_MCAST_BLOCK_MASK_64(port)    IPIPE_BLOCK_ID, (0x40000200 + (port))
#define R_UNKNOWN_UCAST_BLOCK_MASK_64(port)    IPIPE_BLOCK_ID, (0x40000000 + (port))
#define R_VFP_CAM_CONTROL_TM_7_THRU_0          IPIPE_BLOCK_ID, (0x0e011e00)
#define M_VLAN(idx)                            IPIPE_BLOCK_ID, (0x10000000+(idx))
#define R_VLAN_CTRL                            IPIPE_BLOCK_ID, (0x06000300)
#define R_VLAN_DEFAULT_PBM                     IPIPE_BLOCK_ID, (0x12000000)
#define M_VLAN_PROFILE(idx)                    IPIPE_BLOCK_ID, (0x10080000+(idx))
#define M_VLAN_STG(idx)                        IPIPE_BLOCK_ID, (0x10040000+(idx))
#define R_VLAN_SUBNET_CAM_DBGCTRL              IPIPE_BLOCK_ID, (0x0e010200)
/* EPIPE */
#define R_EGR_CONFIG                           EPIPE_BLOCK_ID, (0x06000400)
#define M_EGR_EM_MTP_INDEX(idx)                EPIPE_BLOCK_ID, (0x14380000+(idx))
#define M_EGR_ENABLE(idx)                      EPIPE_BLOCK_ID, (0x30800000+(idx))
#define R_EGR_HW_RESET_CONTROL_0               EPIPE_BLOCK_ID, (0x02000000)
#define R_EGR_HW_RESET_CONTROL_1               EPIPE_BLOCK_ID, (0x02000100)
#define M_EGR_IM_MTP_INDEX(idx)                EPIPE_BLOCK_ID, (0x14340000+(idx))
#define R_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPING(port)   EPIPE_BLOCK_ID, (0x30001c00 + (port))
#define R_EGR_PORT_64(port)                    EPIPE_BLOCK_ID, (0x04000900 + (port))
#define R_EGR_PORT_BUFFER_CLK_SHUTDOWN         EPIPE_BLOCK_ID, (0x32011000)
#define M_EGR_PORT_CREDIT_RESET(idx)           EPIPE_BLOCK_ID, (0x300c0000+(idx))
#define M_EGR_PORT_REQUESTS(idx)               EPIPE_BLOCK_ID, (0x30040000+(idx))
#define M_EGR_VLAN(idx)                        EPIPE_BLOCK_ID, (0x10140000+(idx))
#define R_EGR_VLAN_CONTROL_1(port)             EPIPE_BLOCK_ID, (0x04000b00 + (port))
#define M_EGR_VLAN_STG(idx)                    EPIPE_BLOCK_ID, (0x10180000+(idx))
/* CMIC */
#define CMIC_CMC0_CH0_DMA_CTRL                 (0x03231140)
#define CMIC_CMC0_CH1_COS_CTRL_RX_0            (0x03231170)
#define CMIC_CMC0_CH1_DMA_CTRL                 (0x03231144)
#define CMIC_CMC0_CHx_DMA_CTRL(idx)            (0x03231140 + (idx) * 4)
#define CMIC_CMC0_DMA_DESC(idx)                (0x03231158 + (idx) * 4)
#define CMIC_CMC0_DMA_STAT                     (0x03231150)
#define CMIC_CMC0_DMA_STAT_CLR                 (0x032311a4)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0         (0x03231474)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1         (0x03231478)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2         (0x0323147c)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_3         (0x032314ac)
#define CMIC_CMC0_MIIM_ADDRESS                 (0x03231088)
#define CMIC_CMC0_MIIM_CTRL                    (0x0323108c)
#define CMIC_CMC0_MIIM_PARAM                   (0x03231080)
#define CMIC_CMC0_MIIM_READ_DATA               (0x03231084)
#define CMIC_CMC0_MIIM_STAT                    (0x03231090)
#define CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNT    (0x03231004)
#define CMIC_CMC0_SCHAN_CTRL                   (0x03231000)
#define CMIC_CMC0_SCHAN_ERR                    (0x03231008)
#define CMIC_CMC0_SCHAN_MESSAGE(idx)           (0x0323100c + (idx)*4)
#define CMIC_CMC_CHx_DMA_CTRL(idx)             (0x03231140 + (idx) * 4)
#define CMIC_CMC_DMA_CTRL(idx)                 (0x03231140 + (idx)*4)
#define CMIC_CMC_DMA_DESC(idx)                 (0x03231158 + (idx) * 4)
#define CMIC_CMC_DMA_STAT                      (0x03231150)
#define CMIC_CMC_DMA_STAT_CLR                  (0x032311a4)
#define CMIC_CMC_HOSTMEM_ADDR_REMAP(idx)       (0x03231474 + (idx)*4)
#define CMIC_CMC_MIIM_ADDRESS                  (0x03231088)
#define CMIC_CMC_MIIM_CTRL                     (0x0323108c)
#define CMIC_CMC_MIIM_PARAM                    (0x03231080)
#define CMIC_CMC_MIIM_READ_DATA                (0x03231084)
#define CMIC_CMC_MIIM_STAT                     (0x03231090)
#define CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNT     (0x03231004)
#define CMIC_CMC_SCHAN_CTRL                    (0x03231000)
#define CMIC_CMC_SCHAN_ERR                     (0x03231008)
#define CMIC_CMC_SCHAN_MESSAGE(idx)            (0x0323100c + (idx)*4)
#define CMIC_CPS_RESET                         (0x03210220)
#define CMIC_DEV_REV_ID                        (0x03210224)
#define CMIC_GP_DATA_IN                        (0x03202000)
#define CMIC_GP_DATA_OUT                       (0x03202004)
#define CMIC_GP_OUT_EN                         (0x03202008)
#define CMIC_LEDUP0_CTRL                       (0x03220000)
#define CMIC_LEDUP0_DATA_RAM(idx)              (0x03220400 + (idx)*4)
#define CMIC_LEDUP0_PORT_ORDER_REMAP(idx)      (0x03220010 + (idx)*4)
#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3       (0x03220010)
#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63     (0x0322004c)
#define CMIC_LEDUP0_PROGRAM_RAM(idx)           (0x03220800 + (idx)*4)
#define CMIC_PCIE_USERIF_PURGE_CONTROL         (0x03210260)
#define CMIC_RATE_ADJUST_EXT_MDIO              (0x03211000)
#define CMIC_RATE_ADJUST_INT_MDIO              (0x03211004)
#define CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITS   (0x0321a000)
#define CMIC_SBUS_RING_MAP(idx)                (0x03210098 + (idx)*4)
#define CMIC_SBUS_RING_MAP_0_7                 (0x03210098)
#define CMIC_SBUS_RING_MAP_16_23               (0x032100a0)
#define CMIC_SBUS_RING_MAP_24_31               (0x032100a4)
#define CMIC_SBUS_RING_MAP_32_39               (0x032100a8)
#define CMIC_SBUS_RING_MAP_40_47               (0x032100ac)
#define CMIC_SBUS_RING_MAP_8_15                (0x0321009c)
#define CMIC_SBUS_TIMEOUT                      (0x03210094)
#define CMIC_SEMAPHORE_1                       (0x03210300)
#define CMIC_SEMAPHORE_1_SHADOW                (0x03210304)
#define CMIC_SEMAPHORE_2                       (0x03210308)
#define CMIC_SEMAPHORE_2_SHADOW                (0x0321030c)
#define CMIC_SEMAPHORE_3                       (0x03210310)
#define CMIC_SEMAPHORE_3_SHADOW                (0x03210314)
#define IPROC_WRAP_TOP_STRAP_STATUS_1          (0x1800fca8)
/* PGW_GE0 PGW_GE1 PGW_GE2 */
#define R_PGW_GE0_MODE_REG                     (0x02090200)
#define R_PGW_GE1_MODE_REG                     (0x02090300)
#define R_PGW_GE_RXFIFO_SOFT_RESET             (0x02090400)
/* IPROC */
#define R_CCG_GP_DATA_IN                       (0x1800a000)
#define R_CCG_GP_DATA_OUT                      (0x1800a004)
#define R_CCG_GP_OUT_EN                        (0x1800a008)
#define R_CCS_GP_DATA_IN                       (0x18030000)
#define R_CCS_GP_DATA_OUT                      (0x18030004)
#define R_CCS_GP_OUT_EN                        (0x18030008)
#define R_CMICD_M0_IDM_IO_CONTROL_DIRECT       (0x18103408)
#define R_CMICD_S0_IDM_IO_CONTROL_DIRECT       (0x1810a408)
#define R_CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATA   (0x18002004)
#define R_CHIPCOMMONG_MII_MANAGEMENT_CONTROL   (0x18002000)
#define R_DMU_CRU_RESET                        (0x1800f200)
#define R_IHOST_SCU_CONTROL                    (0x19020000)



/* Fields Marcos */
#define _DD_MAKEMASK1(n) (1 << (n))
#define _DD_MAKEMASK(v,n) ((((1)<<(v))-1) << (n))
#define _DD_MAKEVALUE(v,n) ((v) << (n))
#define _DD_GETVALUE(v,n,m) (((v) & (m)) >> (n))
/* Packet DMA RX descriptor.  */
#define S_DCB1_BYTES_TRANSFERRED           0                               
#define M_DCB1_BYTES_TRANSFERRED           _DD_MAKEMASK(16, S_DCB1_BYTES_TRANSFERRED)
#define V_DCB1_BYTES_TRANSFERRED(x)        _DD_MAKEVALUE(x,S_DCB1_BYTES_TRANSFERRED)
#define G_DCB1_BYTES_TRANSFERRED(x)        _DD_GETVALUE(x, S_DCB1_BYTES_TRANSFERRED, M_DCB1_BYTES_TRANSFERRED)
#define S_DCB1_END_BIT                     16                              
#define M_DCB1_END_BIT                     _DD_MAKEMASK(1, S_DCB1_END_BIT) 
#define V_DCB1_END_BIT(x)                  _DD_MAKEVALUE(x,S_DCB1_END_BIT) 
#define G_DCB1_END_BIT(x)                  _DD_GETVALUE(x, S_DCB1_END_BIT, M_DCB1_END_BIT)
#define S_DCB1_START_BIT                   17                              
#define M_DCB1_START_BIT                   _DD_MAKEMASK(1, S_DCB1_START_BIT)
#define V_DCB1_START_BIT(x)                _DD_MAKEVALUE(x,S_DCB1_START_BIT)
#define G_DCB1_START_BIT(x)                _DD_GETVALUE(x, S_DCB1_START_BIT, M_DCB1_START_BIT)
#define S_DCB1_CELL_ERROR                  18                              
#define M_DCB1_CELL_ERROR                  _DD_MAKEMASK(1, S_DCB1_CELL_ERROR)
#define V_DCB1_CELL_ERROR(x)               _DD_MAKEVALUE(x,S_DCB1_CELL_ERROR)
#define G_DCB1_CELL_ERROR(x)               _DD_GETVALUE(x, S_DCB1_CELL_ERROR, M_DCB1_CELL_ERROR)
#define S_DCB1_PKTDATA_READ_ECC_ERROR      19                              
#define M_DCB1_PKTDATA_READ_ECC_ERROR      _DD_MAKEMASK(1, S_DCB1_PKTDATA_READ_ECC_ERROR)
#define V_DCB1_PKTDATA_READ_ECC_ERROR(x)   _DD_MAKEVALUE(x,S_DCB1_PKTDATA_READ_ECC_ERROR)
#define G_DCB1_PKTDATA_READ_ECC_ERROR(x)   _DD_GETVALUE(x, S_DCB1_PKTDATA_READ_ECC_ERROR, M_DCB1_PKTDATA_READ_ECC_ERROR)
#define S_DCB1_STATUS_READ_ECC_ERROR       20                              
#define M_DCB1_STATUS_READ_ECC_ERROR       _DD_MAKEMASK(1, S_DCB1_STATUS_READ_ECC_ERROR)
#define V_DCB1_STATUS_READ_ECC_ERROR(x)    _DD_MAKEVALUE(x,S_DCB1_STATUS_READ_ECC_ERROR)
#define G_DCB1_STATUS_READ_ECC_ERROR(x)    _DD_GETVALUE(x, S_DCB1_STATUS_READ_ECC_ERROR, M_DCB1_STATUS_READ_ECC_ERROR)
#define S_DCB1_DONE                        31                              
#define M_DCB1_DONE                        _DD_MAKEMASK(1, S_DCB1_DONE)    
#define V_DCB1_DONE(x)                     _DD_MAKEVALUE(x,S_DCB1_DONE)    
#define G_DCB1_DONE(x)                     _DD_GETVALUE(x, S_DCB1_DONE, M_DCB1_DONE)
#define S_DCB1_EP_TO_CPU_HDR_TIMESTAMP_UPPER 0                               
#define M_DCB1_EP_TO_CPU_HDR_TIMESTAMP_UPPER _DD_MAKEMASK(32, S_DCB1_EP_TO_CPU_HDR_TIMESTAMP_UPPER)
#define V_DCB1_EP_TO_CPU_HDR_TIMESTAMP_UPPER(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_TIMESTAMP_UPPER)
#define G_DCB1_EP_TO_CPU_HDR_TIMESTAMP_UPPER(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_TIMESTAMP_UPPER, M_DCB1_EP_TO_CPU_HDR_TIMESTAMP_UPPER)
#define S_DCB1_EP_TO_CPU_HDR_INCOMING_TAG_STATUS 0                               
#define M_DCB1_EP_TO_CPU_HDR_INCOMING_TAG_STATUS _DD_MAKEMASK(2, S_DCB1_EP_TO_CPU_HDR_INCOMING_TAG_STATUS)
#define V_DCB1_EP_TO_CPU_HDR_INCOMING_TAG_STATUS(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_INCOMING_TAG_STATUS)
#define G_DCB1_EP_TO_CPU_HDR_INCOMING_TAG_STATUS(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_INCOMING_TAG_STATUS, M_DCB1_EP_TO_CPU_HDR_INCOMING_TAG_STATUS)
#define S_DCB1_EP_TO_CPU_HDR_ING_OTAG_ACTION 2                               
#define M_DCB1_EP_TO_CPU_HDR_ING_OTAG_ACTION _DD_MAKEMASK(2, S_DCB1_EP_TO_CPU_HDR_ING_OTAG_ACTION)
#define V_DCB1_EP_TO_CPU_HDR_ING_OTAG_ACTION(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_ING_OTAG_ACTION)
#define G_DCB1_EP_TO_CPU_HDR_ING_OTAG_ACTION(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_ING_OTAG_ACTION, M_DCB1_EP_TO_CPU_HDR_ING_OTAG_ACTION)
#define S_DCB1_EP_TO_CPU_HDR_ING_ITAG_ACTION 4                               
#define M_DCB1_EP_TO_CPU_HDR_ING_ITAG_ACTION _DD_MAKEMASK(2, S_DCB1_EP_TO_CPU_HDR_ING_ITAG_ACTION)
#define V_DCB1_EP_TO_CPU_HDR_ING_ITAG_ACTION(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_ING_ITAG_ACTION)
#define G_DCB1_EP_TO_CPU_HDR_ING_ITAG_ACTION(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_ING_ITAG_ACTION, M_DCB1_EP_TO_CPU_HDR_ING_ITAG_ACTION)
#define S_DCB1_EP_TO_CPU_HDR_SD_TAG_PRESENT 6                               
#define M_DCB1_EP_TO_CPU_HDR_SD_TAG_PRESENT _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_SD_TAG_PRESENT)
#define V_DCB1_EP_TO_CPU_HDR_SD_TAG_PRESENT(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_SD_TAG_PRESENT)
#define G_DCB1_EP_TO_CPU_HDR_SD_TAG_PRESENT(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_SD_TAG_PRESENT, M_DCB1_EP_TO_CPU_HDR_SD_TAG_PRESENT)
#define S_DCB1_EP_TO_CPU_HDR_SWITCH        7                               
#define M_DCB1_EP_TO_CPU_HDR_SWITCH        _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_SWITCH)
#define V_DCB1_EP_TO_CPU_HDR_SWITCH(x)     _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_SWITCH)
#define G_DCB1_EP_TO_CPU_HDR_SWITCH(x)     _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_SWITCH, M_DCB1_EP_TO_CPU_HDR_SWITCH)
#define S_DCB1_EP_TO_CPU_HDR_PKT_HIGIG_LOOKUP 8                               
#define M_DCB1_EP_TO_CPU_HDR_PKT_HIGIG_LOOKUP _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_PKT_HIGIG_LOOKUP)
#define V_DCB1_EP_TO_CPU_HDR_PKT_HIGIG_LOOKUP(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_PKT_HIGIG_LOOKUP)
#define G_DCB1_EP_TO_CPU_HDR_PKT_HIGIG_LOOKUP(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_PKT_HIGIG_LOOKUP, M_DCB1_EP_TO_CPU_HDR_PKT_HIGIG_LOOKUP)
#define S_DCB1_EP_TO_CPU_HDR_SRC_HIGIG_TYPE 9                               
#define M_DCB1_EP_TO_CPU_HDR_SRC_HIGIG_TYPE _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_SRC_HIGIG_TYPE)
#define V_DCB1_EP_TO_CPU_HDR_SRC_HIGIG_TYPE(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_SRC_HIGIG_TYPE)
#define G_DCB1_EP_TO_CPU_HDR_SRC_HIGIG_TYPE(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_SRC_HIGIG_TYPE, M_DCB1_EP_TO_CPU_HDR_SRC_HIGIG_TYPE)
#define S_DCB1_EP_TO_CPU_HDR_SRC_HIGIG     10                              
#define M_DCB1_EP_TO_CPU_HDR_SRC_HIGIG     _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_SRC_HIGIG)
#define V_DCB1_EP_TO_CPU_HDR_SRC_HIGIG(x)  _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_SRC_HIGIG)
#define G_DCB1_EP_TO_CPU_HDR_SRC_HIGIG(x)  _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_SRC_HIGIG, M_DCB1_EP_TO_CPU_HDR_SRC_HIGIG)
#define S_DCB1_EP_TO_CPU_HDR_IP_ROUTED     11                              
#define M_DCB1_EP_TO_CPU_HDR_IP_ROUTED     _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_IP_ROUTED)
#define V_DCB1_EP_TO_CPU_HDR_IP_ROUTED(x)  _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_IP_ROUTED)
#define G_DCB1_EP_TO_CPU_HDR_IP_ROUTED(x)  _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_IP_ROUTED, M_DCB1_EP_TO_CPU_HDR_IP_ROUTED)
#define S_DCB1_EP_TO_CPU_HDR_L3ONLY        12                              
#define M_DCB1_EP_TO_CPU_HDR_L3ONLY        _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_L3ONLY)
#define V_DCB1_EP_TO_CPU_HDR_L3ONLY(x)     _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_L3ONLY)
#define G_DCB1_EP_TO_CPU_HDR_L3ONLY(x)     _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_L3ONLY, M_DCB1_EP_TO_CPU_HDR_L3ONLY)
#define S_DCB1_EP_TO_CPU_HDR_VNTAG_ACTION  13                              
#define M_DCB1_EP_TO_CPU_HDR_VNTAG_ACTION  _DD_MAKEMASK(2, S_DCB1_EP_TO_CPU_HDR_VNTAG_ACTION)
#define V_DCB1_EP_TO_CPU_HDR_VNTAG_ACTION(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_VNTAG_ACTION)
#define G_DCB1_EP_TO_CPU_HDR_VNTAG_ACTION(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_VNTAG_ACTION, M_DCB1_EP_TO_CPU_HDR_VNTAG_ACTION)
#define S_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_INDICATOR 15                              
#define M_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_INDICATOR _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_INDICATOR)
#define V_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_INDICATOR(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_INDICATOR)
#define G_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_INDICATOR(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_INDICATOR, M_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_INDICATOR)
#define S_DCB1_EP_TO_CPU_HDR_DO_NOT_CHANGE_TTL 16                              
#define M_DCB1_EP_TO_CPU_HDR_DO_NOT_CHANGE_TTL _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_DO_NOT_CHANGE_TTL)
#define V_DCB1_EP_TO_CPU_HDR_DO_NOT_CHANGE_TTL(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_DO_NOT_CHANGE_TTL)
#define G_DCB1_EP_TO_CPU_HDR_DO_NOT_CHANGE_TTL(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_DO_NOT_CHANGE_TTL, M_DCB1_EP_TO_CPU_HDR_DO_NOT_CHANGE_TTL)
#define S_DCB1_EP_TO_CPU_HDR_BPDU          17                              
#define M_DCB1_EP_TO_CPU_HDR_BPDU          _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_BPDU)
#define V_DCB1_EP_TO_CPU_HDR_BPDU(x)       _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_BPDU)
#define G_DCB1_EP_TO_CPU_HDR_BPDU(x)       _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_BPDU, M_DCB1_EP_TO_CPU_HDR_BPDU)
#define S_DCB1_EP_TO_CPU_HDR_TIMESTAMP_TYPE 18                              
#define M_DCB1_EP_TO_CPU_HDR_TIMESTAMP_TYPE _DD_MAKEMASK(2, S_DCB1_EP_TO_CPU_HDR_TIMESTAMP_TYPE)
#define V_DCB1_EP_TO_CPU_HDR_TIMESTAMP_TYPE(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_TIMESTAMP_TYPE)
#define G_DCB1_EP_TO_CPU_HDR_TIMESTAMP_TYPE(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_TIMESTAMP_TYPE, M_DCB1_EP_TO_CPU_HDR_TIMESTAMP_TYPE)
#define S_DCB1_EP_TO_CPU_HDR_COS           20                              
#define M_DCB1_EP_TO_CPU_HDR_COS           _DD_MAKEMASK(4, S_DCB1_EP_TO_CPU_HDR_COS)
#define V_DCB1_EP_TO_CPU_HDR_COS(x)        _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_COS)
#define G_DCB1_EP_TO_CPU_HDR_COS(x)        _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_COS, M_DCB1_EP_TO_CPU_HDR_COS)
#define S_DCB1_EP_TO_CPU_HDR_IM_MTP_INDEX  24                              
#define M_DCB1_EP_TO_CPU_HDR_IM_MTP_INDEX  _DD_MAKEMASK(5, S_DCB1_EP_TO_CPU_HDR_IM_MTP_INDEX)
#define V_DCB1_EP_TO_CPU_HDR_IM_MTP_INDEX(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_IM_MTP_INDEX)
#define G_DCB1_EP_TO_CPU_HDR_IM_MTP_INDEX(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_IM_MTP_INDEX, M_DCB1_EP_TO_CPU_HDR_IM_MTP_INDEX)
#define S_DCB1_EP_TO_CPU_HDR_ECN           29                              
#define M_DCB1_EP_TO_CPU_HDR_ECN           _DD_MAKEMASK(2, S_DCB1_EP_TO_CPU_HDR_ECN)
#define V_DCB1_EP_TO_CPU_HDR_ECN(x)        _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_ECN)
#define G_DCB1_EP_TO_CPU_HDR_ECN(x)        _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_ECN, M_DCB1_EP_TO_CPU_HDR_ECN)
#define S_DCB1_EP_TO_CPU_HDR_CHANGE_ECN    31                              
#define M_DCB1_EP_TO_CPU_HDR_CHANGE_ECN    _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_CHANGE_ECN)
#define V_DCB1_EP_TO_CPU_HDR_CHANGE_ECN(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_CHANGE_ECN)
#define G_DCB1_EP_TO_CPU_HDR_CHANGE_ECN(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_CHANGE_ECN, M_DCB1_EP_TO_CPU_HDR_CHANGE_ECN)
#define S_DCB1_EP_TO_CPU_HDR_TIMESTAMP     0                               
#define M_DCB1_EP_TO_CPU_HDR_TIMESTAMP     _DD_MAKEMASK(32, S_DCB1_EP_TO_CPU_HDR_TIMESTAMP)
#define V_DCB1_EP_TO_CPU_HDR_TIMESTAMP(x)  _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_TIMESTAMP)
#define G_DCB1_EP_TO_CPU_HDR_TIMESTAMP(x)  _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_TIMESTAMP, M_DCB1_EP_TO_CPU_HDR_TIMESTAMP)
#define S_DCB1_EP_TO_CPU_HDR_VFI           0                               
#define M_DCB1_EP_TO_CPU_HDR_VFI           _DD_MAKEMASK(14, S_DCB1_EP_TO_CPU_HDR_VFI)
#define V_DCB1_EP_TO_CPU_HDR_VFI(x)        _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_VFI)
#define G_DCB1_EP_TO_CPU_HDR_VFI(x)        _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_VFI, M_DCB1_EP_TO_CPU_HDR_VFI)
#define S_DCB1_EP_TO_CPU_HDR_DSCP          0                               
#define M_DCB1_EP_TO_CPU_HDR_DSCP          _DD_MAKEMASK(6, S_DCB1_EP_TO_CPU_HDR_DSCP)
#define V_DCB1_EP_TO_CPU_HDR_DSCP(x)       _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_DSCP)
#define G_DCB1_EP_TO_CPU_HDR_DSCP(x)       _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_DSCP, M_DCB1_EP_TO_CPU_HDR_DSCP)
#define S_DCB1_EP_TO_CPU_HDR_CHANGE_DSCP   6                               
#define M_DCB1_EP_TO_CPU_HDR_CHANGE_DSCP   _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_CHANGE_DSCP)
#define V_DCB1_EP_TO_CPU_HDR_CHANGE_DSCP(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_CHANGE_DSCP)
#define G_DCB1_EP_TO_CPU_HDR_CHANGE_DSCP(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_CHANGE_DSCP, M_DCB1_EP_TO_CPU_HDR_CHANGE_DSCP)
#define S_DCB1_EP_TO_CPU_HDR_IMIRROR       7                               
#define M_DCB1_EP_TO_CPU_HDR_IMIRROR       _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_IMIRROR)
#define V_DCB1_EP_TO_CPU_HDR_IMIRROR(x)    _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_IMIRROR)
#define G_DCB1_EP_TO_CPU_HDR_IMIRROR(x)    _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_IMIRROR, M_DCB1_EP_TO_CPU_HDR_IMIRROR)
#define S_DCB1_EP_TO_CPU_HDR_EMIRROR       8                               
#define M_DCB1_EP_TO_CPU_HDR_EMIRROR       _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_EMIRROR)
#define V_DCB1_EP_TO_CPU_HDR_EMIRROR(x)    _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_EMIRROR)
#define G_DCB1_EP_TO_CPU_HDR_EMIRROR(x)    _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_EMIRROR, M_DCB1_EP_TO_CPU_HDR_EMIRROR)
#define S_DCB1_EP_TO_CPU_HDR_OUTER_CFI     9                               
#define M_DCB1_EP_TO_CPU_HDR_OUTER_CFI     _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_OUTER_CFI)
#define V_DCB1_EP_TO_CPU_HDR_OUTER_CFI(x)  _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_OUTER_CFI)
#define G_DCB1_EP_TO_CPU_HDR_OUTER_CFI(x)  _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_OUTER_CFI, M_DCB1_EP_TO_CPU_HDR_OUTER_CFI)
#define S_DCB1_EP_TO_CPU_HDR_OUTER_PRI     10                              
#define M_DCB1_EP_TO_CPU_HDR_OUTER_PRI     _DD_MAKEMASK(3, S_DCB1_EP_TO_CPU_HDR_OUTER_PRI)
#define V_DCB1_EP_TO_CPU_HDR_OUTER_PRI(x)  _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_OUTER_PRI)
#define G_DCB1_EP_TO_CPU_HDR_OUTER_PRI(x)  _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_OUTER_PRI, M_DCB1_EP_TO_CPU_HDR_OUTER_PRI)
#define S_DCB1_EP_TO_CPU_HDR_HG_COS        13                              
#define M_DCB1_EP_TO_CPU_HDR_HG_COS        _DD_MAKEMASK(5, S_DCB1_EP_TO_CPU_HDR_HG_COS)
#define V_DCB1_EP_TO_CPU_HDR_HG_COS(x)     _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_HG_COS)
#define G_DCB1_EP_TO_CPU_HDR_HG_COS(x)     _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_HG_COS, M_DCB1_EP_TO_CPU_HDR_HG_COS)
#define S_DCB1_EP_TO_CPU_HDR_INNER_VID     18                              
#define M_DCB1_EP_TO_CPU_HDR_INNER_VID     _DD_MAKEMASK(12, S_DCB1_EP_TO_CPU_HDR_INNER_VID)
#define V_DCB1_EP_TO_CPU_HDR_INNER_VID(x)  _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_INNER_VID)
#define G_DCB1_EP_TO_CPU_HDR_INNER_VID(x)  _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_INNER_VID, M_DCB1_EP_TO_CPU_HDR_INNER_VID)
#define S_DCB1_EP_TO_CPU_HDR_INNER_CFI     30                              
#define M_DCB1_EP_TO_CPU_HDR_INNER_CFI     _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_INNER_CFI)
#define V_DCB1_EP_TO_CPU_HDR_INNER_CFI(x)  _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_INNER_CFI)
#define G_DCB1_EP_TO_CPU_HDR_INNER_CFI(x)  _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_INNER_CFI, M_DCB1_EP_TO_CPU_HDR_INNER_CFI)
#define S_DCB1_EP_TO_CPU_HDR_REPLICATION   31                              
#define M_DCB1_EP_TO_CPU_HDR_REPLICATION   _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_REPLICATION)
#define V_DCB1_EP_TO_CPU_HDR_REPLICATION(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_REPLICATION)
#define G_DCB1_EP_TO_CPU_HDR_REPLICATION(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_REPLICATION, M_DCB1_EP_TO_CPU_HDR_REPLICATION)
#define S_DCB1_EP_TO_CPU_HDR_INNER_PRI     0                               
#define M_DCB1_EP_TO_CPU_HDR_INNER_PRI     _DD_MAKEMASK(3, S_DCB1_EP_TO_CPU_HDR_INNER_PRI)
#define V_DCB1_EP_TO_CPU_HDR_INNER_PRI(x)  _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_INNER_PRI)
#define G_DCB1_EP_TO_CPU_HDR_INNER_PRI(x)  _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_INNER_PRI, M_DCB1_EP_TO_CPU_HDR_INNER_PRI)
#define S_DCB1_EP_TO_CPU_HDR_REPLICATION_OR_NHOP_INDEX 3                               
#define M_DCB1_EP_TO_CPU_HDR_REPLICATION_OR_NHOP_INDEX _DD_MAKEMASK(9, S_DCB1_EP_TO_CPU_HDR_REPLICATION_OR_NHOP_INDEX)
#define V_DCB1_EP_TO_CPU_HDR_REPLICATION_OR_NHOP_INDEX(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_REPLICATION_OR_NHOP_INDEX)
#define G_DCB1_EP_TO_CPU_HDR_REPLICATION_OR_NHOP_INDEX(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_REPLICATION_OR_NHOP_INDEX, M_DCB1_EP_TO_CPU_HDR_REPLICATION_OR_NHOP_INDEX)
#define S_DCB1_EP_TO_CPU_HDR_RESERVED_140  12                              
#define M_DCB1_EP_TO_CPU_HDR_RESERVED_140  _DD_MAKEMASK(4, S_DCB1_EP_TO_CPU_HDR_RESERVED_140)
#define V_DCB1_EP_TO_CPU_HDR_RESERVED_140(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_RESERVED_140)
#define G_DCB1_EP_TO_CPU_HDR_RESERVED_140(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_RESERVED_140, M_DCB1_EP_TO_CPU_HDR_RESERVED_140)
#define S_DCB1_EP_TO_CPU_HDR_VLAN_COS      16                              
#define M_DCB1_EP_TO_CPU_HDR_VLAN_COS      _DD_MAKEMASK(5, S_DCB1_EP_TO_CPU_HDR_VLAN_COS)
#define V_DCB1_EP_TO_CPU_HDR_VLAN_COS(x)   _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_VLAN_COS)
#define G_DCB1_EP_TO_CPU_HDR_VLAN_COS(x)   _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_VLAN_COS, M_DCB1_EP_TO_CPU_HDR_VLAN_COS)
#define S_DCB1_EP_TO_CPU_HDR_SHAPING_COS_SEL 21                              
#define M_DCB1_EP_TO_CPU_HDR_SHAPING_COS_SEL _DD_MAKEMASK(2, S_DCB1_EP_TO_CPU_HDR_SHAPING_COS_SEL)
#define V_DCB1_EP_TO_CPU_HDR_SHAPING_COS_SEL(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_SHAPING_COS_SEL)
#define G_DCB1_EP_TO_CPU_HDR_SHAPING_COS_SEL(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_SHAPING_COS_SEL, M_DCB1_EP_TO_CPU_HDR_SHAPING_COS_SEL)
#define S_DCB1_EP_TO_CPU_HDR_VFI_VALID     23                              
#define M_DCB1_EP_TO_CPU_HDR_VFI_VALID     _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_VFI_VALID)
#define V_DCB1_EP_TO_CPU_HDR_VFI_VALID(x)  _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_VFI_VALID)
#define G_DCB1_EP_TO_CPU_HDR_VFI_VALID(x)  _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_VFI_VALID, M_DCB1_EP_TO_CPU_HDR_VFI_VALID)
#define S_DCB1_EP_TO_CPU_HDR_EM_MTP_INDEX  24                              
#define M_DCB1_EP_TO_CPU_HDR_EM_MTP_INDEX  _DD_MAKEMASK(5, S_DCB1_EP_TO_CPU_HDR_EM_MTP_INDEX)
#define V_DCB1_EP_TO_CPU_HDR_EM_MTP_INDEX(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_EM_MTP_INDEX)
#define G_DCB1_EP_TO_CPU_HDR_EM_MTP_INDEX(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_EM_MTP_INDEX, M_DCB1_EP_TO_CPU_HDR_EM_MTP_INDEX)
#define S_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_TYPE 29                              
#define M_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_TYPE _DD_MAKEMASK(3, S_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_TYPE)
#define V_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_TYPE(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_TYPE)
#define G_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_TYPE(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_TYPE, M_DCB1_EP_TO_CPU_HDR_SPECIAL_PACKET_TYPE)
#define S_DCB1_EP_TO_CPU_HDR_SRC_PORT_NUM  0                               
#define M_DCB1_EP_TO_CPU_HDR_SRC_PORT_NUM  _DD_MAKEMASK(8, S_DCB1_EP_TO_CPU_HDR_SRC_PORT_NUM)
#define V_DCB1_EP_TO_CPU_HDR_SRC_PORT_NUM(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_SRC_PORT_NUM)
#define G_DCB1_EP_TO_CPU_HDR_SRC_PORT_NUM(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_SRC_PORT_NUM, M_DCB1_EP_TO_CPU_HDR_SRC_PORT_NUM)
#define S_DCB1_EP_TO_CPU_HDR_PKT_LENGTH    8                               
#define M_DCB1_EP_TO_CPU_HDR_PKT_LENGTH    _DD_MAKEMASK(14, S_DCB1_EP_TO_CPU_HDR_PKT_LENGTH)
#define V_DCB1_EP_TO_CPU_HDR_PKT_LENGTH(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_PKT_LENGTH)
#define G_DCB1_EP_TO_CPU_HDR_PKT_LENGTH(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_PKT_LENGTH, M_DCB1_EP_TO_CPU_HDR_PKT_LENGTH)
#define S_DCB1_EP_TO_CPU_HDR_MATCHED_RULE  22                              
#define M_DCB1_EP_TO_CPU_HDR_MATCHED_RULE  _DD_MAKEMASK(8, S_DCB1_EP_TO_CPU_HDR_MATCHED_RULE)
#define V_DCB1_EP_TO_CPU_HDR_MATCHED_RULE(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_MATCHED_RULE)
#define G_DCB1_EP_TO_CPU_HDR_MATCHED_RULE(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_MATCHED_RULE, M_DCB1_EP_TO_CPU_HDR_MATCHED_RULE)
#define S_DCB1_EP_TO_CPU_HDR_HGI           30                              
#define M_DCB1_EP_TO_CPU_HDR_HGI           _DD_MAKEMASK(2, S_DCB1_EP_TO_CPU_HDR_HGI)
#define V_DCB1_EP_TO_CPU_HDR_HGI(x)        _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_HGI)
#define G_DCB1_EP_TO_CPU_HDR_HGI(x)        _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_HGI, M_DCB1_EP_TO_CPU_HDR_HGI)
#define S_DCB1_EP_TO_CPU_HDR_CPU_COS       0                               
#define M_DCB1_EP_TO_CPU_HDR_CPU_COS       _DD_MAKEMASK(6, S_DCB1_EP_TO_CPU_HDR_CPU_COS)
#define V_DCB1_EP_TO_CPU_HDR_CPU_COS(x)    _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_CPU_COS)
#define G_DCB1_EP_TO_CPU_HDR_CPU_COS(x)    _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_CPU_COS, M_DCB1_EP_TO_CPU_HDR_CPU_COS)
#define S_DCB1_EP_TO_CPU_HDR_REGEN_CRC     6                               
#define M_DCB1_EP_TO_CPU_HDR_REGEN_CRC     _DD_MAKEMASK(1, S_DCB1_EP_TO_CPU_HDR_REGEN_CRC)
#define V_DCB1_EP_TO_CPU_HDR_REGEN_CRC(x)  _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_REGEN_CRC)
#define G_DCB1_EP_TO_CPU_HDR_REGEN_CRC(x)  _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_REGEN_CRC, M_DCB1_EP_TO_CPU_HDR_REGEN_CRC)
#define S_DCB1_EP_TO_CPU_HDR_RESERVED_327  7                               
#define M_DCB1_EP_TO_CPU_HDR_RESERVED_327  _DD_MAKEMASK(9, S_DCB1_EP_TO_CPU_HDR_RESERVED_327)
#define V_DCB1_EP_TO_CPU_HDR_RESERVED_327(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_RESERVED_327)
#define G_DCB1_EP_TO_CPU_HDR_RESERVED_327(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_RESERVED_327, M_DCB1_EP_TO_CPU_HDR_RESERVED_327)
#define S_DCB1_EP_TO_CPU_HDR_CPU_OPCODE_TYPE 16                              
#define M_DCB1_EP_TO_CPU_HDR_CPU_OPCODE_TYPE _DD_MAKEMASK(4, S_DCB1_EP_TO_CPU_HDR_CPU_OPCODE_TYPE)
#define V_DCB1_EP_TO_CPU_HDR_CPU_OPCODE_TYPE(x) _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_CPU_OPCODE_TYPE)
#define G_DCB1_EP_TO_CPU_HDR_CPU_OPCODE_TYPE(x) _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_CPU_OPCODE_TYPE, M_DCB1_EP_TO_CPU_HDR_CPU_OPCODE_TYPE)
#define S_DCB1_EP_TO_CPU_HDR_OUTER_VID     20                              
#define M_DCB1_EP_TO_CPU_HDR_OUTER_VID     _DD_MAKEMASK(12, S_DCB1_EP_TO_CPU_HDR_OUTER_VID)
#define V_DCB1_EP_TO_CPU_HDR_OUTER_VID(x)  _DD_MAKEVALUE(x,S_DCB1_EP_TO_CPU_HDR_OUTER_VID)
#define G_DCB1_EP_TO_CPU_HDR_OUTER_VID(x)  _DD_GETVALUE(x, S_DCB1_EP_TO_CPU_HDR_OUTER_VID, M_DCB1_EP_TO_CPU_HDR_OUTER_VID)
#define S_DCB1_BYTE_COUNT                  0                               
#define M_DCB1_BYTE_COUNT                  _DD_MAKEMASK(16, S_DCB1_BYTE_COUNT)
#define V_DCB1_BYTE_COUNT(x)               _DD_MAKEVALUE(x,S_DCB1_BYTE_COUNT)
#define G_DCB1_BYTE_COUNT(x)               _DD_GETVALUE(x, S_DCB1_BYTE_COUNT, M_DCB1_BYTE_COUNT)
#define S_DCB1_CHAIN                       16                              
#define M_DCB1_CHAIN                       _DD_MAKEMASK(1, S_DCB1_CHAIN)   
#define V_DCB1_CHAIN(x)                    _DD_MAKEVALUE(x,S_DCB1_CHAIN)   
#define G_DCB1_CHAIN(x)                    _DD_GETVALUE(x, S_DCB1_CHAIN, M_DCB1_CHAIN)
#define S_DCB1_SCATTER                     17                              
#define M_DCB1_SCATTER                     _DD_MAKEMASK(1, S_DCB1_SCATTER) 
#define V_DCB1_SCATTER(x)                  _DD_MAKEVALUE(x,S_DCB1_SCATTER) 
#define G_DCB1_SCATTER(x)                  _DD_GETVALUE(x, S_DCB1_SCATTER, M_DCB1_SCATTER)
#define S_DCB1_RELOAD                      18                              
#define M_DCB1_RELOAD                      _DD_MAKEMASK(1, S_DCB1_RELOAD)  
#define V_DCB1_RELOAD(x)                   _DD_MAKEVALUE(x,S_DCB1_RELOAD)  
#define G_DCB1_RELOAD(x)                   _DD_GETVALUE(x, S_DCB1_RELOAD, M_DCB1_RELOAD)
#define S_DCB1_INTERRUPT                   23                              
#define M_DCB1_INTERRUPT                   _DD_MAKEMASK(2, S_DCB1_INTERRUPT)
#define V_DCB1_INTERRUPT(x)                _DD_MAKEVALUE(x,S_DCB1_INTERRUPT)
#define G_DCB1_INTERRUPT(x)                _DD_GETVALUE(x, S_DCB1_INTERRUPT, M_DCB1_INTERRUPT)
#define S_DCB1_MEM_ADDR                    0                               
#define M_DCB1_MEM_ADDR                    _DD_MAKEMASK(32, S_DCB1_MEM_ADDR)
#define V_DCB1_MEM_ADDR(x)                 _DD_MAKEVALUE(x,S_DCB1_MEM_ADDR)
#define G_DCB1_MEM_ADDR(x)                 _DD_GETVALUE(x, S_DCB1_MEM_ADDR, M_DCB1_MEM_ADDR)
/* Phase 0 of S-bus message  */
#define S_SMHDR_NACK                       0                               
#define M_SMHDR_NACK                       _DD_MAKEMASK(1, S_SMHDR_NACK)   
#define V_SMHDR_NACK(x)                    _DD_MAKEVALUE(x,S_SMHDR_NACK)   
#define G_SMHDR_NACK(x)                    _DD_GETVALUE(x, S_SMHDR_NACK, M_SMHDR_NACK)
#define S_SMHDR_BANK                       1                               
#define M_SMHDR_BANK                       _DD_MAKEMASK(2, S_SMHDR_BANK)   
#define V_SMHDR_BANK(x)                    _DD_MAKEVALUE(x,S_SMHDR_BANK)   
#define G_SMHDR_BANK(x)                    _DD_GETVALUE(x, S_SMHDR_BANK, M_SMHDR_BANK)
#define S_SMHDR_DMA                        3                               
#define M_SMHDR_DMA                        _DD_MAKEMASK(1, S_SMHDR_DMA)    
#define V_SMHDR_DMA(x)                     _DD_MAKEVALUE(x,S_SMHDR_DMA)    
#define G_SMHDR_DMA(x)                     _DD_GETVALUE(x, S_SMHDR_DMA, M_SMHDR_DMA)
#define S_SMHDR_ECODE                      4                               
#define M_SMHDR_ECODE                      _DD_MAKEMASK(2, S_SMHDR_ECODE)  
#define V_SMHDR_ECODE(x)                   _DD_MAKEVALUE(x,S_SMHDR_ECODE)  
#define G_SMHDR_ECODE(x)                   _DD_GETVALUE(x, S_SMHDR_ECODE, M_SMHDR_ECODE)
#define S_SMHDR_ERR                        6                               
#define M_SMHDR_ERR                        _DD_MAKEMASK(1, S_SMHDR_ERR)    
#define V_SMHDR_ERR(x)                     _DD_MAKEVALUE(x,S_SMHDR_ERR)    
#define G_SMHDR_ERR(x)                     _DD_GETVALUE(x, S_SMHDR_ERR, M_SMHDR_ERR)
#define S_SMHDR_DATA_LEN                   7                               
#define M_SMHDR_DATA_LEN                   _DD_MAKEMASK(7, S_SMHDR_DATA_LEN)
#define V_SMHDR_DATA_LEN(x)                _DD_MAKEVALUE(x,S_SMHDR_DATA_LEN)
#define G_SMHDR_DATA_LEN(x)                _DD_GETVALUE(x, S_SMHDR_DATA_LEN, M_SMHDR_DATA_LEN)
#define S_SMHDR_ACC                        14                              
#define M_SMHDR_ACC                        _DD_MAKEMASK(5, S_SMHDR_ACC)    
#define V_SMHDR_ACC(x)                     _DD_MAKEVALUE(x,S_SMHDR_ACC)    
#define G_SMHDR_ACC(x)                     _DD_GETVALUE(x, S_SMHDR_ACC, M_SMHDR_ACC)
#define S_SMHDR_DEST_BLOCK                 19                              
#define M_SMHDR_DEST_BLOCK                 _DD_MAKEMASK(7, S_SMHDR_DEST_BLOCK)
#define V_SMHDR_DEST_BLOCK(x)              _DD_MAKEVALUE(x,S_SMHDR_DEST_BLOCK)
#define G_SMHDR_DEST_BLOCK(x)              _DD_GETVALUE(x, S_SMHDR_DEST_BLOCK, M_SMHDR_DEST_BLOCK)
#define S_SMHDR_OP_CODE                    26                              
#define M_SMHDR_OP_CODE                    _DD_MAKEMASK(6, S_SMHDR_OP_CODE)
#define V_SMHDR_OP_CODE(x)                 _DD_MAKEVALUE(x,S_SMHDR_OP_CODE)
#define G_SMHDR_OP_CODE(x)                 _DD_GETVALUE(x, S_SMHDR_OP_CODE, M_SMHDR_OP_CODE)
/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  AUX_ARB_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     IP auxilary arbiter control register for L2 table
 * SIZE:     32
 * FIELDS:
 *     L2_MOD_FIFO_ENABLE_MEMWR Enable L2_MOD_FIFO recording for MEMWR.
 *     L2_MOD_FIFO_ENABLE_LEARN Enable L2_MOD_FIFO recording for LEARN.
 *     L2_MOD_FIFO_ENABLE_PPA_REPLACE Enable L2_MOD_FIFO recording for PPA_REPLACE.
 *     L2_MOD_FIFO_ENABLE_L2_INSERT Enable L2_MOD_FIFO recording for L2_INSERT.
 *     L2_MOD_FIFO_ENABLE_AGE Enable L2_MOD_FIFO recording for AGE.
 *     L2_MOD_FIFO_ENABLE_PPA_DELETE Enable L2_MOD_FIFO recording for PPA_DELETE.
 *     L2_MOD_FIFO_ENABLE_L2_DELETE Enable L2_MOD_FIFO recording for L2_DELETE.
 */
#define AUX_ARB_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program AUX_ARB_CONTROL.
 */
typedef union AUX_ARB_CONTROLr_s {
	uint32 v[1];
	uint32 aux_arb_control[1];
	uint32 _aux_arb_control;
} AUX_ARB_CONTROLr_t;

#define AUX_ARB_CONTROLr_CLR(r) (r).aux_arb_control[0] = 0
#define AUX_ARB_CONTROLr_SET(r,d) (r).aux_arb_control[0] = d
#define AUX_ARB_CONTROLr_GET(r) (r).aux_arb_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_MEMWRf_GET(r) (((r).aux_arb_control[0]) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_MEMWRf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_LEARNf_GET(r) ((((r).aux_arb_control[0]) >> 1) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_LEARNf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_PPA_REPLACEf_GET(r) ((((r).aux_arb_control[0]) >> 2) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_PPA_REPLACEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_L2_INSERTf_GET(r) ((((r).aux_arb_control[0]) >> 3) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_L2_INSERTf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_AGEf_GET(r) ((((r).aux_arb_control[0]) >> 4) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_AGEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_PPA_DELETEf_GET(r) ((((r).aux_arb_control[0]) >> 5) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_PPA_DELETEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_L2_DELETEf_GET(r) ((((r).aux_arb_control[0]) >> 6) & 0x1)
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLE_L2_DELETEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))

/*
 * These macros can be used to access AUX_ARB_CONTROL.
 */
#define WRITE_AUX_ARB_CONTROLr(u,r) bcm5354x_reg_set(u,R_AUX_ARB_CONTROL,(r._aux_arb_control))
#define READ_AUX_ARB_CONTROLr(u,r) bcm5354x_reg_get(u,R_AUX_ARB_CONTROL,&(r._aux_arb_control))

/*******************************************************************************
 * End of 'AUX_ARB_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  AUX_ARB_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     IP auxilary arbiter control register for FP functions.
 * SIZE:     32
 * FIELDS:
 *     CLK_GRAN         clock granularity for ages (speed up for simulation use only)
 *     SBUS_SPACING     specifies minimum spacing between sbus ops
 *     SBUS_ARB_BLOCK_CNT specifies cycles hi-priority sbus arb slot is blocked out after every s-bus trans
 *     FP_REFRESH_ENABLE 1 - Iarb will send out refresh_ticks for IFP meters
 */
#define AUX_ARB_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program AUX_ARB_CONTROL_2.
 */
typedef union AUX_ARB_CONTROL_2r_s {
	uint32 v[1];
	uint32 aux_arb_control_2[1];
	uint32 _aux_arb_control_2;
} AUX_ARB_CONTROL_2r_t;

#define AUX_ARB_CONTROL_2r_CLR(r) (r).aux_arb_control_2[0] = 0
#define AUX_ARB_CONTROL_2r_SET(r,d) (r).aux_arb_control_2[0] = d
#define AUX_ARB_CONTROL_2r_GET(r) (r).aux_arb_control_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define AUX_ARB_CONTROL_2r_CLK_GRANf_GET(r) (((r).aux_arb_control_2[0]) & 0x3)
#define AUX_ARB_CONTROL_2r_CLK_GRANf_SET(r,f) (r).aux_arb_control_2[0]=(((r).aux_arb_control_2[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define AUX_ARB_CONTROL_2r_SBUS_SPACINGf_GET(r) ((((r).aux_arb_control_2[0]) >> 3) & 0xff)
#define AUX_ARB_CONTROL_2r_SBUS_SPACINGf_SET(r,f) (r).aux_arb_control_2[0]=(((r).aux_arb_control_2[0] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define AUX_ARB_CONTROL_2r_SBUS_ARB_BLOCK_CNTf_GET(r) ((((r).aux_arb_control_2[0]) >> 11) & 0x3ff)
#define AUX_ARB_CONTROL_2r_SBUS_ARB_BLOCK_CNTf_SET(r,f) (r).aux_arb_control_2[0]=(((r).aux_arb_control_2[0] & ~((uint32)0x3ff << 11)) | ((((uint32)f) & 0x3ff) << 11))
#define AUX_ARB_CONTROL_2r_FP_REFRESH_ENABLEf_GET(r) ((((r).aux_arb_control_2[0]) >> 26) & 0x1)
#define AUX_ARB_CONTROL_2r_FP_REFRESH_ENABLEf_SET(r,f) (r).aux_arb_control_2[0]=(((r).aux_arb_control_2[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))

/*
 * These macros can be used to access AUX_ARB_CONTROL_2.
 */
#define WRITE_AUX_ARB_CONTROL_2r(u,r) bcm5354x_reg_set(u,R_AUX_ARB_CONTROL_2,(r._aux_arb_control_2))
#define READ_AUX_ARB_CONTROL_2r(u,r) bcm5354x_reg_get(u,R_AUX_ARB_CONTROL_2,&(r._aux_arb_control_2))

/*******************************************************************************
 * End of 'AUX_ARB_CONTROL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTR
 * BLOCKS:   AVS
 * DESC:     Indicate which PVT Monitor measurements should  be masked(skipped) in the measurement sequence
 * SIZE:     32
 * FIELDS:
 *     SEQ_MASK_PVT_MNTR For PVT monitor measurements1 = The sensor will be skipped0 = The sensor will be measure
 *     RESERVED         Reserved bits write has no effect and read always returns 0
 */
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_SIZE 4

/*
 * This structure should be used to declare and program AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTR.
 */
typedef union AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_s {
	uint32 v[1];
	uint32 avs_reg_hw_mntr_sequencer_mask_pvt_mntr[1];
	uint32 _avs_reg_hw_mntr_sequencer_mask_pvt_mntr;
} AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_t;

#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_CLR(r) (r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0] = 0
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_SET(r,d) (r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0] = d
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_GET(r) (r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0]

/*
 * These macros can be used to access individual fields.
 */
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_SEQ_MASK_PVT_MNTRf_GET(r) (((r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0]) & 0x7f)
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_SEQ_MASK_PVT_MNTRf_SET(r,f) (r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0]=(((r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_RESERVEDf_GET(r) ((((r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0]) >> 7) & 0x1ffffff)
#define AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr_RESERVEDf_SET(r,f) (r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0]=(((r).avs_reg_hw_mntr_sequencer_mask_pvt_mntr[0] & ~((uint32)0x1ffffff << 7)) | ((((uint32)f) & 0x1ffffff) << 7))

/*
 * These macros can be used to access AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTR.
 */
#define READ_AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr(u,r) bcm5354x_read32(u, R_AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTR, &(r._avs_reg_hw_mntr_sequencer_mask_pvt_mntr))
#define WRITE_AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr(u,r) bcm5354x_write32(u, R_AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTR, (r._avs_reg_hw_mntr_sequencer_mask_pvt_mntr))

/*******************************************************************************
 * End of 'AVS_REG_HW_MNTR_SEQUENCER_MASK_PVT_MNTRr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CCG_GP_DATA_IN
 * BLOCKS:   IPROC
 * DESC:     GPIO Data in register

 * SIZE:     32
 * FIELDS:
 *     DATA_IN          GPIO Data input register used to read the value on the external GPIO pins. This register always samples the data on the GPIO pins, even when the GPIO pads are configured as output, the value sent out on the GPIO is reflected on the GP_DIN register. Default vaule depends on the default values of GP_RES_EN, GP_PAD_RES and values driven to GPIO inputs."
 */
#define CCG_GP_DATA_INr_SIZE 4

/*
 * This structure should be used to declare and program CCG_GP_DATA_IN.
 */
typedef union CCG_GP_DATA_INr_s {
	uint32 v[1];
	uint32 ccg_gp_data_in[1];
	uint32 _ccg_gp_data_in;
} CCG_GP_DATA_INr_t;

#define CCG_GP_DATA_INr_CLR(r) (r).ccg_gp_data_in[0] = 0
#define CCG_GP_DATA_INr_SET(r,d) (r).ccg_gp_data_in[0] = d
#define CCG_GP_DATA_INr_GET(r) (r).ccg_gp_data_in[0]

/*
 * These macros can be used to access individual fields.
 */
#define CCG_GP_DATA_INr_DATA_INf_GET(r) ((r).ccg_gp_data_in[0])
#define CCG_GP_DATA_INr_DATA_INf_SET(r,f) (r).ccg_gp_data_in[0]=((uint32)f)

/*
 * These macros can be used to access CCG_GP_DATA_IN.
 */
#define READ_CCG_GP_DATA_INr(u,r) bcm5354x_read32(u, R_CCG_GP_DATA_IN, &(r._ccg_gp_data_in))
#define WRITE_CCG_GP_DATA_INr(u,r) bcm5354x_write32(u, R_CCG_GP_DATA_IN, (r._ccg_gp_data_in))

/*******************************************************************************
 * End of 'CCG_GP_DATA_INr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CCG_GP_DATA_OUT
 * BLOCKS:   IPROC
 * DESC:     GPIO Data out register

 * SIZE:     32
 * FIELDS:
 *     DATA_OUT         GPIO Data out register used to write data out to the external GPIO pins. When the corresponding bit in the GP_EN register is programmed to logic 1,  the pin is configured as an output, and writing data to a bit drives the data out on the pad. Reading from a bit indicates the last value written to the register. If the corresponding bit within the GP_EN register is programmed to logic 0, configuring the pad as an input, then writing has no effect.
 */
#define CCG_GP_DATA_OUTr_SIZE 4

/*
 * This structure should be used to declare and program CCG_GP_DATA_OUT.
 */
typedef union CCG_GP_DATA_OUTr_s {
	uint32 v[1];
	uint32 ccg_gp_data_out[1];
	uint32 _ccg_gp_data_out;
} CCG_GP_DATA_OUTr_t;

#define CCG_GP_DATA_OUTr_CLR(r) (r).ccg_gp_data_out[0] = 0
#define CCG_GP_DATA_OUTr_SET(r,d) (r).ccg_gp_data_out[0] = d
#define CCG_GP_DATA_OUTr_GET(r) (r).ccg_gp_data_out[0]

/*
 * These macros can be used to access individual fields.
 */
#define CCG_GP_DATA_OUTr_DATA_OUTf_GET(r) ((r).ccg_gp_data_out[0])
#define CCG_GP_DATA_OUTr_DATA_OUTf_SET(r,f) (r).ccg_gp_data_out[0]=((uint32)f)

/*
 * These macros can be used to access CCG_GP_DATA_OUT.
 */
#define READ_CCG_GP_DATA_OUTr(u,r) bcm5354x_read32(u, R_CCG_GP_DATA_OUT, &(r._ccg_gp_data_out))
#define WRITE_CCG_GP_DATA_OUTr(u,r) bcm5354x_write32(u, R_CCG_GP_DATA_OUT, (r._ccg_gp_data_out))

/*******************************************************************************
 * End of 'CCG_GP_DATA_OUTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CCG_GP_OUT_EN
 * BLOCKS:   IPROC
 * DESC:     GPIO drive enable register

 * SIZE:     32
 * FIELDS:
 *     OUT_ENABLE       GPIO driver enable register. Setting a bit to logic 1 enables the corresponding GPIO pad as an output driver otherwise it is configured as a receiver . When a bit is set low to logic 0, the driver is disabled.
 */
#define CCG_GP_OUT_ENr_SIZE 4

/*
 * This structure should be used to declare and program CCG_GP_OUT_EN.
 */
typedef union CCG_GP_OUT_ENr_s {
	uint32 v[1];
	uint32 ccg_gp_out_en[1];
	uint32 _ccg_gp_out_en;
} CCG_GP_OUT_ENr_t;

#define CCG_GP_OUT_ENr_CLR(r) (r).ccg_gp_out_en[0] = 0
#define CCG_GP_OUT_ENr_SET(r,d) (r).ccg_gp_out_en[0] = d
#define CCG_GP_OUT_ENr_GET(r) (r).ccg_gp_out_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define CCG_GP_OUT_ENr_OUT_ENABLEf_GET(r) ((r).ccg_gp_out_en[0])
#define CCG_GP_OUT_ENr_OUT_ENABLEf_SET(r,f) (r).ccg_gp_out_en[0]=((uint32)f)

/*
 * These macros can be used to access CCG_GP_OUT_EN.
 */
#define READ_CCG_GP_OUT_ENr(u,r) bcm5354x_read32(u, R_CCG_GP_OUT_EN, &(r._ccg_gp_out_en))
#define WRITE_CCG_GP_OUT_ENr(u,r) bcm5354x_write32(u, R_CCG_GP_OUT_EN, (r._ccg_gp_out_en))

/*******************************************************************************
 * End of 'CCG_GP_OUT_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CCS_GP_DATA_IN
 * BLOCKS:   IPROC
 * DESC:     GPIO Data in register

 * SIZE:     32
 * FIELDS:
 *     DATA_IN          GPIO Data input register used to read the value on the external GPIO pins. This register always samples the data on the GPIO pins, even when the GPIO pads are configured as output, the value sent out on the GPIO is reflected on the GP_DIN register. Default vaule depends on the default values of GP_RES_EN, GP_PAD_RES and values driven to GPIO inputs."
 */
#define CCS_GP_DATA_INr_SIZE 4

/*
 * This structure should be used to declare and program CCS_GP_DATA_IN.
 */
typedef union CCS_GP_DATA_INr_s {
	uint32 v[1];
	uint32 ccs_gp_data_in[1];
	uint32 _ccs_gp_data_in;
} CCS_GP_DATA_INr_t;

#define CCS_GP_DATA_INr_CLR(r) (r).ccs_gp_data_in[0] = 0
#define CCS_GP_DATA_INr_SET(r,d) (r).ccs_gp_data_in[0] = d
#define CCS_GP_DATA_INr_GET(r) (r).ccs_gp_data_in[0]

/*
 * These macros can be used to access individual fields.
 */
#define CCS_GP_DATA_INr_DATA_INf_GET(r) ((r).ccs_gp_data_in[0])
#define CCS_GP_DATA_INr_DATA_INf_SET(r,f) (r).ccs_gp_data_in[0]=((uint32)f)

/*
 * These macros can be used to access CCS_GP_DATA_IN.
 */
#define READ_CCS_GP_DATA_INr(u,r) bcm5354x_read32(u, R_CCS_GP_DATA_IN, &(r._ccs_gp_data_in))
#define WRITE_CCS_GP_DATA_INr(u,r) bcm5354x_write32(u, R_CCS_GP_DATA_IN, (r._ccs_gp_data_in))

/*******************************************************************************
 * End of 'CCS_GP_DATA_INr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CCS_GP_DATA_OUT
 * BLOCKS:   IPROC
 * DESC:     GPIO Data out register

 * SIZE:     32
 * FIELDS:
 *     DATA_OUT         GPIO Data out register used to write data out to the external GPIO pins. When the corresponding bit in the GP_EN register is programmed to logic 1,  the pin is configured as an output, and writing data to a bit drives the data out on the pad. Reading from a bit indicates the last value written to the register. If the corresponding bit within the GP_EN register is programmed to logic 0, configuring the pad as an input, then writing has no effect.
 */
#define CCS_GP_DATA_OUTr_SIZE 4

/*
 * This structure should be used to declare and program CCS_GP_DATA_OUT.
 */
typedef union CCS_GP_DATA_OUTr_s {
	uint32 v[1];
	uint32 ccs_gp_data_out[1];
	uint32 _ccs_gp_data_out;
} CCS_GP_DATA_OUTr_t;

#define CCS_GP_DATA_OUTr_CLR(r) (r).ccs_gp_data_out[0] = 0
#define CCS_GP_DATA_OUTr_SET(r,d) (r).ccs_gp_data_out[0] = d
#define CCS_GP_DATA_OUTr_GET(r) (r).ccs_gp_data_out[0]

/*
 * These macros can be used to access individual fields.
 */
#define CCS_GP_DATA_OUTr_DATA_OUTf_GET(r) ((r).ccs_gp_data_out[0])
#define CCS_GP_DATA_OUTr_DATA_OUTf_SET(r,f) (r).ccs_gp_data_out[0]=((uint32)f)

/*
 * These macros can be used to access CCS_GP_DATA_OUT.
 */
#define READ_CCS_GP_DATA_OUTr(u,r) bcm5354x_read32(u, R_CCS_GP_DATA_OUT, &(r._ccs_gp_data_out))
#define WRITE_CCS_GP_DATA_OUTr(u,r) bcm5354x_write32(u, R_CCS_GP_DATA_OUT, (r._ccs_gp_data_out))

/*******************************************************************************
 * End of 'CCS_GP_DATA_OUTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CCS_GP_OUT_EN
 * BLOCKS:   IPROC
 * DESC:     GPIO drive enable register

 * SIZE:     32
 * FIELDS:
 *     OUT_ENABLE       GPIO driver enable register. Setting a bit to logic 1 enables the corresponding GPIO pad as an output driver otherwise it is configured as a receiver . When a bit is set low to logic 0, the driver is disabled.
 */
#define CCS_GP_OUT_ENr_SIZE 4

/*
 * This structure should be used to declare and program CCS_GP_OUT_EN.
 */
typedef union CCS_GP_OUT_ENr_s {
	uint32 v[1];
	uint32 ccs_gp_out_en[1];
	uint32 _ccs_gp_out_en;
} CCS_GP_OUT_ENr_t;

#define CCS_GP_OUT_ENr_CLR(r) (r).ccs_gp_out_en[0] = 0
#define CCS_GP_OUT_ENr_SET(r,d) (r).ccs_gp_out_en[0] = d
#define CCS_GP_OUT_ENr_GET(r) (r).ccs_gp_out_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define CCS_GP_OUT_ENr_OUT_ENABLEf_GET(r) ((r).ccs_gp_out_en[0])
#define CCS_GP_OUT_ENr_OUT_ENABLEf_SET(r,f) (r).ccs_gp_out_en[0]=((uint32)f)

/*
 * These macros can be used to access CCS_GP_OUT_EN.
 */
#define READ_CCS_GP_OUT_ENr(u,r) bcm5354x_read32(u, R_CCS_GP_OUT_EN, &(r._ccs_gp_out_en))
#define WRITE_CCS_GP_OUT_ENr(u,r) bcm5354x_write32(u, R_CCS_GP_OUT_EN, (r._ccs_gp_out_en))

/*******************************************************************************
 * End of 'CCS_GP_OUT_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CFAPCONFIG
 * BLOCKS:   MMU
 * DESC:     Controls the CFAP behavior
 * SIZE:     32
 * FIELDS:
 *     CFAPPOOLSIZE     Maximum number of cell pointers of CBP memory.Number of cells supported is 4K Note: Do NOT set this below the CFAPFULLTHRESHOLD.CFAPFULLRESETPOINT and CFAPFULLSETPOINT values, or it will cause unexpected behavior in the MMU. 
 *     CFAPINIT         Re-Initialize CFAP Memory.Set this bit for the MMU to re-initialize CFAP pointer pre-fetch process after user has rearranged CFAP memory.This bit is also used for XQ prefetching. 
 */
#define CFAPCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CFAPCONFIG.
 */
typedef union CFAPCONFIGr_s {
	uint32 v[1];
	uint32 cfapconfig[1];
	uint32 _cfapconfig;
} CFAPCONFIGr_t;

#define CFAPCONFIGr_CLR(r) (r).cfapconfig[0] = 0
#define CFAPCONFIGr_SET(r,d) (r).cfapconfig[0] = d
#define CFAPCONFIGr_GET(r) (r).cfapconfig[0]

/*
 * These macros can be used to access individual fields.
 */
#define CFAPCONFIGr_CFAPPOOLSIZEf_GET(r) (((r).cfapconfig[0]) & 0xfff)
#define CFAPCONFIGr_CFAPPOOLSIZEf_SET(r,f) (r).cfapconfig[0]=(((r).cfapconfig[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define CFAPCONFIGr_CFAPINITf_GET(r) ((((r).cfapconfig[0]) >> 12) & 0x1)
#define CFAPCONFIGr_CFAPINITf_SET(r,f) (r).cfapconfig[0]=(((r).cfapconfig[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))

/*
 * These macros can be used to access CFAPCONFIG.
 */
#define WRITE_CFAPCONFIGr(u,r) bcm5354x_reg_set(u,R_CFAPCONFIG,(r._cfapconfig))
#define READ_CFAPCONFIGr(u,r) bcm5354x_reg_get(u,R_CFAPCONFIG,&(r._cfapconfig))

/*******************************************************************************
 * End of 'CFAPCONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CFAPFULLTHRESHOLD
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPFULLSETPOINT CFAP FULL Set PointDefine the threshold of entering CFAP FULL condition. CFAP is full when CFAP Read Pointer is above this limit.User should at least reaserve the port_num*2 +8  cell for CAU pre-fetch to prevent underflow!!
 *     CFAPFULLRESETPOINT CFAP FULL Reset PointDefine the threshold of exiting CFAP FULL condition. CFAP is not full when CFAP Read Pointer is below this limit.
 */
#define CFAPFULLTHRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program CFAPFULLTHRESHOLD.
 */
typedef union CFAPFULLTHRESHOLDr_s {
	uint32 v[1];
	uint32 cfapfullthreshold[1];
	uint32 _cfapfullthreshold;
} CFAPFULLTHRESHOLDr_t;

#define CFAPFULLTHRESHOLDr_CLR(r) (r).cfapfullthreshold[0] = 0
#define CFAPFULLTHRESHOLDr_SET(r,d) (r).cfapfullthreshold[0] = d
#define CFAPFULLTHRESHOLDr_GET(r) (r).cfapfullthreshold[0]

/*
 * These macros can be used to access individual fields.
 */
#define CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET(r) (((r).cfapfullthreshold[0]) & 0xfff)
#define CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET(r,f) (r).cfapfullthreshold[0]=(((r).cfapfullthreshold[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET(r) ((((r).cfapfullthreshold[0]) >> 12) & 0xfff)
#define CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET(r,f) (r).cfapfullthreshold[0]=(((r).cfapfullthreshold[0] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))

/*
 * These macros can be used to access CFAPFULLTHRESHOLD.
 */
#define WRITE_CFAPFULLTHRESHOLDr(u,r) bcm5354x_reg_set(u,R_CFAPFULLTHRESHOLD,(r._cfapfullthreshold))
#define READ_CFAPFULLTHRESHOLDr(u,r) bcm5354x_reg_get(u,R_CFAPFULLTHRESHOLD,&(r._cfapfullthreshold))

/*******************************************************************************
 * End of 'CFAPFULLTHRESHOLDr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CHIP_CONFIG
 * BLOCKS:   PMQ0 PMQ1 PMQ2
 * DESC:     Configuration and Status register for PM4x10Q Top
 * SIZE:     32
 * FIELDS:
 *     QMODE            1 = QSGMII Mode, 0 = Ethernet Mode
 *     IP_TDM           This configuration field enforces a specific minimum GPORT/IP TDM gap for gp_to_ip_valid cycles. The default value 0 will allow 1G support with core_clk = 166MHz. Set to 3 to enforce a 1 out of 4 tdm gap.
 *     POWERSAVE        1 = Enable power-save mode. When set, the ILKN bypass rxclk and txclk clocks are gated, and the core clk to the GPORTs is gated.
 */
#define CHIP_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_CONFIG.
 */
typedef union CHIP_CONFIGr_s {
	uint32 v[1];
	uint32 chip_config[1];
	uint32 _chip_config;
} CHIP_CONFIGr_t;

#define CHIP_CONFIGr_CLR(r) (r).chip_config[0] = 0
#define CHIP_CONFIGr_SET(r,d) (r).chip_config[0] = d
#define CHIP_CONFIGr_GET(r) (r).chip_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIP_CONFIGr_QMODEf_GET(r) (((r).chip_config[0]) & 0x1)
#define CHIP_CONFIGr_QMODEf_SET(r,f) (r).chip_config[0]=(((r).chip_config[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CHIP_CONFIGr_IP_TDMf_GET(r) ((((r).chip_config[0]) >> 1) & 0x7)
#define CHIP_CONFIGr_IP_TDMf_SET(r,f) (r).chip_config[0]=(((r).chip_config[0] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define CHIP_CONFIGr_POWERSAVEf_GET(r) ((((r).chip_config[0]) >> 31) & 0x1)
#define CHIP_CONFIGr_POWERSAVEf_SET(r,f) (r).chip_config[0]=(((r).chip_config[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access CHIP_CONFIG.
 */
#define WRITE_CHIP_CONFIGr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_CONFIG, (r._chip_config))
#define READ_CHIP_CONFIGr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_CONFIG, &(r._chip_config))

/*******************************************************************************
 * End of 'CHIP_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CHIP_INDACC_CTLSTS
 * BLOCKS:   PMQ0 PMQ1 PMQ2
 * DESC:     Indirect Access Control and status register for PM4x10Q Top; access to QSGMII_2x_PCS MDIO registers.
 * SIZE:     32
 * FIELDS:
 *     ADDRESS          Indirect Access Address Field
 *     TARGET_SELECT    Select mdio register set of QSGMII0 or QSGMII1 for the mdio transaction
 *     RD_RDY           Read Ready status; 1 = ready for a RD_REQ.
 *     WR_RDY           Write Ready status; 1 = ready for a WR_REQ.
 *     RD_REQ           Read Request; 0 = ready; Write to 1 to start read transaction.
 *     WR_REQ           Write Request; 0 = ready; Write to 1 to start write transaction.
 */
#define CHIP_INDACC_CTLSTSr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_INDACC_CTLSTS.
 */
typedef union CHIP_INDACC_CTLSTSr_s {
	uint32 v[1];
	uint32 chip_indacc_ctlsts[1];
	uint32 _chip_indacc_ctlsts;
} CHIP_INDACC_CTLSTSr_t;

#define CHIP_INDACC_CTLSTSr_CLR(r) (r).chip_indacc_ctlsts[0] = 0
#define CHIP_INDACC_CTLSTSr_SET(r,d) (r).chip_indacc_ctlsts[0] = d
#define CHIP_INDACC_CTLSTSr_GET(r) (r).chip_indacc_ctlsts[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIP_INDACC_CTLSTSr_ADDRESSf_GET(r) (((r).chip_indacc_ctlsts[0]) & 0x3ff)
#define CHIP_INDACC_CTLSTSr_ADDRESSf_SET(r,f) (r).chip_indacc_ctlsts[0]=(((r).chip_indacc_ctlsts[0] & ~((uint32)0x3ff)) | (((uint32)f) & 0x3ff))
#define CHIP_INDACC_CTLSTSr_TARGET_SELECTf_GET(r) ((((r).chip_indacc_ctlsts[0]) >> 10) & 0x1)
#define CHIP_INDACC_CTLSTSr_TARGET_SELECTf_SET(r,f) (r).chip_indacc_ctlsts[0]=(((r).chip_indacc_ctlsts[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define CHIP_INDACC_CTLSTSr_RD_RDYf_GET(r) ((((r).chip_indacc_ctlsts[0]) >> 28) & 0x1)
#define CHIP_INDACC_CTLSTSr_RD_RDYf_SET(r,f) (r).chip_indacc_ctlsts[0]=(((r).chip_indacc_ctlsts[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define CHIP_INDACC_CTLSTSr_WR_RDYf_GET(r) ((((r).chip_indacc_ctlsts[0]) >> 29) & 0x1)
#define CHIP_INDACC_CTLSTSr_WR_RDYf_SET(r,f) (r).chip_indacc_ctlsts[0]=(((r).chip_indacc_ctlsts[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define CHIP_INDACC_CTLSTSr_RD_REQf_GET(r) ((((r).chip_indacc_ctlsts[0]) >> 30) & 0x1)
#define CHIP_INDACC_CTLSTSr_RD_REQf_SET(r,f) (r).chip_indacc_ctlsts[0]=(((r).chip_indacc_ctlsts[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define CHIP_INDACC_CTLSTSr_WR_REQf_GET(r) ((((r).chip_indacc_ctlsts[0]) >> 31) & 0x1)
#define CHIP_INDACC_CTLSTSr_WR_REQf_SET(r,f) (r).chip_indacc_ctlsts[0]=(((r).chip_indacc_ctlsts[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access CHIP_INDACC_CTLSTS.
 */
#define WRITE_CHIP_INDACC_CTLSTSr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_INDACC_CTLSTS, (r._chip_indacc_ctlsts))
#define READ_CHIP_INDACC_CTLSTSr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_INDACC_CTLSTS, &(r._chip_indacc_ctlsts))

/*******************************************************************************
 * End of 'CHIP_INDACC_CTLSTSr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CHIP_INDACC_RDATA
 * BLOCKS:   PMQ0 PMQ1 PMQ2
 * DESC:     Indirect Access READ DATA register for PM4x10Q Top
 * SIZE:     32
 * FIELDS:
 *     RDDATA           Indirect Access READ Data register
 */
#define CHIP_INDACC_RDATAr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_INDACC_RDATA.
 */
typedef union CHIP_INDACC_RDATAr_s {
	uint32 v[1];
	uint32 chip_indacc_rdata[1];
	uint32 _chip_indacc_rdata;
} CHIP_INDACC_RDATAr_t;

#define CHIP_INDACC_RDATAr_CLR(r) (r).chip_indacc_rdata[0] = 0
#define CHIP_INDACC_RDATAr_SET(r,d) (r).chip_indacc_rdata[0] = d
#define CHIP_INDACC_RDATAr_GET(r) (r).chip_indacc_rdata[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIP_INDACC_RDATAr_RDDATAf_GET(r) (((r).chip_indacc_rdata[0]) & 0xffff)
#define CHIP_INDACC_RDATAr_RDDATAf_SET(r,f) (r).chip_indacc_rdata[0]=(((r).chip_indacc_rdata[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access CHIP_INDACC_RDATA.
 */
#define WRITE_CHIP_INDACC_RDATAr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_INDACC_RDATA, (r._chip_indacc_rdata))
#define READ_CHIP_INDACC_RDATAr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_INDACC_RDATA, &(r._chip_indacc_rdata))

/*******************************************************************************
 * End of 'CHIP_INDACC_RDATAr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CHIP_INDACC_WDATA
 * BLOCKS:   PMQ0 PMQ1 PMQ2
 * DESC:     Indirect Access WRITE DATA register for PM4x10Q Top
 * SIZE:     32
 * FIELDS:
 *     WRDATA           Indirect Access WRITE Data register
 */
#define CHIP_INDACC_WDATAr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_INDACC_WDATA.
 */
typedef union CHIP_INDACC_WDATAr_s {
	uint32 v[1];
	uint32 chip_indacc_wdata[1];
	uint32 _chip_indacc_wdata;
} CHIP_INDACC_WDATAr_t;

#define CHIP_INDACC_WDATAr_CLR(r) (r).chip_indacc_wdata[0] = 0
#define CHIP_INDACC_WDATAr_SET(r,d) (r).chip_indacc_wdata[0] = d
#define CHIP_INDACC_WDATAr_GET(r) (r).chip_indacc_wdata[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIP_INDACC_WDATAr_WRDATAf_GET(r) (((r).chip_indacc_wdata[0]) & 0xffff)
#define CHIP_INDACC_WDATAr_WRDATAf_SET(r,f) (r).chip_indacc_wdata[0]=(((r).chip_indacc_wdata[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access CHIP_INDACC_WDATA.
 */
#define WRITE_CHIP_INDACC_WDATAr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_INDACC_WDATA, (r._chip_indacc_wdata))
#define READ_CHIP_INDACC_WDATAr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_INDACC_WDATA, &(r._chip_indacc_wdata))

/*******************************************************************************
 * End of 'CHIP_INDACC_WDATAr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CHIP_SBUS_CFG
 * BLOCKS:   PMQ0 PMQ1 PMQ2
 * DESC:     SBUS Configuration register for PM4x10Q SBUS.
 * SIZE:     32
 * FIELDS:
 *     SBUS_BCST_BLKID_GP0 SBUS Broadcast BLKID[6:0] for GPORT0.
 *     SBUS_CHAIN_LAST_GP0 SBUS Chain Last for GPORT0. Defaults to 1.
 *     SBUS_BCST_BLKID_GP1 SBUS Broadcast BLKID[6:0] for GPORT1.
 *     SBUS_CHAIN_LAST_GP1 SBUS Chain Last for GPORT1. Defaults to 1.
 *     SBUS_BCST_BLKID_PMQREGS SBUS Broadcast BLKID[6:0] for PMQ top level register set.
 *     SBUS_CHAIN_LAST_PMQREGS SBUS Chain Last for PMQ register set. Defaults to 1.
 *     SBUS_BCST_BLKID_PM SBUS Broadcast BLKID[6:0] for PM4x10 port register set. This value should match the programmed value in the PM4x10 core.
 *     SBUS_CHAIN_LAST  SBUS Chain Last for PM4x10 port macro. Defaults to 1. This value should match the programmed value in the PM4x10 core.
 */
#define CHIP_SBUS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_SBUS_CFG.
 */
typedef union CHIP_SBUS_CFGr_s {
	uint32 v[1];
	uint32 chip_sbus_cfg[1];
	uint32 _chip_sbus_cfg;
} CHIP_SBUS_CFGr_t;

#define CHIP_SBUS_CFGr_CLR(r) (r).chip_sbus_cfg[0] = 0
#define CHIP_SBUS_CFGr_SET(r,d) (r).chip_sbus_cfg[0] = d
#define CHIP_SBUS_CFGr_GET(r) (r).chip_sbus_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_GP0f_GET(r) (((r).chip_sbus_cfg[0]) & 0x7f)
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_GP0f_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LAST_GP0f_GET(r) ((((r).chip_sbus_cfg[0]) >> 7) & 0x1)
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LAST_GP0f_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_GP1f_GET(r) ((((r).chip_sbus_cfg[0]) >> 8) & 0x7f)
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_GP1f_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x7f << 8)) | ((((uint32)f) & 0x7f) << 8))
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LAST_GP1f_GET(r) ((((r).chip_sbus_cfg[0]) >> 15) & 0x1)
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LAST_GP1f_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_PMQREGSf_GET(r) ((((r).chip_sbus_cfg[0]) >> 16) & 0x7f)
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_PMQREGSf_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x7f << 16)) | ((((uint32)f) & 0x7f) << 16))
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LAST_PMQREGSf_GET(r) ((((r).chip_sbus_cfg[0]) >> 23) & 0x1)
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LAST_PMQREGSf_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_PMf_GET(r) ((((r).chip_sbus_cfg[0]) >> 24) & 0x7f)
#define CHIP_SBUS_CFGr_SBUS_BCST_BLKID_PMf_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x7f << 24)) | ((((uint32)f) & 0x7f) << 24))
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LASTf_GET(r) ((((r).chip_sbus_cfg[0]) >> 31) & 0x1)
#define CHIP_SBUS_CFGr_SBUS_CHAIN_LASTf_SET(r,f) (r).chip_sbus_cfg[0]=(((r).chip_sbus_cfg[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access CHIP_SBUS_CFG.
 */
#define WRITE_CHIP_SBUS_CFGr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_SBUS_CFG, (r._chip_sbus_cfg))
#define READ_CHIP_SBUS_CFGr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_SBUS_CFG, &(r._chip_sbus_cfg))

/*******************************************************************************
 * End of 'CHIP_SBUS_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CHIP_SWRST
 * BLOCKS:   PMQ0 PMQ1 PMQ2
 * DESC:     Soft Reset register for PM4x10Q Top
 * SIZE:     32
 * FIELDS:
 *     SOFT_RESET_GPORT0 Soft Reset for submodules. 0= normal, 1 = reset.
 *     SOFT_RESET_GPORT1 Soft Reset for submodules. 0= normal, 1 = reset.
 *     SOFT_RESET_QSGMII_PCS Soft Reset for submodules. 0= normal, 1 = reset.
 *     FLUSH            ILKN Gearbox fifo flush, 0= normal, 1 = reset.
 *     ILKN_BYPASS_RSTN Per-lane soft reset control bit. Controls active-low ILKN bypass rst_b soft reset, 1= normal, 0 = reset.
 */
#define CHIP_SWRSTr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_SWRST.
 */
typedef union CHIP_SWRSTr_s {
	uint32 v[1];
	uint32 chip_swrst[1];
	uint32 _chip_swrst;
} CHIP_SWRSTr_t;

#define CHIP_SWRSTr_CLR(r) (r).chip_swrst[0] = 0
#define CHIP_SWRSTr_SET(r,d) (r).chip_swrst[0] = d
#define CHIP_SWRSTr_GET(r) (r).chip_swrst[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIP_SWRSTr_SOFT_RESET_GPORT0f_GET(r) (((r).chip_swrst[0]) & 0x1)
#define CHIP_SWRSTr_SOFT_RESET_GPORT0f_SET(r,f) (r).chip_swrst[0]=(((r).chip_swrst[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CHIP_SWRSTr_SOFT_RESET_GPORT1f_GET(r) ((((r).chip_swrst[0]) >> 1) & 0x1)
#define CHIP_SWRSTr_SOFT_RESET_GPORT1f_SET(r,f) (r).chip_swrst[0]=(((r).chip_swrst[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CHIP_SWRSTr_SOFT_RESET_QSGMII_PCSf_GET(r) ((((r).chip_swrst[0]) >> 2) & 0x1)
#define CHIP_SWRSTr_SOFT_RESET_QSGMII_PCSf_SET(r,f) (r).chip_swrst[0]=(((r).chip_swrst[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CHIP_SWRSTr_FLUSHf_GET(r) ((((r).chip_swrst[0]) >> 3) & 0x1)
#define CHIP_SWRSTr_FLUSHf_SET(r,f) (r).chip_swrst[0]=(((r).chip_swrst[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CHIP_SWRSTr_ILKN_BYPASS_RSTNf_GET(r) ((((r).chip_swrst[0]) >> 4) & 0xf)
#define CHIP_SWRSTr_ILKN_BYPASS_RSTNf_SET(r,f) (r).chip_swrst[0]=(((r).chip_swrst[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))

/*
 * These macros can be used to access CHIP_SWRST.
 */
#define WRITE_CHIP_SWRSTr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_SWRST, (r._chip_swrst))
#define READ_CHIP_SWRSTr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_SWRST, &(r._chip_swrst))

/*******************************************************************************
 * End of 'CHIP_SWRSTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CHIP_UMACSPEED
 * BLOCKS:   PMQ0 PMQ1 PMQ2
 * DESC:     Status register for UMAC SPEED
 * SIZE:     32
 * FIELDS:
 *     UMAC_SPEED_00    Link speed status for lane 0; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_01    Link speed status for lane 1; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_02    Link speed status for lane 2; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_03    Link speed status for lane 3; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_04    Link speed status for lane 4; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_05    Link speed status for lane 5; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_06    Link speed status for lane 6; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_07    Link speed status for lane 7; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_08    Link speed status for lane 8; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_09    Link speed status for lane 8; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_10    Link speed status for lane 10; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_11    Link speed status for lane 11; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_12    Link speed status for lane 12; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_13    Link speed status for lane 13; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_14    Link speed status for lane 14; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 *     UMAC_SPEED_15    Link speed status for lane 15; 0 = 10M, 1 = 100M, 2 = 1G, 3 = 10M
 */
#define CHIP_UMACSPEEDr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_UMACSPEED.
 */
typedef union CHIP_UMACSPEEDr_s {
	uint32 v[1];
	uint32 chip_umacspeed[1];
	uint32 _chip_umacspeed;
} CHIP_UMACSPEEDr_t;

#define CHIP_UMACSPEEDr_CLR(r) (r).chip_umacspeed[0] = 0
#define CHIP_UMACSPEEDr_SET(r,d) (r).chip_umacspeed[0] = d
#define CHIP_UMACSPEEDr_GET(r) (r).chip_umacspeed[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIP_UMACSPEEDr_UMAC_SPEED_00f_GET(r) (((r).chip_umacspeed[0]) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_00f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define CHIP_UMACSPEEDr_UMAC_SPEED_01f_GET(r) ((((r).chip_umacspeed[0]) >> 2) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_01f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define CHIP_UMACSPEEDr_UMAC_SPEED_02f_GET(r) ((((r).chip_umacspeed[0]) >> 4) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_02f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define CHIP_UMACSPEEDr_UMAC_SPEED_03f_GET(r) ((((r).chip_umacspeed[0]) >> 6) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_03f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define CHIP_UMACSPEEDr_UMAC_SPEED_04f_GET(r) ((((r).chip_umacspeed[0]) >> 8) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_04f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define CHIP_UMACSPEEDr_UMAC_SPEED_05f_GET(r) ((((r).chip_umacspeed[0]) >> 10) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_05f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define CHIP_UMACSPEEDr_UMAC_SPEED_06f_GET(r) ((((r).chip_umacspeed[0]) >> 12) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_06f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define CHIP_UMACSPEEDr_UMAC_SPEED_07f_GET(r) ((((r).chip_umacspeed[0]) >> 14) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_07f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define CHIP_UMACSPEEDr_UMAC_SPEED_08f_GET(r) ((((r).chip_umacspeed[0]) >> 16) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_08f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define CHIP_UMACSPEEDr_UMAC_SPEED_09f_GET(r) ((((r).chip_umacspeed[0]) >> 18) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_09f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define CHIP_UMACSPEEDr_UMAC_SPEED_10f_GET(r) ((((r).chip_umacspeed[0]) >> 20) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_10f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define CHIP_UMACSPEEDr_UMAC_SPEED_11f_GET(r) ((((r).chip_umacspeed[0]) >> 22) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_11f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define CHIP_UMACSPEEDr_UMAC_SPEED_12f_GET(r) ((((r).chip_umacspeed[0]) >> 24) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_12f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define CHIP_UMACSPEEDr_UMAC_SPEED_13f_GET(r) ((((r).chip_umacspeed[0]) >> 26) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_13f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define CHIP_UMACSPEEDr_UMAC_SPEED_14f_GET(r) ((((r).chip_umacspeed[0]) >> 28) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_14f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define CHIP_UMACSPEEDr_UMAC_SPEED_15f_GET(r) ((((r).chip_umacspeed[0]) >> 30) & 0x3)
#define CHIP_UMACSPEEDr_UMAC_SPEED_15f_SET(r,f) (r).chip_umacspeed[0]=(((r).chip_umacspeed[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))

/*
 * These macros can be used to access CHIP_UMACSPEED.
 */
#define WRITE_CHIP_UMACSPEEDr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_UMACSPEED, (r._chip_umacspeed))
#define READ_CHIP_UMACSPEEDr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pmq_lport_to_blockid[p], R_CHIP_UMACSPEED, &(r._chip_umacspeed))

/*******************************************************************************
 * End of 'CHIP_UMACSPEEDr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMICD_M0_IDM_IO_CONTROL_DIRECT
 * BLOCKS:   IPROC
 * DESC:     IO Control Direct register
 * SIZE:     32
 * FIELDS:
 *     RESET_ENABLE_FROM_NIC If set, resetn from NIC will be driven to CMICD. Otherwise it is always out of reset.
 *     ARPROT           ARPROT setting
 *     AWCACHE          AXI AWCACHE 
 *     AWPROT           AWPROT setting
 *     ARCACHE          AXI ARCACHE 
 *     AWUSER           AXI AWUSER
 *     ARUSER           AXI ARUSER
 *     BYPASS_CT        bypass coherent transaction. 1: drive AxAddr[32]/AxCache/AxUser from IDM control registers. 0: Drive from Core as is. 
 *     CT               Coherant transaction.
 */
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_SIZE 4

/*
 * This structure should be used to declare and program CMICD_M0_IDM_IO_CONTROL_DIRECT.
 */
typedef union CMICD_M0_IDM_IO_CONTROL_DIRECTr_s {
	uint32 v[1];
	uint32 cmicd_m0_idm_io_control_direct[1];
	uint32 _cmicd_m0_idm_io_control_direct;
} CMICD_M0_IDM_IO_CONTROL_DIRECTr_t;

#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_CLR(r) (r).cmicd_m0_idm_io_control_direct[0] = 0
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_SET(r,d) (r).cmicd_m0_idm_io_control_direct[0] = d
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_GET(r) (r).cmicd_m0_idm_io_control_direct[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_RESET_ENABLE_FROM_NICf_GET(r) ((((r).cmicd_m0_idm_io_control_direct[0]) >> 2) & 0x1)
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_RESET_ENABLE_FROM_NICf_SET(r,f) (r).cmicd_m0_idm_io_control_direct[0]=(((r).cmicd_m0_idm_io_control_direct[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_ARPROTf_GET(r) ((((r).cmicd_m0_idm_io_control_direct[0]) >> 3) & 0x7)
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_ARPROTf_SET(r,f) (r).cmicd_m0_idm_io_control_direct[0]=(((r).cmicd_m0_idm_io_control_direct[0] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_AWCACHEf_GET(r) ((((r).cmicd_m0_idm_io_control_direct[0]) >> 7) & 0xf)
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_AWCACHEf_SET(r,f) (r).cmicd_m0_idm_io_control_direct[0]=(((r).cmicd_m0_idm_io_control_direct[0] & ~((uint32)0xf << 7)) | ((((uint32)f) & 0xf) << 7))
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_AWPROTf_GET(r) ((((r).cmicd_m0_idm_io_control_direct[0]) >> 11) & 0x7)
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_AWPROTf_SET(r,f) (r).cmicd_m0_idm_io_control_direct[0]=(((r).cmicd_m0_idm_io_control_direct[0] & ~((uint32)0x7 << 11)) | ((((uint32)f) & 0x7) << 11))
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_ARCACHEf_GET(r) ((((r).cmicd_m0_idm_io_control_direct[0]) >> 16) & 0xf)
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_ARCACHEf_SET(r,f) (r).cmicd_m0_idm_io_control_direct[0]=(((r).cmicd_m0_idm_io_control_direct[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_AWUSERf_GET(r) ((((r).cmicd_m0_idm_io_control_direct[0]) >> 20) & 0x1f)
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_AWUSERf_SET(r,f) (r).cmicd_m0_idm_io_control_direct[0]=(((r).cmicd_m0_idm_io_control_direct[0] & ~((uint32)0x1f << 20)) | ((((uint32)f) & 0x1f) << 20))
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_ARUSERf_GET(r) ((((r).cmicd_m0_idm_io_control_direct[0]) >> 25) & 0x1f)
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_ARUSERf_SET(r,f) (r).cmicd_m0_idm_io_control_direct[0]=(((r).cmicd_m0_idm_io_control_direct[0] & ~((uint32)0x1f << 25)) | ((((uint32)f) & 0x1f) << 25))
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_BYPASS_CTf_GET(r) ((((r).cmicd_m0_idm_io_control_direct[0]) >> 30) & 0x1)
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_BYPASS_CTf_SET(r,f) (r).cmicd_m0_idm_io_control_direct[0]=(((r).cmicd_m0_idm_io_control_direct[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_CTf_GET(r) ((((r).cmicd_m0_idm_io_control_direct[0]) >> 31) & 0x1)
#define CMICD_M0_IDM_IO_CONTROL_DIRECTr_CTf_SET(r,f) (r).cmicd_m0_idm_io_control_direct[0]=(((r).cmicd_m0_idm_io_control_direct[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access CMICD_M0_IDM_IO_CONTROL_DIRECT.
 */
#define READ_CMICD_M0_IDM_IO_CONTROL_DIRECTr(u,r) bcm5354x_read32(u, R_CMICD_M0_IDM_IO_CONTROL_DIRECT, &(r._cmicd_m0_idm_io_control_direct))
#define WRITE_CMICD_M0_IDM_IO_CONTROL_DIRECTr(u,r) bcm5354x_write32(u, R_CMICD_M0_IDM_IO_CONTROL_DIRECT, (r._cmicd_m0_idm_io_control_direct))

/*******************************************************************************
 * End of 'CMICD_M0_IDM_IO_CONTROL_DIRECTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMICD_S0_IDM_IO_CONTROL_DIRECT
 * BLOCKS:   IPROC
 * DESC:     IO Control direct access regsiter
 * SIZE:     32
 * FIELDS:
 *     RESET_ENABLE_FROM_NIC If set, resetn from NIC will be driven to CMICD. Otherwise it is always out of reset.
 */
#define CMICD_S0_IDM_IO_CONTROL_DIRECTr_SIZE 4

/*
 * This structure should be used to declare and program CMICD_S0_IDM_IO_CONTROL_DIRECT.
 */
typedef union CMICD_S0_IDM_IO_CONTROL_DIRECTr_s {
	uint32 v[1];
	uint32 cmicd_s0_idm_io_control_direct[1];
	uint32 _cmicd_s0_idm_io_control_direct;
} CMICD_S0_IDM_IO_CONTROL_DIRECTr_t;

#define CMICD_S0_IDM_IO_CONTROL_DIRECTr_CLR(r) (r).cmicd_s0_idm_io_control_direct[0] = 0
#define CMICD_S0_IDM_IO_CONTROL_DIRECTr_SET(r,d) (r).cmicd_s0_idm_io_control_direct[0] = d
#define CMICD_S0_IDM_IO_CONTROL_DIRECTr_GET(r) (r).cmicd_s0_idm_io_control_direct[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMICD_S0_IDM_IO_CONTROL_DIRECTr_RESET_ENABLE_FROM_NICf_GET(r) ((((r).cmicd_s0_idm_io_control_direct[0]) >> 2) & 0x1)
#define CMICD_S0_IDM_IO_CONTROL_DIRECTr_RESET_ENABLE_FROM_NICf_SET(r,f) (r).cmicd_s0_idm_io_control_direct[0]=(((r).cmicd_s0_idm_io_control_direct[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))

/*
 * These macros can be used to access CMICD_S0_IDM_IO_CONTROL_DIRECT.
 */
#define READ_CMICD_S0_IDM_IO_CONTROL_DIRECTr(u,r) bcm5354x_read32(u, R_CMICD_S0_IDM_IO_CONTROL_DIRECT, &(r._cmicd_s0_idm_io_control_direct))
#define WRITE_CMICD_S0_IDM_IO_CONTROL_DIRECTr(u,r) bcm5354x_write32(u, R_CMICD_S0_IDM_IO_CONTROL_DIRECT, (r._cmicd_s0_idm_io_control_direct))

/*******************************************************************************
 * End of 'CMICD_S0_IDM_IO_CONTROL_DIRECTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_CH0_DMA_CTRL
 * BLOCKS:   CMIC
 * DESC:     DMA Control Register
 * SIZE:     32
 * FIELDS:
 *     DIRECTION        DMA channel 0 direction:1=Mem->SOC, 0=SOC->Mem
 *     DMA_EN           Set by CPU to start a DMA on CH0 
 *     ABORT_DMA        DMA channel 0 abort
 *     SEL_INTR_ON_DESC_OR_PKT DMA channel 0 interrupt select:1=after descriptor, 0=after packet
 *     PKTDMA_ENDIANESS (Bit 1) 0 = 1 = big word order for Packet DMA operations
 *     DESC_ENDIANESS   (Bit 1) 0 = 1 = big word order for Descriptor operations
 *     DROP_RX_PKT_ON_CHAIN_END DMA channel 0 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     RLD_STS_UPD_DIS  When set, do not update status fields on reload operation.
 *     DESC_DONE_INTR_MODE 1'b0: Descriptor Done interrupt will be raised after completions of every descriptor.1'b1: Descriptor Done interrupt will be raised only when descriptor.INT bit is set in the descriptor. In both casses, interrupt should be cleared by SW.
 *     ENABLE_CONTINUOUS_DMA When set, continuous DMA is enabled. CH_IN_HALT interrupt will be genrated only when this mode is enabled. 
 */
#define CMIC_CMC0_CH0_DMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_CH0_DMA_CTRL.
 */
typedef union CMIC_CMC0_CH0_DMA_CTRLr_s {
	uint32 v[1];
	uint32 cmic_cmc0_ch0_dma_ctrl[1];
	uint32 _cmic_cmc0_ch0_dma_ctrl;
} CMIC_CMC0_CH0_DMA_CTRLr_t;

#define CMIC_CMC0_CH0_DMA_CTRLr_CLR(r) (r).cmic_cmc0_ch0_dma_ctrl[0] = 0
#define CMIC_CMC0_CH0_DMA_CTRLr_SET(r,d) (r).cmic_cmc0_ch0_dma_ctrl[0] = d
#define CMIC_CMC0_CH0_DMA_CTRLr_GET(r) (r).cmic_cmc0_ch0_dma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_CH0_DMA_CTRLr_DIRECTIONf_GET(r) (((r).cmic_cmc0_ch0_dma_ctrl[0]) & 0x1)
#define CMIC_CMC0_CH0_DMA_CTRLr_DIRECTIONf_SET(r,f) (r).cmic_cmc0_ch0_dma_ctrl[0]=(((r).cmic_cmc0_ch0_dma_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC0_CH0_DMA_CTRLr_DMA_ENf_GET(r) ((((r).cmic_cmc0_ch0_dma_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC0_CH0_DMA_CTRLr_DMA_ENf_SET(r,f) (r).cmic_cmc0_ch0_dma_ctrl[0]=(((r).cmic_cmc0_ch0_dma_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC0_CH0_DMA_CTRLr_ABORT_DMAf_GET(r) ((((r).cmic_cmc0_ch0_dma_ctrl[0]) >> 2) & 0x1)
#define CMIC_CMC0_CH0_DMA_CTRLr_ABORT_DMAf_SET(r,f) (r).cmic_cmc0_ch0_dma_ctrl[0]=(((r).cmic_cmc0_ch0_dma_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC0_CH0_DMA_CTRLr_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_cmc0_ch0_dma_ctrl[0]) >> 3) & 0x1)
#define CMIC_CMC0_CH0_DMA_CTRLr_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_cmc0_ch0_dma_ctrl[0]=(((r).cmic_cmc0_ch0_dma_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC0_CH0_DMA_CTRLr_PKTDMA_ENDIANESSf_GET(r) ((((r).cmic_cmc0_ch0_dma_ctrl[0]) >> 4) & 0x1)
#define CMIC_CMC0_CH0_DMA_CTRLr_PKTDMA_ENDIANESSf_SET(r,f) (r).cmic_cmc0_ch0_dma_ctrl[0]=(((r).cmic_cmc0_ch0_dma_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC0_CH0_DMA_CTRLr_DESC_ENDIANESSf_GET(r) ((((r).cmic_cmc0_ch0_dma_ctrl[0]) >> 5) & 0x1)
#define CMIC_CMC0_CH0_DMA_CTRLr_DESC_ENDIANESSf_SET(r,f) (r).cmic_cmc0_ch0_dma_ctrl[0]=(((r).cmic_cmc0_ch0_dma_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC0_CH0_DMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_cmc0_ch0_dma_ctrl[0]) >> 6) & 0x1)
#define CMIC_CMC0_CH0_DMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_cmc0_ch0_dma_ctrl[0]=(((r).cmic_cmc0_ch0_dma_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC0_CH0_DMA_CTRLr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_cmc0_ch0_dma_ctrl[0]) >> 7) & 0x1)
#define CMIC_CMC0_CH0_DMA_CTRLr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_cmc0_ch0_dma_ctrl[0]=(((r).cmic_cmc0_ch0_dma_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_CMC0_CH0_DMA_CTRLr_DESC_DONE_INTR_MODEf_GET(r) ((((r).cmic_cmc0_ch0_dma_ctrl[0]) >> 8) & 0x1)
#define CMIC_CMC0_CH0_DMA_CTRLr_DESC_DONE_INTR_MODEf_SET(r,f) (r).cmic_cmc0_ch0_dma_ctrl[0]=(((r).cmic_cmc0_ch0_dma_ctrl[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_CMC0_CH0_DMA_CTRLr_ENABLE_CONTINUOUS_DMAf_GET(r) ((((r).cmic_cmc0_ch0_dma_ctrl[0]) >> 9) & 0x1)
#define CMIC_CMC0_CH0_DMA_CTRLr_ENABLE_CONTINUOUS_DMAf_SET(r,f) (r).cmic_cmc0_ch0_dma_ctrl[0]=(((r).cmic_cmc0_ch0_dma_ctrl[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))

/*
 * These macros can be used to access CMIC_CMC0_CH0_DMA_CTRL.
 */
#define READ_CMIC_CMC0_CH0_DMA_CTRLr(u,r) bcm5354x_read32(u, CMIC_CMC0_CH0_DMA_CTRL, &(r._cmic_cmc0_ch0_dma_ctrl))
#define WRITE_CMIC_CMC0_CH0_DMA_CTRLr(u,r) bcm5354x_write32(u, CMIC_CMC0_CH0_DMA_CTRL, (r._cmic_cmc0_ch0_dma_ctrl))

/*******************************************************************************
 * End of 'CMIC_CMC0_CH0_DMA_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_CH1_COS_CTRL_RX_0
 * BLOCKS:   CMIC
 * DESC:     When COS_RX_EN of CMIC_CONFIG is set, this register
indicates which cos are admitted by channel. This register
gives Cos 0 to 31.

 * SIZE:     32
 * FIELDS:
 *     COS_BMP          Channel 1 COS bitmap
 */
#define CMIC_CMC0_CH1_COS_CTRL_RX_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_CH1_COS_CTRL_RX_0.
 */
typedef union CMIC_CMC0_CH1_COS_CTRL_RX_0r_s {
	uint32 v[1];
	uint32 cmic_cmc0_ch1_cos_ctrl_rx_0[1];
	uint32 _cmic_cmc0_ch1_cos_ctrl_rx_0;
} CMIC_CMC0_CH1_COS_CTRL_RX_0r_t;

#define CMIC_CMC0_CH1_COS_CTRL_RX_0r_CLR(r) (r).cmic_cmc0_ch1_cos_ctrl_rx_0[0] = 0
#define CMIC_CMC0_CH1_COS_CTRL_RX_0r_SET(r,d) (r).cmic_cmc0_ch1_cos_ctrl_rx_0[0] = d
#define CMIC_CMC0_CH1_COS_CTRL_RX_0r_GET(r) (r).cmic_cmc0_ch1_cos_ctrl_rx_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_CH1_COS_CTRL_RX_0r_COS_BMPf_GET(r) ((r).cmic_cmc0_ch1_cos_ctrl_rx_0[0])
#define CMIC_CMC0_CH1_COS_CTRL_RX_0r_COS_BMPf_SET(r,f) (r).cmic_cmc0_ch1_cos_ctrl_rx_0[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_CMC0_CH1_COS_CTRL_RX_0.
 */
#define READ_CMIC_CMC0_CH1_COS_CTRL_RX_0r(u,r) bcm5354x_read32(u, CMIC_CMC0_CH1_COS_CTRL_RX_0, &(r._cmic_cmc0_ch1_cos_ctrl_rx_0))
#define WRITE_CMIC_CMC0_CH1_COS_CTRL_RX_0r(u,r) bcm5354x_write32(u, CMIC_CMC0_CH1_COS_CTRL_RX_0, (r._cmic_cmc0_ch1_cos_ctrl_rx_0))

/*******************************************************************************
 * End of 'CMIC_CMC0_CH1_COS_CTRL_RX_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_CH1_DMA_CTRL
 * BLOCKS:   CMIC
 * DESC:     DMA Control Register
 * SIZE:     32
 * FIELDS:
 *     DIRECTION        DMA channel 1 direction:1=Mem->SOC, 0=SOC->Mem
 *     DMA_EN           Set by CPU to start a DMA on CH1 
 *     ABORT_DMA        DMA channel 1 abort
 *     SEL_INTR_ON_DESC_OR_PKT DMA channel 1 interrupt select:1=after descriptor, 0=after packet
 *     PKTDMA_ENDIANESS (Bit 1) 0 = 1 = big word order for Packet DMA operations
 *     DESC_ENDIANESS   (Bit 1) 0 = 1 = big word order for Descriptor operations
 *     DROP_RX_PKT_ON_CHAIN_END DMA channel 1 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     RLD_STS_UPD_DIS  When set, do not update status fields on reload operation.
 *     DESC_DONE_INTR_MODE 1'b0: Descriptor Done interrupt will be raised after completions of every descriptor.1'b1: Descriptor Done interrupt will be raised only when descriptor.INT bit is set in the descriptor. In both casses, interrupt should be cleared by SW.
 *     ENABLE_CONTINUOUS_DMA When set, continuous DMA is enabled. CH_IN_HALT interrupt will be genrated only when this mode is enabled. 
 */
#define CMIC_CMC0_CH1_DMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_CH1_DMA_CTRL.
 */
typedef union CMIC_CMC0_CH1_DMA_CTRLr_s {
	uint32 v[1];
	uint32 cmic_cmc0_ch1_dma_ctrl[1];
	uint32 _cmic_cmc0_ch1_dma_ctrl;
} CMIC_CMC0_CH1_DMA_CTRLr_t;

#define CMIC_CMC0_CH1_DMA_CTRLr_CLR(r) (r).cmic_cmc0_ch1_dma_ctrl[0] = 0
#define CMIC_CMC0_CH1_DMA_CTRLr_SET(r,d) (r).cmic_cmc0_ch1_dma_ctrl[0] = d
#define CMIC_CMC0_CH1_DMA_CTRLr_GET(r) (r).cmic_cmc0_ch1_dma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_CH1_DMA_CTRLr_DIRECTIONf_GET(r) (((r).cmic_cmc0_ch1_dma_ctrl[0]) & 0x1)
#define CMIC_CMC0_CH1_DMA_CTRLr_DIRECTIONf_SET(r,f) (r).cmic_cmc0_ch1_dma_ctrl[0]=(((r).cmic_cmc0_ch1_dma_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC0_CH1_DMA_CTRLr_DMA_ENf_GET(r) ((((r).cmic_cmc0_ch1_dma_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC0_CH1_DMA_CTRLr_DMA_ENf_SET(r,f) (r).cmic_cmc0_ch1_dma_ctrl[0]=(((r).cmic_cmc0_ch1_dma_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC0_CH1_DMA_CTRLr_ABORT_DMAf_GET(r) ((((r).cmic_cmc0_ch1_dma_ctrl[0]) >> 2) & 0x1)
#define CMIC_CMC0_CH1_DMA_CTRLr_ABORT_DMAf_SET(r,f) (r).cmic_cmc0_ch1_dma_ctrl[0]=(((r).cmic_cmc0_ch1_dma_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC0_CH1_DMA_CTRLr_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_cmc0_ch1_dma_ctrl[0]) >> 3) & 0x1)
#define CMIC_CMC0_CH1_DMA_CTRLr_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_cmc0_ch1_dma_ctrl[0]=(((r).cmic_cmc0_ch1_dma_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC0_CH1_DMA_CTRLr_PKTDMA_ENDIANESSf_GET(r) ((((r).cmic_cmc0_ch1_dma_ctrl[0]) >> 4) & 0x1)
#define CMIC_CMC0_CH1_DMA_CTRLr_PKTDMA_ENDIANESSf_SET(r,f) (r).cmic_cmc0_ch1_dma_ctrl[0]=(((r).cmic_cmc0_ch1_dma_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC0_CH1_DMA_CTRLr_DESC_ENDIANESSf_GET(r) ((((r).cmic_cmc0_ch1_dma_ctrl[0]) >> 5) & 0x1)
#define CMIC_CMC0_CH1_DMA_CTRLr_DESC_ENDIANESSf_SET(r,f) (r).cmic_cmc0_ch1_dma_ctrl[0]=(((r).cmic_cmc0_ch1_dma_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC0_CH1_DMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_cmc0_ch1_dma_ctrl[0]) >> 6) & 0x1)
#define CMIC_CMC0_CH1_DMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_cmc0_ch1_dma_ctrl[0]=(((r).cmic_cmc0_ch1_dma_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC0_CH1_DMA_CTRLr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_cmc0_ch1_dma_ctrl[0]) >> 7) & 0x1)
#define CMIC_CMC0_CH1_DMA_CTRLr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_cmc0_ch1_dma_ctrl[0]=(((r).cmic_cmc0_ch1_dma_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_CMC0_CH1_DMA_CTRLr_DESC_DONE_INTR_MODEf_GET(r) ((((r).cmic_cmc0_ch1_dma_ctrl[0]) >> 8) & 0x1)
#define CMIC_CMC0_CH1_DMA_CTRLr_DESC_DONE_INTR_MODEf_SET(r,f) (r).cmic_cmc0_ch1_dma_ctrl[0]=(((r).cmic_cmc0_ch1_dma_ctrl[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_CMC0_CH1_DMA_CTRLr_ENABLE_CONTINUOUS_DMAf_GET(r) ((((r).cmic_cmc0_ch1_dma_ctrl[0]) >> 9) & 0x1)
#define CMIC_CMC0_CH1_DMA_CTRLr_ENABLE_CONTINUOUS_DMAf_SET(r,f) (r).cmic_cmc0_ch1_dma_ctrl[0]=(((r).cmic_cmc0_ch1_dma_ctrl[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))

/*
 * These macros can be used to access CMIC_CMC0_CH1_DMA_CTRL.
 */
#define READ_CMIC_CMC0_CH1_DMA_CTRLr(u,r) bcm5354x_read32(u, CMIC_CMC0_CH1_DMA_CTRL, &(r._cmic_cmc0_ch1_dma_ctrl))
#define WRITE_CMIC_CMC0_CH1_DMA_CTRLr(u,r) bcm5354x_write32(u, CMIC_CMC0_CH1_DMA_CTRL, (r._cmic_cmc0_ch1_dma_ctrl))

/*******************************************************************************
 * End of 'CMIC_CMC0_CH1_DMA_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_CHx_DMA_CTRL
 * BLOCKS:   CMIC
 * DESC:     DMA Control Register
 * SIZE:     32
 * FIELDS:
 *     DIRECTION        DMA channel 0 direction:1=Mem->SOC, 0=SOC->Mem
 *     DMA_EN           Set by CPU to start a DMA on CH0 
 *     ABORT_DMA        DMA channel 0 abort
 *     SEL_INTR_ON_DESC_OR_PKT DMA channel 0 interrupt select:1=after descriptor, 0=after packet
 *     PKTDMA_ENDIANESS (Bit 1) 0 = 1 = big word order for Packet DMA operations
 *     DESC_ENDIANESS   (Bit 1) 0 = 1 = big word order for Descriptor operations
 *     DROP_RX_PKT_ON_CHAIN_END DMA channel 0 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     RLD_STS_UPD_DIS  When set, do not update status fields on reload operation.
 *     DESC_DONE_INTR_MODE 1'b0: Descriptor Done interrupt will be raised after completions of every descriptor.1'b1: Descriptor Done interrupt will be raised only when descriptor.INT bit is set in the descriptor. In both casses, interrupt should be cleared by SW.
 *     ENABLE_CONTINUOUS_DMA When set, continuous DMA is enabled. CH_IN_HALT interrupt will be genrated only when this mode is enabled. 
 */
#define CMIC_CMC0_CHX_DMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_CHx_DMA_CTRL.
 */
typedef union CMIC_CMC0_CHX_DMA_CTRLr_s {
	uint32 v[1];
	uint32 cmic_cmc0_chx_dma_ctrl[1];
	uint32 _cmic_cmc0_chx_dma_ctrl;
} CMIC_CMC0_CHX_DMA_CTRLr_t;

#define CMIC_CMC0_CHX_DMA_CTRLr_CLR(r) (r).cmic_cmc0_chx_dma_ctrl[0] = 0
#define CMIC_CMC0_CHX_DMA_CTRLr_SET(r,d) (r).cmic_cmc0_chx_dma_ctrl[0] = d
#define CMIC_CMC0_CHX_DMA_CTRLr_GET(r) (r).cmic_cmc0_chx_dma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_CHX_DMA_CTRLr_DIRECTIONf_GET(r) (((r).cmic_cmc0_chx_dma_ctrl[0]) & 0x1)
#define CMIC_CMC0_CHX_DMA_CTRLr_DIRECTIONf_SET(r,f) (r).cmic_cmc0_chx_dma_ctrl[0]=(((r).cmic_cmc0_chx_dma_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC0_CHX_DMA_CTRLr_DMA_ENf_GET(r) ((((r).cmic_cmc0_chx_dma_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC0_CHX_DMA_CTRLr_DMA_ENf_SET(r,f) (r).cmic_cmc0_chx_dma_ctrl[0]=(((r).cmic_cmc0_chx_dma_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC0_CHX_DMA_CTRLr_ABORT_DMAf_GET(r) ((((r).cmic_cmc0_chx_dma_ctrl[0]) >> 2) & 0x1)
#define CMIC_CMC0_CHX_DMA_CTRLr_ABORT_DMAf_SET(r,f) (r).cmic_cmc0_chx_dma_ctrl[0]=(((r).cmic_cmc0_chx_dma_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC0_CHX_DMA_CTRLr_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_cmc0_chx_dma_ctrl[0]) >> 3) & 0x1)
#define CMIC_CMC0_CHX_DMA_CTRLr_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_cmc0_chx_dma_ctrl[0]=(((r).cmic_cmc0_chx_dma_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC0_CHX_DMA_CTRLr_PKTDMA_ENDIANESSf_GET(r) ((((r).cmic_cmc0_chx_dma_ctrl[0]) >> 4) & 0x1)
#define CMIC_CMC0_CHX_DMA_CTRLr_PKTDMA_ENDIANESSf_SET(r,f) (r).cmic_cmc0_chx_dma_ctrl[0]=(((r).cmic_cmc0_chx_dma_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC0_CHX_DMA_CTRLr_DESC_ENDIANESSf_GET(r) ((((r).cmic_cmc0_chx_dma_ctrl[0]) >> 5) & 0x1)
#define CMIC_CMC0_CHX_DMA_CTRLr_DESC_ENDIANESSf_SET(r,f) (r).cmic_cmc0_chx_dma_ctrl[0]=(((r).cmic_cmc0_chx_dma_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC0_CHX_DMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_cmc0_chx_dma_ctrl[0]) >> 6) & 0x1)
#define CMIC_CMC0_CHX_DMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_cmc0_chx_dma_ctrl[0]=(((r).cmic_cmc0_chx_dma_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC0_CHX_DMA_CTRLr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_cmc0_chx_dma_ctrl[0]) >> 7) & 0x1)
#define CMIC_CMC0_CHX_DMA_CTRLr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_cmc0_chx_dma_ctrl[0]=(((r).cmic_cmc0_chx_dma_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_CMC0_CHX_DMA_CTRLr_DESC_DONE_INTR_MODEf_GET(r) ((((r).cmic_cmc0_chx_dma_ctrl[0]) >> 8) & 0x1)
#define CMIC_CMC0_CHX_DMA_CTRLr_DESC_DONE_INTR_MODEf_SET(r,f) (r).cmic_cmc0_chx_dma_ctrl[0]=(((r).cmic_cmc0_chx_dma_ctrl[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_CMC0_CHX_DMA_CTRLr_ENABLE_CONTINUOUS_DMAf_GET(r) ((((r).cmic_cmc0_chx_dma_ctrl[0]) >> 9) & 0x1)
#define CMIC_CMC0_CHX_DMA_CTRLr_ENABLE_CONTINUOUS_DMAf_SET(r,f) (r).cmic_cmc0_chx_dma_ctrl[0]=(((r).cmic_cmc0_chx_dma_ctrl[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))

/*
 * These macros can be used to access CMIC_CMC0_CHx_DMA_CTRL.
 */
#define READ_CMIC_CMC0_CHX_DMA_CTRLr(u,i,r) bcm5354x_read32(u, CMIC_CMC0_CHx_DMA_CTRL(i), &(r._cmic_cmc0_chx_dma_ctrl))
#define WRITE_CMIC_CMC0_CHX_DMA_CTRLr(u,i,r) bcm5354x_write32(u, CMIC_CMC0_CHx_DMA_CTRL(i), (r._cmic_cmc0_chx_dma_ctrl))

/*******************************************************************************
 * End of 'CMIC_CMC0_CHX_DMA_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_DMA_DESC
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 0 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH0 DESCRIPTOR ADDRESS REGISTER
 */
#define CMIC_CMC0_DMA_DESCr_SIZE 4

/* CMIC_CMC0_DMA_DESCr is element of CMIC_CMC0_CH1_DMA_CTRL */

/*
 * This structure should be used to declare and program CMIC_CMC0_DMA_DESC.
 */
typedef union CMIC_CMC0_DMA_DESCr_s {
	uint32 v[1];
	uint32 cmic_cmc0_dma_desc[1];
	uint32 _cmic_cmc0_dma_desc;
} CMIC_CMC0_DMA_DESCr_t;

#define CMIC_CMC0_DMA_DESCr_CLR(r) (r).cmic_cmc0_dma_desc[0] = 0
#define CMIC_CMC0_DMA_DESCr_SET(r,d) (r).cmic_cmc0_dma_desc[0] = d
#define CMIC_CMC0_DMA_DESCr_GET(r) (r).cmic_cmc0_dma_desc[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_DMA_DESCr_ADDRf_GET(r) ((r).cmic_cmc0_dma_desc[0])
#define CMIC_CMC0_DMA_DESCr_ADDRf_SET(r,f) (r).cmic_cmc0_dma_desc[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_CMC0_DMA_DESC.
 */
#define READ_CMIC_CMC0_DMA_DESCr(u,i,r) bcm5354x_read32(u, CMIC_CMC0_DMA_DESC(i), &(r._cmic_cmc0_dma_desc))
#define WRITE_CMIC_CMC0_DMA_DESCr(u,i,r) bcm5354x_write32(u, CMIC_CMC0_DMA_DESC(i), (r._cmic_cmc0_dma_desc))

/*******************************************************************************
 * End of 'CMIC_CMC0_DMA_DESCr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_DMA_STAT
 * BLOCKS:   CMIC
 * DESC:     DMA Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     CH0_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH1_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH2_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH3_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH0_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH1_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH2_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH3_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH0_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH1_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH2_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH3_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH0_STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH1_STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH2_STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH3_STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH0_PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH1_PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH2_PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH3_PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH0_DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH1_DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH2_DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH3_DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH0_STWR_ECC_ERR Set by CMIC to indicate ECC error found while reading status buffer. This can be cleared by resetting ENABLE bit. 
 *     CH1_STWR_ECC_ERR Set by CMIC to indicate ECC error found while reading status buffer. This can be cleared by resetting ENABLE bit. 
 *     CH2_STWR_ECC_ERR Set by CMIC to indicate ECC error found while reading status buffer. This can be cleared by resetting ENABLE bit. 
 *     CH3_STWR_ECC_ERR Set by CMIC to indicate ECC error found while reading status buffer. This can be cleared by resetting ENABLE bit. 
 *     CH0_PKTWR_ECC_ERR Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 *     CH1_PKTWR_ECC_ERR Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 *     CH2_PKTWR_ECC_ERR Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 *     CH3_PKTWR_ECC_ERR Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 */
#define CMIC_CMC0_DMA_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_DMA_STAT.
 */
typedef union CMIC_CMC0_DMA_STATr_s {
	uint32 v[1];
	uint32 cmic_cmc0_dma_stat[1];
	uint32 _cmic_cmc0_dma_stat;
} CMIC_CMC0_DMA_STATr_t;

#define CMIC_CMC0_DMA_STATr_CLR(r) (r).cmic_cmc0_dma_stat[0] = 0
#define CMIC_CMC0_DMA_STATr_SET(r,d) (r).cmic_cmc0_dma_stat[0] = d
#define CMIC_CMC0_DMA_STATr_GET(r) (r).cmic_cmc0_dma_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_DMA_STATr_CH0_CHAIN_DONEf_GET(r) (((r).cmic_cmc0_dma_stat[0]) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC0_DMA_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 1) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC0_DMA_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 2) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC0_DMA_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 3) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC0_DMA_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 4) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC0_DMA_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 5) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC0_DMA_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 6) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC0_DMA_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 7) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_CMC0_DMA_STATr_CH0_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 8) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH0_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_CMC0_DMA_STATr_CH1_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 9) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH1_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CMIC_CMC0_DMA_STATr_CH2_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 10) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH2_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define CMIC_CMC0_DMA_STATr_CH3_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 11) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH3_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define CMIC_CMC0_DMA_STATr_CH0_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 12) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH0_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define CMIC_CMC0_DMA_STATr_CH1_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 13) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH1_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define CMIC_CMC0_DMA_STATr_CH2_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 14) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH2_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define CMIC_CMC0_DMA_STATr_CH3_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 15) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH3_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define CMIC_CMC0_DMA_STATr_CH0_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 16) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH0_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define CMIC_CMC0_DMA_STATr_CH1_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 17) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH1_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define CMIC_CMC0_DMA_STATr_CH2_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 18) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH2_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define CMIC_CMC0_DMA_STATr_CH3_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 19) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH3_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define CMIC_CMC0_DMA_STATr_CH0_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 20) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH0_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define CMIC_CMC0_DMA_STATr_CH1_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 21) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH1_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_CMC0_DMA_STATr_CH2_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 22) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH2_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CMIC_CMC0_DMA_STATr_CH3_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 23) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH3_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define CMIC_CMC0_DMA_STATr_CH0_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 24) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH0_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define CMIC_CMC0_DMA_STATr_CH1_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 25) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH1_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define CMIC_CMC0_DMA_STATr_CH2_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 26) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH2_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define CMIC_CMC0_DMA_STATr_CH3_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 27) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH3_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define CMIC_CMC0_DMA_STATr_CH0_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 28) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH0_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define CMIC_CMC0_DMA_STATr_CH1_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 29) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH1_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define CMIC_CMC0_DMA_STATr_CH2_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 30) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH2_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define CMIC_CMC0_DMA_STATr_CH3_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc0_dma_stat[0]) >> 31) & 0x1)
#define CMIC_CMC0_DMA_STATr_CH3_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc0_dma_stat[0]=(((r).cmic_cmc0_dma_stat[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_CMC0_DMA_STAT.
 */
#define READ_CMIC_CMC0_DMA_STATr(u,r) bcm5354x_read32(u, CMIC_CMC0_DMA_STAT, &(r._cmic_cmc0_dma_stat))
#define WRITE_CMIC_CMC0_DMA_STATr(u,r) bcm5354x_write32(u, CMIC_CMC0_DMA_STAT, (r._cmic_cmc0_dma_stat))

/*******************************************************************************
 * End of 'CMIC_CMC0_DMA_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_DMA_STAT_CLR
 * BLOCKS:   CMIC
 * DESC:     Desc read complete information in CMIC_CMC_DMA_STAT can be cleared using this register.


 * SIZE:     32
 * FIELDS:
 *     CH0_DESCRD_CMPLT_CLR Write 0x1 to clear ch0 descrd_cmplt in DMA_STAT register.
 *     CH1_DESCRD_CMPLT_CLR Write 0x2 to clear ch1 descrd_cmplt in DMA_STAT register.
 *     CH2_DESCRD_CMPLT_CLR Write 0x4 to clear ch2 descrd_cmplt in DMA_STAT register.
 *     CH3_DESCRD_CMPLT_CLR Write 0x8 to clear ch3 descrd_cmplt in DMA_STAT register.
 *     CH0_INTR_COALESCING_CLR Write 0x10 to clear ch0 intr_coalescing.
 *     CH1_INTR_COALESCING_CLR Write 0x20 to clear ch1 intr_coalescing.
 *     CH2_INTR_COALESCING_CLR Write 0x40 to clear ch2 intr_coalescing.
 *     CH3_INTR_COALESCING_CLR Write 0x80 to clear ch3 intr_coalescing.
 *     CH0_DESC_CONTROLLED_INTR_CLR Write 0x100 to clear CH0_DESC_CONTROLLED_INTR.
 *     CH1_DESC_CONTROLLED_INTR_CLR Write 0x200 to clear CH1_DESC_CONTROLLED_INTR.
 *     CH2_DESC_CONTROLLED_INTR_CLR Write 0x400 to clear CH2_DESC_CONTROLLED_INTR.
 *     CH3_DESC_CONTROLLED_INTR_CLR Write 0x800 to clear CH3_DESC_CONTROLLED_INTR.
 */
#define CMIC_CMC0_DMA_STAT_CLRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_DMA_STAT_CLR.
 */
typedef union CMIC_CMC0_DMA_STAT_CLRr_s {
	uint32 v[1];
	uint32 cmic_cmc0_dma_stat_clr[1];
	uint32 _cmic_cmc0_dma_stat_clr;
} CMIC_CMC0_DMA_STAT_CLRr_t;

#define CMIC_CMC0_DMA_STAT_CLRr_CLR(r) (r).cmic_cmc0_dma_stat_clr[0] = 0
#define CMIC_CMC0_DMA_STAT_CLRr_SET(r,d) (r).cmic_cmc0_dma_stat_clr[0] = d
#define CMIC_CMC0_DMA_STAT_CLRr_GET(r) (r).cmic_cmc0_dma_stat_clr[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_DMA_STAT_CLRr_CH0_DESCRD_CMPLT_CLRf_GET(r) (((r).cmic_cmc0_dma_stat_clr[0]) & 0x1)
#define CMIC_CMC0_DMA_STAT_CLRr_CH0_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc0_dma_stat_clr[0]=(((r).cmic_cmc0_dma_stat_clr[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC0_DMA_STAT_CLRr_CH1_DESCRD_CMPLT_CLRf_GET(r) ((((r).cmic_cmc0_dma_stat_clr[0]) >> 1) & 0x1)
#define CMIC_CMC0_DMA_STAT_CLRr_CH1_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc0_dma_stat_clr[0]=(((r).cmic_cmc0_dma_stat_clr[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC0_DMA_STAT_CLRr_CH2_DESCRD_CMPLT_CLRf_GET(r) ((((r).cmic_cmc0_dma_stat_clr[0]) >> 2) & 0x1)
#define CMIC_CMC0_DMA_STAT_CLRr_CH2_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc0_dma_stat_clr[0]=(((r).cmic_cmc0_dma_stat_clr[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC0_DMA_STAT_CLRr_CH3_DESCRD_CMPLT_CLRf_GET(r) ((((r).cmic_cmc0_dma_stat_clr[0]) >> 3) & 0x1)
#define CMIC_CMC0_DMA_STAT_CLRr_CH3_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc0_dma_stat_clr[0]=(((r).cmic_cmc0_dma_stat_clr[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC0_DMA_STAT_CLRr_CH0_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc0_dma_stat_clr[0]) >> 4) & 0x1)
#define CMIC_CMC0_DMA_STAT_CLRr_CH0_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc0_dma_stat_clr[0]=(((r).cmic_cmc0_dma_stat_clr[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC0_DMA_STAT_CLRr_CH1_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc0_dma_stat_clr[0]) >> 5) & 0x1)
#define CMIC_CMC0_DMA_STAT_CLRr_CH1_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc0_dma_stat_clr[0]=(((r).cmic_cmc0_dma_stat_clr[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC0_DMA_STAT_CLRr_CH2_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc0_dma_stat_clr[0]) >> 6) & 0x1)
#define CMIC_CMC0_DMA_STAT_CLRr_CH2_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc0_dma_stat_clr[0]=(((r).cmic_cmc0_dma_stat_clr[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC0_DMA_STAT_CLRr_CH3_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc0_dma_stat_clr[0]) >> 7) & 0x1)
#define CMIC_CMC0_DMA_STAT_CLRr_CH3_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc0_dma_stat_clr[0]=(((r).cmic_cmc0_dma_stat_clr[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_CMC0_DMA_STAT_CLRr_CH0_DESC_CONTROLLED_INTR_CLRf_GET(r) ((((r).cmic_cmc0_dma_stat_clr[0]) >> 8) & 0x1)
#define CMIC_CMC0_DMA_STAT_CLRr_CH0_DESC_CONTROLLED_INTR_CLRf_SET(r,f) (r).cmic_cmc0_dma_stat_clr[0]=(((r).cmic_cmc0_dma_stat_clr[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_CMC0_DMA_STAT_CLRr_CH1_DESC_CONTROLLED_INTR_CLRf_GET(r) ((((r).cmic_cmc0_dma_stat_clr[0]) >> 9) & 0x1)
#define CMIC_CMC0_DMA_STAT_CLRr_CH1_DESC_CONTROLLED_INTR_CLRf_SET(r,f) (r).cmic_cmc0_dma_stat_clr[0]=(((r).cmic_cmc0_dma_stat_clr[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CMIC_CMC0_DMA_STAT_CLRr_CH2_DESC_CONTROLLED_INTR_CLRf_GET(r) ((((r).cmic_cmc0_dma_stat_clr[0]) >> 10) & 0x1)
#define CMIC_CMC0_DMA_STAT_CLRr_CH2_DESC_CONTROLLED_INTR_CLRf_SET(r,f) (r).cmic_cmc0_dma_stat_clr[0]=(((r).cmic_cmc0_dma_stat_clr[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define CMIC_CMC0_DMA_STAT_CLRr_CH3_DESC_CONTROLLED_INTR_CLRf_GET(r) ((((r).cmic_cmc0_dma_stat_clr[0]) >> 11) & 0x1)
#define CMIC_CMC0_DMA_STAT_CLRr_CH3_DESC_CONTROLLED_INTR_CLRf_SET(r,f) (r).cmic_cmc0_dma_stat_clr[0]=(((r).cmic_cmc0_dma_stat_clr[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))

/*
 * These macros can be used to access CMIC_CMC0_DMA_STAT_CLR.
 */
#define READ_CMIC_CMC0_DMA_STAT_CLRr(u,r) bcm5354x_read32(u, CMIC_CMC0_DMA_STAT_CLR, &(r._cmic_cmc0_dma_stat_clr))
#define WRITE_CMIC_CMC0_DMA_STAT_CLRr(u,r) bcm5354x_write32(u, CMIC_CMC0_DMA_STAT_CLR, (r._cmic_cmc0_dma_stat_clr))

/*******************************************************************************
 * End of 'CMIC_CMC0_DMA_STAT_CLRr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_HOSTMEM_ADDR_REMAP_0
 * BLOCKS:   CMIC
 * DESC:     Memory mapping using [31:28] of programmed host mem address.
 * SIZE:     32
 * FIELDS:
 *     ADDR_0           Remapped address when HOSTMEM_ADDR[31:28] == 0.
 *     ADDR_1           Remapped address when HOSTMEM_ADDR[31:28] == 1.
 *     ADDR_2           Remapped address when HOSTMEM_ADDR[31:28] == 2.
 *     ADDR_3           Remapped address when HOSTMEM_ADDR[31:28] == 3. 
 *     ADDR_4           Remapped address when HOSTMEM_ADDR[31:28] == 4.
 */
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_HOSTMEM_ADDR_REMAP_0.
 */
typedef union CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_s {
	uint32 v[1];
	uint32 cmic_cmc0_hostmem_addr_remap_0[1];
	uint32 _cmic_cmc0_hostmem_addr_remap_0;
} CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_t;

#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_CLR(r) (r).cmic_cmc0_hostmem_addr_remap_0[0] = 0
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_SET(r,d) (r).cmic_cmc0_hostmem_addr_remap_0[0] = d
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_GET(r) (r).cmic_cmc0_hostmem_addr_remap_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_ADDR_0f_GET(r) (((r).cmic_cmc0_hostmem_addr_remap_0[0]) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_ADDR_0f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_0[0]=(((r).cmic_cmc0_hostmem_addr_remap_0[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_ADDR_1f_GET(r) ((((r).cmic_cmc0_hostmem_addr_remap_0[0]) >> 6) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_ADDR_1f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_0[0]=(((r).cmic_cmc0_hostmem_addr_remap_0[0] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_ADDR_2f_GET(r) ((((r).cmic_cmc0_hostmem_addr_remap_0[0]) >> 12) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_ADDR_2f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_0[0]=(((r).cmic_cmc0_hostmem_addr_remap_0[0] & ~((uint32)0x3f << 12)) | ((((uint32)f) & 0x3f) << 12))
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_ADDR_3f_GET(r) ((((r).cmic_cmc0_hostmem_addr_remap_0[0]) >> 18) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_ADDR_3f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_0[0]=(((r).cmic_cmc0_hostmem_addr_remap_0[0] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_ADDR_4f_GET(r) ((((r).cmic_cmc0_hostmem_addr_remap_0[0]) >> 24) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r_ADDR_4f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_0[0]=(((r).cmic_cmc0_hostmem_addr_remap_0[0] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_CMC0_HOSTMEM_ADDR_REMAP_0.
 */
#define READ_CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r(u,r) bcm5354x_read32(u, CMIC_CMC0_HOSTMEM_ADDR_REMAP_0, &(r._cmic_cmc0_hostmem_addr_remap_0))
#define WRITE_CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r(u,r) bcm5354x_write32(u, CMIC_CMC0_HOSTMEM_ADDR_REMAP_0, (r._cmic_cmc0_hostmem_addr_remap_0))

/*******************************************************************************
 * End of 'CMIC_CMC0_HOSTMEM_ADDR_REMAP_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_HOSTMEM_ADDR_REMAP_1
 * BLOCKS:   CMIC
 * DESC:     Memory mapping using [31:28] of programmed host mem address.
 * SIZE:     32
 * FIELDS:
 *     ADDR_0           Remapped address when HOSTMEM_ADDR[31:28] == 5. 
 *     ADDR_1           Remapped address when HOSTMEM_ADDR[31:28] == 6.
 *     ADDR_2           Remapped address when HOSTMEM_ADDR[31:28] == 7.
 *     ADDR_3           Remapped address when HOSTMEM_ADDR[31:28] == 8
 *     ADDR_4           Remapped address when HOSTMEM_ADDR[31:28] == 9. 
 */
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_HOSTMEM_ADDR_REMAP_1.
 */
typedef union CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_s {
	uint32 v[1];
	uint32 cmic_cmc0_hostmem_addr_remap_1[1];
	uint32 _cmic_cmc0_hostmem_addr_remap_1;
} CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_t;

#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_CLR(r) (r).cmic_cmc0_hostmem_addr_remap_1[0] = 0
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_SET(r,d) (r).cmic_cmc0_hostmem_addr_remap_1[0] = d
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_GET(r) (r).cmic_cmc0_hostmem_addr_remap_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_ADDR_0f_GET(r) (((r).cmic_cmc0_hostmem_addr_remap_1[0]) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_ADDR_0f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_1[0]=(((r).cmic_cmc0_hostmem_addr_remap_1[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_ADDR_1f_GET(r) ((((r).cmic_cmc0_hostmem_addr_remap_1[0]) >> 6) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_ADDR_1f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_1[0]=(((r).cmic_cmc0_hostmem_addr_remap_1[0] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_ADDR_2f_GET(r) ((((r).cmic_cmc0_hostmem_addr_remap_1[0]) >> 12) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_ADDR_2f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_1[0]=(((r).cmic_cmc0_hostmem_addr_remap_1[0] & ~((uint32)0x3f << 12)) | ((((uint32)f) & 0x3f) << 12))
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_ADDR_3f_GET(r) ((((r).cmic_cmc0_hostmem_addr_remap_1[0]) >> 18) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_ADDR_3f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_1[0]=(((r).cmic_cmc0_hostmem_addr_remap_1[0] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_ADDR_4f_GET(r) ((((r).cmic_cmc0_hostmem_addr_remap_1[0]) >> 24) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r_ADDR_4f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_1[0]=(((r).cmic_cmc0_hostmem_addr_remap_1[0] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_CMC0_HOSTMEM_ADDR_REMAP_1.
 */
#define READ_CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r(u,r) bcm5354x_read32(u, CMIC_CMC0_HOSTMEM_ADDR_REMAP_1, &(r._cmic_cmc0_hostmem_addr_remap_1))
#define WRITE_CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r(u,r) bcm5354x_write32(u, CMIC_CMC0_HOSTMEM_ADDR_REMAP_1, (r._cmic_cmc0_hostmem_addr_remap_1))

/*******************************************************************************
 * End of 'CMIC_CMC0_HOSTMEM_ADDR_REMAP_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_HOSTMEM_ADDR_REMAP_2
 * BLOCKS:   CMIC
 * DESC:     Memory mapping using [31:28] of programmed host mem address.
 * SIZE:     32
 * FIELDS:
 *     ADDR_0           Remapped address when HOSTMEM_ADDR[31:28] == 10.
 *     ADDR_1           Remapped address when HOSTMEM_ADDR[31:28] == 11.
 *     ADDR_2           Remapped address when HOSTMEM_ADDR[31:28] == 12.
 *     ADDR_3           Remapped address when HOSTMEM_ADDR[31:28] == 13. 
 *     ADDR_4           Remapped address when HOSTMEM_ADDR[31:28] == 14. 
 */
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_HOSTMEM_ADDR_REMAP_2.
 */
typedef union CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_s {
	uint32 v[1];
	uint32 cmic_cmc0_hostmem_addr_remap_2[1];
	uint32 _cmic_cmc0_hostmem_addr_remap_2;
} CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_t;

#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_CLR(r) (r).cmic_cmc0_hostmem_addr_remap_2[0] = 0
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_SET(r,d) (r).cmic_cmc0_hostmem_addr_remap_2[0] = d
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_GET(r) (r).cmic_cmc0_hostmem_addr_remap_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_ADDR_0f_GET(r) (((r).cmic_cmc0_hostmem_addr_remap_2[0]) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_ADDR_0f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_2[0]=(((r).cmic_cmc0_hostmem_addr_remap_2[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_ADDR_1f_GET(r) ((((r).cmic_cmc0_hostmem_addr_remap_2[0]) >> 6) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_ADDR_1f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_2[0]=(((r).cmic_cmc0_hostmem_addr_remap_2[0] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_ADDR_2f_GET(r) ((((r).cmic_cmc0_hostmem_addr_remap_2[0]) >> 12) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_ADDR_2f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_2[0]=(((r).cmic_cmc0_hostmem_addr_remap_2[0] & ~((uint32)0x3f << 12)) | ((((uint32)f) & 0x3f) << 12))
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_ADDR_3f_GET(r) ((((r).cmic_cmc0_hostmem_addr_remap_2[0]) >> 18) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_ADDR_3f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_2[0]=(((r).cmic_cmc0_hostmem_addr_remap_2[0] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_ADDR_4f_GET(r) ((((r).cmic_cmc0_hostmem_addr_remap_2[0]) >> 24) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r_ADDR_4f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_2[0]=(((r).cmic_cmc0_hostmem_addr_remap_2[0] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_CMC0_HOSTMEM_ADDR_REMAP_2.
 */
#define READ_CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r(u,r) bcm5354x_read32(u, CMIC_CMC0_HOSTMEM_ADDR_REMAP_2, &(r._cmic_cmc0_hostmem_addr_remap_2))
#define WRITE_CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r(u,r) bcm5354x_write32(u, CMIC_CMC0_HOSTMEM_ADDR_REMAP_2, (r._cmic_cmc0_hostmem_addr_remap_2))

/*******************************************************************************
 * End of 'CMIC_CMC0_HOSTMEM_ADDR_REMAP_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_HOSTMEM_ADDR_REMAP_3
 * BLOCKS:   CMIC
 * DESC:     Memory mapping using [31:28] of programmed host mem address.
 * SIZE:     32
 * FIELDS:
 *     ADDR_0           Remapped address when HOSTMEM_ADDR[31:28] == 0xF.  
 */
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_3r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_HOSTMEM_ADDR_REMAP_3.
 */
typedef union CMIC_CMC0_HOSTMEM_ADDR_REMAP_3r_s {
	uint32 v[1];
	uint32 cmic_cmc0_hostmem_addr_remap_3[1];
	uint32 _cmic_cmc0_hostmem_addr_remap_3;
} CMIC_CMC0_HOSTMEM_ADDR_REMAP_3r_t;

#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_3r_CLR(r) (r).cmic_cmc0_hostmem_addr_remap_3[0] = 0
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_3r_SET(r,d) (r).cmic_cmc0_hostmem_addr_remap_3[0] = d
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_3r_GET(r) (r).cmic_cmc0_hostmem_addr_remap_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_3r_ADDR_0f_GET(r) (((r).cmic_cmc0_hostmem_addr_remap_3[0]) & 0x3f)
#define CMIC_CMC0_HOSTMEM_ADDR_REMAP_3r_ADDR_0f_SET(r,f) (r).cmic_cmc0_hostmem_addr_remap_3[0]=(((r).cmic_cmc0_hostmem_addr_remap_3[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))

/*
 * These macros can be used to access CMIC_CMC0_HOSTMEM_ADDR_REMAP_3.
 */
#define READ_CMIC_CMC0_HOSTMEM_ADDR_REMAP_3r(u,r) bcm5354x_read32(u, CMIC_CMC0_HOSTMEM_ADDR_REMAP_3, &(r._cmic_cmc0_hostmem_addr_remap_3))
#define WRITE_CMIC_CMC0_HOSTMEM_ADDR_REMAP_3r(u,r) bcm5354x_write32(u, CMIC_CMC0_HOSTMEM_ADDR_REMAP_3, (r._cmic_cmc0_hostmem_addr_remap_3))

/*******************************************************************************
 * End of 'CMIC_CMC0_HOSTMEM_ADDR_REMAP_3r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_MIIM_ADDRESS
 * BLOCKS:   CMIC
 * DESC:     Supplies the register address of MIIM reads and writes.
For clause 22 devices, bits [4:0] supply the REGAD.
For clause 45 devices, bits [20:16] supply the DTYPE,
                   and bits [15: 0] supply the reg address

 * SIZE:     32
 * FIELDS:
 *     CLAUSE_45_REGADR Register address for associated read or writeClause 45: Address = bits[15:0]Clause 22: Address = bits[4:0]
 *     CLAUSE_45_DTYPE  Block-within-PHY address for associated read or write
 */
#define CMIC_CMC0_MIIM_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_MIIM_ADDRESS.
 */
typedef union CMIC_CMC0_MIIM_ADDRESSr_s {
	uint32 v[1];
	uint32 cmic_cmc0_miim_address[1];
	uint32 _cmic_cmc0_miim_address;
} CMIC_CMC0_MIIM_ADDRESSr_t;

#define CMIC_CMC0_MIIM_ADDRESSr_CLR(r) (r).cmic_cmc0_miim_address[0] = 0
#define CMIC_CMC0_MIIM_ADDRESSr_SET(r,d) (r).cmic_cmc0_miim_address[0] = d
#define CMIC_CMC0_MIIM_ADDRESSr_GET(r) (r).cmic_cmc0_miim_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET(r) (((r).cmic_cmc0_miim_address[0]) & 0xffff)
#define CMIC_CMC0_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET(r,f) (r).cmic_cmc0_miim_address[0]=(((r).cmic_cmc0_miim_address[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CMIC_CMC0_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET(r) ((((r).cmic_cmc0_miim_address[0]) >> 16) & 0x1f)
#define CMIC_CMC0_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET(r,f) (r).cmic_cmc0_miim_address[0]=(((r).cmic_cmc0_miim_address[0] & ~((uint32)0x1f << 16)) | ((((uint32)f) & 0x1f) << 16))

/*
 * These macros can be used to access CMIC_CMC0_MIIM_ADDRESS.
 */
#define READ_CMIC_CMC0_MIIM_ADDRESSr(u,r) bcm5354x_read32(u, CMIC_CMC0_MIIM_ADDRESS, &(r._cmic_cmc0_miim_address))
#define WRITE_CMIC_CMC0_MIIM_ADDRESSr(u,r) bcm5354x_write32(u, CMIC_CMC0_MIIM_ADDRESS, (r._cmic_cmc0_miim_address))

/*******************************************************************************
 * End of 'CMIC_CMC0_MIIM_ADDRESSr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_MIIM_CTRL
 * BLOCKS:   CMIC
 * DESC:     register to enable MIIM read and Writes.

 * SIZE:     32
 * FIELDS:
 *     MIIM_WR_START    Set this bit to initiate MDIO read operation. This bit needs to be cleared to reset MDIO COMPLETE bit
 *     MIIM_RD_START    Set this bit to initiate MDIO read operation. This bit needs to be cleared to reset MDIO COMPLETE bit
 */
#define CMIC_CMC0_MIIM_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_MIIM_CTRL.
 */
typedef union CMIC_CMC0_MIIM_CTRLr_s {
	uint32 v[1];
	uint32 cmic_cmc0_miim_ctrl[1];
	uint32 _cmic_cmc0_miim_ctrl;
} CMIC_CMC0_MIIM_CTRLr_t;

#define CMIC_CMC0_MIIM_CTRLr_CLR(r) (r).cmic_cmc0_miim_ctrl[0] = 0
#define CMIC_CMC0_MIIM_CTRLr_SET(r,d) (r).cmic_cmc0_miim_ctrl[0] = d
#define CMIC_CMC0_MIIM_CTRLr_GET(r) (r).cmic_cmc0_miim_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_MIIM_CTRLr_MIIM_WR_STARTf_GET(r) (((r).cmic_cmc0_miim_ctrl[0]) & 0x1)
#define CMIC_CMC0_MIIM_CTRLr_MIIM_WR_STARTf_SET(r,f) (r).cmic_cmc0_miim_ctrl[0]=(((r).cmic_cmc0_miim_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC0_MIIM_CTRLr_MIIM_RD_STARTf_GET(r) ((((r).cmic_cmc0_miim_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC0_MIIM_CTRLr_MIIM_RD_STARTf_SET(r,f) (r).cmic_cmc0_miim_ctrl[0]=(((r).cmic_cmc0_miim_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access CMIC_CMC0_MIIM_CTRL.
 */
#define READ_CMIC_CMC0_MIIM_CTRLr(u,r) bcm5354x_read32(u, CMIC_CMC0_MIIM_CTRL, &(r._cmic_cmc0_miim_ctrl))
#define WRITE_CMIC_CMC0_MIIM_CTRLr(u,r) bcm5354x_write32(u, CMIC_CMC0_MIIM_CTRL, (r._cmic_cmc0_miim_ctrl))

/*******************************************************************************
 * End of 'CMIC_CMC0_MIIM_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_MIIM_PARAM
 * BLOCKS:   CMIC
 * DESC:     MIIM Parameter Register
 * SIZE:     32
 * FIELDS:
 *     PHY_DATA         PHY register data
 *     PHY_ID           Port number (Phy ID is looked up from port number)
 *     C45_SEL          When set, send MIIM transaction using Clause 45.Otherwise, send as Clause 22 transaction.
 *     BUS_ID           Select MIIM Bus number from  6 of available MIIM busses.
 *     INTERNAL_SEL     When set, send MIIM transaction on Internal MDIO bus.Otherwise, send on External MDIO bus.
 *     MIIM_CYCLE       This field is used to select which type of MIIM cycle to run.Normally, it should just be set to 000.    000: Automatically runs the proper read or write cycle based         on the ports' protocol preference, and whether a read         or write cycle was requested.  If the port is clause 45         enabled, then the read or write will be preceeded by         an address cycle.    001: requests a clause 22 write cycle;         use MIIM_WR_REG_EN control    010: requests a clause 22 read cycle;         use MIIM_RD_REG_EN control    100: requests a clause 45 address cycle;         use MIIM_WR_REG_EN control    101: requests a clause 45 write cycle;         use MIIM_WR_REG_EN control    110: requests a clause 45 read cycle w/addr increment;         use MIIM_RD_REG_EN control    111: requests a clause 45 read cycle;         use MIIM_RD_REG_EN control
 */
#define CMIC_CMC0_MIIM_PARAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_MIIM_PARAM.
 */
typedef union CMIC_CMC0_MIIM_PARAMr_s {
	uint32 v[1];
	uint32 cmic_cmc0_miim_param[1];
	uint32 _cmic_cmc0_miim_param;
} CMIC_CMC0_MIIM_PARAMr_t;

#define CMIC_CMC0_MIIM_PARAMr_CLR(r) (r).cmic_cmc0_miim_param[0] = 0
#define CMIC_CMC0_MIIM_PARAMr_SET(r,d) (r).cmic_cmc0_miim_param[0] = d
#define CMIC_CMC0_MIIM_PARAMr_GET(r) (r).cmic_cmc0_miim_param[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_MIIM_PARAMr_PHY_DATAf_GET(r) (((r).cmic_cmc0_miim_param[0]) & 0xffff)
#define CMIC_CMC0_MIIM_PARAMr_PHY_DATAf_SET(r,f) (r).cmic_cmc0_miim_param[0]=(((r).cmic_cmc0_miim_param[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CMIC_CMC0_MIIM_PARAMr_PHY_IDf_GET(r) ((((r).cmic_cmc0_miim_param[0]) >> 16) & 0x1f)
#define CMIC_CMC0_MIIM_PARAMr_PHY_IDf_SET(r,f) (r).cmic_cmc0_miim_param[0]=(((r).cmic_cmc0_miim_param[0] & ~((uint32)0x1f << 16)) | ((((uint32)f) & 0x1f) << 16))
#define CMIC_CMC0_MIIM_PARAMr_C45_SELf_GET(r) ((((r).cmic_cmc0_miim_param[0]) >> 21) & 0x1)
#define CMIC_CMC0_MIIM_PARAMr_C45_SELf_SET(r,f) (r).cmic_cmc0_miim_param[0]=(((r).cmic_cmc0_miim_param[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_CMC0_MIIM_PARAMr_BUS_IDf_GET(r) ((((r).cmic_cmc0_miim_param[0]) >> 22) & 0x7)
#define CMIC_CMC0_MIIM_PARAMr_BUS_IDf_SET(r,f) (r).cmic_cmc0_miim_param[0]=(((r).cmic_cmc0_miim_param[0] & ~((uint32)0x7 << 22)) | ((((uint32)f) & 0x7) << 22))
#define CMIC_CMC0_MIIM_PARAMr_INTERNAL_SELf_GET(r) ((((r).cmic_cmc0_miim_param[0]) >> 25) & 0x1)
#define CMIC_CMC0_MIIM_PARAMr_INTERNAL_SELf_SET(r,f) (r).cmic_cmc0_miim_param[0]=(((r).cmic_cmc0_miim_param[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define CMIC_CMC0_MIIM_PARAMr_MIIM_CYCLEf_GET(r) ((((r).cmic_cmc0_miim_param[0]) >> 29) & 0x7)
#define CMIC_CMC0_MIIM_PARAMr_MIIM_CYCLEf_SET(r,f) (r).cmic_cmc0_miim_param[0]=(((r).cmic_cmc0_miim_param[0] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_CMC0_MIIM_PARAM.
 */
#define READ_CMIC_CMC0_MIIM_PARAMr(u,r) bcm5354x_read32(u, CMIC_CMC0_MIIM_PARAM, &(r._cmic_cmc0_miim_param))
#define WRITE_CMIC_CMC0_MIIM_PARAMr(u,r) bcm5354x_write32(u, CMIC_CMC0_MIIM_PARAM, (r._cmic_cmc0_miim_param))

/*******************************************************************************
 * End of 'CMIC_CMC0_MIIM_PARAMr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_MIIM_READ_DATA
 * BLOCKS:   CMIC
 * DESC:     MIIM Read Data Register
 * SIZE:     32
 * FIELDS:
 *     DATA             MIIM Read Data Register
 */
#define CMIC_CMC0_MIIM_READ_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_MIIM_READ_DATA.
 */
typedef union CMIC_CMC0_MIIM_READ_DATAr_s {
	uint32 v[1];
	uint32 cmic_cmc0_miim_read_data[1];
	uint32 _cmic_cmc0_miim_read_data;
} CMIC_CMC0_MIIM_READ_DATAr_t;

#define CMIC_CMC0_MIIM_READ_DATAr_CLR(r) (r).cmic_cmc0_miim_read_data[0] = 0
#define CMIC_CMC0_MIIM_READ_DATAr_SET(r,d) (r).cmic_cmc0_miim_read_data[0] = d
#define CMIC_CMC0_MIIM_READ_DATAr_GET(r) (r).cmic_cmc0_miim_read_data[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_MIIM_READ_DATAr_DATAf_GET(r) (((r).cmic_cmc0_miim_read_data[0]) & 0xffff)
#define CMIC_CMC0_MIIM_READ_DATAr_DATAf_SET(r,f) (r).cmic_cmc0_miim_read_data[0]=(((r).cmic_cmc0_miim_read_data[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access CMIC_CMC0_MIIM_READ_DATA.
 */
#define READ_CMIC_CMC0_MIIM_READ_DATAr(u,r) bcm5354x_read32(u, CMIC_CMC0_MIIM_READ_DATA, &(r._cmic_cmc0_miim_read_data))
#define WRITE_CMIC_CMC0_MIIM_READ_DATAr(u,r) bcm5354x_write32(u, CMIC_CMC0_MIIM_READ_DATA, (r._cmic_cmc0_miim_read_data))

/*******************************************************************************
 * End of 'CMIC_CMC0_MIIM_READ_DATAr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_MIIM_STAT
 * BLOCKS:   CMIC
 * DESC:     register to enable MIIM read and Writes.

 * SIZE:     32
 * FIELDS:
 *     MIIM_OPN_DONE    MIIM read operation is complete. This bit will be cleared if MIIM_RD/WR_START are disabled.
 */
#define CMIC_CMC0_MIIM_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_MIIM_STAT.
 */
typedef union CMIC_CMC0_MIIM_STATr_s {
	uint32 v[1];
	uint32 cmic_cmc0_miim_stat[1];
	uint32 _cmic_cmc0_miim_stat;
} CMIC_CMC0_MIIM_STATr_t;

#define CMIC_CMC0_MIIM_STATr_CLR(r) (r).cmic_cmc0_miim_stat[0] = 0
#define CMIC_CMC0_MIIM_STATr_SET(r,d) (r).cmic_cmc0_miim_stat[0] = d
#define CMIC_CMC0_MIIM_STATr_GET(r) (r).cmic_cmc0_miim_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_MIIM_STATr_MIIM_OPN_DONEf_GET(r) (((r).cmic_cmc0_miim_stat[0]) & 0x1)
#define CMIC_CMC0_MIIM_STATr_MIIM_OPN_DONEf_SET(r,f) (r).cmic_cmc0_miim_stat[0]=(((r).cmic_cmc0_miim_stat[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_CMC0_MIIM_STAT.
 */
#define READ_CMIC_CMC0_MIIM_STATr(u,r) bcm5354x_read32(u, CMIC_CMC0_MIIM_STAT, &(r._cmic_cmc0_miim_stat))
#define WRITE_CMIC_CMC0_MIIM_STATr(u,r) bcm5354x_write32(u, CMIC_CMC0_MIIM_STAT, (r._cmic_cmc0_miim_stat))

/*******************************************************************************
 * End of 'CMIC_CMC0_MIIM_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNT
 * BLOCKS:   CMIC
 * DESC:     Debug register that provides the number of data
beats in the last SW PIO S-bus ACK

 * SIZE:     32
 * FIELDS:
 *     BEAT_COUNT       Beat count
 *     RESERVED_0       Reserved
 */
#define CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNT.
 */
typedef union CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr_s {
	uint32 v[1];
	uint32 cmic_cmc0_schan_ack_data_beat_count[1];
	uint32 _cmic_cmc0_schan_ack_data_beat_count;
} CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr_t;

#define CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr_CLR(r) (r).cmic_cmc0_schan_ack_data_beat_count[0] = 0
#define CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr_SET(r,d) (r).cmic_cmc0_schan_ack_data_beat_count[0] = d
#define CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr_GET(r) (r).cmic_cmc0_schan_ack_data_beat_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET(r) (((r).cmic_cmc0_schan_ack_data_beat_count[0]) & 0x1f)
#define CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET(r,f) (r).cmic_cmc0_schan_ack_data_beat_count[0]=(((r).cmic_cmc0_schan_ack_data_beat_count[0] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))
#define CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET(r) ((((r).cmic_cmc0_schan_ack_data_beat_count[0]) >> 5) & 0x7ffffff)
#define CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET(r,f) (r).cmic_cmc0_schan_ack_data_beat_count[0]=(((r).cmic_cmc0_schan_ack_data_beat_count[0] & ~((uint32)0x7ffffff << 5)) | ((((uint32)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNT.
 */
#define READ_CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr(u,r) bcm5354x_read32(u, CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNT, &(r._cmic_cmc0_schan_ack_data_beat_count))
#define WRITE_CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr(u,r) bcm5354x_write32(u, CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNT, (r._cmic_cmc0_schan_ack_data_beat_count))

/*******************************************************************************
 * End of 'CMIC_CMC0_SCHAN_ACK_DATA_BEAT_COUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_SCHAN_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     MSG_START        Set by SW to start an SCH operation. Cleared by HW.
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion. When SW clears this bit, the status bits TIMEOUT, NACK and SER_CHECK_FAILED arecleared.
 *     ABORT            Set by SW to ABORT ongoing SCHAN Operation. SCHAN operation can be aborted only if SBus grant has not ben received. Once grant isreceived, the entire message should be sent and complete ack received. 
 *     SER_CHECK_FAIL   Set by CMIC to indicate last S-bus operation resulted in a SER Parity Check errorClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     SCHAN_ERROR      Set by CMIC to indicate last S-bus operation resulted in an errorThe following could be the cause of error:1) Transaction was aborted by software2) Transaction timed out3) A NACK was received4) SER error was received5) Message error was received6) Opcode was not properClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 */
#define CMIC_CMC0_SCHAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_SCHAN_CTRL.
 */
typedef union CMIC_CMC0_SCHAN_CTRLr_s {
	uint32 v[1];
	uint32 cmic_cmc0_schan_ctrl[1];
	uint32 _cmic_cmc0_schan_ctrl;
} CMIC_CMC0_SCHAN_CTRLr_t;

#define CMIC_CMC0_SCHAN_CTRLr_CLR(r) (r).cmic_cmc0_schan_ctrl[0] = 0
#define CMIC_CMC0_SCHAN_CTRLr_SET(r,d) (r).cmic_cmc0_schan_ctrl[0] = d
#define CMIC_CMC0_SCHAN_CTRLr_GET(r) (r).cmic_cmc0_schan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_SCHAN_CTRLr_MSG_STARTf_GET(r) (((r).cmic_cmc0_schan_ctrl[0]) & 0x1)
#define CMIC_CMC0_SCHAN_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_cmc0_schan_ctrl[0]=(((r).cmic_cmc0_schan_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC0_SCHAN_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_cmc0_schan_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC0_SCHAN_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_cmc0_schan_ctrl[0]=(((r).cmic_cmc0_schan_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC0_SCHAN_CTRLr_ABORTf_GET(r) ((((r).cmic_cmc0_schan_ctrl[0]) >> 2) & 0x1)
#define CMIC_CMC0_SCHAN_CTRLr_ABORTf_SET(r,f) (r).cmic_cmc0_schan_ctrl[0]=(((r).cmic_cmc0_schan_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC0_SCHAN_CTRLr_SER_CHECK_FAILf_GET(r) ((((r).cmic_cmc0_schan_ctrl[0]) >> 20) & 0x1)
#define CMIC_CMC0_SCHAN_CTRLr_SER_CHECK_FAILf_SET(r,f) (r).cmic_cmc0_schan_ctrl[0]=(((r).cmic_cmc0_schan_ctrl[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define CMIC_CMC0_SCHAN_CTRLr_NACKf_GET(r) ((((r).cmic_cmc0_schan_ctrl[0]) >> 21) & 0x1)
#define CMIC_CMC0_SCHAN_CTRLr_NACKf_SET(r,f) (r).cmic_cmc0_schan_ctrl[0]=(((r).cmic_cmc0_schan_ctrl[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_CMC0_SCHAN_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_cmc0_schan_ctrl[0]) >> 22) & 0x1)
#define CMIC_CMC0_SCHAN_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_cmc0_schan_ctrl[0]=(((r).cmic_cmc0_schan_ctrl[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CMIC_CMC0_SCHAN_CTRLr_SCHAN_ERRORf_GET(r) ((((r).cmic_cmc0_schan_ctrl[0]) >> 23) & 0x1)
#define CMIC_CMC0_SCHAN_CTRLr_SCHAN_ERRORf_SET(r,f) (r).cmic_cmc0_schan_ctrl[0]=(((r).cmic_cmc0_schan_ctrl[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))

/*
 * These macros can be used to access CMIC_CMC0_SCHAN_CTRL.
 */
#define READ_CMIC_CMC0_SCHAN_CTRLr(u,r) bcm5354x_read32(u, CMIC_CMC0_SCHAN_CTRL, &(r._cmic_cmc0_schan_ctrl))
#define WRITE_CMIC_CMC0_SCHAN_CTRLr(u,r) bcm5354x_write32(u, CMIC_CMC0_SCHAN_CTRL, (r._cmic_cmc0_schan_ctrl))

/*******************************************************************************
 * End of 'CMIC_CMC0_SCHAN_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_SCHAN_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 */
#define CMIC_CMC0_SCHAN_ERRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_SCHAN_ERR.
 */
typedef union CMIC_CMC0_SCHAN_ERRr_s {
	uint32 v[1];
	uint32 cmic_cmc0_schan_err[1];
	uint32 _cmic_cmc0_schan_err;
} CMIC_CMC0_SCHAN_ERRr_t;

#define CMIC_CMC0_SCHAN_ERRr_CLR(r) (r).cmic_cmc0_schan_err[0] = 0
#define CMIC_CMC0_SCHAN_ERRr_SET(r,d) (r).cmic_cmc0_schan_err[0] = d
#define CMIC_CMC0_SCHAN_ERRr_GET(r) (r).cmic_cmc0_schan_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_SCHAN_ERRr_NACKf_GET(r) (((r).cmic_cmc0_schan_err[0]) & 0x1)
#define CMIC_CMC0_SCHAN_ERRr_NACKf_SET(r,f) (r).cmic_cmc0_schan_err[0]=(((r).cmic_cmc0_schan_err[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC0_SCHAN_ERRr_ERR_CODEf_GET(r) ((((r).cmic_cmc0_schan_err[0]) >> 4) & 0x3)
#define CMIC_CMC0_SCHAN_ERRr_ERR_CODEf_SET(r,f) (r).cmic_cmc0_schan_err[0]=(((r).cmic_cmc0_schan_err[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define CMIC_CMC0_SCHAN_ERRr_ERRBITf_GET(r) ((((r).cmic_cmc0_schan_err[0]) >> 6) & 0x1)
#define CMIC_CMC0_SCHAN_ERRr_ERRBITf_SET(r,f) (r).cmic_cmc0_schan_err[0]=(((r).cmic_cmc0_schan_err[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC0_SCHAN_ERRr_DATA_LENf_GET(r) ((((r).cmic_cmc0_schan_err[0]) >> 7) & 0x7f)
#define CMIC_CMC0_SCHAN_ERRr_DATA_LENf_SET(r,f) (r).cmic_cmc0_schan_err[0]=(((r).cmic_cmc0_schan_err[0] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define CMIC_CMC0_SCHAN_ERRr_SRC_PORTf_GET(r) ((((r).cmic_cmc0_schan_err[0]) >> 14) & 0x3f)
#define CMIC_CMC0_SCHAN_ERRr_SRC_PORTf_SET(r,f) (r).cmic_cmc0_schan_err[0]=(((r).cmic_cmc0_schan_err[0] & ~((uint32)0x3f << 14)) | ((((uint32)f) & 0x3f) << 14))
#define CMIC_CMC0_SCHAN_ERRr_DST_PORTf_GET(r) ((((r).cmic_cmc0_schan_err[0]) >> 20) & 0x3f)
#define CMIC_CMC0_SCHAN_ERRr_DST_PORTf_SET(r,f) (r).cmic_cmc0_schan_err[0]=(((r).cmic_cmc0_schan_err[0] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define CMIC_CMC0_SCHAN_ERRr_OP_CODEf_GET(r) ((((r).cmic_cmc0_schan_err[0]) >> 26) & 0x3f)
#define CMIC_CMC0_SCHAN_ERRr_OP_CODEf_SET(r,f) (r).cmic_cmc0_schan_err[0]=(((r).cmic_cmc0_schan_err[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_CMC0_SCHAN_ERR.
 */
#define READ_CMIC_CMC0_SCHAN_ERRr(u,r) bcm5354x_read32(u, CMIC_CMC0_SCHAN_ERR, &(r._cmic_cmc0_schan_err))
#define WRITE_CMIC_CMC0_SCHAN_ERRr(u,r) bcm5354x_write32(u, CMIC_CMC0_SCHAN_ERR, (r._cmic_cmc0_schan_err))

/*******************************************************************************
 * End of 'CMIC_CMC0_SCHAN_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC0_SCHAN_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 */
#define CMIC_CMC0_SCHAN_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC0_SCHAN_MESSAGE.
 */
typedef union CMIC_CMC0_SCHAN_MESSAGEr_s {
	uint32 v[1];
	uint32 cmic_cmc0_schan_message[1];
	uint32 _cmic_cmc0_schan_message;
} CMIC_CMC0_SCHAN_MESSAGEr_t;

#define CMIC_CMC0_SCHAN_MESSAGEr_CLR(r) (r).cmic_cmc0_schan_message[0] = 0
#define CMIC_CMC0_SCHAN_MESSAGEr_SET(r,d) (r).cmic_cmc0_schan_message[0] = d
#define CMIC_CMC0_SCHAN_MESSAGEr_GET(r) (r).cmic_cmc0_schan_message[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC0_SCHAN_MESSAGEr_DATAf_GET(r) ((r).cmic_cmc0_schan_message[0])
#define CMIC_CMC0_SCHAN_MESSAGEr_DATAf_SET(r,f) (r).cmic_cmc0_schan_message[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_CMC0_SCHAN_MESSAGE.
 */
#define READ_CMIC_CMC0_SCHAN_MESSAGEr(u,i,r) bcm5354x_read32(u, CMIC_CMC0_SCHAN_MESSAGE(i), &(r._cmic_cmc0_schan_message))
#define WRITE_CMIC_CMC0_SCHAN_MESSAGEr(u,i,r) bcm5354x_write32(u, CMIC_CMC0_SCHAN_MESSAGE(i), (r._cmic_cmc0_schan_message))

/*******************************************************************************
 * End of 'CMIC_CMC0_SCHAN_MESSAGEr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_CHx_DMA_CTRL
 * BLOCKS:   CMIC
 * DESC:     DMA Control Register
 * SIZE:     32
 * FIELDS:
 *     DIRECTION        DMA channel 0 direction:1=Mem->SOC, 0=SOC->Mem
 *     DMA_EN           Set by CPU to start a DMA on CH0 
 *     ABORT_DMA        DMA channel 0 abort
 *     SEL_INTR_ON_DESC_OR_PKT DMA channel 0 interrupt select:1=after descriptor, 0=after packet
 *     PKTDMA_ENDIANESS (Bit 1) 0 = 1 = big word order for Packet DMA operations
 *     DESC_ENDIANESS   (Bit 1) 0 = 1 = big word order for Descriptor operations
 *     DROP_RX_PKT_ON_CHAIN_END DMA channel 0 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     RLD_STS_UPD_DIS  When set, do not update status fields on reload operation.
 *     DESC_DONE_INTR_MODE 1'b0: Descriptor Done interrupt will be raised after completions of every descriptor.1'b1: Descriptor Done interrupt will be raised only when descriptor.INT bit is set in the descriptor. In both casses, interrupt should be cleared by SW.
 *     ENABLE_CONTINUOUS_DMA When set, continuous DMA is enabled. CH_IN_HALT interrupt will be genrated only when this mode is enabled. 
 */
#define CMIC_CMC_CHX_DMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_CHx_DMA_CTRL.
 */
typedef union CMIC_CMC_CHX_DMA_CTRLr_s {
	uint32 v[1];
	uint32 cmic_cmc_chx_dma_ctrl[1];
	uint32 _cmic_cmc_chx_dma_ctrl;
} CMIC_CMC_CHX_DMA_CTRLr_t;

#define CMIC_CMC_CHX_DMA_CTRLr_CLR(r) (r).cmic_cmc_chx_dma_ctrl[0] = 0
#define CMIC_CMC_CHX_DMA_CTRLr_SET(r,d) (r).cmic_cmc_chx_dma_ctrl[0] = d
#define CMIC_CMC_CHX_DMA_CTRLr_GET(r) (r).cmic_cmc_chx_dma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_CHX_DMA_CTRLr_DIRECTIONf_GET(r) (((r).cmic_cmc_chx_dma_ctrl[0]) & 0x1)
#define CMIC_CMC_CHX_DMA_CTRLr_DIRECTIONf_SET(r,f) (r).cmic_cmc_chx_dma_ctrl[0]=(((r).cmic_cmc_chx_dma_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC_CHX_DMA_CTRLr_DMA_ENf_GET(r) ((((r).cmic_cmc_chx_dma_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC_CHX_DMA_CTRLr_DMA_ENf_SET(r,f) (r).cmic_cmc_chx_dma_ctrl[0]=(((r).cmic_cmc_chx_dma_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC_CHX_DMA_CTRLr_ABORT_DMAf_GET(r) ((((r).cmic_cmc_chx_dma_ctrl[0]) >> 2) & 0x1)
#define CMIC_CMC_CHX_DMA_CTRLr_ABORT_DMAf_SET(r,f) (r).cmic_cmc_chx_dma_ctrl[0]=(((r).cmic_cmc_chx_dma_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC_CHX_DMA_CTRLr_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_cmc_chx_dma_ctrl[0]) >> 3) & 0x1)
#define CMIC_CMC_CHX_DMA_CTRLr_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_cmc_chx_dma_ctrl[0]=(((r).cmic_cmc_chx_dma_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC_CHX_DMA_CTRLr_PKTDMA_ENDIANESSf_GET(r) ((((r).cmic_cmc_chx_dma_ctrl[0]) >> 4) & 0x1)
#define CMIC_CMC_CHX_DMA_CTRLr_PKTDMA_ENDIANESSf_SET(r,f) (r).cmic_cmc_chx_dma_ctrl[0]=(((r).cmic_cmc_chx_dma_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC_CHX_DMA_CTRLr_DESC_ENDIANESSf_GET(r) ((((r).cmic_cmc_chx_dma_ctrl[0]) >> 5) & 0x1)
#define CMIC_CMC_CHX_DMA_CTRLr_DESC_ENDIANESSf_SET(r,f) (r).cmic_cmc_chx_dma_ctrl[0]=(((r).cmic_cmc_chx_dma_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC_CHX_DMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_cmc_chx_dma_ctrl[0]) >> 6) & 0x1)
#define CMIC_CMC_CHX_DMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_cmc_chx_dma_ctrl[0]=(((r).cmic_cmc_chx_dma_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC_CHX_DMA_CTRLr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_cmc_chx_dma_ctrl[0]) >> 7) & 0x1)
#define CMIC_CMC_CHX_DMA_CTRLr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_cmc_chx_dma_ctrl[0]=(((r).cmic_cmc_chx_dma_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_CMC_CHX_DMA_CTRLr_DESC_DONE_INTR_MODEf_GET(r) ((((r).cmic_cmc_chx_dma_ctrl[0]) >> 8) & 0x1)
#define CMIC_CMC_CHX_DMA_CTRLr_DESC_DONE_INTR_MODEf_SET(r,f) (r).cmic_cmc_chx_dma_ctrl[0]=(((r).cmic_cmc_chx_dma_ctrl[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_CMC_CHX_DMA_CTRLr_ENABLE_CONTINUOUS_DMAf_GET(r) ((((r).cmic_cmc_chx_dma_ctrl[0]) >> 9) & 0x1)
#define CMIC_CMC_CHX_DMA_CTRLr_ENABLE_CONTINUOUS_DMAf_SET(r,f) (r).cmic_cmc_chx_dma_ctrl[0]=(((r).cmic_cmc_chx_dma_ctrl[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))

/*
 * These macros can be used to access CMIC_CMC_CHx_DMA_CTRL.
 */
#define READ_CMIC_CMC_CHX_DMA_CTRLr(u,i,r) bcm5354x_read32(u, CMIC_CMC_CHx_DMA_CTRL(i), &(r._cmic_cmc_chx_dma_ctrl))
#define WRITE_CMIC_CMC_CHX_DMA_CTRLr(u,i,r) bcm5354x_write32(u, CMIC_CMC_CHx_DMA_CTRL(i), (r._cmic_cmc_chx_dma_ctrl))

/*******************************************************************************
 * End of 'CMIC_CMC_CHX_DMA_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_DMA_CTRL
 * BLOCKS:   CMIC
 * DESC:     DMA Control Register
 * SIZE:     32
 * FIELDS:
 *     DIRECTION        DMA channel 0 direction:1=Mem->SOC, 0=SOC->Mem
 *     DMA_EN           Set by CPU to start a DMA on CH0 
 *     ABORT_DMA        DMA channel 0 abort
 *     SEL_INTR_ON_DESC_OR_PKT DMA channel 0 interrupt select:1=after descriptor, 0=after packet
 *     PKTDMA_ENDIANESS (Bit 1) 0 = 1 = big word order for Packet DMA operations
 *     DESC_ENDIANESS   (Bit 1) 0 = 1 = big word order for Descriptor operations
 *     DROP_RX_PKT_ON_CHAIN_END DMA channel 0 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     RLD_STS_UPD_DIS  When set, do not update status fields on reload operation.
 *     DESC_DONE_INTR_MODE 1'b0: Descriptor Done interrupt will be raised after completions of every descriptor.1'b1: Descriptor Done interrupt will be raised only when descriptor.INT bit is set in the descriptor. In both casses, interrupt should be cleared by SW.
 *     ENABLE_CONTINUOUS_DMA When set, continuous DMA is enabled. CH_IN_HALT interrupt will be genrated only when this mode is enabled. 
 */
#define CMIC_CMC_DMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_DMA_CTRL.
 */
typedef union CMIC_CMC_DMA_CTRLr_s {
	uint32 v[1];
	uint32 cmic_cmc_dma_ctrl[1];
	uint32 _cmic_cmc_dma_ctrl;
} CMIC_CMC_DMA_CTRLr_t;

#define CMIC_CMC_DMA_CTRLr_CLR(r) (r).cmic_cmc_dma_ctrl[0] = 0
#define CMIC_CMC_DMA_CTRLr_SET(r,d) (r).cmic_cmc_dma_ctrl[0] = d
#define CMIC_CMC_DMA_CTRLr_GET(r) (r).cmic_cmc_dma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_DMA_CTRLr_DIRECTIONf_GET(r) (((r).cmic_cmc_dma_ctrl[0]) & 0x1)
#define CMIC_CMC_DMA_CTRLr_DIRECTIONf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC_DMA_CTRLr_DMA_ENf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC_DMA_CTRLr_DMA_ENf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC_DMA_CTRLr_ABORT_DMAf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 2) & 0x1)
#define CMIC_CMC_DMA_CTRLr_ABORT_DMAf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC_DMA_CTRLr_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 3) & 0x1)
#define CMIC_CMC_DMA_CTRLr_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC_DMA_CTRLr_PKTDMA_ENDIANESSf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 4) & 0x1)
#define CMIC_CMC_DMA_CTRLr_PKTDMA_ENDIANESSf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC_DMA_CTRLr_DESC_ENDIANESSf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 5) & 0x1)
#define CMIC_CMC_DMA_CTRLr_DESC_ENDIANESSf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC_DMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 6) & 0x1)
#define CMIC_CMC_DMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC_DMA_CTRLr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 7) & 0x1)
#define CMIC_CMC_DMA_CTRLr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_CMC_DMA_CTRLr_DESC_DONE_INTR_MODEf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 8) & 0x1)
#define CMIC_CMC_DMA_CTRLr_DESC_DONE_INTR_MODEf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_CMC_DMA_CTRLr_ENABLE_CONTINUOUS_DMAf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 9) & 0x1)
#define CMIC_CMC_DMA_CTRLr_ENABLE_CONTINUOUS_DMAf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))

/*
 * These macros can be used to access CMIC_CMC_DMA_CTRL.
 */
#define READ_CMIC_CMC_DMA_CTRLr(u,i,r) bcm5354x_read32(u, CMIC_CMC_DMA_CTRL(i), &(r._cmic_cmc_dma_ctrl))
#define WRITE_CMIC_CMC_DMA_CTRLr(u,i,r) bcm5354x_write32(u, CMIC_CMC_DMA_CTRL(i), (r._cmic_cmc_dma_ctrl))

/*******************************************************************************
 * End of 'CMIC_CMC_DMA_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_DMA_DESC
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 0 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH0 DESCRIPTOR ADDRESS REGISTER
 */
#define CMIC_CMC_DMA_DESCr_SIZE 4

/* CMIC_CMC_DMA_DESCr is element of CMIC_CMC0_CH1_DMA_CTRL */

/*
 * This structure should be used to declare and program CMIC_CMC_DMA_DESC.
 */
typedef union CMIC_CMC_DMA_DESCr_s {
	uint32 v[1];
	uint32 cmic_cmc_dma_desc[1];
	uint32 _cmic_cmc_dma_desc;
} CMIC_CMC_DMA_DESCr_t;

#define CMIC_CMC_DMA_DESCr_CLR(r) (r).cmic_cmc_dma_desc[0] = 0
#define CMIC_CMC_DMA_DESCr_SET(r,d) (r).cmic_cmc_dma_desc[0] = d
#define CMIC_CMC_DMA_DESCr_GET(r) (r).cmic_cmc_dma_desc[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_DMA_DESCr_ADDRf_GET(r) ((r).cmic_cmc_dma_desc[0])
#define CMIC_CMC_DMA_DESCr_ADDRf_SET(r,f) (r).cmic_cmc_dma_desc[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_CMC_DMA_DESC.
 */
#define READ_CMIC_CMC_DMA_DESCr(u,i,r) bcm5354x_read32(u, CMIC_CMC_DMA_DESC(i), &(r._cmic_cmc_dma_desc))
#define WRITE_CMIC_CMC_DMA_DESCr(u,i,r) bcm5354x_write32(u, CMIC_CMC_DMA_DESC(i), (r._cmic_cmc_dma_desc))

/*******************************************************************************
 * End of 'CMIC_CMC_DMA_DESCr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_DMA_STAT
 * BLOCKS:   CMIC
 * DESC:     DMA Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     CH0_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH1_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH2_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH3_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH0_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH1_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH2_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH3_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH0_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH1_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH2_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH3_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH0_STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH1_STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH2_STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH3_STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH0_PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH1_PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH2_PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH3_PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH0_DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH1_DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH2_DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH3_DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH0_STWR_ECC_ERR Set by CMIC to indicate ECC error found while reading status buffer. This can be cleared by resetting ENABLE bit. 
 *     CH1_STWR_ECC_ERR Set by CMIC to indicate ECC error found while reading status buffer. This can be cleared by resetting ENABLE bit. 
 *     CH2_STWR_ECC_ERR Set by CMIC to indicate ECC error found while reading status buffer. This can be cleared by resetting ENABLE bit. 
 *     CH3_STWR_ECC_ERR Set by CMIC to indicate ECC error found while reading status buffer. This can be cleared by resetting ENABLE bit. 
 *     CH0_PKTWR_ECC_ERR Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 *     CH1_PKTWR_ECC_ERR Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 *     CH2_PKTWR_ECC_ERR Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 *     CH3_PKTWR_ECC_ERR Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 */
#define CMIC_CMC_DMA_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_DMA_STAT.
 */
typedef union CMIC_CMC_DMA_STATr_s {
	uint32 v[1];
	uint32 cmic_cmc_dma_stat[1];
	uint32 _cmic_cmc_dma_stat;
} CMIC_CMC_DMA_STATr_t;

#define CMIC_CMC_DMA_STATr_CLR(r) (r).cmic_cmc_dma_stat[0] = 0
#define CMIC_CMC_DMA_STATr_SET(r,d) (r).cmic_cmc_dma_stat[0] = d
#define CMIC_CMC_DMA_STATr_GET(r) (r).cmic_cmc_dma_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_DMA_STATr_CH0_CHAIN_DONEf_GET(r) (((r).cmic_cmc_dma_stat[0]) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC_DMA_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 1) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC_DMA_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 2) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC_DMA_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 3) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC_DMA_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 4) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC_DMA_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 5) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC_DMA_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 6) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC_DMA_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 7) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_CMC_DMA_STATr_CH0_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 8) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_CMC_DMA_STATr_CH1_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 9) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CMIC_CMC_DMA_STATr_CH2_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 10) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define CMIC_CMC_DMA_STATr_CH3_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 11) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define CMIC_CMC_DMA_STATr_CH0_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 12) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define CMIC_CMC_DMA_STATr_CH1_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 13) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define CMIC_CMC_DMA_STATr_CH2_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 14) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define CMIC_CMC_DMA_STATr_CH3_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 15) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define CMIC_CMC_DMA_STATr_CH0_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 16) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define CMIC_CMC_DMA_STATr_CH1_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 17) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define CMIC_CMC_DMA_STATr_CH2_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 18) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define CMIC_CMC_DMA_STATr_CH3_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 19) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define CMIC_CMC_DMA_STATr_CH0_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 20) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define CMIC_CMC_DMA_STATr_CH1_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 21) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_CMC_DMA_STATr_CH2_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 22) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CMIC_CMC_DMA_STATr_CH3_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 23) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define CMIC_CMC_DMA_STATr_CH0_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 24) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define CMIC_CMC_DMA_STATr_CH1_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 25) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define CMIC_CMC_DMA_STATr_CH2_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 26) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define CMIC_CMC_DMA_STATr_CH3_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 27) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define CMIC_CMC_DMA_STATr_CH0_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 28) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define CMIC_CMC_DMA_STATr_CH1_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 29) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define CMIC_CMC_DMA_STATr_CH2_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 30) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define CMIC_CMC_DMA_STATr_CH3_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 31) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_CMC_DMA_STAT.
 */
#define READ_CMIC_CMC_DMA_STATr(u,r) bcm5354x_read32(u, CMIC_CMC_DMA_STAT, &(r._cmic_cmc_dma_stat))
#define WRITE_CMIC_CMC_DMA_STATr(u,r) bcm5354x_write32(u, CMIC_CMC_DMA_STAT, (r._cmic_cmc_dma_stat))

/*******************************************************************************
 * End of 'CMIC_CMC_DMA_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_DMA_STAT_CLR
 * BLOCKS:   CMIC
 * DESC:     Desc read complete information in CMIC_CMC_DMA_STAT can be cleared using this register.


 * SIZE:     32
 * FIELDS:
 *     CH0_DESCRD_CMPLT_CLR Write 0x1 to clear ch0 descrd_cmplt in DMA_STAT register.
 *     CH1_DESCRD_CMPLT_CLR Write 0x2 to clear ch1 descrd_cmplt in DMA_STAT register.
 *     CH2_DESCRD_CMPLT_CLR Write 0x4 to clear ch2 descrd_cmplt in DMA_STAT register.
 *     CH3_DESCRD_CMPLT_CLR Write 0x8 to clear ch3 descrd_cmplt in DMA_STAT register.
 *     CH0_INTR_COALESCING_CLR Write 0x10 to clear ch0 intr_coalescing.
 *     CH1_INTR_COALESCING_CLR Write 0x20 to clear ch1 intr_coalescing.
 *     CH2_INTR_COALESCING_CLR Write 0x40 to clear ch2 intr_coalescing.
 *     CH3_INTR_COALESCING_CLR Write 0x80 to clear ch3 intr_coalescing.
 *     CH0_DESC_CONTROLLED_INTR_CLR Write 0x100 to clear CH0_DESC_CONTROLLED_INTR.
 *     CH1_DESC_CONTROLLED_INTR_CLR Write 0x200 to clear CH1_DESC_CONTROLLED_INTR.
 *     CH2_DESC_CONTROLLED_INTR_CLR Write 0x400 to clear CH2_DESC_CONTROLLED_INTR.
 *     CH3_DESC_CONTROLLED_INTR_CLR Write 0x800 to clear CH3_DESC_CONTROLLED_INTR.
 */
#define CMIC_CMC_DMA_STAT_CLRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_DMA_STAT_CLR.
 */
typedef union CMIC_CMC_DMA_STAT_CLRr_s {
	uint32 v[1];
	uint32 cmic_cmc_dma_stat_clr[1];
	uint32 _cmic_cmc_dma_stat_clr;
} CMIC_CMC_DMA_STAT_CLRr_t;

#define CMIC_CMC_DMA_STAT_CLRr_CLR(r) (r).cmic_cmc_dma_stat_clr[0] = 0
#define CMIC_CMC_DMA_STAT_CLRr_SET(r,d) (r).cmic_cmc_dma_stat_clr[0] = d
#define CMIC_CMC_DMA_STAT_CLRr_GET(r) (r).cmic_cmc_dma_stat_clr[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_DMA_STAT_CLRr_CH0_DESCRD_CMPLT_CLRf_GET(r) (((r).cmic_cmc_dma_stat_clr[0]) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH0_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC_DMA_STAT_CLRr_CH1_DESCRD_CMPLT_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 1) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH1_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC_DMA_STAT_CLRr_CH2_DESCRD_CMPLT_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 2) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH2_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC_DMA_STAT_CLRr_CH3_DESCRD_CMPLT_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 3) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH3_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_CMC_DMA_STAT_CLRr_CH0_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 4) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH0_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define CMIC_CMC_DMA_STAT_CLRr_CH1_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 5) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH1_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define CMIC_CMC_DMA_STAT_CLRr_CH2_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 6) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH2_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC_DMA_STAT_CLRr_CH3_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 7) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH3_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CMIC_CMC_DMA_STAT_CLRr_CH0_DESC_CONTROLLED_INTR_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 8) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH0_DESC_CONTROLLED_INTR_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CMIC_CMC_DMA_STAT_CLRr_CH1_DESC_CONTROLLED_INTR_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 9) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH1_DESC_CONTROLLED_INTR_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CMIC_CMC_DMA_STAT_CLRr_CH2_DESC_CONTROLLED_INTR_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 10) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH2_DESC_CONTROLLED_INTR_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define CMIC_CMC_DMA_STAT_CLRr_CH3_DESC_CONTROLLED_INTR_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 11) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH3_DESC_CONTROLLED_INTR_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))

/*
 * These macros can be used to access CMIC_CMC_DMA_STAT_CLR.
 */
#define READ_CMIC_CMC_DMA_STAT_CLRr(u,r) bcm5354x_read32(u, CMIC_CMC_DMA_STAT_CLR, &(r._cmic_cmc_dma_stat_clr))
#define WRITE_CMIC_CMC_DMA_STAT_CLRr(u,r) bcm5354x_write32(u, CMIC_CMC_DMA_STAT_CLR, (r._cmic_cmc_dma_stat_clr))

/*******************************************************************************
 * End of 'CMIC_CMC_DMA_STAT_CLRr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_HOSTMEM_ADDR_REMAP
 * BLOCKS:   CMIC
 * DESC:     Memory mapping using [31:28] of programmed host mem address.
 * SIZE:     32
 * FIELDS:
 *     ADDR_0           Remapped address when HOSTMEM_ADDR[31:28] == 0.
 *     ADDR_1           Remapped address when HOSTMEM_ADDR[31:28] == 1.
 *     ADDR_2           Remapped address when HOSTMEM_ADDR[31:28] == 2.
 *     ADDR_3           Remapped address when HOSTMEM_ADDR[31:28] == 3. 
 *     ADDR_4           Remapped address when HOSTMEM_ADDR[31:28] == 4.
 */
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_HOSTMEM_ADDR_REMAP.
 */
typedef union CMIC_CMC_HOSTMEM_ADDR_REMAPr_s {
	uint32 v[1];
	uint32 cmic_cmc_hostmem_addr_remap[1];
	uint32 _cmic_cmc_hostmem_addr_remap;
} CMIC_CMC_HOSTMEM_ADDR_REMAPr_t;

#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_CLR(r) (r).cmic_cmc_hostmem_addr_remap[0] = 0
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_SET(r,d) (r).cmic_cmc_hostmem_addr_remap[0] = d
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_GET(r) (r).cmic_cmc_hostmem_addr_remap[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_ADDR_0f_GET(r) (((r).cmic_cmc_hostmem_addr_remap[0]) & 0x3f)
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_ADDR_0f_SET(r,f) (r).cmic_cmc_hostmem_addr_remap[0]=(((r).cmic_cmc_hostmem_addr_remap[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_ADDR_1f_GET(r) ((((r).cmic_cmc_hostmem_addr_remap[0]) >> 6) & 0x3f)
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_ADDR_1f_SET(r,f) (r).cmic_cmc_hostmem_addr_remap[0]=(((r).cmic_cmc_hostmem_addr_remap[0] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_ADDR_2f_GET(r) ((((r).cmic_cmc_hostmem_addr_remap[0]) >> 12) & 0x3f)
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_ADDR_2f_SET(r,f) (r).cmic_cmc_hostmem_addr_remap[0]=(((r).cmic_cmc_hostmem_addr_remap[0] & ~((uint32)0x3f << 12)) | ((((uint32)f) & 0x3f) << 12))
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_ADDR_3f_GET(r) ((((r).cmic_cmc_hostmem_addr_remap[0]) >> 18) & 0x3f)
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_ADDR_3f_SET(r,f) (r).cmic_cmc_hostmem_addr_remap[0]=(((r).cmic_cmc_hostmem_addr_remap[0] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_ADDR_4f_GET(r) ((((r).cmic_cmc_hostmem_addr_remap[0]) >> 24) & 0x3f)
#define CMIC_CMC_HOSTMEM_ADDR_REMAPr_ADDR_4f_SET(r,f) (r).cmic_cmc_hostmem_addr_remap[0]=(((r).cmic_cmc_hostmem_addr_remap[0] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_CMC_HOSTMEM_ADDR_REMAP.
 */
#define READ_CMIC_CMC_HOSTMEM_ADDR_REMAPr(u,i,r) bcm5354x_read32(u, CMIC_CMC_HOSTMEM_ADDR_REMAP(i), &(r._cmic_cmc_hostmem_addr_remap))
#define WRITE_CMIC_CMC_HOSTMEM_ADDR_REMAPr(u,i,r) bcm5354x_write32(u, CMIC_CMC_HOSTMEM_ADDR_REMAP(i), (r._cmic_cmc_hostmem_addr_remap))

/*******************************************************************************
 * End of 'CMIC_CMC_HOSTMEM_ADDR_REMAPr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_MIIM_ADDRESS
 * BLOCKS:   CMIC
 * DESC:     Supplies the register address of MIIM reads and writes.
For clause 22 devices, bits [4:0] supply the REGAD.
For clause 45 devices, bits [20:16] supply the DTYPE,
                   and bits [15: 0] supply the reg address

 * SIZE:     32
 * FIELDS:
 *     CLAUSE_45_REGADR Register address for associated read or writeClause 45: Address = bits[15:0]Clause 22: Address = bits[4:0]
 *     CLAUSE_45_DTYPE  Block-within-PHY address for associated read or write
 */
#define CMIC_CMC_MIIM_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_MIIM_ADDRESS.
 */
typedef union CMIC_CMC_MIIM_ADDRESSr_s {
	uint32 v[1];
	uint32 cmic_cmc_miim_address[1];
	uint32 _cmic_cmc_miim_address;
} CMIC_CMC_MIIM_ADDRESSr_t;

#define CMIC_CMC_MIIM_ADDRESSr_CLR(r) (r).cmic_cmc_miim_address[0] = 0
#define CMIC_CMC_MIIM_ADDRESSr_SET(r,d) (r).cmic_cmc_miim_address[0] = d
#define CMIC_CMC_MIIM_ADDRESSr_GET(r) (r).cmic_cmc_miim_address[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET(r) (((r).cmic_cmc_miim_address[0]) & 0xffff)
#define CMIC_CMC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET(r,f) (r).cmic_cmc_miim_address[0]=(((r).cmic_cmc_miim_address[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CMIC_CMC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET(r) ((((r).cmic_cmc_miim_address[0]) >> 16) & 0x1f)
#define CMIC_CMC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET(r,f) (r).cmic_cmc_miim_address[0]=(((r).cmic_cmc_miim_address[0] & ~((uint32)0x1f << 16)) | ((((uint32)f) & 0x1f) << 16))

/*
 * These macros can be used to access CMIC_CMC_MIIM_ADDRESS.
 */
#define READ_CMIC_CMC_MIIM_ADDRESSr(u,r) bcm5354x_read32(u, CMIC_CMC_MIIM_ADDRESS, &(r._cmic_cmc_miim_address))
#define WRITE_CMIC_CMC_MIIM_ADDRESSr(u,r) bcm5354x_write32(u, CMIC_CMC_MIIM_ADDRESS, (r._cmic_cmc_miim_address))

/*******************************************************************************
 * End of 'CMIC_CMC_MIIM_ADDRESSr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_MIIM_CTRL
 * BLOCKS:   CMIC
 * DESC:     register to enable MIIM read and Writes.

 * SIZE:     32
 * FIELDS:
 *     MIIM_WR_START    Set this bit to initiate MDIO read operation. This bit needs to be cleared to reset MDIO COMPLETE bit
 *     MIIM_RD_START    Set this bit to initiate MDIO read operation. This bit needs to be cleared to reset MDIO COMPLETE bit
 */
#define CMIC_CMC_MIIM_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_MIIM_CTRL.
 */
typedef union CMIC_CMC_MIIM_CTRLr_s {
	uint32 v[1];
	uint32 cmic_cmc_miim_ctrl[1];
	uint32 _cmic_cmc_miim_ctrl;
} CMIC_CMC_MIIM_CTRLr_t;

#define CMIC_CMC_MIIM_CTRLr_CLR(r) (r).cmic_cmc_miim_ctrl[0] = 0
#define CMIC_CMC_MIIM_CTRLr_SET(r,d) (r).cmic_cmc_miim_ctrl[0] = d
#define CMIC_CMC_MIIM_CTRLr_GET(r) (r).cmic_cmc_miim_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_MIIM_CTRLr_MIIM_WR_STARTf_GET(r) (((r).cmic_cmc_miim_ctrl[0]) & 0x1)
#define CMIC_CMC_MIIM_CTRLr_MIIM_WR_STARTf_SET(r,f) (r).cmic_cmc_miim_ctrl[0]=(((r).cmic_cmc_miim_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC_MIIM_CTRLr_MIIM_RD_STARTf_GET(r) ((((r).cmic_cmc_miim_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC_MIIM_CTRLr_MIIM_RD_STARTf_SET(r,f) (r).cmic_cmc_miim_ctrl[0]=(((r).cmic_cmc_miim_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access CMIC_CMC_MIIM_CTRL.
 */
#define READ_CMIC_CMC_MIIM_CTRLr(u,r) bcm5354x_read32(u, CMIC_CMC_MIIM_CTRL, &(r._cmic_cmc_miim_ctrl))
#define WRITE_CMIC_CMC_MIIM_CTRLr(u,r) bcm5354x_write32(u, CMIC_CMC_MIIM_CTRL, (r._cmic_cmc_miim_ctrl))

/*******************************************************************************
 * End of 'CMIC_CMC_MIIM_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_MIIM_PARAM
 * BLOCKS:   CMIC
 * DESC:     MIIM Parameter Register
 * SIZE:     32
 * FIELDS:
 *     PHY_DATA         PHY register data
 *     PHY_ID           Port number (Phy ID is looked up from port number)
 *     C45_SEL          When set, send MIIM transaction using Clause 45.Otherwise, send as Clause 22 transaction.
 *     BUS_ID           Select MIIM Bus number from  6 of available MIIM busses.
 *     INTERNAL_SEL     When set, send MIIM transaction on Internal MDIO bus.Otherwise, send on External MDIO bus.
 *     MIIM_CYCLE       This field is used to select which type of MIIM cycle to run.Normally, it should just be set to 000.    000: Automatically runs the proper read or write cycle based         on the ports' protocol preference, and whether a read         or write cycle was requested.  If the port is clause 45         enabled, then the read or write will be preceeded by         an address cycle.    001: requests a clause 22 write cycle;         use MIIM_WR_REG_EN control    010: requests a clause 22 read cycle;         use MIIM_RD_REG_EN control    100: requests a clause 45 address cycle;         use MIIM_WR_REG_EN control    101: requests a clause 45 write cycle;         use MIIM_WR_REG_EN control    110: requests a clause 45 read cycle w/addr increment;         use MIIM_RD_REG_EN control    111: requests a clause 45 read cycle;         use MIIM_RD_REG_EN control
 */
#define CMIC_CMC_MIIM_PARAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_MIIM_PARAM.
 */
typedef union CMIC_CMC_MIIM_PARAMr_s {
	uint32 v[1];
	uint32 cmic_cmc_miim_param[1];
	uint32 _cmic_cmc_miim_param;
} CMIC_CMC_MIIM_PARAMr_t;

#define CMIC_CMC_MIIM_PARAMr_CLR(r) (r).cmic_cmc_miim_param[0] = 0
#define CMIC_CMC_MIIM_PARAMr_SET(r,d) (r).cmic_cmc_miim_param[0] = d
#define CMIC_CMC_MIIM_PARAMr_GET(r) (r).cmic_cmc_miim_param[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_MIIM_PARAMr_PHY_DATAf_GET(r) (((r).cmic_cmc_miim_param[0]) & 0xffff)
#define CMIC_CMC_MIIM_PARAMr_PHY_DATAf_SET(r,f) (r).cmic_cmc_miim_param[0]=(((r).cmic_cmc_miim_param[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CMIC_CMC_MIIM_PARAMr_PHY_IDf_GET(r) ((((r).cmic_cmc_miim_param[0]) >> 16) & 0x1f)
#define CMIC_CMC_MIIM_PARAMr_PHY_IDf_SET(r,f) (r).cmic_cmc_miim_param[0]=(((r).cmic_cmc_miim_param[0] & ~((uint32)0x1f << 16)) | ((((uint32)f) & 0x1f) << 16))
#define CMIC_CMC_MIIM_PARAMr_C45_SELf_GET(r) ((((r).cmic_cmc_miim_param[0]) >> 21) & 0x1)
#define CMIC_CMC_MIIM_PARAMr_C45_SELf_SET(r,f) (r).cmic_cmc_miim_param[0]=(((r).cmic_cmc_miim_param[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_CMC_MIIM_PARAMr_BUS_IDf_GET(r) ((((r).cmic_cmc_miim_param[0]) >> 22) & 0x7)
#define CMIC_CMC_MIIM_PARAMr_BUS_IDf_SET(r,f) (r).cmic_cmc_miim_param[0]=(((r).cmic_cmc_miim_param[0] & ~((uint32)0x7 << 22)) | ((((uint32)f) & 0x7) << 22))
#define CMIC_CMC_MIIM_PARAMr_INTERNAL_SELf_GET(r) ((((r).cmic_cmc_miim_param[0]) >> 25) & 0x1)
#define CMIC_CMC_MIIM_PARAMr_INTERNAL_SELf_SET(r,f) (r).cmic_cmc_miim_param[0]=(((r).cmic_cmc_miim_param[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define CMIC_CMC_MIIM_PARAMr_MIIM_CYCLEf_GET(r) ((((r).cmic_cmc_miim_param[0]) >> 29) & 0x7)
#define CMIC_CMC_MIIM_PARAMr_MIIM_CYCLEf_SET(r,f) (r).cmic_cmc_miim_param[0]=(((r).cmic_cmc_miim_param[0] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_CMC_MIIM_PARAM.
 */
#define READ_CMIC_CMC_MIIM_PARAMr(u,r) bcm5354x_read32(u, CMIC_CMC_MIIM_PARAM, &(r._cmic_cmc_miim_param))
#define WRITE_CMIC_CMC_MIIM_PARAMr(u,r) bcm5354x_write32(u, CMIC_CMC_MIIM_PARAM, (r._cmic_cmc_miim_param))

/*******************************************************************************
 * End of 'CMIC_CMC_MIIM_PARAMr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_MIIM_READ_DATA
 * BLOCKS:   CMIC
 * DESC:     MIIM Read Data Register
 * SIZE:     32
 * FIELDS:
 *     DATA             MIIM Read Data Register
 */
#define CMIC_CMC_MIIM_READ_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_MIIM_READ_DATA.
 */
typedef union CMIC_CMC_MIIM_READ_DATAr_s {
	uint32 v[1];
	uint32 cmic_cmc_miim_read_data[1];
	uint32 _cmic_cmc_miim_read_data;
} CMIC_CMC_MIIM_READ_DATAr_t;

#define CMIC_CMC_MIIM_READ_DATAr_CLR(r) (r).cmic_cmc_miim_read_data[0] = 0
#define CMIC_CMC_MIIM_READ_DATAr_SET(r,d) (r).cmic_cmc_miim_read_data[0] = d
#define CMIC_CMC_MIIM_READ_DATAr_GET(r) (r).cmic_cmc_miim_read_data[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_MIIM_READ_DATAr_DATAf_GET(r) (((r).cmic_cmc_miim_read_data[0]) & 0xffff)
#define CMIC_CMC_MIIM_READ_DATAr_DATAf_SET(r,f) (r).cmic_cmc_miim_read_data[0]=(((r).cmic_cmc_miim_read_data[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access CMIC_CMC_MIIM_READ_DATA.
 */
#define READ_CMIC_CMC_MIIM_READ_DATAr(u,r) bcm5354x_read32(u, CMIC_CMC_MIIM_READ_DATA, &(r._cmic_cmc_miim_read_data))
#define WRITE_CMIC_CMC_MIIM_READ_DATAr(u,r) bcm5354x_write32(u, CMIC_CMC_MIIM_READ_DATA, (r._cmic_cmc_miim_read_data))

/*******************************************************************************
 * End of 'CMIC_CMC_MIIM_READ_DATAr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_MIIM_STAT
 * BLOCKS:   CMIC
 * DESC:     register to enable MIIM read and Writes.

 * SIZE:     32
 * FIELDS:
 *     MIIM_OPN_DONE    MIIM read operation is complete. This bit will be cleared if MIIM_RD/WR_START are disabled.
 */
#define CMIC_CMC_MIIM_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_MIIM_STAT.
 */
typedef union CMIC_CMC_MIIM_STATr_s {
	uint32 v[1];
	uint32 cmic_cmc_miim_stat[1];
	uint32 _cmic_cmc_miim_stat;
} CMIC_CMC_MIIM_STATr_t;

#define CMIC_CMC_MIIM_STATr_CLR(r) (r).cmic_cmc_miim_stat[0] = 0
#define CMIC_CMC_MIIM_STATr_SET(r,d) (r).cmic_cmc_miim_stat[0] = d
#define CMIC_CMC_MIIM_STATr_GET(r) (r).cmic_cmc_miim_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_MIIM_STATr_MIIM_OPN_DONEf_GET(r) (((r).cmic_cmc_miim_stat[0]) & 0x1)
#define CMIC_CMC_MIIM_STATr_MIIM_OPN_DONEf_SET(r,f) (r).cmic_cmc_miim_stat[0]=(((r).cmic_cmc_miim_stat[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_CMC_MIIM_STAT.
 */
#define READ_CMIC_CMC_MIIM_STATr(u,r) bcm5354x_read32(u, CMIC_CMC_MIIM_STAT, &(r._cmic_cmc_miim_stat))
#define WRITE_CMIC_CMC_MIIM_STATr(u,r) bcm5354x_write32(u, CMIC_CMC_MIIM_STAT, (r._cmic_cmc_miim_stat))

/*******************************************************************************
 * End of 'CMIC_CMC_MIIM_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNT
 * BLOCKS:   CMIC
 * DESC:     Debug register that provides the number of data
beats in the last SW PIO S-bus ACK

 * SIZE:     32
 * FIELDS:
 *     BEAT_COUNT       Beat count
 *     RESERVED_0       Reserved
 */
#define CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNT.
 */
typedef union CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr_s {
	uint32 v[1];
	uint32 cmic_cmc_schan_ack_data_beat_count[1];
	uint32 _cmic_cmc_schan_ack_data_beat_count;
} CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr_t;

#define CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr_CLR(r) (r).cmic_cmc_schan_ack_data_beat_count[0] = 0
#define CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr_SET(r,d) (r).cmic_cmc_schan_ack_data_beat_count[0] = d
#define CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr_GET(r) (r).cmic_cmc_schan_ack_data_beat_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET(r) (((r).cmic_cmc_schan_ack_data_beat_count[0]) & 0x1f)
#define CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET(r,f) (r).cmic_cmc_schan_ack_data_beat_count[0]=(((r).cmic_cmc_schan_ack_data_beat_count[0] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))
#define CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET(r) ((((r).cmic_cmc_schan_ack_data_beat_count[0]) >> 5) & 0x7ffffff)
#define CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET(r,f) (r).cmic_cmc_schan_ack_data_beat_count[0]=(((r).cmic_cmc_schan_ack_data_beat_count[0] & ~((uint32)0x7ffffff << 5)) | ((((uint32)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNT.
 */
#define READ_CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr(u,r) bcm5354x_read32(u, CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNT, &(r._cmic_cmc_schan_ack_data_beat_count))
#define WRITE_CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr(u,r) bcm5354x_write32(u, CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNT, (r._cmic_cmc_schan_ack_data_beat_count))

/*******************************************************************************
 * End of 'CMIC_CMC_SCHAN_ACK_DATA_BEAT_COUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_SCHAN_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     MSG_START        Set by SW to start an SCH operation. Cleared by HW.
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion. When SW clears this bit, the status bits TIMEOUT, NACK and SER_CHECK_FAILED arecleared.
 *     ABORT            Set by SW to ABORT ongoing SCHAN Operation. SCHAN operation can be aborted only if SBus grant has not ben received. Once grant isreceived, the entire message should be sent and complete ack received. 
 *     SER_CHECK_FAIL   Set by CMIC to indicate last S-bus operation resulted in a SER Parity Check errorClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     SCHAN_ERROR      Set by CMIC to indicate last S-bus operation resulted in an errorThe following could be the cause of error:1) Transaction was aborted by software2) Transaction timed out3) A NACK was received4) SER error was received5) Message error was received6) Opcode was not properClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 */
#define CMIC_CMC_SCHAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SCHAN_CTRL.
 */
typedef union CMIC_CMC_SCHAN_CTRLr_s {
	uint32 v[1];
	uint32 cmic_cmc_schan_ctrl[1];
	uint32 _cmic_cmc_schan_ctrl;
} CMIC_CMC_SCHAN_CTRLr_t;

#define CMIC_CMC_SCHAN_CTRLr_CLR(r) (r).cmic_cmc_schan_ctrl[0] = 0
#define CMIC_CMC_SCHAN_CTRLr_SET(r,d) (r).cmic_cmc_schan_ctrl[0] = d
#define CMIC_CMC_SCHAN_CTRLr_GET(r) (r).cmic_cmc_schan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SCHAN_CTRLr_MSG_STARTf_GET(r) (((r).cmic_cmc_schan_ctrl[0]) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC_SCHAN_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_cmc_schan_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_CMC_SCHAN_CTRLr_ABORTf_GET(r) ((((r).cmic_cmc_schan_ctrl[0]) >> 2) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_ABORTf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_CMC_SCHAN_CTRLr_SER_CHECK_FAILf_GET(r) ((((r).cmic_cmc_schan_ctrl[0]) >> 20) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_SER_CHECK_FAILf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define CMIC_CMC_SCHAN_CTRLr_NACKf_GET(r) ((((r).cmic_cmc_schan_ctrl[0]) >> 21) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_NACKf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define CMIC_CMC_SCHAN_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_cmc_schan_ctrl[0]) >> 22) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define CMIC_CMC_SCHAN_CTRLr_SCHAN_ERRORf_GET(r) ((((r).cmic_cmc_schan_ctrl[0]) >> 23) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_SCHAN_ERRORf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))

/*
 * These macros can be used to access CMIC_CMC_SCHAN_CTRL.
 */
#define READ_CMIC_CMC_SCHAN_CTRLr(u,r) bcm5354x_read32(u, CMIC_CMC_SCHAN_CTRL, &(r._cmic_cmc_schan_ctrl))
#define WRITE_CMIC_CMC_SCHAN_CTRLr(u,r) bcm5354x_write32(u, CMIC_CMC_SCHAN_CTRL, (r._cmic_cmc_schan_ctrl))

/*******************************************************************************
 * End of 'CMIC_CMC_SCHAN_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_SCHAN_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 */
#define CMIC_CMC_SCHAN_ERRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SCHAN_ERR.
 */
typedef union CMIC_CMC_SCHAN_ERRr_s {
	uint32 v[1];
	uint32 cmic_cmc_schan_err[1];
	uint32 _cmic_cmc_schan_err;
} CMIC_CMC_SCHAN_ERRr_t;

#define CMIC_CMC_SCHAN_ERRr_CLR(r) (r).cmic_cmc_schan_err[0] = 0
#define CMIC_CMC_SCHAN_ERRr_SET(r,d) (r).cmic_cmc_schan_err[0] = d
#define CMIC_CMC_SCHAN_ERRr_GET(r) (r).cmic_cmc_schan_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SCHAN_ERRr_NACKf_GET(r) (((r).cmic_cmc_schan_err[0]) & 0x1)
#define CMIC_CMC_SCHAN_ERRr_NACKf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CMC_SCHAN_ERRr_ERR_CODEf_GET(r) ((((r).cmic_cmc_schan_err[0]) >> 4) & 0x3)
#define CMIC_CMC_SCHAN_ERRr_ERR_CODEf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define CMIC_CMC_SCHAN_ERRr_ERRBITf_GET(r) ((((r).cmic_cmc_schan_err[0]) >> 6) & 0x1)
#define CMIC_CMC_SCHAN_ERRr_ERRBITf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define CMIC_CMC_SCHAN_ERRr_DATA_LENf_GET(r) ((((r).cmic_cmc_schan_err[0]) >> 7) & 0x7f)
#define CMIC_CMC_SCHAN_ERRr_DATA_LENf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define CMIC_CMC_SCHAN_ERRr_SRC_PORTf_GET(r) ((((r).cmic_cmc_schan_err[0]) >> 14) & 0x3f)
#define CMIC_CMC_SCHAN_ERRr_SRC_PORTf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32)0x3f << 14)) | ((((uint32)f) & 0x3f) << 14))
#define CMIC_CMC_SCHAN_ERRr_DST_PORTf_GET(r) ((((r).cmic_cmc_schan_err[0]) >> 20) & 0x3f)
#define CMIC_CMC_SCHAN_ERRr_DST_PORTf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define CMIC_CMC_SCHAN_ERRr_OP_CODEf_GET(r) ((((r).cmic_cmc_schan_err[0]) >> 26) & 0x3f)
#define CMIC_CMC_SCHAN_ERRr_OP_CODEf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_CMC_SCHAN_ERR.
 */
#define READ_CMIC_CMC_SCHAN_ERRr(u,r) bcm5354x_read32(u, CMIC_CMC_SCHAN_ERR, &(r._cmic_cmc_schan_err))
#define WRITE_CMIC_CMC_SCHAN_ERRr(u,r) bcm5354x_write32(u, CMIC_CMC_SCHAN_ERR, (r._cmic_cmc_schan_err))

/*******************************************************************************
 * End of 'CMIC_CMC_SCHAN_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CMC_SCHAN_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 */
#define CMIC_CMC_SCHAN_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SCHAN_MESSAGE.
 */
typedef union CMIC_CMC_SCHAN_MESSAGEr_s {
	uint32 v[1];
	uint32 cmic_cmc_schan_message[1];
	uint32 _cmic_cmc_schan_message;
} CMIC_CMC_SCHAN_MESSAGEr_t;

#define CMIC_CMC_SCHAN_MESSAGEr_CLR(r) (r).cmic_cmc_schan_message[0] = 0
#define CMIC_CMC_SCHAN_MESSAGEr_SET(r,d) (r).cmic_cmc_schan_message[0] = d
#define CMIC_CMC_SCHAN_MESSAGEr_GET(r) (r).cmic_cmc_schan_message[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CMC_SCHAN_MESSAGEr_DATAf_GET(r) ((r).cmic_cmc_schan_message[0])
#define CMIC_CMC_SCHAN_MESSAGEr_DATAf_SET(r,f) (r).cmic_cmc_schan_message[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_CMC_SCHAN_MESSAGE.
 */
#define READ_CMIC_CMC_SCHAN_MESSAGEr(u,i,r) bcm5354x_read32(u, CMIC_CMC_SCHAN_MESSAGE(i), &(r._cmic_cmc_schan_message))
#define WRITE_CMIC_CMC_SCHAN_MESSAGEr(u,i,r) bcm5354x_write32(u, CMIC_CMC_SCHAN_MESSAGE(i), (r._cmic_cmc_schan_message))

/*******************************************************************************
 * End of 'CMIC_CMC_SCHAN_MESSAGEr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_CPS_RESET
 * BLOCKS:   CMIC
 * DESC:     CPS Reset Register
 * SIZE:     32
 * FIELDS:
 *     CPS_RESET        Write 1 to this bit to initiate CPS Reset. 
 *     CHIP_SOFT_RESET  Write 1 to this bit to reset the chip, RSTFSM goes to RESET state.
 */
#define CMIC_CPS_RESETr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CPS_RESET.
 */
typedef union CMIC_CPS_RESETr_s {
	uint32 v[1];
	uint32 cmic_cps_reset[1];
	uint32 _cmic_cps_reset;
} CMIC_CPS_RESETr_t;

#define CMIC_CPS_RESETr_CLR(r) (r).cmic_cps_reset[0] = 0
#define CMIC_CPS_RESETr_SET(r,d) (r).cmic_cps_reset[0] = d
#define CMIC_CPS_RESETr_GET(r) (r).cmic_cps_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_CPS_RESETr_CPS_RESETf_GET(r) (((r).cmic_cps_reset[0]) & 0x1)
#define CMIC_CPS_RESETr_CPS_RESETf_SET(r,f) (r).cmic_cps_reset[0]=(((r).cmic_cps_reset[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_CPS_RESETr_CHIP_SOFT_RESETf_GET(r) ((((r).cmic_cps_reset[0]) >> 1) & 0x1)
#define CMIC_CPS_RESETr_CHIP_SOFT_RESETf_SET(r,f) (r).cmic_cps_reset[0]=(((r).cmic_cps_reset[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access CMIC_CPS_RESET.
 */
#define READ_CMIC_CPS_RESETr(u,r) bcm5354x_read32(u, CMIC_CPS_RESET, &(r._cmic_cps_reset))
#define WRITE_CMIC_CPS_RESETr(u,r) bcm5354x_write32(u, CMIC_CPS_RESET, (r._cmic_cps_reset))

/*******************************************************************************
 * End of 'CMIC_CPS_RESETr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_DEV_REV_ID
 * BLOCKS:   CMIC
 * DESC:     Device/revision ID
 * SIZE:     32
 * FIELDS:
 *     DEV_ID           Device ID
 *     REV_ID           Revision ID
 */
#define CMIC_DEV_REV_IDr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DEV_REV_ID.
 */
typedef union CMIC_DEV_REV_IDr_s {
	uint32 v[1];
	uint32 cmic_dev_rev_id[1];
	uint32 _cmic_dev_rev_id;
} CMIC_DEV_REV_IDr_t;

#define CMIC_DEV_REV_IDr_CLR(r) (r).cmic_dev_rev_id[0] = 0
#define CMIC_DEV_REV_IDr_SET(r,d) (r).cmic_dev_rev_id[0] = d
#define CMIC_DEV_REV_IDr_GET(r) (r).cmic_dev_rev_id[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_DEV_REV_IDr_DEV_IDf_GET(r) (((r).cmic_dev_rev_id[0]) & 0xffff)
#define CMIC_DEV_REV_IDr_DEV_IDf_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CMIC_DEV_REV_IDr_REV_IDf_GET(r) ((((r).cmic_dev_rev_id[0]) >> 16) & 0xff)
#define CMIC_DEV_REV_IDr_REV_IDf_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))

/*
 * These macros can be used to access CMIC_DEV_REV_ID.
 */
#define READ_CMIC_DEV_REV_IDr(u,r) bcm5354x_read32(u, CMIC_DEV_REV_ID, &(r._cmic_dev_rev_id))
#define WRITE_CMIC_DEV_REV_IDr(u,r) bcm5354x_write32(u, CMIC_DEV_REV_ID, (r._cmic_dev_rev_id))

/*******************************************************************************
 * End of 'CMIC_DEV_REV_IDr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_GP_DATA_IN
 * BLOCKS:   CMIC
 * DESC:     GPIO Data in register

 * SIZE:     32
 * FIELDS:
 *     DATA_IN          GPIO Data input register used to read the value on the external GPIO pins. This register always samples the data on the GPIO pins, even when the GPIO pads are configured as output, the value sent out on the GPIO is reflected on the GP_DIN register. Default vaule depends on the default values of GP_RES_EN, GP_PAD_RES and values driven to GPIO inputs."
 *     RESERVED         Reserved
 */
#define CMIC_GP_DATA_INr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_GP_DATA_IN.
 */
typedef union CMIC_GP_DATA_INr_s {
	uint32 v[1];
	uint32 cmic_gp_data_in[1];
	uint32 _cmic_gp_data_in;
} CMIC_GP_DATA_INr_t;

#define CMIC_GP_DATA_INr_CLR(r) (r).cmic_gp_data_in[0] = 0
#define CMIC_GP_DATA_INr_SET(r,d) (r).cmic_gp_data_in[0] = d
#define CMIC_GP_DATA_INr_GET(r) (r).cmic_gp_data_in[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_GP_DATA_INr_DATA_INf_GET(r) (((r).cmic_gp_data_in[0]) & 0xf)
#define CMIC_GP_DATA_INr_DATA_INf_SET(r,f) (r).cmic_gp_data_in[0]=(((r).cmic_gp_data_in[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_GP_DATA_INr_RESERVEDf_GET(r) ((((r).cmic_gp_data_in[0]) >> 4) & 0xfffffff)
#define CMIC_GP_DATA_INr_RESERVEDf_SET(r,f) (r).cmic_gp_data_in[0]=(((r).cmic_gp_data_in[0] & ~((uint32)0xfffffff << 4)) | ((((uint32)f) & 0xfffffff) << 4))

/*
 * These macros can be used to access CMIC_GP_DATA_IN.
 */
#define READ_CMIC_GP_DATA_INr(u,r) bcm5354x_read32(u, CMIC_GP_DATA_IN, &(r._cmic_gp_data_in))
#define WRITE_CMIC_GP_DATA_INr(u,r) bcm5354x_write32(u, CMIC_GP_DATA_IN, (r._cmic_gp_data_in))

/*******************************************************************************
 * End of 'CMIC_GP_DATA_INr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_GP_DATA_OUT
 * BLOCKS:   CMIC
 * DESC:     GPIO Data out register

 * SIZE:     32
 * FIELDS:
 *     DATA_OUT         GPIO Data out register used to write data out to the external GPIO pins. When the corresponding bit in the GP_EN register is programmed to logic 1,  the pin is configured as an output, and writing data to a bit drives the data out on the pad. Reading from a bit indicates the last value written to the register. If the corresponding bit within the GP_EN register is programmed to logic 0, configuring the pad as an input, then writing has no effect.
 *     RESERVED         Reserved
 */
#define CMIC_GP_DATA_OUTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_GP_DATA_OUT.
 */
typedef union CMIC_GP_DATA_OUTr_s {
	uint32 v[1];
	uint32 cmic_gp_data_out[1];
	uint32 _cmic_gp_data_out;
} CMIC_GP_DATA_OUTr_t;

#define CMIC_GP_DATA_OUTr_CLR(r) (r).cmic_gp_data_out[0] = 0
#define CMIC_GP_DATA_OUTr_SET(r,d) (r).cmic_gp_data_out[0] = d
#define CMIC_GP_DATA_OUTr_GET(r) (r).cmic_gp_data_out[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_GP_DATA_OUTr_DATA_OUTf_GET(r) (((r).cmic_gp_data_out[0]) & 0xf)
#define CMIC_GP_DATA_OUTr_DATA_OUTf_SET(r,f) (r).cmic_gp_data_out[0]=(((r).cmic_gp_data_out[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_GP_DATA_OUTr_RESERVEDf_GET(r) ((((r).cmic_gp_data_out[0]) >> 4) & 0xfffffff)
#define CMIC_GP_DATA_OUTr_RESERVEDf_SET(r,f) (r).cmic_gp_data_out[0]=(((r).cmic_gp_data_out[0] & ~((uint32)0xfffffff << 4)) | ((((uint32)f) & 0xfffffff) << 4))

/*
 * These macros can be used to access CMIC_GP_DATA_OUT.
 */
#define READ_CMIC_GP_DATA_OUTr(u,r) bcm5354x_read32(u, CMIC_GP_DATA_OUT, &(r._cmic_gp_data_out))
#define WRITE_CMIC_GP_DATA_OUTr(u,r) bcm5354x_write32(u, CMIC_GP_DATA_OUT, (r._cmic_gp_data_out))

/*******************************************************************************
 * End of 'CMIC_GP_DATA_OUTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_GP_OUT_EN
 * BLOCKS:   CMIC
 * DESC:     GPIO drive enable register

 * SIZE:     32
 * FIELDS:
 *     OUT_ENABLE       GPIO driver enable register. Setting a bit to logic 1 enables the corresponding GPIO pad as an output driver otherwise it is configured as a receiver . When a bit is set low to logic 0, the driver is disabled.
 *     RESERVED         Reserved
 */
#define CMIC_GP_OUT_ENr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_GP_OUT_EN.
 */
typedef union CMIC_GP_OUT_ENr_s {
	uint32 v[1];
	uint32 cmic_gp_out_en[1];
	uint32 _cmic_gp_out_en;
} CMIC_GP_OUT_ENr_t;

#define CMIC_GP_OUT_ENr_CLR(r) (r).cmic_gp_out_en[0] = 0
#define CMIC_GP_OUT_ENr_SET(r,d) (r).cmic_gp_out_en[0] = d
#define CMIC_GP_OUT_ENr_GET(r) (r).cmic_gp_out_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_GP_OUT_ENr_OUT_ENABLEf_GET(r) (((r).cmic_gp_out_en[0]) & 0xf)
#define CMIC_GP_OUT_ENr_OUT_ENABLEf_SET(r,f) (r).cmic_gp_out_en[0]=(((r).cmic_gp_out_en[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_GP_OUT_ENr_RESERVEDf_GET(r) ((((r).cmic_gp_out_en[0]) >> 4) & 0xfffffff)
#define CMIC_GP_OUT_ENr_RESERVEDf_SET(r,f) (r).cmic_gp_out_en[0]=(((r).cmic_gp_out_en[0] & ~((uint32)0xfffffff << 4)) | ((((uint32)f) & 0xfffffff) << 4))

/*
 * These macros can be used to access CMIC_GP_OUT_EN.
 */
#define READ_CMIC_GP_OUT_ENr(u,r) bcm5354x_read32(u, CMIC_GP_OUT_EN, &(r._cmic_gp_out_en))
#define WRITE_CMIC_GP_OUT_ENr(u,r) bcm5354x_write32(u, CMIC_GP_OUT_EN, (r._cmic_gp_out_en))

/*******************************************************************************
 * End of 'CMIC_GP_OUT_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_LEDUP0_CTRL
 * BLOCKS:   CMIC
 * DESC:     LEDUP0 Control
 * SIZE:     32
 * FIELDS:
 *     LEDUP_EN         LEDUP Enable.
 *     LEDUP_SCAN_INTRA_PORT_DELAY Delay between the scan-in data for two consecutive ports (in switch clock cycles). Reset value is dependent of strap_cmicm_led_retimingflops[2:0]
 *     LEDUP_SCAN_START_DELAY Delay between the scan-in data for the time refresh starts to the first bit of scan-in data. Reset value is dependent of strap_cmicm_led_retimingflops[8:3]
 */
#define CMIC_LEDUP0_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP0_CTRL.
 */
typedef union CMIC_LEDUP0_CTRLr_s {
	uint32 v[1];
	uint32 cmic_ledup0_ctrl[1];
	uint32 _cmic_ledup0_ctrl;
} CMIC_LEDUP0_CTRLr_t;

#define CMIC_LEDUP0_CTRLr_CLR(r) (r).cmic_ledup0_ctrl[0] = 0
#define CMIC_LEDUP0_CTRLr_SET(r,d) (r).cmic_ledup0_ctrl[0] = d
#define CMIC_LEDUP0_CTRLr_GET(r) (r).cmic_ledup0_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_LEDUP0_CTRLr_LEDUP_ENf_GET(r) (((r).cmic_ledup0_ctrl[0]) & 0x1)
#define CMIC_LEDUP0_CTRLr_LEDUP_ENf_SET(r,f) (r).cmic_ledup0_ctrl[0]=(((r).cmic_ledup0_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_LEDUP0_CTRLr_LEDUP_SCAN_INTRA_PORT_DELAYf_GET(r) ((((r).cmic_ledup0_ctrl[0]) >> 1) & 0x7)
#define CMIC_LEDUP0_CTRLr_LEDUP_SCAN_INTRA_PORT_DELAYf_SET(r,f) (r).cmic_ledup0_ctrl[0]=(((r).cmic_ledup0_ctrl[0] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define CMIC_LEDUP0_CTRLr_LEDUP_SCAN_START_DELAYf_GET(r) ((((r).cmic_ledup0_ctrl[0]) >> 4) & 0x3f)
#define CMIC_LEDUP0_CTRLr_LEDUP_SCAN_START_DELAYf_SET(r,f) (r).cmic_ledup0_ctrl[0]=(((r).cmic_ledup0_ctrl[0] & ~((uint32)0x3f << 4)) | ((((uint32)f) & 0x3f) << 4))

/*
 * These macros can be used to access CMIC_LEDUP0_CTRL.
 */
#define READ_CMIC_LEDUP0_CTRLr(u,r) bcm5354x_read32(u, CMIC_LEDUP0_CTRL, &(r._cmic_ledup0_ctrl))
#define WRITE_CMIC_LEDUP0_CTRLr(u,r) bcm5354x_write32(u, CMIC_LEDUP0_CTRL, (r._cmic_ledup0_ctrl))

/*******************************************************************************
 * End of 'CMIC_LEDUP0_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_LEDUP0_DATA_RAM
 * BLOCKS:   CMIC
 * DESC:     LEDUP0 Data RAM
 * SIZE:     32
 * FIELDS:
 *     DATA             LEDUP0 DATA RAM data (Rd/Wr) word
 */
#define CMIC_LEDUP0_DATA_RAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP0_DATA_RAM.
 */
typedef union CMIC_LEDUP0_DATA_RAMr_s {
	uint32 v[1];
	uint32 cmic_ledup0_data_ram[1];
	uint32 _cmic_ledup0_data_ram;
} CMIC_LEDUP0_DATA_RAMr_t;

#define CMIC_LEDUP0_DATA_RAMr_CLR(r) (r).cmic_ledup0_data_ram[0] = 0
#define CMIC_LEDUP0_DATA_RAMr_SET(r,d) (r).cmic_ledup0_data_ram[0] = d
#define CMIC_LEDUP0_DATA_RAMr_GET(r) (r).cmic_ledup0_data_ram[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_LEDUP0_DATA_RAMr_DATAf_GET(r) (((r).cmic_ledup0_data_ram[0]) & 0xff)
#define CMIC_LEDUP0_DATA_RAMr_DATAf_SET(r,f) (r).cmic_ledup0_data_ram[0]=(((r).cmic_ledup0_data_ram[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))

/*
 * These macros can be used to access CMIC_LEDUP0_DATA_RAM.
 */
#define READ_CMIC_LEDUP0_DATA_RAMr(u,i,r) bcm5354x_read32(u, CMIC_LEDUP0_DATA_RAM(i), &(r._cmic_ledup0_data_ram))
#define WRITE_CMIC_LEDUP0_DATA_RAMr(u,i,r) bcm5354x_write32(u, CMIC_LEDUP0_DATA_RAM(i), (r._cmic_ledup0_data_ram))

/*******************************************************************************
 * End of 'CMIC_LEDUP0_DATA_RAMr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_LEDUP0_PORT_ORDER_REMAP
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 0-3
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_0     Remapping for Port 0
 *     REMAP_PORT_1     Remapping for Port 1
 *     REMAP_PORT_2     Remapping for Port 2
 *     REMAP_PORT_3     Remapping for Port 3
 */
#define CMIC_LEDUP0_PORT_ORDER_REMAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP0_PORT_ORDER_REMAP.
 */
typedef union CMIC_LEDUP0_PORT_ORDER_REMAPr_s {
	uint32 v[1];
	uint32 cmic_ledup0_port_order_remap[1];
	uint32 _cmic_ledup0_port_order_remap;
} CMIC_LEDUP0_PORT_ORDER_REMAPr_t;

#define CMIC_LEDUP0_PORT_ORDER_REMAPr_CLR(r) (r).cmic_ledup0_port_order_remap[0] = 0
#define CMIC_LEDUP0_PORT_ORDER_REMAPr_SET(r,d) (r).cmic_ledup0_port_order_remap[0] = d
#define CMIC_LEDUP0_PORT_ORDER_REMAPr_GET(r) (r).cmic_ledup0_port_order_remap[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_LEDUP0_PORT_ORDER_REMAPr_REMAP_PORT_0f_GET(r) (((r).cmic_ledup0_port_order_remap[0]) & 0x3f)
#define CMIC_LEDUP0_PORT_ORDER_REMAPr_REMAP_PORT_0f_SET(r,f) (r).cmic_ledup0_port_order_remap[0]=(((r).cmic_ledup0_port_order_remap[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define CMIC_LEDUP0_PORT_ORDER_REMAPr_REMAP_PORT_1f_GET(r) ((((r).cmic_ledup0_port_order_remap[0]) >> 6) & 0x3f)
#define CMIC_LEDUP0_PORT_ORDER_REMAPr_REMAP_PORT_1f_SET(r,f) (r).cmic_ledup0_port_order_remap[0]=(((r).cmic_ledup0_port_order_remap[0] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define CMIC_LEDUP0_PORT_ORDER_REMAPr_REMAP_PORT_2f_GET(r) ((((r).cmic_ledup0_port_order_remap[0]) >> 12) & 0x3f)
#define CMIC_LEDUP0_PORT_ORDER_REMAPr_REMAP_PORT_2f_SET(r,f) (r).cmic_ledup0_port_order_remap[0]=(((r).cmic_ledup0_port_order_remap[0] & ~((uint32)0x3f << 12)) | ((((uint32)f) & 0x3f) << 12))
#define CMIC_LEDUP0_PORT_ORDER_REMAPr_REMAP_PORT_3f_GET(r) ((((r).cmic_ledup0_port_order_remap[0]) >> 18) & 0x3f)
#define CMIC_LEDUP0_PORT_ORDER_REMAPr_REMAP_PORT_3f_SET(r,f) (r).cmic_ledup0_port_order_remap[0]=(((r).cmic_ledup0_port_order_remap[0] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))

/*
 * These macros can be used to access CMIC_LEDUP0_PORT_ORDER_REMAP.
 */
#define READ_CMIC_LEDUP0_PORT_ORDER_REMAPr(u,i,r) bcm5354x_read32(u, CMIC_LEDUP0_PORT_ORDER_REMAP(i), &(r._cmic_ledup0_port_order_remap))
#define WRITE_CMIC_LEDUP0_PORT_ORDER_REMAPr(u,i,r) bcm5354x_write32(u, CMIC_LEDUP0_PORT_ORDER_REMAP(i), (r._cmic_ledup0_port_order_remap))

/*******************************************************************************
 * End of 'CMIC_LEDUP0_PORT_ORDER_REMAPr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_LEDUP0_PORT_ORDER_REMAP_0_3
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 0-3
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_0     Remapping for Port 0
 *     REMAP_PORT_1     Remapping for Port 1
 *     REMAP_PORT_2     Remapping for Port 2
 *     REMAP_PORT_3     Remapping for Port 3
 */
#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_SIZE 4

/* CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r is element of CMIC_LEDUP0_PORT_ORDER_REMAP */

/*
 * This structure should be used to declare and program CMIC_LEDUP0_PORT_ORDER_REMAP_0_3.
 */
typedef union CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_s {
	uint32 v[1];
	uint32 cmic_ledup0_port_order_remap_0_3[1];
	uint32 _cmic_ledup0_port_order_remap_0_3;
} CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_t;

#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_CLR(r) (r).cmic_ledup0_port_order_remap_0_3[0] = 0
#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_SET(r,d) (r).cmic_ledup0_port_order_remap_0_3[0] = d
#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_GET(r) (r).cmic_ledup0_port_order_remap_0_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_REMAP_PORT_0f_GET(r) (((r).cmic_ledup0_port_order_remap_0_3[0]) & 0x3f)
#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_REMAP_PORT_0f_SET(r,f) (r).cmic_ledup0_port_order_remap_0_3[0]=(((r).cmic_ledup0_port_order_remap_0_3[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_REMAP_PORT_1f_GET(r) ((((r).cmic_ledup0_port_order_remap_0_3[0]) >> 6) & 0x3f)
#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_REMAP_PORT_1f_SET(r,f) (r).cmic_ledup0_port_order_remap_0_3[0]=(((r).cmic_ledup0_port_order_remap_0_3[0] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_REMAP_PORT_2f_GET(r) ((((r).cmic_ledup0_port_order_remap_0_3[0]) >> 12) & 0x3f)
#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_REMAP_PORT_2f_SET(r,f) (r).cmic_ledup0_port_order_remap_0_3[0]=(((r).cmic_ledup0_port_order_remap_0_3[0] & ~((uint32)0x3f << 12)) | ((((uint32)f) & 0x3f) << 12))
#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_REMAP_PORT_3f_GET(r) ((((r).cmic_ledup0_port_order_remap_0_3[0]) >> 18) & 0x3f)
#define CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r_REMAP_PORT_3f_SET(r,f) (r).cmic_ledup0_port_order_remap_0_3[0]=(((r).cmic_ledup0_port_order_remap_0_3[0] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))

/*
 * These macros can be used to access CMIC_LEDUP0_PORT_ORDER_REMAP_0_3.
 */
#define READ_CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r(u,r) bcm5354x_read32(u, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3, &(r._cmic_ledup0_port_order_remap_0_3))
#define WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r(u,r) bcm5354x_write32(u, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3, (r._cmic_ledup0_port_order_remap_0_3))

/*******************************************************************************
 * End of 'CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_LEDUP0_PORT_ORDER_REMAP_60_63
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 60-63
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_60    Remapping for Port 60
 *     REMAP_PORT_61    Remapping for Port 61
 *     REMAP_PORT_62    Remapping for Port 62
 *     REMAP_PORT_63    Remapping for Port 63
 */
#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_SIZE 4

/* CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r is element of CMIC_LEDUP0_PORT_ORDER_REMAP */

/*
 * This structure should be used to declare and program CMIC_LEDUP0_PORT_ORDER_REMAP_60_63.
 */
typedef union CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_s {
	uint32 v[1];
	uint32 cmic_ledup0_port_order_remap_60_63[1];
	uint32 _cmic_ledup0_port_order_remap_60_63;
} CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_t;

#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_CLR(r) (r).cmic_ledup0_port_order_remap_60_63[0] = 0
#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_SET(r,d) (r).cmic_ledup0_port_order_remap_60_63[0] = d
#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_GET(r) (r).cmic_ledup0_port_order_remap_60_63[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_REMAP_PORT_60f_GET(r) (((r).cmic_ledup0_port_order_remap_60_63[0]) & 0x3f)
#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_REMAP_PORT_60f_SET(r,f) (r).cmic_ledup0_port_order_remap_60_63[0]=(((r).cmic_ledup0_port_order_remap_60_63[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_REMAP_PORT_61f_GET(r) ((((r).cmic_ledup0_port_order_remap_60_63[0]) >> 6) & 0x3f)
#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_REMAP_PORT_61f_SET(r,f) (r).cmic_ledup0_port_order_remap_60_63[0]=(((r).cmic_ledup0_port_order_remap_60_63[0] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_REMAP_PORT_62f_GET(r) ((((r).cmic_ledup0_port_order_remap_60_63[0]) >> 12) & 0x3f)
#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_REMAP_PORT_62f_SET(r,f) (r).cmic_ledup0_port_order_remap_60_63[0]=(((r).cmic_ledup0_port_order_remap_60_63[0] & ~((uint32)0x3f << 12)) | ((((uint32)f) & 0x3f) << 12))
#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_REMAP_PORT_63f_GET(r) ((((r).cmic_ledup0_port_order_remap_60_63[0]) >> 18) & 0x3f)
#define CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r_REMAP_PORT_63f_SET(r,f) (r).cmic_ledup0_port_order_remap_60_63[0]=(((r).cmic_ledup0_port_order_remap_60_63[0] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))

/*
 * These macros can be used to access CMIC_LEDUP0_PORT_ORDER_REMAP_60_63.
 */
#define READ_CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r(u,r) bcm5354x_read32(u, CMIC_LEDUP0_PORT_ORDER_REMAP_60_63, &(r._cmic_ledup0_port_order_remap_60_63))
#define WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r(u,r) bcm5354x_write32(u, CMIC_LEDUP0_PORT_ORDER_REMAP_60_63, (r._cmic_ledup0_port_order_remap_60_63))

/*******************************************************************************
 * End of 'CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_LEDUP0_PROGRAM_RAM
 * BLOCKS:   CMIC
 * DESC:     LEDUP0 Program RAM
 * SIZE:     32
 * FIELDS:
 *     DATA             LEDUP0 PROGRAM RAM data (Rd/Wr) word
 */
#define CMIC_LEDUP0_PROGRAM_RAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP0_PROGRAM_RAM.
 */
typedef union CMIC_LEDUP0_PROGRAM_RAMr_s {
	uint32 v[1];
	uint32 cmic_ledup0_program_ram[1];
	uint32 _cmic_ledup0_program_ram;
} CMIC_LEDUP0_PROGRAM_RAMr_t;

#define CMIC_LEDUP0_PROGRAM_RAMr_CLR(r) (r).cmic_ledup0_program_ram[0] = 0
#define CMIC_LEDUP0_PROGRAM_RAMr_SET(r,d) (r).cmic_ledup0_program_ram[0] = d
#define CMIC_LEDUP0_PROGRAM_RAMr_GET(r) (r).cmic_ledup0_program_ram[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_LEDUP0_PROGRAM_RAMr_DATAf_GET(r) (((r).cmic_ledup0_program_ram[0]) & 0xff)
#define CMIC_LEDUP0_PROGRAM_RAMr_DATAf_SET(r,f) (r).cmic_ledup0_program_ram[0]=(((r).cmic_ledup0_program_ram[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))

/*
 * These macros can be used to access CMIC_LEDUP0_PROGRAM_RAM.
 */
#define READ_CMIC_LEDUP0_PROGRAM_RAMr(u,i,r) bcm5354x_read32(u, CMIC_LEDUP0_PROGRAM_RAM(i), &(r._cmic_ledup0_program_ram))
#define WRITE_CMIC_LEDUP0_PROGRAM_RAMr(u,i,r) bcm5354x_write32(u, CMIC_LEDUP0_PROGRAM_RAM(i), (r._cmic_ledup0_program_ram))

/*******************************************************************************
 * End of 'CMIC_LEDUP0_PROGRAM_RAMr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_PCIE_USERIF_PURGE_CONTROL
 * BLOCKS:   CMIC
 * DESC:     CMIC_PCIE_USERIF_PURGE_CONTROL
 * SIZE:     32
 * FIELDS:
 *     ENABLE_PURGE_IF_USERIF_TIMESOUT Not used in CMICD. Set this bit if Purge operation needs to be enabled as soon as timeout is detected.
 *     ENABLE_PURGE_IF_USERIF_RESET Not used in CMICD. Set this bit if Purge operation needs to be enabled as soon as PCIe core goes to reset.
 *     ENABLE_PURGE_SW_PROGRAMMABLE Not used in CMICD. Set this bit if Purge operation needs to be enabled by force at any given time
 *     ENABLE_PIO_PURGE_SW_PROGRAMMABLE Not used in CMICD. Set this bit to terminate any pending write request on going on target side of user interface. 
 *     ENABLE_PIO_PURGE_IF_USERIF_RESET Not used in CMICD. Set this bit to terminate any pending write request on going on target side of user interface as soon as pcie core TL goes to reset. 
 */
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PCIE_USERIF_PURGE_CONTROL.
 */
typedef union CMIC_PCIE_USERIF_PURGE_CONTROLr_s {
	uint32 v[1];
	uint32 cmic_pcie_userif_purge_control[1];
	uint32 _cmic_pcie_userif_purge_control;
} CMIC_PCIE_USERIF_PURGE_CONTROLr_t;

#define CMIC_PCIE_USERIF_PURGE_CONTROLr_CLR(r) (r).cmic_pcie_userif_purge_control[0] = 0
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_SET(r,d) (r).cmic_pcie_userif_purge_control[0] = d
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_GET(r) (r).cmic_pcie_userif_purge_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_ENABLE_PURGE_IF_USERIF_TIMESOUTf_GET(r) (((r).cmic_pcie_userif_purge_control[0]) & 0x1)
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_ENABLE_PURGE_IF_USERIF_TIMESOUTf_SET(r,f) (r).cmic_pcie_userif_purge_control[0]=(((r).cmic_pcie_userif_purge_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_ENABLE_PURGE_IF_USERIF_RESETf_GET(r) ((((r).cmic_pcie_userif_purge_control[0]) >> 1) & 0x1)
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_ENABLE_PURGE_IF_USERIF_RESETf_SET(r,f) (r).cmic_pcie_userif_purge_control[0]=(((r).cmic_pcie_userif_purge_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_ENABLE_PURGE_SW_PROGRAMMABLEf_GET(r) ((((r).cmic_pcie_userif_purge_control[0]) >> 2) & 0x1)
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_ENABLE_PURGE_SW_PROGRAMMABLEf_SET(r,f) (r).cmic_pcie_userif_purge_control[0]=(((r).cmic_pcie_userif_purge_control[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_ENABLE_PIO_PURGE_SW_PROGRAMMABLEf_GET(r) ((((r).cmic_pcie_userif_purge_control[0]) >> 3) & 0x1)
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_ENABLE_PIO_PURGE_SW_PROGRAMMABLEf_SET(r,f) (r).cmic_pcie_userif_purge_control[0]=(((r).cmic_pcie_userif_purge_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_ENABLE_PIO_PURGE_IF_USERIF_RESETf_GET(r) ((((r).cmic_pcie_userif_purge_control[0]) >> 4) & 0x1)
#define CMIC_PCIE_USERIF_PURGE_CONTROLr_ENABLE_PIO_PURGE_IF_USERIF_RESETf_SET(r,f) (r).cmic_pcie_userif_purge_control[0]=(((r).cmic_pcie_userif_purge_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))

/*
 * These macros can be used to access CMIC_PCIE_USERIF_PURGE_CONTROL.
 */
#define READ_CMIC_PCIE_USERIF_PURGE_CONTROLr(u,r) bcm5354x_read32(u, CMIC_PCIE_USERIF_PURGE_CONTROL, &(r._cmic_pcie_userif_purge_control))
#define WRITE_CMIC_PCIE_USERIF_PURGE_CONTROLr(u,r) bcm5354x_write32(u, CMIC_PCIE_USERIF_PURGE_CONTROL, (r._cmic_pcie_userif_purge_control))

/*******************************************************************************
 * End of 'CMIC_PCIE_USERIF_PURGE_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_RATE_ADJUST_EXT_MDIO
 * BLOCKS:   CMIC
 * DESC:     The clock divider configuration register for External MDIO.

Various parts of the chip involved in rate control 
require a constant, known frequency. This reference 
frequency is based off of the chip 's core clock.
However, the core clock can be different in different
designs, thus the need for this register.

The core clock frequency is multiplied by the rational
quantity (DIVIDEND/DIVISOR), and the further divided
down by 2 to produce the actual MDIO operation freqeuncy.

To avoid skew, it is recommended that the DIVIDEND value
usually be set to 1.

The default values are for 133MHz operation:
DIVIDEND=1, DIVISOR=6, 
MDIO operation freq = 133MHz/(6*2) =~ 11MHz

For 157MHz core clock chips, set:
DIVIDEND=1, DIVISOR=7, 
MDIO operation freq = 133MHz/(7*2) =~ 11MHz


 * SIZE:     32
 * FIELDS:
 *     DIVISOR          Denominator of clock scale factor.
 *     DIVIDEND         Numerator of clock scale factor.
 */
#define CMIC_RATE_ADJUST_EXT_MDIOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RATE_ADJUST_EXT_MDIO.
 */
typedef union CMIC_RATE_ADJUST_EXT_MDIOr_s {
	uint32 v[1];
	uint32 cmic_rate_adjust_ext_mdio[1];
	uint32 _cmic_rate_adjust_ext_mdio;
} CMIC_RATE_ADJUST_EXT_MDIOr_t;

#define CMIC_RATE_ADJUST_EXT_MDIOr_CLR(r) (r).cmic_rate_adjust_ext_mdio[0] = 0
#define CMIC_RATE_ADJUST_EXT_MDIOr_SET(r,d) (r).cmic_rate_adjust_ext_mdio[0] = d
#define CMIC_RATE_ADJUST_EXT_MDIOr_GET(r) (r).cmic_rate_adjust_ext_mdio[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_RATE_ADJUST_EXT_MDIOr_DIVISORf_GET(r) (((r).cmic_rate_adjust_ext_mdio[0]) & 0xffff)
#define CMIC_RATE_ADJUST_EXT_MDIOr_DIVISORf_SET(r,f) (r).cmic_rate_adjust_ext_mdio[0]=(((r).cmic_rate_adjust_ext_mdio[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CMIC_RATE_ADJUST_EXT_MDIOr_DIVIDENDf_GET(r) ((((r).cmic_rate_adjust_ext_mdio[0]) >> 16) & 0xffff)
#define CMIC_RATE_ADJUST_EXT_MDIOr_DIVIDENDf_SET(r,f) (r).cmic_rate_adjust_ext_mdio[0]=(((r).cmic_rate_adjust_ext_mdio[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_RATE_ADJUST_EXT_MDIO.
 */
#define READ_CMIC_RATE_ADJUST_EXT_MDIOr(u,r) bcm5354x_read32(u, CMIC_RATE_ADJUST_EXT_MDIO, &(r._cmic_rate_adjust_ext_mdio))
#define WRITE_CMIC_RATE_ADJUST_EXT_MDIOr(u,r) bcm5354x_write32(u, CMIC_RATE_ADJUST_EXT_MDIO, (r._cmic_rate_adjust_ext_mdio))

/*******************************************************************************
 * End of 'CMIC_RATE_ADJUST_EXT_MDIOr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_RATE_ADJUST_INT_MDIO
 * BLOCKS:   CMIC
 * DESC:     The clock divider configuration register for Internal MDIO.

Various parts of the chip involved in rate control 
require a constant, known frequency. This reference 
frequency is based off of the chip 's core clock.
However, the core clock can be different in different
designs, thus the need for this register.

The core clock frequency is multiplied by the rational
quantity (DIVIDEND/DIVISOR), and the further divided
down by 2 to produce the actual MDIO operation freqeuncy.

To avoid skew, it is recommended that the DIVIDEND value
usually be set to 1.

The default values are for 133MHz operation:
DIVIDEND=1, DIVISOR=6, 
MDIO operation freq = 133MHz/(6*2) =~ 11MHz

For 157MHz core clock chips, set:
DIVIDEND=1, DIVISOR=7, 
MDIO operation freq = 133MHz/(7*2) =~ 11MHz


 * SIZE:     32
 * FIELDS:
 *     DIVISOR          Denominator of clock scale factor.
 *     DIVIDEND         Numerator of clock scale factor.
 */
#define CMIC_RATE_ADJUST_INT_MDIOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RATE_ADJUST_INT_MDIO.
 */
typedef union CMIC_RATE_ADJUST_INT_MDIOr_s {
	uint32 v[1];
	uint32 cmic_rate_adjust_int_mdio[1];
	uint32 _cmic_rate_adjust_int_mdio;
} CMIC_RATE_ADJUST_INT_MDIOr_t;

#define CMIC_RATE_ADJUST_INT_MDIOr_CLR(r) (r).cmic_rate_adjust_int_mdio[0] = 0
#define CMIC_RATE_ADJUST_INT_MDIOr_SET(r,d) (r).cmic_rate_adjust_int_mdio[0] = d
#define CMIC_RATE_ADJUST_INT_MDIOr_GET(r) (r).cmic_rate_adjust_int_mdio[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_GET(r) (((r).cmic_rate_adjust_int_mdio[0]) & 0xffff)
#define CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_SET(r,f) (r).cmic_rate_adjust_int_mdio[0]=(((r).cmic_rate_adjust_int_mdio[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_GET(r) ((((r).cmic_rate_adjust_int_mdio[0]) >> 16) & 0xffff)
#define CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_SET(r,f) (r).cmic_rate_adjust_int_mdio[0]=(((r).cmic_rate_adjust_int_mdio[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_RATE_ADJUST_INT_MDIO.
 */
#define READ_CMIC_RATE_ADJUST_INT_MDIOr(u,r) bcm5354x_read32(u, CMIC_RATE_ADJUST_INT_MDIO, &(r._cmic_rate_adjust_int_mdio))
#define WRITE_CMIC_RATE_ADJUST_INT_MDIOr(u,r) bcm5354x_write32(u, CMIC_RATE_ADJUST_INT_MDIO, (r._cmic_rate_adjust_int_mdio))

/*******************************************************************************
 * End of 'CMIC_RATE_ADJUST_INT_MDIOr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITS
 * BLOCKS:   CMIC
 * DESC:     This register has the config bit which when written to 1 will release the max number of credits to the EP block so EP block can send data worth number of credits times 8B. This has to be done only once after both CMIC and EP blocks are out of reset. If EP block is not out of reset, it will not be able to sample the number of credits released to it resulting in hang scenario. Once ininitial credits are released, CMIC block will continue to release the credits as it reads the interface buffer.

 * SIZE:     32
 * FIELDS:
 *     RELEASE_ALL_CREDITS Changing this from 0 to 1, will cause the credits to be released
 */
#define CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITS.
 */
typedef union CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITSr_s {
	uint32 v[1];
	uint32 cmic_rxbuf_epintf_release_all_credits[1];
	uint32 _cmic_rxbuf_epintf_release_all_credits;
} CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITSr_t;

#define CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITSr_CLR(r) (r).cmic_rxbuf_epintf_release_all_credits[0] = 0
#define CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITSr_SET(r,d) (r).cmic_rxbuf_epintf_release_all_credits[0] = d
#define CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITSr_GET(r) (r).cmic_rxbuf_epintf_release_all_credits[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITSr_RELEASE_ALL_CREDITSf_GET(r) (((r).cmic_rxbuf_epintf_release_all_credits[0]) & 0x1)
#define CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITSr_RELEASE_ALL_CREDITSf_SET(r,f) (r).cmic_rxbuf_epintf_release_all_credits[0]=(((r).cmic_rxbuf_epintf_release_all_credits[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITS.
 */
#define READ_CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITSr(u,r) bcm5354x_read32(u, CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITS, &(r._cmic_rxbuf_epintf_release_all_credits))
#define WRITE_CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITSr(u,r) bcm5354x_write32(u, CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITS, (r._cmic_rxbuf_epintf_release_all_credits))

/*******************************************************************************
 * End of 'CMIC_RXBUF_EPINTF_RELEASE_ALL_CREDITSr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SBUS_RING_MAP
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (0 to 7) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_0 S-bus ring number for agent with S-bus ID  0
 *     RING_NUM_SBUS_ID_1 S-bus ring number for agent with S-bus ID  1
 *     RING_NUM_SBUS_ID_2 S-bus ring number for agent with S-bus ID  2
 *     RING_NUM_SBUS_ID_3 S-bus ring number for agent with S-bus ID  3
 *     RING_NUM_SBUS_ID_4 S-bus ring number for agent with S-bus ID  4
 *     RING_NUM_SBUS_ID_5 S-bus ring number for agent with S-bus ID  5
 *     RING_NUM_SBUS_ID_6 S-bus ring number for agent with S-bus ID  6
 *     RING_NUM_SBUS_ID_7 S-bus ring number for agent with S-bus ID  7
 */
#define CMIC_SBUS_RING_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SBUS_RING_MAP.
 */
typedef union CMIC_SBUS_RING_MAPr_s {
	uint32 v[1];
	uint32 cmic_sbus_ring_map[1];
	uint32 _cmic_sbus_ring_map;
} CMIC_SBUS_RING_MAPr_t;

#define CMIC_SBUS_RING_MAPr_CLR(r) (r).cmic_sbus_ring_map[0] = 0
#define CMIC_SBUS_RING_MAPr_SET(r,d) (r).cmic_sbus_ring_map[0] = d
#define CMIC_SBUS_RING_MAPr_GET(r) (r).cmic_sbus_ring_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET(r) (((r).cmic_sbus_ring_map[0]) & 0xf)
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 4) & 0xf)
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 8) & 0xf)
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 12) & 0xf)
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 16) & 0xf)
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 20) & 0xf)
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 24) & 0xf)
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 28) & 0xf)
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_SBUS_RING_MAP.
 */
#define READ_CMIC_SBUS_RING_MAPr(u,i,r) bcm5354x_read32(u, CMIC_SBUS_RING_MAP(i), &(r._cmic_sbus_ring_map))
#define WRITE_CMIC_SBUS_RING_MAPr(u,i,r) bcm5354x_write32(u, CMIC_SBUS_RING_MAP(i), (r._cmic_sbus_ring_map))

/*******************************************************************************
 * End of 'CMIC_SBUS_RING_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SBUS_RING_MAP_0_7
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (0 to 7) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_0 S-bus ring number for agent with S-bus ID  0
 *     RING_NUM_SBUS_ID_1 S-bus ring number for agent with S-bus ID  1
 *     RING_NUM_SBUS_ID_2 S-bus ring number for agent with S-bus ID  2
 *     RING_NUM_SBUS_ID_3 S-bus ring number for agent with S-bus ID  3
 *     RING_NUM_SBUS_ID_4 S-bus ring number for agent with S-bus ID  4
 *     RING_NUM_SBUS_ID_5 S-bus ring number for agent with S-bus ID  5
 *     RING_NUM_SBUS_ID_6 S-bus ring number for agent with S-bus ID  6
 *     RING_NUM_SBUS_ID_7 S-bus ring number for agent with S-bus ID  7
 */
#define CMIC_SBUS_RING_MAP_0_7r_SIZE 4

/* CMIC_SBUS_RING_MAP_0_7r is element of CMIC_SBUS_RING_MAP */

/*
 * This structure should be used to declare and program CMIC_SBUS_RING_MAP_0_7.
 */
typedef union CMIC_SBUS_RING_MAP_0_7r_s {
	uint32 v[1];
	uint32 cmic_sbus_ring_map_0_7[1];
	uint32 _cmic_sbus_ring_map_0_7;
} CMIC_SBUS_RING_MAP_0_7r_t;

#define CMIC_SBUS_RING_MAP_0_7r_CLR(r) (r).cmic_sbus_ring_map_0_7[0] = 0
#define CMIC_SBUS_RING_MAP_0_7r_SET(r,d) (r).cmic_sbus_ring_map_0_7[0] = d
#define CMIC_SBUS_RING_MAP_0_7r_GET(r) (r).cmic_sbus_ring_map_0_7[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_0f_GET(r) (((r).cmic_sbus_ring_map_0_7[0]) & 0xf)
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_0f_SET(r,f) (r).cmic_sbus_ring_map_0_7[0]=(((r).cmic_sbus_ring_map_0_7[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_1f_GET(r) ((((r).cmic_sbus_ring_map_0_7[0]) >> 4) & 0xf)
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_1f_SET(r,f) (r).cmic_sbus_ring_map_0_7[0]=(((r).cmic_sbus_ring_map_0_7[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_2f_GET(r) ((((r).cmic_sbus_ring_map_0_7[0]) >> 8) & 0xf)
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_2f_SET(r,f) (r).cmic_sbus_ring_map_0_7[0]=(((r).cmic_sbus_ring_map_0_7[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_3f_GET(r) ((((r).cmic_sbus_ring_map_0_7[0]) >> 12) & 0xf)
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_3f_SET(r,f) (r).cmic_sbus_ring_map_0_7[0]=(((r).cmic_sbus_ring_map_0_7[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_4f_GET(r) ((((r).cmic_sbus_ring_map_0_7[0]) >> 16) & 0xf)
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_4f_SET(r,f) (r).cmic_sbus_ring_map_0_7[0]=(((r).cmic_sbus_ring_map_0_7[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_5f_GET(r) ((((r).cmic_sbus_ring_map_0_7[0]) >> 20) & 0xf)
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_5f_SET(r,f) (r).cmic_sbus_ring_map_0_7[0]=(((r).cmic_sbus_ring_map_0_7[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_6f_GET(r) ((((r).cmic_sbus_ring_map_0_7[0]) >> 24) & 0xf)
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_6f_SET(r,f) (r).cmic_sbus_ring_map_0_7[0]=(((r).cmic_sbus_ring_map_0_7[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_7f_GET(r) ((((r).cmic_sbus_ring_map_0_7[0]) >> 28) & 0xf)
#define CMIC_SBUS_RING_MAP_0_7r_RING_NUM_SBUS_ID_7f_SET(r,f) (r).cmic_sbus_ring_map_0_7[0]=(((r).cmic_sbus_ring_map_0_7[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_SBUS_RING_MAP_0_7.
 */
#define READ_CMIC_SBUS_RING_MAP_0_7r(u,r) bcm5354x_read32(u, CMIC_SBUS_RING_MAP_0_7, &(r._cmic_sbus_ring_map_0_7))
#define WRITE_CMIC_SBUS_RING_MAP_0_7r(u,r) bcm5354x_write32(u, CMIC_SBUS_RING_MAP_0_7, (r._cmic_sbus_ring_map_0_7))

/*******************************************************************************
 * End of 'CMIC_SBUS_RING_MAP_0_7r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SBUS_RING_MAP_16_23
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (16 to 23) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_16 S-bus ring number for agent with S-bus ID  16
 *     RING_NUM_SBUS_ID_17 S-bus ring number for agent with S-bus ID  17
 *     RING_NUM_SBUS_ID_18 S-bus ring number for agent with S-bus ID  18
 *     RING_NUM_SBUS_ID_19 S-bus ring number for agent with S-bus ID  19
 *     RING_NUM_SBUS_ID_20 S-bus ring number for agent with S-bus ID  20
 *     RING_NUM_SBUS_ID_21 S-bus ring number for agent with S-bus ID  21
 *     RING_NUM_SBUS_ID_22 S-bus ring number for agent with S-bus ID  22
 *     RING_NUM_SBUS_ID_23 S-bus ring number for agent with S-bus ID  23
 */
#define CMIC_SBUS_RING_MAP_16_23r_SIZE 4

/* CMIC_SBUS_RING_MAP_16_23r is element of CMIC_SBUS_RING_MAP */

/*
 * This structure should be used to declare and program CMIC_SBUS_RING_MAP_16_23.
 */
typedef union CMIC_SBUS_RING_MAP_16_23r_s {
	uint32 v[1];
	uint32 cmic_sbus_ring_map_16_23[1];
	uint32 _cmic_sbus_ring_map_16_23;
} CMIC_SBUS_RING_MAP_16_23r_t;

#define CMIC_SBUS_RING_MAP_16_23r_CLR(r) (r).cmic_sbus_ring_map_16_23[0] = 0
#define CMIC_SBUS_RING_MAP_16_23r_SET(r,d) (r).cmic_sbus_ring_map_16_23[0] = d
#define CMIC_SBUS_RING_MAP_16_23r_GET(r) (r).cmic_sbus_ring_map_16_23[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_16f_GET(r) (((r).cmic_sbus_ring_map_16_23[0]) & 0xf)
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_16f_SET(r,f) (r).cmic_sbus_ring_map_16_23[0]=(((r).cmic_sbus_ring_map_16_23[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_17f_GET(r) ((((r).cmic_sbus_ring_map_16_23[0]) >> 4) & 0xf)
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_17f_SET(r,f) (r).cmic_sbus_ring_map_16_23[0]=(((r).cmic_sbus_ring_map_16_23[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_18f_GET(r) ((((r).cmic_sbus_ring_map_16_23[0]) >> 8) & 0xf)
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_18f_SET(r,f) (r).cmic_sbus_ring_map_16_23[0]=(((r).cmic_sbus_ring_map_16_23[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_19f_GET(r) ((((r).cmic_sbus_ring_map_16_23[0]) >> 12) & 0xf)
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_19f_SET(r,f) (r).cmic_sbus_ring_map_16_23[0]=(((r).cmic_sbus_ring_map_16_23[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_20f_GET(r) ((((r).cmic_sbus_ring_map_16_23[0]) >> 16) & 0xf)
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_20f_SET(r,f) (r).cmic_sbus_ring_map_16_23[0]=(((r).cmic_sbus_ring_map_16_23[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_21f_GET(r) ((((r).cmic_sbus_ring_map_16_23[0]) >> 20) & 0xf)
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_21f_SET(r,f) (r).cmic_sbus_ring_map_16_23[0]=(((r).cmic_sbus_ring_map_16_23[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_22f_GET(r) ((((r).cmic_sbus_ring_map_16_23[0]) >> 24) & 0xf)
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_22f_SET(r,f) (r).cmic_sbus_ring_map_16_23[0]=(((r).cmic_sbus_ring_map_16_23[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_23f_GET(r) ((((r).cmic_sbus_ring_map_16_23[0]) >> 28) & 0xf)
#define CMIC_SBUS_RING_MAP_16_23r_RING_NUM_SBUS_ID_23f_SET(r,f) (r).cmic_sbus_ring_map_16_23[0]=(((r).cmic_sbus_ring_map_16_23[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_SBUS_RING_MAP_16_23.
 */
#define READ_CMIC_SBUS_RING_MAP_16_23r(u,r) bcm5354x_read32(u, CMIC_SBUS_RING_MAP_16_23, &(r._cmic_sbus_ring_map_16_23))
#define WRITE_CMIC_SBUS_RING_MAP_16_23r(u,r) bcm5354x_write32(u, CMIC_SBUS_RING_MAP_16_23, (r._cmic_sbus_ring_map_16_23))

/*******************************************************************************
 * End of 'CMIC_SBUS_RING_MAP_16_23r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SBUS_RING_MAP_24_31
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (24 to 31) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_24 S-bus ring number for agent with S-bus ID  24
 *     RING_NUM_SBUS_ID_25 S-bus ring number for agent with S-bus ID  25
 *     RING_NUM_SBUS_ID_26 S-bus ring number for agent with S-bus ID  26
 *     RING_NUM_SBUS_ID_27 S-bus ring number for agent with S-bus ID  27
 *     RING_NUM_SBUS_ID_28 S-bus ring number for agent with S-bus ID  28
 *     RING_NUM_SBUS_ID_29 S-bus ring number for agent with S-bus ID  29
 *     RING_NUM_SBUS_ID_30 S-bus ring number for agent with S-bus ID  30
 *     RING_NUM_SBUS_ID_31 S-bus ring number for agent with S-bus ID  31
 */
#define CMIC_SBUS_RING_MAP_24_31r_SIZE 4

/* CMIC_SBUS_RING_MAP_24_31r is element of CMIC_SBUS_RING_MAP */

/*
 * This structure should be used to declare and program CMIC_SBUS_RING_MAP_24_31.
 */
typedef union CMIC_SBUS_RING_MAP_24_31r_s {
	uint32 v[1];
	uint32 cmic_sbus_ring_map_24_31[1];
	uint32 _cmic_sbus_ring_map_24_31;
} CMIC_SBUS_RING_MAP_24_31r_t;

#define CMIC_SBUS_RING_MAP_24_31r_CLR(r) (r).cmic_sbus_ring_map_24_31[0] = 0
#define CMIC_SBUS_RING_MAP_24_31r_SET(r,d) (r).cmic_sbus_ring_map_24_31[0] = d
#define CMIC_SBUS_RING_MAP_24_31r_GET(r) (r).cmic_sbus_ring_map_24_31[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_24f_GET(r) (((r).cmic_sbus_ring_map_24_31[0]) & 0xf)
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_24f_SET(r,f) (r).cmic_sbus_ring_map_24_31[0]=(((r).cmic_sbus_ring_map_24_31[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_25f_GET(r) ((((r).cmic_sbus_ring_map_24_31[0]) >> 4) & 0xf)
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_25f_SET(r,f) (r).cmic_sbus_ring_map_24_31[0]=(((r).cmic_sbus_ring_map_24_31[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_26f_GET(r) ((((r).cmic_sbus_ring_map_24_31[0]) >> 8) & 0xf)
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_26f_SET(r,f) (r).cmic_sbus_ring_map_24_31[0]=(((r).cmic_sbus_ring_map_24_31[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_27f_GET(r) ((((r).cmic_sbus_ring_map_24_31[0]) >> 12) & 0xf)
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_27f_SET(r,f) (r).cmic_sbus_ring_map_24_31[0]=(((r).cmic_sbus_ring_map_24_31[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_28f_GET(r) ((((r).cmic_sbus_ring_map_24_31[0]) >> 16) & 0xf)
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_28f_SET(r,f) (r).cmic_sbus_ring_map_24_31[0]=(((r).cmic_sbus_ring_map_24_31[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_29f_GET(r) ((((r).cmic_sbus_ring_map_24_31[0]) >> 20) & 0xf)
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_29f_SET(r,f) (r).cmic_sbus_ring_map_24_31[0]=(((r).cmic_sbus_ring_map_24_31[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_30f_GET(r) ((((r).cmic_sbus_ring_map_24_31[0]) >> 24) & 0xf)
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_30f_SET(r,f) (r).cmic_sbus_ring_map_24_31[0]=(((r).cmic_sbus_ring_map_24_31[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_31f_GET(r) ((((r).cmic_sbus_ring_map_24_31[0]) >> 28) & 0xf)
#define CMIC_SBUS_RING_MAP_24_31r_RING_NUM_SBUS_ID_31f_SET(r,f) (r).cmic_sbus_ring_map_24_31[0]=(((r).cmic_sbus_ring_map_24_31[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_SBUS_RING_MAP_24_31.
 */
#define READ_CMIC_SBUS_RING_MAP_24_31r(u,r) bcm5354x_read32(u, CMIC_SBUS_RING_MAP_24_31, &(r._cmic_sbus_ring_map_24_31))
#define WRITE_CMIC_SBUS_RING_MAP_24_31r(u,r) bcm5354x_write32(u, CMIC_SBUS_RING_MAP_24_31, (r._cmic_sbus_ring_map_24_31))

/*******************************************************************************
 * End of 'CMIC_SBUS_RING_MAP_24_31r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SBUS_RING_MAP_32_39
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (32 to 39) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_32 S-bus ring number for agent with S-bus ID  32
 *     RING_NUM_SBUS_ID_33 S-bus ring number for agent with S-bus ID  33
 *     RING_NUM_SBUS_ID_34 S-bus ring number for agent with S-bus ID  34
 *     RING_NUM_SBUS_ID_35 S-bus ring number for agent with S-bus ID  35
 *     RING_NUM_SBUS_ID_36 S-bus ring number for agent with S-bus ID  36
 *     RING_NUM_SBUS_ID_37 S-bus ring number for agent with S-bus ID  37
 *     RING_NUM_SBUS_ID_38 S-bus ring number for agent with S-bus ID  38
 *     RING_NUM_SBUS_ID_39 S-bus ring number for agent with S-bus ID  39
 */
#define CMIC_SBUS_RING_MAP_32_39r_SIZE 4

/* CMIC_SBUS_RING_MAP_32_39r is element of CMIC_SBUS_RING_MAP */

/*
 * This structure should be used to declare and program CMIC_SBUS_RING_MAP_32_39.
 */
typedef union CMIC_SBUS_RING_MAP_32_39r_s {
	uint32 v[1];
	uint32 cmic_sbus_ring_map_32_39[1];
	uint32 _cmic_sbus_ring_map_32_39;
} CMIC_SBUS_RING_MAP_32_39r_t;

#define CMIC_SBUS_RING_MAP_32_39r_CLR(r) (r).cmic_sbus_ring_map_32_39[0] = 0
#define CMIC_SBUS_RING_MAP_32_39r_SET(r,d) (r).cmic_sbus_ring_map_32_39[0] = d
#define CMIC_SBUS_RING_MAP_32_39r_GET(r) (r).cmic_sbus_ring_map_32_39[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_32f_GET(r) (((r).cmic_sbus_ring_map_32_39[0]) & 0xf)
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_32f_SET(r,f) (r).cmic_sbus_ring_map_32_39[0]=(((r).cmic_sbus_ring_map_32_39[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_33f_GET(r) ((((r).cmic_sbus_ring_map_32_39[0]) >> 4) & 0xf)
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_33f_SET(r,f) (r).cmic_sbus_ring_map_32_39[0]=(((r).cmic_sbus_ring_map_32_39[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_34f_GET(r) ((((r).cmic_sbus_ring_map_32_39[0]) >> 8) & 0xf)
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_34f_SET(r,f) (r).cmic_sbus_ring_map_32_39[0]=(((r).cmic_sbus_ring_map_32_39[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_35f_GET(r) ((((r).cmic_sbus_ring_map_32_39[0]) >> 12) & 0xf)
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_35f_SET(r,f) (r).cmic_sbus_ring_map_32_39[0]=(((r).cmic_sbus_ring_map_32_39[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_36f_GET(r) ((((r).cmic_sbus_ring_map_32_39[0]) >> 16) & 0xf)
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_36f_SET(r,f) (r).cmic_sbus_ring_map_32_39[0]=(((r).cmic_sbus_ring_map_32_39[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_37f_GET(r) ((((r).cmic_sbus_ring_map_32_39[0]) >> 20) & 0xf)
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_37f_SET(r,f) (r).cmic_sbus_ring_map_32_39[0]=(((r).cmic_sbus_ring_map_32_39[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_38f_GET(r) ((((r).cmic_sbus_ring_map_32_39[0]) >> 24) & 0xf)
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_38f_SET(r,f) (r).cmic_sbus_ring_map_32_39[0]=(((r).cmic_sbus_ring_map_32_39[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_39f_GET(r) ((((r).cmic_sbus_ring_map_32_39[0]) >> 28) & 0xf)
#define CMIC_SBUS_RING_MAP_32_39r_RING_NUM_SBUS_ID_39f_SET(r,f) (r).cmic_sbus_ring_map_32_39[0]=(((r).cmic_sbus_ring_map_32_39[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_SBUS_RING_MAP_32_39.
 */
#define READ_CMIC_SBUS_RING_MAP_32_39r(u,r) bcm5354x_read32(u, CMIC_SBUS_RING_MAP_32_39, &(r._cmic_sbus_ring_map_32_39))
#define WRITE_CMIC_SBUS_RING_MAP_32_39r(u,r) bcm5354x_write32(u, CMIC_SBUS_RING_MAP_32_39, (r._cmic_sbus_ring_map_32_39))

/*******************************************************************************
 * End of 'CMIC_SBUS_RING_MAP_32_39r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SBUS_RING_MAP_40_47
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (40 to 47) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_40 S-bus ring number for agent with S-bus ID  40
 *     RING_NUM_SBUS_ID_41 S-bus ring number for agent with S-bus ID  41
 *     RING_NUM_SBUS_ID_42 S-bus ring number for agent with S-bus ID  42
 *     RING_NUM_SBUS_ID_43 S-bus ring number for agent with S-bus ID  43
 *     RING_NUM_SBUS_ID_44 S-bus ring number for agent with S-bus ID  44
 *     RING_NUM_SBUS_ID_45 S-bus ring number for agent with S-bus ID  45
 *     RING_NUM_SBUS_ID_46 S-bus ring number for agent with S-bus ID  46
 *     RING_NUM_SBUS_ID_47 S-bus ring number for agent with S-bus ID  47
 */
#define CMIC_SBUS_RING_MAP_40_47r_SIZE 4

/* CMIC_SBUS_RING_MAP_40_47r is element of CMIC_SBUS_RING_MAP */

/*
 * This structure should be used to declare and program CMIC_SBUS_RING_MAP_40_47.
 */
typedef union CMIC_SBUS_RING_MAP_40_47r_s {
	uint32 v[1];
	uint32 cmic_sbus_ring_map_40_47[1];
	uint32 _cmic_sbus_ring_map_40_47;
} CMIC_SBUS_RING_MAP_40_47r_t;

#define CMIC_SBUS_RING_MAP_40_47r_CLR(r) (r).cmic_sbus_ring_map_40_47[0] = 0
#define CMIC_SBUS_RING_MAP_40_47r_SET(r,d) (r).cmic_sbus_ring_map_40_47[0] = d
#define CMIC_SBUS_RING_MAP_40_47r_GET(r) (r).cmic_sbus_ring_map_40_47[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_40f_GET(r) (((r).cmic_sbus_ring_map_40_47[0]) & 0xf)
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_40f_SET(r,f) (r).cmic_sbus_ring_map_40_47[0]=(((r).cmic_sbus_ring_map_40_47[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_41f_GET(r) ((((r).cmic_sbus_ring_map_40_47[0]) >> 4) & 0xf)
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_41f_SET(r,f) (r).cmic_sbus_ring_map_40_47[0]=(((r).cmic_sbus_ring_map_40_47[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_42f_GET(r) ((((r).cmic_sbus_ring_map_40_47[0]) >> 8) & 0xf)
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_42f_SET(r,f) (r).cmic_sbus_ring_map_40_47[0]=(((r).cmic_sbus_ring_map_40_47[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_43f_GET(r) ((((r).cmic_sbus_ring_map_40_47[0]) >> 12) & 0xf)
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_43f_SET(r,f) (r).cmic_sbus_ring_map_40_47[0]=(((r).cmic_sbus_ring_map_40_47[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_44f_GET(r) ((((r).cmic_sbus_ring_map_40_47[0]) >> 16) & 0xf)
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_44f_SET(r,f) (r).cmic_sbus_ring_map_40_47[0]=(((r).cmic_sbus_ring_map_40_47[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_45f_GET(r) ((((r).cmic_sbus_ring_map_40_47[0]) >> 20) & 0xf)
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_45f_SET(r,f) (r).cmic_sbus_ring_map_40_47[0]=(((r).cmic_sbus_ring_map_40_47[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_46f_GET(r) ((((r).cmic_sbus_ring_map_40_47[0]) >> 24) & 0xf)
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_46f_SET(r,f) (r).cmic_sbus_ring_map_40_47[0]=(((r).cmic_sbus_ring_map_40_47[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_47f_GET(r) ((((r).cmic_sbus_ring_map_40_47[0]) >> 28) & 0xf)
#define CMIC_SBUS_RING_MAP_40_47r_RING_NUM_SBUS_ID_47f_SET(r,f) (r).cmic_sbus_ring_map_40_47[0]=(((r).cmic_sbus_ring_map_40_47[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_SBUS_RING_MAP_40_47.
 */
#define READ_CMIC_SBUS_RING_MAP_40_47r(u,r) bcm5354x_read32(u, CMIC_SBUS_RING_MAP_40_47, &(r._cmic_sbus_ring_map_40_47))
#define WRITE_CMIC_SBUS_RING_MAP_40_47r(u,r) bcm5354x_write32(u, CMIC_SBUS_RING_MAP_40_47, (r._cmic_sbus_ring_map_40_47))

/*******************************************************************************
 * End of 'CMIC_SBUS_RING_MAP_40_47r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SBUS_RING_MAP_8_15
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents (8 to 15) on all S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_8 S-bus ring number for agent with S-bus ID  8
 *     RING_NUM_SBUS_ID_9 S-bus ring number for agent with S-bus ID  9
 *     RING_NUM_SBUS_ID_10 S-bus ring number for agent with S-bus ID  10
 *     RING_NUM_SBUS_ID_11 S-bus ring number for agent with S-bus ID  11
 *     RING_NUM_SBUS_ID_12 S-bus ring number for agent with S-bus ID  12
 *     RING_NUM_SBUS_ID_13 S-bus ring number for agent with S-bus ID  13
 *     RING_NUM_SBUS_ID_14 S-bus ring number for agent with S-bus ID  14
 *     RING_NUM_SBUS_ID_15 S-bus ring number for agent with S-bus ID  15
 */
#define CMIC_SBUS_RING_MAP_8_15r_SIZE 4

/* CMIC_SBUS_RING_MAP_8_15r is element of CMIC_SBUS_RING_MAP */

/*
 * This structure should be used to declare and program CMIC_SBUS_RING_MAP_8_15.
 */
typedef union CMIC_SBUS_RING_MAP_8_15r_s {
	uint32 v[1];
	uint32 cmic_sbus_ring_map_8_15[1];
	uint32 _cmic_sbus_ring_map_8_15;
} CMIC_SBUS_RING_MAP_8_15r_t;

#define CMIC_SBUS_RING_MAP_8_15r_CLR(r) (r).cmic_sbus_ring_map_8_15[0] = 0
#define CMIC_SBUS_RING_MAP_8_15r_SET(r,d) (r).cmic_sbus_ring_map_8_15[0] = d
#define CMIC_SBUS_RING_MAP_8_15r_GET(r) (r).cmic_sbus_ring_map_8_15[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_8f_GET(r) (((r).cmic_sbus_ring_map_8_15[0]) & 0xf)
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_8f_SET(r,f) (r).cmic_sbus_ring_map_8_15[0]=(((r).cmic_sbus_ring_map_8_15[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_9f_GET(r) ((((r).cmic_sbus_ring_map_8_15[0]) >> 4) & 0xf)
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_9f_SET(r,f) (r).cmic_sbus_ring_map_8_15[0]=(((r).cmic_sbus_ring_map_8_15[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_10f_GET(r) ((((r).cmic_sbus_ring_map_8_15[0]) >> 8) & 0xf)
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_10f_SET(r,f) (r).cmic_sbus_ring_map_8_15[0]=(((r).cmic_sbus_ring_map_8_15[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_11f_GET(r) ((((r).cmic_sbus_ring_map_8_15[0]) >> 12) & 0xf)
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_11f_SET(r,f) (r).cmic_sbus_ring_map_8_15[0]=(((r).cmic_sbus_ring_map_8_15[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_12f_GET(r) ((((r).cmic_sbus_ring_map_8_15[0]) >> 16) & 0xf)
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_12f_SET(r,f) (r).cmic_sbus_ring_map_8_15[0]=(((r).cmic_sbus_ring_map_8_15[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_13f_GET(r) ((((r).cmic_sbus_ring_map_8_15[0]) >> 20) & 0xf)
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_13f_SET(r,f) (r).cmic_sbus_ring_map_8_15[0]=(((r).cmic_sbus_ring_map_8_15[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_14f_GET(r) ((((r).cmic_sbus_ring_map_8_15[0]) >> 24) & 0xf)
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_14f_SET(r,f) (r).cmic_sbus_ring_map_8_15[0]=(((r).cmic_sbus_ring_map_8_15[0] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_15f_GET(r) ((((r).cmic_sbus_ring_map_8_15[0]) >> 28) & 0xf)
#define CMIC_SBUS_RING_MAP_8_15r_RING_NUM_SBUS_ID_15f_SET(r,f) (r).cmic_sbus_ring_map_8_15[0]=(((r).cmic_sbus_ring_map_8_15[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_SBUS_RING_MAP_8_15.
 */
#define READ_CMIC_SBUS_RING_MAP_8_15r(u,r) bcm5354x_read32(u, CMIC_SBUS_RING_MAP_8_15, &(r._cmic_sbus_ring_map_8_15))
#define WRITE_CMIC_SBUS_RING_MAP_8_15r(u,r) bcm5354x_write32(u, CMIC_SBUS_RING_MAP_8_15, (r._cmic_sbus_ring_map_8_15))

/*******************************************************************************
 * End of 'CMIC_SBUS_RING_MAP_8_15r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SBUS_TIMEOUT
 * BLOCKS:   CMIC
 * DESC:     Secret register that allows software to program the
S-bus operation completion time limit (in terms of 
number of core clocks).
If this limit is exceeded, the CMIC will set the SW PIO
"DONE" bit and the "ERROR" bit to indicate the timeout.

 * SIZE:     32
 * FIELDS:
 *     TIMEOUT_VAL      Timeout value in core clocks
 */
#define CMIC_SBUS_TIMEOUTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SBUS_TIMEOUT.
 */
typedef union CMIC_SBUS_TIMEOUTr_s {
	uint32 v[1];
	uint32 cmic_sbus_timeout[1];
	uint32 _cmic_sbus_timeout;
} CMIC_SBUS_TIMEOUTr_t;

#define CMIC_SBUS_TIMEOUTr_CLR(r) (r).cmic_sbus_timeout[0] = 0
#define CMIC_SBUS_TIMEOUTr_SET(r,d) (r).cmic_sbus_timeout[0] = d
#define CMIC_SBUS_TIMEOUTr_GET(r) (r).cmic_sbus_timeout[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET(r) ((r).cmic_sbus_timeout[0])
#define CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET(r,f) (r).cmic_sbus_timeout[0]=((uint32)f)

/*
 * These macros can be used to access CMIC_SBUS_TIMEOUT.
 */
#define READ_CMIC_SBUS_TIMEOUTr(u,r) bcm5354x_read32(u, CMIC_SBUS_TIMEOUT, &(r._cmic_sbus_timeout))
#define WRITE_CMIC_SBUS_TIMEOUTr(u,r) bcm5354x_write32(u, CMIC_SBUS_TIMEOUT, (r._cmic_sbus_timeout))

/*******************************************************************************
 * End of 'CMIC_SBUS_TIMEOUTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SEMAPHORE_1
 * BLOCKS:   CMIC
 * DESC:     Semaphore Test and Set Register
(Internal)0: Unlocked
(Internal)1: Locked
Read returns 0x0: Lock cannot be acquired
Read returns 0x1: Lock has been acquired
To clear the lock, master should write 0x0.
A write of 0x1 has no effect.


 * SIZE:     32
 * FIELDS:
 *     SEMAPHORE        Semaphore Test and Set Bit.
 */
#define CMIC_SEMAPHORE_1r_SIZE 4

/* CMIC_SEMAPHORE_1r is element of CMIC_SEMAPHORE */

/*
 * This structure should be used to declare and program CMIC_SEMAPHORE_1.
 */
typedef union CMIC_SEMAPHORE_1r_s {
	uint32 v[1];
	uint32 cmic_semaphore_1[1];
	uint32 _cmic_semaphore_1;
} CMIC_SEMAPHORE_1r_t;

#define CMIC_SEMAPHORE_1r_CLR(r) (r).cmic_semaphore_1[0] = 0
#define CMIC_SEMAPHORE_1r_SET(r,d) (r).cmic_semaphore_1[0] = d
#define CMIC_SEMAPHORE_1r_GET(r) (r).cmic_semaphore_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SEMAPHORE_1r_SEMAPHOREf_GET(r) (((r).cmic_semaphore_1[0]) & 0x1)
#define CMIC_SEMAPHORE_1r_SEMAPHOREf_SET(r,f) (r).cmic_semaphore_1[0]=(((r).cmic_semaphore_1[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_SEMAPHORE_1.
 */
#define READ_CMIC_SEMAPHORE_1r(u,r) bcm5354x_read32(u, CMIC_SEMAPHORE_1, &(r._cmic_semaphore_1))
#define WRITE_CMIC_SEMAPHORE_1r(u,r) bcm5354x_write32(u, CMIC_SEMAPHORE_1, (r._cmic_semaphore_1))

/*******************************************************************************
 * End of 'CMIC_SEMAPHORE_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SEMAPHORE_1_SHADOW
 * BLOCKS:   CMIC
 * DESC:     Semaphore Test and Set Register (Shadow)
This returns the actual value of the lock
0: Unlocked
1: Locked


 * SIZE:     32
 * FIELDS:
 *     SEMAPHORE        Semaphore Test and Set Bit.
 */
#define CMIC_SEMAPHORE_1_SHADOWr_SIZE 4

/* CMIC_SEMAPHORE_1_SHADOWr is element of CMIC_SEMAPHORE_SHADOW */

/*
 * This structure should be used to declare and program CMIC_SEMAPHORE_1_SHADOW.
 */
typedef union CMIC_SEMAPHORE_1_SHADOWr_s {
	uint32 v[1];
	uint32 cmic_semaphore_1_shadow[1];
	uint32 _cmic_semaphore_1_shadow;
} CMIC_SEMAPHORE_1_SHADOWr_t;

#define CMIC_SEMAPHORE_1_SHADOWr_CLR(r) (r).cmic_semaphore_1_shadow[0] = 0
#define CMIC_SEMAPHORE_1_SHADOWr_SET(r,d) (r).cmic_semaphore_1_shadow[0] = d
#define CMIC_SEMAPHORE_1_SHADOWr_GET(r) (r).cmic_semaphore_1_shadow[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SEMAPHORE_1_SHADOWr_SEMAPHOREf_GET(r) (((r).cmic_semaphore_1_shadow[0]) & 0x1)
#define CMIC_SEMAPHORE_1_SHADOWr_SEMAPHOREf_SET(r,f) (r).cmic_semaphore_1_shadow[0]=(((r).cmic_semaphore_1_shadow[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_SEMAPHORE_1_SHADOW.
 */
#define READ_CMIC_SEMAPHORE_1_SHADOWr(u,r) bcm5354x_read32(u, CMIC_SEMAPHORE_1_SHADOW, &(r._cmic_semaphore_1_shadow))
#define WRITE_CMIC_SEMAPHORE_1_SHADOWr(u,r) bcm5354x_write32(u, CMIC_SEMAPHORE_1_SHADOW, (r._cmic_semaphore_1_shadow))

/*******************************************************************************
 * End of 'CMIC_SEMAPHORE_1_SHADOWr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SEMAPHORE_2
 * BLOCKS:   CMIC
 * DESC:     Semaphore Test and Set Register
(Internal)0: Unlocked
(Internal)1: Locked
Read returns 0x0: Lock cannot be acquired
Read returns 0x1: Lock has been acquired
To clear the lock, master should write 0x0.
A write of 0x1 has no effect.


 * SIZE:     32
 * FIELDS:
 *     SEMAPHORE        Semaphore Test and Set Bit.
 */
#define CMIC_SEMAPHORE_2r_SIZE 4

/* CMIC_SEMAPHORE_2r is element of CMIC_SEMAPHORE */

/*
 * This structure should be used to declare and program CMIC_SEMAPHORE_2.
 */
typedef union CMIC_SEMAPHORE_2r_s {
	uint32 v[1];
	uint32 cmic_semaphore_2[1];
	uint32 _cmic_semaphore_2;
} CMIC_SEMAPHORE_2r_t;

#define CMIC_SEMAPHORE_2r_CLR(r) (r).cmic_semaphore_2[0] = 0
#define CMIC_SEMAPHORE_2r_SET(r,d) (r).cmic_semaphore_2[0] = d
#define CMIC_SEMAPHORE_2r_GET(r) (r).cmic_semaphore_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SEMAPHORE_2r_SEMAPHOREf_GET(r) (((r).cmic_semaphore_2[0]) & 0x1)
#define CMIC_SEMAPHORE_2r_SEMAPHOREf_SET(r,f) (r).cmic_semaphore_2[0]=(((r).cmic_semaphore_2[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_SEMAPHORE_2.
 */
#define READ_CMIC_SEMAPHORE_2r(u,r) bcm5354x_read32(u, CMIC_SEMAPHORE_2, &(r._cmic_semaphore_2))
#define WRITE_CMIC_SEMAPHORE_2r(u,r) bcm5354x_write32(u, CMIC_SEMAPHORE_2, (r._cmic_semaphore_2))

/*******************************************************************************
 * End of 'CMIC_SEMAPHORE_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SEMAPHORE_2_SHADOW
 * BLOCKS:   CMIC
 * DESC:     Semaphore Test and Set Register (Shadow)
This returns the actual value of the lock
0: Unlocked
1: Locked


 * SIZE:     32
 * FIELDS:
 *     SEMAPHORE        Semaphore Test and Set Bit.
 */
#define CMIC_SEMAPHORE_2_SHADOWr_SIZE 4

/* CMIC_SEMAPHORE_2_SHADOWr is element of CMIC_SEMAPHORE_SHADOW */

/*
 * This structure should be used to declare and program CMIC_SEMAPHORE_2_SHADOW.
 */
typedef union CMIC_SEMAPHORE_2_SHADOWr_s {
	uint32 v[1];
	uint32 cmic_semaphore_2_shadow[1];
	uint32 _cmic_semaphore_2_shadow;
} CMIC_SEMAPHORE_2_SHADOWr_t;

#define CMIC_SEMAPHORE_2_SHADOWr_CLR(r) (r).cmic_semaphore_2_shadow[0] = 0
#define CMIC_SEMAPHORE_2_SHADOWr_SET(r,d) (r).cmic_semaphore_2_shadow[0] = d
#define CMIC_SEMAPHORE_2_SHADOWr_GET(r) (r).cmic_semaphore_2_shadow[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SEMAPHORE_2_SHADOWr_SEMAPHOREf_GET(r) (((r).cmic_semaphore_2_shadow[0]) & 0x1)
#define CMIC_SEMAPHORE_2_SHADOWr_SEMAPHOREf_SET(r,f) (r).cmic_semaphore_2_shadow[0]=(((r).cmic_semaphore_2_shadow[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_SEMAPHORE_2_SHADOW.
 */
#define READ_CMIC_SEMAPHORE_2_SHADOWr(u,r) bcm5354x_read32(u, CMIC_SEMAPHORE_2_SHADOW, &(r._cmic_semaphore_2_shadow))
#define WRITE_CMIC_SEMAPHORE_2_SHADOWr(u,r) bcm5354x_write32(u, CMIC_SEMAPHORE_2_SHADOW, (r._cmic_semaphore_2_shadow))

/*******************************************************************************
 * End of 'CMIC_SEMAPHORE_2_SHADOWr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SEMAPHORE_3
 * BLOCKS:   CMIC
 * DESC:     Semaphore Test and Set Register
(Internal)0: Unlocked
(Internal)1: Locked
Read returns 0x0: Lock cannot be acquired
Read returns 0x1: Lock has been acquired
To clear the lock, master should write 0x0.
A write of 0x1 has no effect.


 * SIZE:     32
 * FIELDS:
 *     SEMAPHORE        Semaphore Test and Set Bit.
 */
#define CMIC_SEMAPHORE_3r_SIZE 4

/* CMIC_SEMAPHORE_3r is element of CMIC_SEMAPHORE */

/*
 * This structure should be used to declare and program CMIC_SEMAPHORE_3.
 */
typedef union CMIC_SEMAPHORE_3r_s {
	uint32 v[1];
	uint32 cmic_semaphore_3[1];
	uint32 _cmic_semaphore_3;
} CMIC_SEMAPHORE_3r_t;

#define CMIC_SEMAPHORE_3r_CLR(r) (r).cmic_semaphore_3[0] = 0
#define CMIC_SEMAPHORE_3r_SET(r,d) (r).cmic_semaphore_3[0] = d
#define CMIC_SEMAPHORE_3r_GET(r) (r).cmic_semaphore_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SEMAPHORE_3r_SEMAPHOREf_GET(r) (((r).cmic_semaphore_3[0]) & 0x1)
#define CMIC_SEMAPHORE_3r_SEMAPHOREf_SET(r,f) (r).cmic_semaphore_3[0]=(((r).cmic_semaphore_3[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_SEMAPHORE_3.
 */
#define READ_CMIC_SEMAPHORE_3r(u,r) bcm5354x_read32(u, CMIC_SEMAPHORE_3, &(r._cmic_semaphore_3))
#define WRITE_CMIC_SEMAPHORE_3r(u,r) bcm5354x_write32(u, CMIC_SEMAPHORE_3, (r._cmic_semaphore_3))

/*******************************************************************************
 * End of 'CMIC_SEMAPHORE_3r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CMIC_SEMAPHORE_3_SHADOW
 * BLOCKS:   CMIC
 * DESC:     Semaphore Test and Set Register (Shadow)
This returns the actual value of the lock
0: Unlocked
1: Locked


 * SIZE:     32
 * FIELDS:
 *     SEMAPHORE        Semaphore Test and Set Bit.
 */
#define CMIC_SEMAPHORE_3_SHADOWr_SIZE 4

/* CMIC_SEMAPHORE_3_SHADOWr is element of CMIC_SEMAPHORE_SHADOW */

/*
 * This structure should be used to declare and program CMIC_SEMAPHORE_3_SHADOW.
 */
typedef union CMIC_SEMAPHORE_3_SHADOWr_s {
	uint32 v[1];
	uint32 cmic_semaphore_3_shadow[1];
	uint32 _cmic_semaphore_3_shadow;
} CMIC_SEMAPHORE_3_SHADOWr_t;

#define CMIC_SEMAPHORE_3_SHADOWr_CLR(r) (r).cmic_semaphore_3_shadow[0] = 0
#define CMIC_SEMAPHORE_3_SHADOWr_SET(r,d) (r).cmic_semaphore_3_shadow[0] = d
#define CMIC_SEMAPHORE_3_SHADOWr_GET(r) (r).cmic_semaphore_3_shadow[0]

/*
 * These macros can be used to access individual fields.
 */
#define CMIC_SEMAPHORE_3_SHADOWr_SEMAPHOREf_GET(r) (((r).cmic_semaphore_3_shadow[0]) & 0x1)
#define CMIC_SEMAPHORE_3_SHADOWr_SEMAPHOREf_SET(r,f) (r).cmic_semaphore_3_shadow[0]=(((r).cmic_semaphore_3_shadow[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access CMIC_SEMAPHORE_3_SHADOW.
 */
#define READ_CMIC_SEMAPHORE_3_SHADOWr(u,r) bcm5354x_read32(u, CMIC_SEMAPHORE_3_SHADOW, &(r._cmic_semaphore_3_shadow))
#define WRITE_CMIC_SEMAPHORE_3_SHADOWr(u,r) bcm5354x_write32(u, CMIC_SEMAPHORE_3_SHADOW, (r._cmic_semaphore_3_shadow))

/*******************************************************************************
 * End of 'CMIC_SEMAPHORE_3_SHADOWr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CNGCOSPKTLIMIT0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT0  CNG0 Set Limit for COS n for an egress port.This sets the packet threshold numbers that are allowed for CNG0 packets per egress port of CoS n.When MISCCONIG.CNG_DROP_EN=1, all incoming packets with packet counts above (>=) this threshold and with the following congestion value (CNG[1:0] == 2'b01 => RED) will be dropped. 
 */
#define CNGCOSPKTLIMIT0r_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT0.
 */
typedef union CNGCOSPKTLIMIT0r_s {
	uint32 v[1];
	uint32 cngcospktlimit0[1];
	uint32 _cngcospktlimit0;
} CNGCOSPKTLIMIT0r_t;

#define CNGCOSPKTLIMIT0r_CLR(r) (r).cngcospktlimit0[0] = 0
#define CNGCOSPKTLIMIT0r_SET(r,d) (r).cngcospktlimit0[0] = d
#define CNGCOSPKTLIMIT0r_GET(r) (r).cngcospktlimit0[0]

/*
 * These macros can be used to access individual fields.
 */
#define CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_GET(r) (((r).cngcospktlimit0[0]) & 0x1ff)
#define CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_SET(r,f) (r).cngcospktlimit0[0]=(((r).cngcospktlimit0[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT0.
 */
#define WRITE_CNGCOSPKTLIMIT0r(u,p, cos,r) bcm5354x_reg_set(u, R_CNGCOSPKTLIMIT0(cos,p), (r._cngcospktlimit0))
#define READ_CNGCOSPKTLIMIT0r(u,p, cos,r) bcm5354x_reg_get(u,R_CNGCOSPKTLIMIT0(cos,p),&(r._cngcospktlimit0))

/*******************************************************************************
 * End of 'CNGCOSPKTLIMIT0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CNGCOSPKTLIMIT1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT1  CNG1 Set Limit for COS n for an egress port.This sets the packet threshold numbers that are allowed for CNG1 packets per egress port of COS n.When MISCCONIG.CNG_DROP_EN=1, all incoming packets with packet counts above (>=) this threshold and with the following congestion value (CNG[1:0] == 2'b11 => YELLOW)will be dropped. 
 */
#define CNGCOSPKTLIMIT1r_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT1.
 */
typedef union CNGCOSPKTLIMIT1r_s {
	uint32 v[1];
	uint32 cngcospktlimit1[1];
	uint32 _cngcospktlimit1;
} CNGCOSPKTLIMIT1r_t;

#define CNGCOSPKTLIMIT1r_CLR(r) (r).cngcospktlimit1[0] = 0
#define CNGCOSPKTLIMIT1r_SET(r,d) (r).cngcospktlimit1[0] = d
#define CNGCOSPKTLIMIT1r_GET(r) (r).cngcospktlimit1[0]

/*
 * These macros can be used to access individual fields.
 */
#define CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_GET(r) (((r).cngcospktlimit1[0]) & 0x1ff)
#define CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_SET(r,f) (r).cngcospktlimit1[0]=(((r).cngcospktlimit1[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT1.
 */
#define WRITE_CNGCOSPKTLIMIT1r(u,p, cos,r) bcm5354x_reg_set(u, R_CNGCOSPKTLIMIT1(cos,p), (r._cngcospktlimit1))
#define READ_CNGCOSPKTLIMIT1r(u,p, cos,r) bcm5354x_reg_get(u,R_CNGCOSPKTLIMIT1(cos,p),&(r._cngcospktlimit1))

/*******************************************************************************
 * End of 'CNGCOSPKTLIMIT1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CNGPORTPKTLIMIT0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPORTPKTLIMIT0 CNG0 Set Limit for an egress port.This sets the packet threshold numbers that are allowed for CNG0 packets per egress port. When packet count for an egress port is above (>=) this limit, incoming packet carried congestion color red (CNG[1:0]==2'b01) will be dropped for that port, if that cos is consuming XQ dynamic space. This limit is needed to be set lower than Total XQ size of the same port to ensure dropping CNG0 packet mechanism will take effect early than HOL. 
 */
#define CNGPORTPKTLIMIT0r_SIZE 4

/* CNGPORTPKTLIMIT0r is element of CNGPORTPKTLIMIT */

/*
 * This structure should be used to declare and program CNGPORTPKTLIMIT0.
 */
typedef union CNGPORTPKTLIMIT0r_s {
	uint32 v[1];
	uint32 cngportpktlimit0[1];
	uint32 _cngportpktlimit0;
} CNGPORTPKTLIMIT0r_t;

#define CNGPORTPKTLIMIT0r_CLR(r) (r).cngportpktlimit0[0] = 0
#define CNGPORTPKTLIMIT0r_SET(r,d) (r).cngportpktlimit0[0] = d
#define CNGPORTPKTLIMIT0r_GET(r) (r).cngportpktlimit0[0]

/*
 * These macros can be used to access individual fields.
 */
#define CNGPORTPKTLIMIT0r_CNGPORTPKTLIMIT0f_GET(r) (((r).cngportpktlimit0[0]) & 0x1ff)
#define CNGPORTPKTLIMIT0r_CNGPORTPKTLIMIT0f_SET(r,f) (r).cngportpktlimit0[0]=(((r).cngportpktlimit0[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))

/*
 * These macros can be used to access CNGPORTPKTLIMIT0.
 */
#define WRITE_CNGPORTPKTLIMIT0r(u,p,r) bcm5354x_reg_set(u,R_CNGPORTPKTLIMIT0(p),(r._cngportpktlimit0))
#define READ_CNGPORTPKTLIMIT0r(u,p,r) bcm5354x_reg_get(u,R_CNGPORTPKTLIMIT0(p),&(r._cngportpktlimit0))

/*******************************************************************************
 * End of 'CNGPORTPKTLIMIT0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  CNGPORTPKTLIMIT1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPORTPKTLIMIT1 CNG1 Set Limit for an egress port.This sets the packet threshold numbers that are allowed for CNG1 packets per egress port. When packet count for an egress port is above (>=) this limit, incoming packet carried congestion color yellow (CNG[1:0]==2'b11) will be dropped for that port, if that cos is consuming XQ dynamic space. This limit is needed to be set lower than Total XQ size of the same port to ensure dropping CNG1 packet mechanism will take effect early than HOL. 
 */
#define CNGPORTPKTLIMIT1r_SIZE 4

/* CNGPORTPKTLIMIT1r is element of CNGPORTPKTLIMIT */

/*
 * This structure should be used to declare and program CNGPORTPKTLIMIT1.
 */
typedef union CNGPORTPKTLIMIT1r_s {
	uint32 v[1];
	uint32 cngportpktlimit1[1];
	uint32 _cngportpktlimit1;
} CNGPORTPKTLIMIT1r_t;

#define CNGPORTPKTLIMIT1r_CLR(r) (r).cngportpktlimit1[0] = 0
#define CNGPORTPKTLIMIT1r_SET(r,d) (r).cngportpktlimit1[0] = d
#define CNGPORTPKTLIMIT1r_GET(r) (r).cngportpktlimit1[0]

/*
 * These macros can be used to access individual fields.
 */
#define CNGPORTPKTLIMIT1r_CNGPORTPKTLIMIT1f_GET(r) (((r).cngportpktlimit1[0]) & 0x1ff)
#define CNGPORTPKTLIMIT1r_CNGPORTPKTLIMIT1f_SET(r,f) (r).cngportpktlimit1[0]=(((r).cngportpktlimit1[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))

/*
 * These macros can be used to access CNGPORTPKTLIMIT1.
 */
#define WRITE_CNGPORTPKTLIMIT1r(u,p,r) bcm5354x_reg_set(u,R_CNGPORTPKTLIMIT1(p),(r._cngportpktlimit1))
#define READ_CNGPORTPKTLIMIT1r(u,p,r) bcm5354x_reg_get(u,R_CNGPORTPKTLIMIT1(p),&(r._cngportpktlimit1))

/*******************************************************************************
 * End of 'CNGPORTPKTLIMIT1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  COLOR_DROP_EN
 * BLOCKS:   MMU
 * DESC:     Enable register for queue color discard for color congestion management
 * SIZE:     32
 * FIELDS:
 *     COLOR_DROP_EN    Enable register for queue's color discard for color congestion management0: Disable1: Enable 
 */
#define COLOR_DROP_ENr_SIZE 4

/*
 * This structure should be used to declare and program COLOR_DROP_EN.
 */
typedef union COLOR_DROP_ENr_s {
	uint32 v[1];
	uint32 color_drop_en[1];
	uint32 _color_drop_en;
} COLOR_DROP_ENr_t;

#define COLOR_DROP_ENr_CLR(r) (r).color_drop_en[0] = 0
#define COLOR_DROP_ENr_SET(r,d) (r).color_drop_en[0] = d
#define COLOR_DROP_ENr_GET(r) (r).color_drop_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define COLOR_DROP_ENr_COLOR_DROP_ENf_GET(r) (((r).color_drop_en[0]) & 0xff)
#define COLOR_DROP_ENr_COLOR_DROP_ENf_SET(r,f) (r).color_drop_en[0]=(((r).color_drop_en[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))

/*
 * These macros can be used to access COLOR_DROP_EN.
 */
#define WRITE_COLOR_DROP_ENr(u,p,r) bcm5354x_reg_set(u,R_COLOR_DROP_EN(p),(r._color_drop_en))
#define READ_COLOR_DROP_ENr(u,p,r) bcm5354x_reg_get(u,R_COLOR_DROP_EN(p),&(r._color_drop_en))

/*******************************************************************************
 * End of 'COLOR_DROP_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  COMMAND_CONFIG
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Command register. Used by the host processor to control and configure the core
 * SIZE:     32
 * FIELDS:
 *     TX_ENA           Enable/Disable MAC transmit path for data packets & pause/pfc packets sent in the normal data path.Pause/pfc packets generated internally are allowed if ignore_tx_pause is not set. When set to '0' (Reset value), the MAC transmit function is disable.  When set to '1', the MAC transmit function is enabled.
 *     RX_ENA           Enable/Disable MAC receive path. When set to '0' (Reset value), the MAC receive function is disable.  When set to '1', the MAC receive function is enabled.
 *     ETH_SPEED        Set MAC speed. Ignored when the register bit ENA_EXT_CONFIG is set to '1'.  When the Register bit ENA_EXT_CONFIG is set to '0', used to set the core mode of operation: 00: Enable 10Mbps Ethernet mode 01: Enable 100Mbps Ethernet mode 10: Enable Gigabit Ethernet mode 11: Enable 2.5Gigabit Ethernet mode
 *     PROMIS_EN        Enable/Disable MAC promiscuous operation. When asserted (Set to '1'), all frames are received without Unicast address filtering.
 *     PAD_EN           Enable/Disable Frame Padding. If enabled (Set to '1'), then padding is removed from the received frame before it is transmitted to the userapplication. If disabled (set to reset value '0'), then no padding is removed on receive by the MAC. This bit has no effect on Tx padding and hence Transmit always pad runts to guarantee a minimum frame size of 64 octets.
 *     CRC_FWD          Terminate/Forward Received CRC. If enabled (1) the CRC field of received frames are transmitted to the user application.If disabled (0) the CRC field is stripped from the frame.Note: If padding function (Bit PAD_EN set to '1') is enabled. CRC_FWD is ignored and the CRC field is checked and always terminated and removed.
 *     PAUSE_FWD        Terminate/Forward Pause Frames. If enabled (Set to '1') pause frames are forwarded to the user application.  If disabled (Set to reset value '0'), pause frames are terminated and discarded in the MAC.
 *     PAUSE_IGNORE     Ignore Pause Frame Quanta. If enabled (Set to '1') received pause frames are ignored by the MAC. When disabled (Set to reset value '0') the transmit process is stopped for the amount of time specified in the pause quanta received within the pause frame.
 *     TX_ADDR_INS      Set MAC address on transmit. If enabled (Set to '1') the MAC overwrites the source MAC address with the programmed MAC address in registers MAC_0 and MAC_1. If disabled (Set to reset value '0'), the source MAC address received from the transmit application transmitted is not modified by the MAC.
 *     HD_ENA           Half duplex enable. When set to '1', enables half duplex mode, when set to '0', the MAC operates in full duplex mode.Ignored at ethernet speeds 1G/2.5G or when the register ENA_EXT_CONFIG is set to '1'.
 *     RX_LOW_LATENCY_EN This works only when runt filter is disabled. It reduces the receive latency by 48 MAC clock time.
 *     OVERFLOW_EN      If set, enables Rx FIFO overflow logic. In this case, the RXFIFO_STAT[1] register bit is not operational (always set to 0).If cleared, disables RX FIFO overflow logic. In this case, the RXFIFO_STAT[1] register bit is operational (Sticky set when overrun occurs, clearable only by SW_Reset).
 *     SW_RESET         Software Reset Command. When asserted, the TX and RX are disabled. Config registers are not affected by sw reset. Write a 0 to de-assert the sw reset. 
 *     FCS_CORRUPT_URUN_EN Corrupt Tx FCS, on underrun, when set to '1', No FCS corruption when set to '0' (Reset value).
 *     LOOP_ENA         Enable GMII/MII loopback when set to '1', normal operation when set to '0' (Reset value).
 *     MAC_LOOP_CON     Transmit packets to PHY while in MAC local loopback, when set to '1', otherwise transmit to PHY is disabled (normal operation),when set to '0' (Reset value).
 *     SW_OVERRIDE_TX   If set, enables the SW programmed Tx pause capability config bits to overwrite the auto negotiated Tx pause capabilities when ena_ext_config (autoconfig) is set.If cleared, and when ena_ext_config (autoconfig) is set, then SW programmed Tx pause capability config bits has no effect over auto negotiated capabilities.
 *     SW_OVERRIDE_RX   If set, enables the SW programmed Rx pause capability config bits to overwrite the auto negotiated Rx pause capabilities when ena_ext_config (autoconfig) is set.If cleared, and when ena_ext_config (autoconfig) is set, then SW programmed Rx pause capability config bits has no effect over auto negotiated capabilities.
 *     EN_INTERNAL_TX_CRS If enabled, then CRS input to Unimac is ORed with tds[8] (tx data valid output). This is helpful when TX CRS is disabled inside PHY.
 *     ENA_EXT_CONFIG   Enable Configuration with External Pins. When set to '0' (Reset value) the Core speed and Mode is programmed with the register bits ETH_SPEED(1:0) and HD_ENA. When set to '1', the Core is configured with the pins set_speed(1:0) and set_duplex.
 *     CNTL_FRM_ENA     MAC Control Frame Enable. When set to '1', MAC Control frames with any Opcode other than 0x0001 are accepted and forward to the Client interface. When set to '0' (Reset value), MAC Control frames with any Opcode other than 0x0001 are silently discarded.
 *     NO_LGTH_CHECK    Payload Length Check Disable. When set to '0', the Core checks the frame's payload length with the FrameLength/Type field, when set to '1'(Reset value), the payload length check is disabled.
 *     LINE_LOOPBACK    Enable Line Loopback i.e. MAC FIFO side loopback, when set to '1', normal operation when set to '0' (Reset value).
 *     RX_ERR_DISC      Receive Errored Frame Discard Enable. When set to '1', any frame received with an error is discarded in the Core and not forwarded to the Client interface. When set to '0', errored Frames are forwarded to the Client interface with ff_rx_err asserted.It is recommended to set RX_ERR_DISC to '1' only when Store and Forward operation is enabled on the Core Receive FIFO Receive FIFO Section full threshold set to 0).
 *     FD_TX_URUN_FIX_EN Tx Underflow detection can be improved by accounting for residue bytes in 128b to 8b convertor. The fix is valid only for full duplex mode and can be enabled by setting this bit. 
 *     IGNORE_TX_PAUSE  Ignores the back pressure signaling from the system and hence no Tx pause generation, when set.
 *     OOB_EFC_EN       If set then out-of-band egress flow control is enabled. When this bit is set and input pin ext_tx_flow_control is enabled then data frame trasmission is stopped, whereas Pause & PFC frames are transmitted normally. This operation is similar to halting the transmit datapath due to the reception of a Pause Frame with non-zero timer value, and is used in applications where the flow control information is exchanged out of band. Enabling or disabling this bit has no effect on regular Rx_pause pkt based egress flow control.
 *     RUNT_FILTER_DIS  When set, disable runt filtering.
 */
#define COMMAND_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program COMMAND_CONFIG.
 */
typedef union COMMAND_CONFIGr_s {
	uint32 v[1];
	uint32 command_config[1];
	uint32 _command_config;
} COMMAND_CONFIGr_t;

#define COMMAND_CONFIGr_CLR(r) (r).command_config[0] = 0
#define COMMAND_CONFIGr_SET(r,d) (r).command_config[0] = d
#define COMMAND_CONFIGr_GET(r) (r).command_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define COMMAND_CONFIGr_TX_ENAf_GET(r) (((r).command_config[0]) & 0x1)
#define COMMAND_CONFIGr_TX_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define COMMAND_CONFIGr_RX_ENAf_GET(r) ((((r).command_config[0]) >> 1) & 0x1)
#define COMMAND_CONFIGr_RX_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define COMMAND_CONFIGr_ETH_SPEEDf_GET(r) ((((r).command_config[0]) >> 2) & 0x3)
#define COMMAND_CONFIGr_ETH_SPEEDf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define COMMAND_CONFIGr_PROMIS_ENf_GET(r) ((((r).command_config[0]) >> 4) & 0x1)
#define COMMAND_CONFIGr_PROMIS_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define COMMAND_CONFIGr_PAD_ENf_GET(r) ((((r).command_config[0]) >> 5) & 0x1)
#define COMMAND_CONFIGr_PAD_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define COMMAND_CONFIGr_CRC_FWDf_GET(r) ((((r).command_config[0]) >> 6) & 0x1)
#define COMMAND_CONFIGr_CRC_FWDf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define COMMAND_CONFIGr_PAUSE_FWDf_GET(r) ((((r).command_config[0]) >> 7) & 0x1)
#define COMMAND_CONFIGr_PAUSE_FWDf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define COMMAND_CONFIGr_PAUSE_IGNOREf_GET(r) ((((r).command_config[0]) >> 8) & 0x1)
#define COMMAND_CONFIGr_PAUSE_IGNOREf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define COMMAND_CONFIGr_TX_ADDR_INSf_GET(r) ((((r).command_config[0]) >> 9) & 0x1)
#define COMMAND_CONFIGr_TX_ADDR_INSf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define COMMAND_CONFIGr_HD_ENAf_GET(r) ((((r).command_config[0]) >> 10) & 0x1)
#define COMMAND_CONFIGr_HD_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define COMMAND_CONFIGr_RX_LOW_LATENCY_ENf_GET(r) ((((r).command_config[0]) >> 11) & 0x1)
#define COMMAND_CONFIGr_RX_LOW_LATENCY_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define COMMAND_CONFIGr_OVERFLOW_ENf_GET(r) ((((r).command_config[0]) >> 12) & 0x1)
#define COMMAND_CONFIGr_OVERFLOW_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define COMMAND_CONFIGr_SW_RESETf_GET(r) ((((r).command_config[0]) >> 13) & 0x1)
#define COMMAND_CONFIGr_SW_RESETf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define COMMAND_CONFIGr_FCS_CORRUPT_URUN_ENf_GET(r) ((((r).command_config[0]) >> 14) & 0x1)
#define COMMAND_CONFIGr_FCS_CORRUPT_URUN_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define COMMAND_CONFIGr_LOOP_ENAf_GET(r) ((((r).command_config[0]) >> 15) & 0x1)
#define COMMAND_CONFIGr_LOOP_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define COMMAND_CONFIGr_MAC_LOOP_CONf_GET(r) ((((r).command_config[0]) >> 16) & 0x1)
#define COMMAND_CONFIGr_MAC_LOOP_CONf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define COMMAND_CONFIGr_SW_OVERRIDE_TXf_GET(r) ((((r).command_config[0]) >> 17) & 0x1)
#define COMMAND_CONFIGr_SW_OVERRIDE_TXf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define COMMAND_CONFIGr_SW_OVERRIDE_RXf_GET(r) ((((r).command_config[0]) >> 18) & 0x1)
#define COMMAND_CONFIGr_SW_OVERRIDE_RXf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define COMMAND_CONFIGr_EN_INTERNAL_TX_CRSf_GET(r) ((((r).command_config[0]) >> 21) & 0x1)
#define COMMAND_CONFIGr_EN_INTERNAL_TX_CRSf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define COMMAND_CONFIGr_ENA_EXT_CONFIGf_GET(r) ((((r).command_config[0]) >> 22) & 0x1)
#define COMMAND_CONFIGr_ENA_EXT_CONFIGf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define COMMAND_CONFIGr_CNTL_FRM_ENAf_GET(r) ((((r).command_config[0]) >> 23) & 0x1)
#define COMMAND_CONFIGr_CNTL_FRM_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define COMMAND_CONFIGr_NO_LGTH_CHECKf_GET(r) ((((r).command_config[0]) >> 24) & 0x1)
#define COMMAND_CONFIGr_NO_LGTH_CHECKf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define COMMAND_CONFIGr_LINE_LOOPBACKf_GET(r) ((((r).command_config[0]) >> 25) & 0x1)
#define COMMAND_CONFIGr_LINE_LOOPBACKf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define COMMAND_CONFIGr_RX_ERR_DISCf_GET(r) ((((r).command_config[0]) >> 26) & 0x1)
#define COMMAND_CONFIGr_RX_ERR_DISCf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define COMMAND_CONFIGr_FD_TX_URUN_FIX_ENf_GET(r) ((((r).command_config[0]) >> 27) & 0x1)
#define COMMAND_CONFIGr_FD_TX_URUN_FIX_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define COMMAND_CONFIGr_IGNORE_TX_PAUSEf_GET(r) ((((r).command_config[0]) >> 28) & 0x1)
#define COMMAND_CONFIGr_IGNORE_TX_PAUSEf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define COMMAND_CONFIGr_OOB_EFC_ENf_GET(r) ((((r).command_config[0]) >> 29) & 0x1)
#define COMMAND_CONFIGr_OOB_EFC_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define COMMAND_CONFIGr_RUNT_FILTER_DISf_GET(r) ((((r).command_config[0]) >> 30) & 0x1)
#define COMMAND_CONFIGr_RUNT_FILTER_DISf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))

/*
 * These macros can be used to access COMMAND_CONFIG.
 */
#define WRITE_COMMAND_CONFIGr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_COMMAND_CONFIG(bcm5354x_gport_lport_to_index_in_block[p]), (r._command_config))
#define READ_COMMAND_CONFIGr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_COMMAND_CONFIG(bcm5354x_gport_lport_to_index_in_block[p]), &(r._command_config))

/*******************************************************************************
 * End of 'COMMAND_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  COSLCCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     LCCOUNT          This indicates the number of cells enqueued for an egress port of COS n. 
 */
#define COSLCCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program COSLCCOUNT.
 */
typedef union COSLCCOUNTr_s {
	uint32 v[1];
	uint32 coslccount[1];
	uint32 _coslccount;
} COSLCCOUNTr_t;

#define COSLCCOUNTr_CLR(r) (r).coslccount[0] = 0
#define COSLCCOUNTr_SET(r,d) (r).coslccount[0] = d
#define COSLCCOUNTr_GET(r) (r).coslccount[0]

/*
 * These macros can be used to access individual fields.
 */
#define COSLCCOUNTr_LCCOUNTf_GET(r) (((r).coslccount[0]) & 0xfff)
#define COSLCCOUNTr_LCCOUNTf_SET(r,f) (r).coslccount[0]=(((r).coslccount[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))

/*
 * These macros can be used to access COSLCCOUNT.
 */
#define WRITE_COSLCCOUNTr(u,p, cos,r) bcm5354x_reg_set(u, R_COSLCCOUNT(cos,p), (r._coslccount))
#define READ_COSLCCOUNTr(u,p, cos,r) bcm5354x_reg_get(u,R_COSLCCOUNT(cos,p),&(r._coslccount))

/*******************************************************************************
 * End of 'COSLCCOUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  COS_MAP
 * BLOCKS:   IPIPE
 * DESC:     This table allows per ingress port priorities to be mapped to egress queues. This table is indexed by {COS_MAP_SEL.SELECT[1:0], ingress port internal priority[3:0]}
 * SIZE:     8
 * FIELDS:
 *     COS              8 CoS for Front Panel ports 
 */
#define COS_MAPm_MIN 0
#define COS_MAPm_MAX 63
#define COS_MAPm_CMAX(u) 63
#define COS_MAPm_SIZE 1

/*
 * This structure should be used to declare and program COS_MAP.
 */
typedef union COS_MAPm_s {
	uint32 v[1];
	uint32 cos_map[1];
	uint32 _cos_map;
} COS_MAPm_t;

#define COS_MAPm_CLR(r) (r).cos_map[0] = 0
#define COS_MAPm_SET(r,d) (r).cos_map[0] = d
#define COS_MAPm_GET(r) (r).cos_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define COS_MAPm_COSf_GET(r) (((r).cos_map[0]) & 0x7)
#define COS_MAPm_COSf_SET(r,f) (r).cos_map[0]=(((r).cos_map[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))

/*
 * These macros can be used to access COS_MAP.
 */
#define WRITE_COS_MAPm(u,i,r) bcm5354x_mem_set(u, M_COS_MAP(i), &(r._cos_map), 1)
#define READ_COS_MAPm(u,i,r) bcm5354x_mem_get(u, M_COS_MAP(i), &(r._cos_map), 1)

/*******************************************************************************
 * End of 'COS_MAPm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  ChipcommonG_MII_Management_Command_Data
 * BLOCKS:   IPROC
 * DESC:     This registers defines the data that is to be exchanged with the addressed PHY. 

 * SIZE:     32
 * FIELDS:
 *     DATA             Upon completion of a read operation, hardware updates this field with the data read from the target PHY. Prior to initiation of a write operation, software updates this field with the data intended for a target PHY. 
 *     TA               Turn around time in MII Mgt cycles between PHY accesses. This must be programmed to 10 to generate a valid MII Mgt Frame. 
 *     RA               PHY Register Address. The register inside the targeted PHY that is to be accessed. 
 *     PA               PHY Address. The particular PHY on the MII Mgt bus that is to be addressed.  To access the USB PHY, this value must be set to 2b01 
 *     OP               Command opcode. 10 is read, 01 is write. 
 *     SB               Start bits. A 01 indicates start of frame to MII Mgt slave devices.
 */
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_SIZE 4

/*
 * This structure should be used to declare and program ChipcommonG_MII_Management_Command_Data.
 */
typedef union CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_s {
	uint32 v[1];
	uint32 chipcommong_mii_management_command_data[1];
	uint32 _chipcommong_mii_management_command_data;
} CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_t;

#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_CLR(r) (r).chipcommong_mii_management_command_data[0] = 0
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_SET(r,d) (r).chipcommong_mii_management_command_data[0] = d
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_GET(r) (r).chipcommong_mii_management_command_data[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_DATAf_GET(r) (((r).chipcommong_mii_management_command_data[0]) & 0xffff)
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_DATAf_SET(r,f) (r).chipcommong_mii_management_command_data[0]=(((r).chipcommong_mii_management_command_data[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_TAf_GET(r) ((((r).chipcommong_mii_management_command_data[0]) >> 16) & 0x3)
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_TAf_SET(r,f) (r).chipcommong_mii_management_command_data[0]=(((r).chipcommong_mii_management_command_data[0] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_RAf_GET(r) ((((r).chipcommong_mii_management_command_data[0]) >> 18) & 0x1f)
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_RAf_SET(r,f) (r).chipcommong_mii_management_command_data[0]=(((r).chipcommong_mii_management_command_data[0] & ~((uint32)0x1f << 18)) | ((((uint32)f) & 0x1f) << 18))
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_PAf_GET(r) ((((r).chipcommong_mii_management_command_data[0]) >> 23) & 0x1f)
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_PAf_SET(r,f) (r).chipcommong_mii_management_command_data[0]=(((r).chipcommong_mii_management_command_data[0] & ~((uint32)0x1f << 23)) | ((((uint32)f) & 0x1f) << 23))
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_OPf_GET(r) ((((r).chipcommong_mii_management_command_data[0]) >> 28) & 0x3)
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_OPf_SET(r,f) (r).chipcommong_mii_management_command_data[0]=(((r).chipcommong_mii_management_command_data[0] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_SBf_GET(r) ((((r).chipcommong_mii_management_command_data[0]) >> 30) & 0x3)
#define CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr_SBf_SET(r,f) (r).chipcommong_mii_management_command_data[0]=(((r).chipcommong_mii_management_command_data[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))

/*
 * These macros can be used to access ChipcommonG_MII_Management_Command_Data.
 */
#define READ_CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr(u,r) bcm5354x_read32(u, R_CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATA, &(r._chipcommong_mii_management_command_data))
#define WRITE_CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr(u,r) bcm5354x_write32(u, R_CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATA, (r._chipcommong_mii_management_command_data))

/*******************************************************************************
 * End of 'CHIPCOMMONG_MII_MANAGEMENT_COMMAND_DATAr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  ChipcommonG_MII_Management_Control
 * BLOCKS:   IPROC
 * DESC:     Configuration of the PHY is done via an internal MII Management interface. Care must be taken with the MDCDIV value to ensure the resultant MDIO Clock (MDC) does not exceed 2.5MHz

 * SIZE:     32
 * FIELDS:
 *     MDCDIV           MII Mgt Clock (MDC) Divisor. 0x0: Disable output of the MDC Non-zero: Output the MDC with a frequencythat is PCLK/(2* the value of this field). 
 *     PRE              When set, a preamble sequence of 32 consecutive 1s is prepended to each MII Mgt read or write operation. 0 No preamble 1 Send preamble sequence prior to MII Mgt frame 
 *     BSY              The MII Mgt Interface is busy, software should not access MIICMD. 0 MII Mgt Interface is idle 1 MII Mgt Interface is busy, writes to MIICMD could interrupt current access. 
 *     EXT              When set, MII Management Interface is directed to external MDIO pins. This bit is ignored if MIIMGT[BYP] is set. 0 MII Mgt Interface connected to on-chip PHYs 1 MII Mgt Interface connected to external MDIO pins. Communication with internal PHYs is disabled. 
 *     BYP              When set, an external MDIO master is used and the MMI is bypassed. This bit overides the setting of MIIMGT[EXT]. 0 MDIO Master is the MMI Block 1 MMI is disabled and the on chip PHYs are driven by an external MDIO master 
 */
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program ChipcommonG_MII_Management_Control.
 */
typedef union CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_s {
	uint32 v[1];
	uint32 chipcommong_mii_management_control[1];
	uint32 _chipcommong_mii_management_control;
} CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_t;

#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_CLR(r) (r).chipcommong_mii_management_control[0] = 0
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_SET(r,d) (r).chipcommong_mii_management_control[0] = d
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_GET(r) (r).chipcommong_mii_management_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_MDCDIVf_GET(r) (((r).chipcommong_mii_management_control[0]) & 0x7f)
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_MDCDIVf_SET(r,f) (r).chipcommong_mii_management_control[0]=(((r).chipcommong_mii_management_control[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_PREf_GET(r) ((((r).chipcommong_mii_management_control[0]) >> 7) & 0x1)
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_PREf_SET(r,f) (r).chipcommong_mii_management_control[0]=(((r).chipcommong_mii_management_control[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_BSYf_GET(r) ((((r).chipcommong_mii_management_control[0]) >> 8) & 0x1)
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_BSYf_SET(r,f) (r).chipcommong_mii_management_control[0]=(((r).chipcommong_mii_management_control[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_EXTf_GET(r) ((((r).chipcommong_mii_management_control[0]) >> 9) & 0x1)
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_EXTf_SET(r,f) (r).chipcommong_mii_management_control[0]=(((r).chipcommong_mii_management_control[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_BYPf_GET(r) ((((r).chipcommong_mii_management_control[0]) >> 10) & 0x1)
#define CHIPCOMMONG_MII_MANAGEMENT_CONTROLr_BYPf_SET(r,f) (r).chipcommong_mii_management_control[0]=(((r).chipcommong_mii_management_control[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))

/*
 * These macros can be used to access ChipcommonG_MII_Management_Control.
 */
#define READ_CHIPCOMMONG_MII_MANAGEMENT_CONTROLr(u,r) bcm5354x_read32(u, R_CHIPCOMMONG_MII_MANAGEMENT_CONTROL, &(r._chipcommong_mii_management_control))
#define WRITE_CHIPCOMMONG_MII_MANAGEMENT_CONTROLr(u,r) bcm5354x_write32(u, R_CHIPCOMMONG_MII_MANAGEMENT_CONTROL, (r._chipcommong_mii_management_control))

/*******************************************************************************
 * End of 'CHIPCOMMONG_MII_MANAGEMENT_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  DMU_CRU_RESET
 * BLOCKS:   IPROC
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SW_RESET_N       Switch/CMICd reset. This includes top registers. (self-clear)
 *     IPROC_RESET_N    iProc only reset. (self-clear)
 */
#define DMU_CRU_RESETr_SIZE 4

/*
 * This structure should be used to declare and program DMU_CRU_RESET.
 */
typedef union DMU_CRU_RESETr_s {
	uint32 v[1];
	uint32 dmu_cru_reset[1];
	uint32 _dmu_cru_reset;
} DMU_CRU_RESETr_t;

#define DMU_CRU_RESETr_CLR(r) (r).dmu_cru_reset[0] = 0
#define DMU_CRU_RESETr_SET(r,d) (r).dmu_cru_reset[0] = d
#define DMU_CRU_RESETr_GET(r) (r).dmu_cru_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define DMU_CRU_RESETr_SW_RESET_Nf_GET(r) (((r).dmu_cru_reset[0]) & 0x1)
#define DMU_CRU_RESETr_SW_RESET_Nf_SET(r,f) (r).dmu_cru_reset[0]=(((r).dmu_cru_reset[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define DMU_CRU_RESETr_IPROC_RESET_Nf_GET(r) ((((r).dmu_cru_reset[0]) >> 1) & 0x1)
#define DMU_CRU_RESETr_IPROC_RESET_Nf_SET(r,f) (r).dmu_cru_reset[0]=(((r).dmu_cru_reset[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access DMU_CRU_RESET.
 */
#define READ_DMU_CRU_RESETr(u,r) bcm5354x_read32(u, R_DMU_CRU_RESET, &(r._dmu_cru_reset))
#define WRITE_DMU_CRU_RESETr(u,r) bcm5354x_write32(u, R_DMU_CRU_RESET, (r._dmu_cru_reset))

/*******************************************************************************
 * End of 'DMU_CRU_RESETr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  DOS_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     DOS (Denial of Service) Attack Control Register
 * SIZE:     32
 * FIELDS:
 *     IPV4_FIRST_FRAG_CHECK_ENABLE If set to 1, enable checking DOS attacks on IP first fragments for both IPv4 and IPv6 packets.
 *     IP_FIRST_FRAG_CHECK_ENABLE If set to 1, enable checking DOS attacks on IP first fragments for both IPv4 and IPv6.
 *     BIG_ICMP_PKT_SIZE Maximum length ICMP packet allowed before dropping (maximum 16k bytes)
 *     MIN_TCPHDR_SIZE  Minimum TCP header length allowed (minimum 0 bytes, maximum 255 bytes)
 *     DROP_IF_SIP_EQUALS_DIP If set to 1, drop IPv4/IPv6 packets if the SIP == DIP
 *     MACSA_EQUALS_MACDA_DROP If set to 1, drop packets with MACSA == MACDA
 *     TCP_FLAGS_SYN_FRAG_ENABLE If set to 1, enable dropping of TCP SYN Packets with Source Port 0-1023. It applies to unfragmented packets and IPv4 first fragments (if DOS_CONTROL.IPV4_FIRST_FRAG_CHECK_ENABLE = 1) 
 *     TCP_FLAGS_CTRL0_SEQ0_ENABLE If set to 1, TCP Packets with control flags == 0 AND sequence number == 0 will be dropped
 */
#define DOS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program DOS_CONTROL.
 */
typedef union DOS_CONTROLr_s {
	uint32 v[1];
	uint32 dos_control[1];
	uint32 _dos_control;
} DOS_CONTROLr_t;

#define DOS_CONTROLr_CLR(r) (r).dos_control[0] = 0
#define DOS_CONTROLr_SET(r,d) (r).dos_control[0] = d
#define DOS_CONTROLr_GET(r) (r).dos_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET(r) (((r).dos_control[0]) & 0x1)
#define DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define DOS_CONTROLr_IP_FIRST_FRAG_CHECK_ENABLEf_GET(r) (((r).dos_control[0]) & 0x1)
#define DOS_CONTROLr_IP_FIRST_FRAG_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_GET(r) ((((r).dos_control[0]) >> 1) & 0xffff)
#define DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0xffff << 1)) | ((((uint32)f) & 0xffff) << 1))
#define DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET(r) ((((r).dos_control[0]) >> 17) & 0xff)
#define DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0xff << 17)) | ((((uint32)f) & 0xff) << 17))
#define DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET(r) ((((r).dos_control[0]) >> 25) & 0x1)
#define DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_GET(r) ((((r).dos_control[0]) >> 26) & 0x1)
#define DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_GET(r) ((((r).dos_control[0]) >> 27) & 0x1)
#define DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_GET(r) ((((r).dos_control[0]) >> 28) & 0x1)
#define DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))

/*
 * These macros can be used to access DOS_CONTROL.
 */
#define WRITE_DOS_CONTROLr(u,r) bcm5354x_reg_set(u,R_DOS_CONTROL,(r._dos_control))
#define READ_DOS_CONTROLr(u,r) bcm5354x_reg_get(u,R_DOS_CONTROL,&(r._dos_control))

/*******************************************************************************
 * End of 'DOS_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  DOS_CONTROL2
 * BLOCKS:   IPIPE
 * DESC:     DOS (Denial of Service) Attack Control Register 2
 * SIZE:     32
 * FIELDS:
 *     BIG_ICMPV6_PKT_SIZE Maximum length ICMPv6 ping packet allowed before dropping (maximum 16k bytes)
 *     TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLE If set to 1, TCP packets with FIN, URG and PSH bits set AND seq. number == 0 are dropped
 *     TCP_FLAGS_SYN_FIN_ENABLE If set to 1, TCP packets with SYN & FIN bits set are dropped
 *     TCP_SPORT_EQ_DPORT_ENABLE If set to 1, BLAT - TCP packets with SPORT = DPORT are dropped
 *     UDP_SPORT_EQ_DPORT_ENABLE If set to 1, BLAT - UDP packets with SPORT = DPORT are dropped
 *     TCP_HDR_PARTIAL_ENABLE If set to 1, FIRST TCP fragments that have a TCP header smaller than DOS_CONTROL.MIN_TCPHDR_SIZE are dropped.
 *     TCP_HDR_OFFSET_EQ1_ENABLE If set to 1, TCP fragments with offset value of 1 are dropped. Fragment offset values are programmed in 8byte increments. The value of 1 means 8bytes
 *     ICMP_V6_PING_SIZE_ENABLE If set to 1, ICMPv6 ping packets with payload size greater than the programmable value in DOS_CONTROL.BIG_ICMP_PKT_SIZE.
 *     ICMP_V4_PING_SIZE_ENABLE If set to 1, ICMPv4 ping packets with payload size greater than the programmable value in DOS_CONTROL.BIG_ICMP_PKT_SIZE
 *     ICMP_FRAG_PKTS_ENABLE If set to 1, fragmented ICMP packets will be dropped
 *     IPV6_MIN_FRAG_SIZE_ENABLE Check for minimum size of IPV6 fragments. See also register IPV6_MIN_FRAG_SIZE.
 */
#define DOS_CONTROL2r_SIZE 4

/*
 * This structure should be used to declare and program DOS_CONTROL2.
 */
typedef union DOS_CONTROL2r_s {
	uint32 v[1];
	uint32 dos_control2[1];
	uint32 _dos_control2;
} DOS_CONTROL2r_t;

#define DOS_CONTROL2r_CLR(r) (r).dos_control2[0] = 0
#define DOS_CONTROL2r_SET(r,d) (r).dos_control2[0] = d
#define DOS_CONTROL2r_GET(r) (r).dos_control2[0]

/*
 * These macros can be used to access individual fields.
 */
#define DOS_CONTROL2r_BIG_ICMPV6_PKT_SIZEf_GET(r) (((r).dos_control2[0]) & 0xffff)
#define DOS_CONTROL2r_BIG_ICMPV6_PKT_SIZEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define DOS_CONTROL2r_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 16) & 0x1)
#define DOS_CONTROL2r_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define DOS_CONTROL2r_TCP_FLAGS_SYN_FIN_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 17) & 0x1)
#define DOS_CONTROL2r_TCP_FLAGS_SYN_FIN_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define DOS_CONTROL2r_TCP_SPORT_EQ_DPORT_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 18) & 0x1)
#define DOS_CONTROL2r_TCP_SPORT_EQ_DPORT_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define DOS_CONTROL2r_UDP_SPORT_EQ_DPORT_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 19) & 0x1)
#define DOS_CONTROL2r_UDP_SPORT_EQ_DPORT_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define DOS_CONTROL2r_TCP_HDR_PARTIAL_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 20) & 0x1)
#define DOS_CONTROL2r_TCP_HDR_PARTIAL_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define DOS_CONTROL2r_TCP_HDR_OFFSET_EQ1_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 21) & 0x1)
#define DOS_CONTROL2r_TCP_HDR_OFFSET_EQ1_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define DOS_CONTROL2r_ICMP_V6_PING_SIZE_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 22) & 0x1)
#define DOS_CONTROL2r_ICMP_V6_PING_SIZE_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define DOS_CONTROL2r_ICMP_V4_PING_SIZE_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 23) & 0x1)
#define DOS_CONTROL2r_ICMP_V4_PING_SIZE_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define DOS_CONTROL2r_ICMP_FRAG_PKTS_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 24) & 0x1)
#define DOS_CONTROL2r_ICMP_FRAG_PKTS_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define DOS_CONTROL2r_IPV6_MIN_FRAG_SIZE_ENABLEf_GET(r) ((((r).dos_control2[0]) >> 25) & 0x1)
#define DOS_CONTROL2r_IPV6_MIN_FRAG_SIZE_ENABLEf_SET(r,f) (r).dos_control2[0]=(((r).dos_control2[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))

/*
 * These macros can be used to access DOS_CONTROL2.
 */
#define WRITE_DOS_CONTROL2r(u,r) bcm5354x_reg_set(u,R_DOS_CONTROL2,(r._dos_control2))
#define READ_DOS_CONTROL2r(u,r) bcm5354x_reg_get(u,R_DOS_CONTROL2,&(r._dos_control2))

/*******************************************************************************
 * End of 'DOS_CONTROL2r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  DSCP_TB
 * BLOCKS:   IPIPE
 * DESC:     Diff Serv Code Point Table
This table provides the ability to reassign the DSCP value of the incoming packet to the new DSCP/PRI/CNG values. This table is enabled when ingress port has TRUST_DSCP_V4 or V6 value set to 1 in the PORT table. When this table is used, its values will override the ING_PRI_CNG_MAP and CNG_MAP tables. This table is indexed by the ingress port and packet DSCP.
 * SIZE:     11
 * FIELDS:
 *     DSCP             New Diff Serv Code Point
 *     PRI              Priority
 *     CNG              Congestion bits
 */
#define DSCP_TBm_MIN 0
#define DSCP_TBm_MAX 2047
#define DSCP_TBm_CMAX(u) 2047
#define DSCP_TBm_SIZE 2

/*
 * This structure should be used to declare and program DSCP_TB.
 */
typedef union DSCP_TBm_s {
	uint32 v[1];
	uint32 dscp_tb[1];
	uint32 _dscp_tb;
} DSCP_TBm_t;

#define DSCP_TBm_CLR(r) (r).dscp_tb[0] = 0
#define DSCP_TBm_SET(r,d) (r).dscp_tb[0] = d
#define DSCP_TBm_GET(r) (r).dscp_tb[0]

/*
 * These macros can be used to access individual fields.
 */
#define DSCP_TBm_DSCPf_GET(r) (((r).dscp_tb[0]) & 0x3f)
#define DSCP_TBm_DSCPf_SET(r,f) (r).dscp_tb[0]=(((r).dscp_tb[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define DSCP_TBm_PRIf_GET(r) ((((r).dscp_tb[0]) >> 6) & 0x7)
#define DSCP_TBm_PRIf_SET(r,f) (r).dscp_tb[0]=(((r).dscp_tb[0] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define DSCP_TBm_CNGf_GET(r) ((((r).dscp_tb[0]) >> 9) & 0x3)
#define DSCP_TBm_CNGf_SET(r,f) (r).dscp_tb[0]=(((r).dscp_tb[0] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))

/*
 * These macros can be used to access DSCP_TB.
 */
#define WRITE_DSCP_TBm(u,i,r) bcm5354x_mem_set(u, M_DSCP_TB(i), &(r._dscp_tb), 1)
#define READ_DSCP_TBm(u,i,r) bcm5354x_mem_get(u, M_DSCP_TB(i), &(r._dscp_tb), 1)

/*******************************************************************************
 * End of 'DSCP_TBm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  DYNCELLLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNCELLSETLIMIT  This field specifies the number of cells a port may utilize from the dynamic memory pool.When the following conditions are met, it will set this queue's HOL status and stop admitting any new coming cells. ( ( DYNCELLCOUNT(port) >= DYNCELLLIMIT.DYNCELLLIMIT(port) ) OR ( TOTALDYNCELLUSED >= TOTALDYNCELLLIMIT.SETLIMIT ) ) AND ( COSLCCOUNT(port, cos) >=LWMCOSCELLSETLIMIT.CELLSETLIMIT(port, cos) ) 
 *     DYNCELLRESETLIMIT This field indicates the level at which buffer utilization in terms of cells must drop below before traffic is allowed to resume from HOL blocking state.To reset a cos queue's HOL status, it needs to meet following conditions ( ( DYNCELLCOUNT(port) < DYNCELLLIMIT.RESETLIMIT (port) ) AND ( TOTALDYNCELLUSED < TOTALDYNCELLRESETLIMIT.RESETLIMIT ) ) OR ( COSLCCOUNT(port, cos) <LWMCOSCELLSETLIMIT.RESETLIMIT(port, cos) ) 
 */
#define DYNCELLLIMITr_SIZE 4

/*
 * This structure should be used to declare and program DYNCELLLIMIT.
 */
typedef union DYNCELLLIMITr_s {
	uint32 v[1];
	uint32 dyncelllimit[1];
	uint32 _dyncelllimit;
} DYNCELLLIMITr_t;

#define DYNCELLLIMITr_CLR(r) (r).dyncelllimit[0] = 0
#define DYNCELLLIMITr_SET(r,d) (r).dyncelllimit[0] = d
#define DYNCELLLIMITr_GET(r) (r).dyncelllimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define DYNCELLLIMITr_DYNCELLSETLIMITf_GET(r) (((r).dyncelllimit[0]) & 0xfff)
#define DYNCELLLIMITr_DYNCELLSETLIMITf_SET(r,f) (r).dyncelllimit[0]=(((r).dyncelllimit[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define DYNCELLLIMITr_DYNCELLRESETLIMITf_GET(r) ((((r).dyncelllimit[0]) >> 12) & 0xfff)
#define DYNCELLLIMITr_DYNCELLRESETLIMITf_SET(r,f) (r).dyncelllimit[0]=(((r).dyncelllimit[0] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))

/*
 * These macros can be used to access DYNCELLLIMIT.
 */
#define WRITE_DYNCELLLIMITr(u,p,r) bcm5354x_reg_set(u,R_DYNCELLLIMIT(p),(r._dyncelllimit))
#define READ_DYNCELLLIMITr(u,p,r) bcm5354x_reg_get(u,R_DYNCELLLIMIT(p),&(r._dyncelllimit))

/*******************************************************************************
 * End of 'DYNCELLLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  DYNRESETLIMPORT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNRESETLIMPORT  Dynamic reset limit for HOLWhen (DYNPKTCNTPORT >= DYNXQCNTPORT) the COS queues which are using pointers from the dynamic XQ pool and (COSPKTCOUNT>HOLCOSMINXQCNT) will be put into HOL blocking state.The HOL blocking state will be cleared once DYNPKTCNTPORT has fallen below the DYNRESETLIMPORT value. 
 */
#define DYNRESETLIMPORTr_SIZE 4

/*
 * This structure should be used to declare and program DYNRESETLIMPORT.
 */
typedef union DYNRESETLIMPORTr_s {
	uint32 v[1];
	uint32 dynresetlimport[1];
	uint32 _dynresetlimport;
} DYNRESETLIMPORTr_t;

#define DYNRESETLIMPORTr_CLR(r) (r).dynresetlimport[0] = 0
#define DYNRESETLIMPORTr_SET(r,d) (r).dynresetlimport[0] = d
#define DYNRESETLIMPORTr_GET(r) (r).dynresetlimport[0]

/*
 * These macros can be used to access individual fields.
 */
#define DYNRESETLIMPORTr_DYNRESETLIMPORTf_GET(r) (((r).dynresetlimport[0]) & 0x1ff)
#define DYNRESETLIMPORTr_DYNRESETLIMPORTf_SET(r,f) (r).dynresetlimport[0]=(((r).dynresetlimport[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))

/*
 * These macros can be used to access DYNRESETLIMPORT.
 */
#define WRITE_DYNRESETLIMPORTr(u,p,r) bcm5354x_reg_set(u,R_DYNRESETLIMPORT(p),(r._dynresetlimport))
#define READ_DYNRESETLIMPORTr(u,p,r) bcm5354x_reg_get(u,R_DYNRESETLIMPORT(p),&(r._dynresetlimport))

/*******************************************************************************
 * End of 'DYNRESETLIMPORTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  DYNXQCNTPORT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNXQCNTPORT     Number of dynamic XQ pointers per egress port.When dynamic XQ mode is enabled program this field to: Size of XQ(port) - MISCCONFIG.SKIDMARKER - (Sum of all HOLCOSMINXQCNT) - 9 When dynamic XQ mode is not used program this field to 0. In order to make use of the dynamic XQ pointers the HOLCOSPKTSETLIMIT.PKTSETLIMIT must be greater than the HOLCOSMINXQCNT setting. When (DYNPKTCNTPORT >= DYNXQCNTPORT) the COS queues which are using pointers from the dynamic XQ pool and (COSPKTCOUNT>HOLCOSMINXQCNT) will be put into HOL blocking state. The HOL blocking state will be cleared once DYNPKTCNTPORT has fallen below the DYNRESETLIMPORT value. 
 */
#define DYNXQCNTPORTr_SIZE 4

/*
 * This structure should be used to declare and program DYNXQCNTPORT.
 */
typedef union DYNXQCNTPORTr_s {
	uint32 v[1];
	uint32 dynxqcntport[1];
	uint32 _dynxqcntport;
} DYNXQCNTPORTr_t;

#define DYNXQCNTPORTr_CLR(r) (r).dynxqcntport[0] = 0
#define DYNXQCNTPORTr_SET(r,d) (r).dynxqcntport[0] = d
#define DYNXQCNTPORTr_GET(r) (r).dynxqcntport[0]

/*
 * These macros can be used to access individual fields.
 */
#define DYNXQCNTPORTr_DYNXQCNTPORTf_GET(r) (((r).dynxqcntport[0]) & 0x1ff)
#define DYNXQCNTPORTr_DYNXQCNTPORTf_SET(r,f) (r).dynxqcntport[0]=(((r).dynxqcntport[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))

/*
 * These macros can be used to access DYNXQCNTPORT.
 */
#define WRITE_DYNXQCNTPORTr(u,p,r) bcm5354x_reg_set(u,R_DYNXQCNTPORT(p),(r._dynxqcntport))
#define READ_DYNXQCNTPORTr(u,p,r) bcm5354x_reg_get(u,R_DYNXQCNTPORT(p),&(r._dynxqcntport))

/*******************************************************************************
 * End of 'DYNXQCNTPORTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  EGRMETERINGBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     BUCKET           Level of maximum rate bucket with unit of 0.5 or 1 bit depends on METER_EGR_PORT_GRAN setting.
 *     IN_PROFILE_FLAG  IN_PROFILE_FLAG inidcates the current state of metering bucket1: Out profile (port egress rate has been reached) 0: In profile (port egress rate has been not reached)(default) 
 */
#define EGRMETERINGBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program EGRMETERINGBUCKET.
 */
typedef union EGRMETERINGBUCKETr_s {
	uint32 v[1];
	uint32 egrmeteringbucket[1];
	uint32 _egrmeteringbucket;
} EGRMETERINGBUCKETr_t;

#define EGRMETERINGBUCKETr_CLR(r) (r).egrmeteringbucket[0] = 0
#define EGRMETERINGBUCKETr_SET(r,d) (r).egrmeteringbucket[0] = d
#define EGRMETERINGBUCKETr_GET(r) (r).egrmeteringbucket[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGRMETERINGBUCKETr_BUCKETf_GET(r) (((r).egrmeteringbucket[0]) & 0x1fffffff)
#define EGRMETERINGBUCKETr_BUCKETf_SET(r,f) (r).egrmeteringbucket[0]=(((r).egrmeteringbucket[0] & ~((uint32)0x1fffffff)) | (((uint32)f) & 0x1fffffff))
#define EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_GET(r) ((((r).egrmeteringbucket[0]) >> 29) & 0x1)
#define EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_SET(r,f) (r).egrmeteringbucket[0]=(((r).egrmeteringbucket[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))

/*
 * These macros can be used to access EGRMETERINGBUCKET.
 */
#define WRITE_EGRMETERINGBUCKETr(u,p,r) bcm5354x_reg_set(u,R_EGRMETERINGBUCKET(p),(r._egrmeteringbucket))
#define READ_EGRMETERINGBUCKETr(u,p,r) bcm5354x_reg_get(u,R_EGRMETERINGBUCKET(p),&(r._egrmeteringbucket))

/*******************************************************************************
 * End of 'EGRMETERINGBUCKETr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  EGRMETERINGCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     THD_SEL          Egress Metering Bucket function is disabled when bucket size is 0.Threshold for metering bucket.The setting of Threshold determines the size of bucket and not related to actual bandwidth rate number. It also determines how burstiness of traffic is.When METER_EGR_PORT_GRAN corresponding setting is 0:  The Bucket Size is range from 4k Bytes to 16M Bytes with 4k Bytes increment. The Bucket size is determined by the formula,  Bucket Size = PAUSE_THD * 4KBytesWhen METER_EGR_PORT_GRAN corresponding setting is 1:  The Bucket Size is range from 8k Bytes to 32M Bytes with 8k Bytes increment. The Bucket size is determined by the formula,  Bucket Size = PAUSE_THD * 8KBytes
 *     REFRESH          Refresh count for metering bucket. When METER_EGR_PORT_GRAN corresponding setting is 0:  Every unit of REFRESH represents 64,000 bps, (bits per second).  Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),                set MIN_REFRESH = 7812,  Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),                set MIN_REFRESH = 15624.When METER_ING_PORT_GRAN corresponding setting is 1:  Every unit of REFRESH represents 256,000 bps, (bits per second).
 */
#define EGRMETERINGCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGRMETERINGCONFIG.
 */
typedef union EGRMETERINGCONFIGr_s {
	uint32 v[1];
	uint32 egrmeteringconfig[1];
	uint32 _egrmeteringconfig;
} EGRMETERINGCONFIGr_t;

#define EGRMETERINGCONFIGr_CLR(r) (r).egrmeteringconfig[0] = 0
#define EGRMETERINGCONFIGr_SET(r,d) (r).egrmeteringconfig[0] = d
#define EGRMETERINGCONFIGr_GET(r) (r).egrmeteringconfig[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGRMETERINGCONFIGr_THD_SELf_GET(r) (((r).egrmeteringconfig[0]) & 0xfff)
#define EGRMETERINGCONFIGr_THD_SELf_SET(r,f) (r).egrmeteringconfig[0]=(((r).egrmeteringconfig[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define EGRMETERINGCONFIGr_REFRESHf_GET(r) ((((r).egrmeteringconfig[0]) >> 12) & 0x3ffff)
#define EGRMETERINGCONFIGr_REFRESHf_SET(r,f) (r).egrmeteringconfig[0]=(((r).egrmeteringconfig[0] & ~((uint32)0x3ffff << 12)) | ((((uint32)f) & 0x3ffff) << 12))

/*
 * These macros can be used to access EGRMETERINGCONFIG.
 */
#define WRITE_EGRMETERINGCONFIGr(u,p,r) bcm5354x_reg_set(u,R_EGRMETERINGCONFIG(p),(r._egrmeteringconfig))
#define READ_EGRMETERINGCONFIGr(u,p,r) bcm5354x_reg_get(u,R_EGRMETERINGCONFIG(p),&(r._egrmeteringconfig))

/*******************************************************************************
 * End of 'EGRMETERINGCONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  EGR_CONFIG
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for the entire chip.
 * SIZE:     32
 * FIELDS:
 *     SNAP_OTHER_DECODE_ENABLE Decode SNAP packets with non-zero OUI for protocol-based VLAN
 *     USE_LEARN_VID    Use the learn_vid for vid membership and STG state check.
 *     LEARN_VID        Vid to be used for vid membership and STG state check when USE_LEARN_VID is set.
 *     INNER_TPID       TPID to identify inner vlan tag of the packet when switch is operating in DT mode, i.e. DT_MODE bit is set.
 */
#define EGR_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_CONFIG.
 */
typedef union EGR_CONFIGr_s {
	uint32 v[1];
	uint32 egr_config[1];
	uint32 _egr_config;
} EGR_CONFIGr_t;

#define EGR_CONFIGr_CLR(r) (r).egr_config[0] = 0
#define EGR_CONFIGr_SET(r,d) (r).egr_config[0] = d
#define EGR_CONFIGr_GET(r) (r).egr_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET(r) ((((r).egr_config[0]) >> 2) & 0x1)
#define EGR_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define EGR_CONFIGr_USE_LEARN_VIDf_GET(r) ((((r).egr_config[0]) >> 3) & 0x1)
#define EGR_CONFIGr_USE_LEARN_VIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define EGR_CONFIGr_LEARN_VIDf_GET(r) ((((r).egr_config[0]) >> 4) & 0xfff)
#define EGR_CONFIGr_LEARN_VIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32)0xfff << 4)) | ((((uint32)f) & 0xfff) << 4))
#define EGR_CONFIGr_INNER_TPIDf_GET(r) ((((r).egr_config[0]) >> 16) & 0xffff)
#define EGR_CONFIGr_INNER_TPIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access EGR_CONFIG.
 */
#define WRITE_EGR_CONFIGr(u,r) bcm5354x_reg_set(u,R_EGR_CONFIG,(r._egr_config))
#define READ_EGR_CONFIGr(u,r) bcm5354x_reg_get(u,R_EGR_CONFIG,&(r._egr_config))

/*******************************************************************************
 * End of 'EGR_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  EGR_EM_MTP_INDEX
 * BLOCKS:   EPIPE
 * DESC:     Mirror to Port Table. 
Index is constructed using pbe.mtp_index[6:0] field.
We use {pbe.mtp_index[5:4],pbe.mtp_index[2:0]} as index into this table.

 * SIZE:     18
 * FIELDS:
 *     MTP_DST_MODID    DST_MODID field to be used in the module header in case of mirroring.
 *     MTP_DST_PORT     DST_PORT field to be used in module header in case of mirroring.
 *     MIRROR_ENCAP_ENABLE If set, causes a mirroring encapsulation on mirror packets using the EGR_MIRROR_ENCAP_DATA_1/_2/CONTROL tables.
 *     MIRROR_ENCAP_INDEX Index into the EGR_MIRROR_ENCAP_DATA_1/_2/CONTROL tables.
 */
#define EGR_EM_MTP_INDEXm_MIN 0
#define EGR_EM_MTP_INDEXm_MAX 31
#define EGR_EM_MTP_INDEXm_CMAX(u) 31
#define EGR_EM_MTP_INDEXm_SIZE 3

/*
 * This structure should be used to declare and program EGR_EM_MTP_INDEX.
 */
typedef union EGR_EM_MTP_INDEXm_s {
	uint32 v[1];
	uint32 egr_em_mtp_index[1];
	uint32 _egr_em_mtp_index;
} EGR_EM_MTP_INDEXm_t;

#define EGR_EM_MTP_INDEXm_CLR(r) (r).egr_em_mtp_index[0] = 0
#define EGR_EM_MTP_INDEXm_SET(r,d) (r).egr_em_mtp_index[0] = d
#define EGR_EM_MTP_INDEXm_GET(r) (r).egr_em_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_GET(r) (((r).egr_em_mtp_index[0]) & 0xff)
#define EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define EGR_EM_MTP_INDEXm_MTP_DST_PORTf_GET(r) ((((r).egr_em_mtp_index[0]) >> 8) & 0x3f)
#define EGR_EM_MTP_INDEXm_MTP_DST_PORTf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32)0x3f << 8)) | ((((uint32)f) & 0x3f) << 8))
#define EGR_EM_MTP_INDEXm_MIRROR_ENCAP_ENABLEf_GET(r) ((((r).egr_em_mtp_index[0]) >> 14) & 0x1)
#define EGR_EM_MTP_INDEXm_MIRROR_ENCAP_ENABLEf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define EGR_EM_MTP_INDEXm_MIRROR_ENCAP_INDEXf_GET(r) ((((r).egr_em_mtp_index[0]) >> 15) & 0x7)
#define EGR_EM_MTP_INDEXm_MIRROR_ENCAP_INDEXf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))

/*
 * These macros can be used to access EGR_EM_MTP_INDEX.
 */
#define WRITE_EGR_EM_MTP_INDEXm(u,i,r) bcm5354x_mem_set(u, M_EGR_EM_MTP_INDEX(i), &(r._egr_em_mtp_index), 1)
#define READ_EGR_EM_MTP_INDEXm(u,i,r) bcm5354x_mem_get(u, M_EGR_EM_MTP_INDEX(i), &(r._egr_em_mtp_index), 1)

/*******************************************************************************
 * End of 'EGR_EM_MTP_INDEXm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  EGR_ENABLE
 * BLOCKS:   EPIPE
 * DESC:     Egress Enable (per physical port)
 * SIZE:     1
 * FIELDS:
 *     PRT_ENABLE       Port is enabled. If this bit is set, this port will generate requests to the MMU.
 */
#define EGR_ENABLEm_MIN 0
#define EGR_ENABLEm_MAX 41
#define EGR_ENABLEm_CMAX(u) 41
#define EGR_ENABLEm_SIZE 1

/*
 * This structure should be used to declare and program EGR_ENABLE.
 */
typedef union EGR_ENABLEm_s {
	uint32 v[1];
	uint32 egr_enable[1];
	uint32 _egr_enable;
} EGR_ENABLEm_t;

#define EGR_ENABLEm_CLR(r) (r).egr_enable[0] = 0
#define EGR_ENABLEm_SET(r,d) (r).egr_enable[0] = d
#define EGR_ENABLEm_GET(r) (r).egr_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_ENABLEm_PRT_ENABLEf_GET(r) (((r).egr_enable[0]) & 0x1)
#define EGR_ENABLEm_PRT_ENABLEf_SET(r,f) (r).egr_enable[0]=(((r).egr_enable[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access EGR_ENABLE.
 */
#define WRITE_EGR_ENABLEm(u,i,r) bcm5354x_mem_set(u, M_EGR_ENABLE(i), &(r._egr_enable), 1)
#define READ_EGR_ENABLEm(u,i,r) bcm5354x_mem_get(u, M_EGR_ENABLE(i), &(r._egr_enable), 1)

/*******************************************************************************
 * End of 'EGR_ENABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  EGR_HW_RESET_CONTROL_0
 * BLOCKS:   EPIPE
 * DESC:     This register is for controlling the HW Table Initialization Feature of the Egress Pipeline.
This register should be programmed before programming EGR_HW_RESET_CONTROL_1 register.

 * SIZE:     32
 * FIELDS:
 *     START_ADDRESS    HW starts incrementing from this address until EGR_HW_RESET_CONTROL_1.COUNT is completed.  START_ADDRESS is relevant even when EGR_HW_RESET_CONTROL_1.RESET_ALL bit is set.
 *     STAGE_NUMBER     Stage Number where table to be reset is located. This is NOT used when EGR_HW_RESET_CONTROL_1.RESET_ALL bit is set.
 */
#define EGR_HW_RESET_CONTROL_0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_HW_RESET_CONTROL_0.
 */
typedef union EGR_HW_RESET_CONTROL_0r_s {
	uint32 v[1];
	uint32 egr_hw_reset_control_0[1];
	uint32 _egr_hw_reset_control_0;
} EGR_HW_RESET_CONTROL_0r_t;

#define EGR_HW_RESET_CONTROL_0r_CLR(r) (r).egr_hw_reset_control_0[0] = 0
#define EGR_HW_RESET_CONTROL_0r_SET(r,d) (r).egr_hw_reset_control_0[0] = d
#define EGR_HW_RESET_CONTROL_0r_GET(r) (r).egr_hw_reset_control_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET(r) (((r).egr_hw_reset_control_0[0]) & 0x3ffffff)
#define EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET(r,f) (r).egr_hw_reset_control_0[0]=(((r).egr_hw_reset_control_0[0] & ~((uint32)0x3ffffff)) | (((uint32)f) & 0x3ffffff))
#define EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET(r) ((((r).egr_hw_reset_control_0[0]) >> 26) & 0x3f)
#define EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET(r,f) (r).egr_hw_reset_control_0[0]=(((r).egr_hw_reset_control_0[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access EGR_HW_RESET_CONTROL_0.
 */
#define WRITE_EGR_HW_RESET_CONTROL_0r(u,r) bcm5354x_reg_set(u,R_EGR_HW_RESET_CONTROL_0,(r._egr_hw_reset_control_0))
#define READ_EGR_HW_RESET_CONTROL_0r(u,r) bcm5354x_reg_get(u,R_EGR_HW_RESET_CONTROL_0,&(r._egr_hw_reset_control_0))

/*******************************************************************************
 * End of 'EGR_HW_RESET_CONTROL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  EGR_HW_RESET_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     This register is for controlling the HW Table Initialization Feature of the Egress Pipeline.

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count of entries which need to be resetted starting from EGR_HW_RESET_CONTROL_0.START_ADDRESS.
 *     RESET_ALL        If set, then ALL Tables in the Egress Pipeline will be resetted for COUNT entries. STAGE_NUMBER is ignored when this bit is set. 
 *     VALID            The HW table initialization will start after Logic sees this bit as set.
 *     DONE             After HW has issued memory reset commands equal to COUNT times, it will set DONE bit,SW can poll this bit from time to time and whenever it is set, SW should reset DONE and VALIDbits to 0. This will end the HW Reset Sequence of memories in the HW.
 */
#define EGR_HW_RESET_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_HW_RESET_CONTROL_1.
 */
typedef union EGR_HW_RESET_CONTROL_1r_s {
	uint32 v[1];
	uint32 egr_hw_reset_control_1[1];
	uint32 _egr_hw_reset_control_1;
} EGR_HW_RESET_CONTROL_1r_t;

#define EGR_HW_RESET_CONTROL_1r_CLR(r) (r).egr_hw_reset_control_1[0] = 0
#define EGR_HW_RESET_CONTROL_1r_SET(r,d) (r).egr_hw_reset_control_1[0] = d
#define EGR_HW_RESET_CONTROL_1r_GET(r) (r).egr_hw_reset_control_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_HW_RESET_CONTROL_1r_COUNTf_GET(r) (((r).egr_hw_reset_control_1[0]) & 0xffff)
#define EGR_HW_RESET_CONTROL_1r_COUNTf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 16) & 0x1)
#define EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define EGR_HW_RESET_CONTROL_1r_VALIDf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 17) & 0x1)
#define EGR_HW_RESET_CONTROL_1r_VALIDf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define EGR_HW_RESET_CONTROL_1r_DONEf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 18) & 0x1)
#define EGR_HW_RESET_CONTROL_1r_DONEf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))

/*
 * These macros can be used to access EGR_HW_RESET_CONTROL_1.
 */
#define WRITE_EGR_HW_RESET_CONTROL_1r(u,r) bcm5354x_reg_set(u,R_EGR_HW_RESET_CONTROL_1,(r._egr_hw_reset_control_1))
#define READ_EGR_HW_RESET_CONTROL_1r(u,r) bcm5354x_reg_get(u,R_EGR_HW_RESET_CONTROL_1,&(r._egr_hw_reset_control_1))

/*******************************************************************************
 * End of 'EGR_HW_RESET_CONTROL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  EGR_IM_MTP_INDEX
 * BLOCKS:   EPIPE
 * DESC:     Mirror to Port Table to be used for IM tagged packets. 
Index is constructed using pbe.mtp_index[6:0] field.
We use {pbe.mtp_index[4:3],pbe.mtp_index[2:0]} as index into this table.

 * SIZE:     18
 * FIELDS:
 *     MTP_DST_MODID    DST_MODID field to be used in the module header in case of mirroring.
 *     MTP_DST_PORT     DST_PORT field to be used in module header in case of mirroring.
 *     MIRROR_ENCAP_ENABLE If set, causes a mirroring encapsulation on mirror packets using the EGR_MIRROR_ENCAP_DATA_1/_2/CONTROL tables.
 *     MIRROR_ENCAP_INDEX Index into the EGR_MIRROR_ENCAP_DATA_1/_2/CONTROL tables.
 */
#define EGR_IM_MTP_INDEXm_MIN 0
#define EGR_IM_MTP_INDEXm_MAX 31
#define EGR_IM_MTP_INDEXm_CMAX(u) 31
#define EGR_IM_MTP_INDEXm_SIZE 3

/*
 * This structure should be used to declare and program EGR_IM_MTP_INDEX.
 */
typedef union EGR_IM_MTP_INDEXm_s {
	uint32 v[1];
	uint32 egr_im_mtp_index[1];
	uint32 _egr_im_mtp_index;
} EGR_IM_MTP_INDEXm_t;

#define EGR_IM_MTP_INDEXm_CLR(r) (r).egr_im_mtp_index[0] = 0
#define EGR_IM_MTP_INDEXm_SET(r,d) (r).egr_im_mtp_index[0] = d
#define EGR_IM_MTP_INDEXm_GET(r) (r).egr_im_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_GET(r) (((r).egr_im_mtp_index[0]) & 0xff)
#define EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define EGR_IM_MTP_INDEXm_MTP_DST_PORTf_GET(r) ((((r).egr_im_mtp_index[0]) >> 8) & 0x3f)
#define EGR_IM_MTP_INDEXm_MTP_DST_PORTf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32)0x3f << 8)) | ((((uint32)f) & 0x3f) << 8))
#define EGR_IM_MTP_INDEXm_MIRROR_ENCAP_ENABLEf_GET(r) ((((r).egr_im_mtp_index[0]) >> 14) & 0x1)
#define EGR_IM_MTP_INDEXm_MIRROR_ENCAP_ENABLEf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define EGR_IM_MTP_INDEXm_MIRROR_ENCAP_INDEXf_GET(r) ((((r).egr_im_mtp_index[0]) >> 15) & 0x7)
#define EGR_IM_MTP_INDEXm_MIRROR_ENCAP_INDEXf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))

/*
 * These macros can be used to access EGR_IM_MTP_INDEX.
 */
#define WRITE_EGR_IM_MTP_INDEXm(u,i,r) bcm5354x_mem_set(u, M_EGR_IM_MTP_INDEX(i), &(r._egr_im_mtp_index), 1)
#define READ_EGR_IM_MTP_INDEXm(u,i,r) bcm5354x_mem_get(u, M_EGR_IM_MTP_INDEX(i), &(r._egr_im_mtp_index), 1)

/*******************************************************************************
 * End of 'EGR_IM_MTP_INDEXm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPING
 * BLOCKS:   EPIPE
 * DESC:     Egress Logical to Physical Port Number Mapping Register. Indexed by the Logical port number, and provides the corresponding physical port number.
 * SIZE:     32
 * FIELDS:
 *     PHYSICAL_PORT_NUMBER Physical port number value
 */
#define EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPING.
 */
typedef union EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_s {
	uint32 v[1];
	uint32 egr_logical_to_physical_port_number_mapping[1];
	uint32 _egr_logical_to_physical_port_number_mapping;
} EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_t;

#define EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_CLR(r) (r).egr_logical_to_physical_port_number_mapping[0] = 0
#define EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_SET(r,d) (r).egr_logical_to_physical_port_number_mapping[0] = d
#define EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_GET(r) (r).egr_logical_to_physical_port_number_mapping[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_PHYSICAL_PORT_NUMBERf_GET(r) (((r).egr_logical_to_physical_port_number_mapping[0]) & 0x3f)
#define EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr_PHYSICAL_PORT_NUMBERf_SET(r,f) (r).egr_logical_to_physical_port_number_mapping[0]=(((r).egr_logical_to_physical_port_number_mapping[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))

/*
 * These macros can be used to access EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPING.
 */
#define WRITE_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr(u,p,r) bcm5354x_reg_set(u,R_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPING(p),(r._egr_logical_to_physical_port_number_mapping))
#define READ_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr(u,p,r) bcm5354x_reg_get(u,R_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPING(p),&(r._egr_logical_to_physical_port_number_mapping))

/*******************************************************************************
 * End of 'EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  EGR_MASK
 * BLOCKS:   IPIPE
 * DESC:     Egress Mask Table
 * SIZE:     33
 * FIELDS:
 *     EGRESS_MASK      Egress mask block mask for source port
 *     EGRESS_MASK_LO   Egress mask block mask for source port
 *     EVEN_PARITY       Even parity
 */
#define EGR_MASKm_MIN 0
#define EGR_MASKm_MAX 511
#define EGR_MASKm_CMAX(u) 511
#define EGR_MASKm_SIZE 5

/*
 * This structure should be used to declare and program EGR_MASK.
 */
typedef union EGR_MASKm_s {
	uint32 v[2];
	uint32 egr_mask[2];
	uint32 _egr_mask;
} EGR_MASKm_t;

#define EGR_MASKm_CLR(r) sal_memset(&((r)._egr_mask), 0, sizeof(EGR_MASKm_t))
#define EGR_MASKm_SET(r,i,d) (r).egr_mask[i] = d
#define EGR_MASKm_GET(r,i) (r).egr_mask[i]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_MASKm_EGRESS_MASKf_GET(r) ((r).egr_mask[0])
#define EGR_MASKm_EGRESS_MASKf_SET(r,f) (r).egr_mask[0]=((uint32)f)
#define EGR_MASKm_EGRESS_MASK_LOf_GET(r) ((r).egr_mask[0])
#define EGR_MASKm_EGRESS_MASK_LOf_SET(r,f) (r).egr_mask[0]=((uint32)f)
#define EGR_MASKm_EVEN_PARITYf_GET(r) (((r).egr_mask[1]) & 0x1)
#define EGR_MASKm_EVEN_PARITYf_SET(r,f) (r).egr_mask[1]=(((r).egr_mask[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access EGR_MASK.
 */
#define WRITE_EGR_MASKm(u,i,r) bcm5354x_mem_set(u, M_EGR_MASK(i), &(r._egr_mask), 2)
#define READ_EGR_MASKm(u,i,r) bcm5354x_mem_get(u, M_EGR_MASK(i), &(r._egr_mask), 2)

/*******************************************************************************
 * End of 'EGR_MASKm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  EGR_PORT_64
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for a Port. This is different for each GE, 10GE port. FeatureSpecific-Ethernet
 * SIZE:     64
 * FIELDS:
 *     PORT_TYPE        
 *     HIGIG2           If PORT_TYPE bit is set to HiGig, then this bit indicates HIGIG2 or HIGIG+.
 *     EN_EFILTER       If this bit is set, the VLAN Membership check is done for the outgoing port.
 *     PRESERVE_CPU_TAG Preserve the tag of the packet destines to CPU.
 *     EM_SRCMOD_CHANGE Set to change the src_modid for the egress mirrored pkts going out of the higig port.
 *     MY_MODID         Module ID of this chip.
 *     EGR_PORT_GROUP_ID FP port group ID (used in the EFP for grouping ports)
 *     VT_PORT_GROUP_ID Port group ID of the egress port for egress VLAN translation
 *     EFP_FILTER_ENABLE RESERVED.
 *     VNTAG_ACTIONS_IF_PRESENT Values are: 00: No OP (do nothing), 01: Reserved, 10: Modify VNTAG - Set outgoing VNTAG's L-bit to 0 and src_vif to this egress port's NIV_VIF_ID/ETAG.VID, Reserved for ETAG. 11: Remove VNTAG/ETAG from the outgoing packet if present. Do not add a new VNTAG. Outgoing packet should be sent without VNTAG/ETAG.
 *     NIV_PRUNE_ENABLE This egress port is connecting to a VM and hence is a leaf port of the network. The outgoing packet needs to undergo a NIV/PE based pruning check. Compare the src_vif/VID field of the packet's VNTAG/ETAG with this egrss port's NIV_VIF_ID/ETAG.VID. If there is a match, do not forward the packet.
 *     NIV_VIF_ID       This port's NIV/PE Virtual Interface (VIF) identifier. If this port is a downlink port, then this value shall be used for setting the SRC_VIF of the outgoing VTAG if VTAG is added by the egress port and the packet originated from a different Namespace. If this port is an IV downlink port then this value shall be use to compare against VTAG src_vif field in the packet for NIV-based pruning (if NIV_PRUNE_ENABLE is set).
 *     NIV_UPLINK_PORT  If set to 1, this port is an NIV/PE uplink port. So, if VTAG's are inserted by the outgoing port, the d-field of the VNTAG/ETAG should be set to 1.
 *     MIRROR_ENCAP_ENABLE If set, causes a mirroring encapsulation on mirror packets using the EGR_MIRROR_ENCAP_DATA_1/_2/CONTROL tables.
 *     MIRROR_ENCAP_INDEX Index into the EGR_MIRROR_ENCAP_DATA_1/_2/CONTROL tables.
 *     CUSTOM_HEADER_ENABLE The CUSTOM_HEADER_ENABLE will decide if a packet will be modified to add the custom header even if the IFP action is to add a custom header.
 */
#define EGR_PORT_64r_SIZE 8

/*
 * This structure should be used to declare and program EGR_PORT_64.
 */
typedef union EGR_PORT_64r_s {
	uint32 v[2];
	uint32 egr_port_64[2];
	uint32 _egr_port_64;
} EGR_PORT_64r_t;

#define EGR_PORT_64r_CLR(r) sal_memset(&((r)._egr_port_64), 0, sizeof(EGR_PORT_64r_t))
#define EGR_PORT_64r_SET(r,i,d) (r).egr_port_64[i] = d
#define EGR_PORT_64r_GET(r,i) (r).egr_port_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_PORT_64r_PORT_TYPEf_GET(r) (((r).egr_port_64[0]) & 0x3)
#define EGR_PORT_64r_PORT_TYPEf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EGR_PORT_64r_HIGIG2f_GET(r) ((((r).egr_port_64[0]) >> 2) & 0x1)
#define EGR_PORT_64r_HIGIG2f_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define EGR_PORT_64r_EN_EFILTERf_GET(r) ((((r).egr_port_64[0]) >> 3) & 0x1)
#define EGR_PORT_64r_EN_EFILTERf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define EGR_PORT_64r_PRESERVE_CPU_TAGf_GET(r) ((((r).egr_port_64[0]) >> 4) & 0x1)
#define EGR_PORT_64r_PRESERVE_CPU_TAGf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define EGR_PORT_64r_EM_SRCMOD_CHANGEf_GET(r) ((((r).egr_port_64[0]) >> 7) & 0x1)
#define EGR_PORT_64r_EM_SRCMOD_CHANGEf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define EGR_PORT_64r_MY_MODIDf_GET(r) ((((r).egr_port_64[0]) >> 8) & 0xff)
#define EGR_PORT_64r_MY_MODIDf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define EGR_PORT_64r_EGR_PORT_GROUP_IDf_GET(r) ((((r).egr_port_64[0]) >> 16) & 0xff)
#define EGR_PORT_64r_EGR_PORT_GROUP_IDf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define EGR_PORT_64r_VT_PORT_GROUP_IDf_GET(r) ((((r).egr_port_64[0]) >> 24) & 0x3f)
#define EGR_PORT_64r_VT_PORT_GROUP_IDf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))
#define EGR_PORT_64r_EFP_FILTER_ENABLEf_GET(r) ((((r).egr_port_64[0]) >> 31) & 0x1)
#define EGR_PORT_64r_EFP_FILTER_ENABLEf_SET(r,f) (r).egr_port_64[0]=(((r).egr_port_64[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define EGR_PORT_64r_VNTAG_ACTIONS_IF_PRESENTf_GET(r) (((r).egr_port_64[1]) & 0x3)
#define EGR_PORT_64r_VNTAG_ACTIONS_IF_PRESENTf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EGR_PORT_64r_NIV_PRUNE_ENABLEf_GET(r) ((((r).egr_port_64[1]) >> 2) & 0x1)
#define EGR_PORT_64r_NIV_PRUNE_ENABLEf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define EGR_PORT_64r_NIV_VIF_IDf_GET(r) ((((r).egr_port_64[1]) >> 3) & 0xfff)
#define EGR_PORT_64r_NIV_VIF_IDf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define EGR_PORT_64r_NIV_UPLINK_PORTf_GET(r) ((((r).egr_port_64[1]) >> 15) & 0x1)
#define EGR_PORT_64r_NIV_UPLINK_PORTf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define EGR_PORT_64r_MIRROR_ENCAP_ENABLEf_GET(r) ((((r).egr_port_64[1]) >> 16) & 0x1)
#define EGR_PORT_64r_MIRROR_ENCAP_ENABLEf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define EGR_PORT_64r_MIRROR_ENCAP_INDEXf_GET(r) ((((r).egr_port_64[1]) >> 17) & 0x7)
#define EGR_PORT_64r_MIRROR_ENCAP_INDEXf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0x7 << 17)) | ((((uint32)f) & 0x7) << 17))
#define EGR_PORT_64r_CUSTOM_HEADER_ENABLEf_GET(r) ((((r).egr_port_64[1]) >> 20) & 0x1)
#define EGR_PORT_64r_CUSTOM_HEADER_ENABLEf_SET(r,f) (r).egr_port_64[1]=(((r).egr_port_64[1] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))

/*
 * These macros can be used to access EGR_PORT_64.
 */
#define WRITE_EGR_PORT_64r(u,p,r) bcm5354x_reg64_set(u,R_EGR_PORT_64(p),&(r._egr_port_64),2)
#define READ_EGR_PORT_64r(u,p,r) bcm5354x_reg64_get(u,R_EGR_PORT_64(p),&(r._egr_port_64),2)

/*******************************************************************************
 * End of 'EGR_PORT_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  EGR_PORT_BUFFER_CLK_SHUTDOWN
 * BLOCKS:   EPIPE
 * DESC:     Soft shutdown the clocking of interface buffer
 * SIZE:     32
 * FIELDS:
 *     CM               Soft shutdown the clocking of the cm buffer
 *     GP0              Soft shutdown the clocking of the gp0 buffer
 *     GP1              Soft shutdown the clocking of the gp1 buffer
 *     GP2              Soft shutdown the clocking of the gp2 buffer
 *     GP3              Soft shutdown the clocking of the gp3 buffer
 *     GP4              Soft shutdown the clocking of the gp4 buffer
 */
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT_BUFFER_CLK_SHUTDOWN.
 */
typedef union EGR_PORT_BUFFER_CLK_SHUTDOWNr_s {
	uint32 v[1];
	uint32 egr_port_buffer_clk_shutdown[1];
	uint32 _egr_port_buffer_clk_shutdown;
} EGR_PORT_BUFFER_CLK_SHUTDOWNr_t;

#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_CLR(r) (r).egr_port_buffer_clk_shutdown[0] = 0
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_SET(r,d) (r).egr_port_buffer_clk_shutdown[0] = d
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_GET(r) (r).egr_port_buffer_clk_shutdown[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_CMf_GET(r) (((r).egr_port_buffer_clk_shutdown[0]) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_CMf_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_GP0f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 1) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_GP0f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_GP1f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 2) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_GP1f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_GP2f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 3) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_GP2f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_GP3f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 4) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_GP3f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_GP4f_GET(r) ((((r).egr_port_buffer_clk_shutdown[0]) >> 5) & 0x1)
#define EGR_PORT_BUFFER_CLK_SHUTDOWNr_GP4f_SET(r,f) (r).egr_port_buffer_clk_shutdown[0]=(((r).egr_port_buffer_clk_shutdown[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))

/*
 * These macros can be used to access EGR_PORT_BUFFER_CLK_SHUTDOWN.
 */
#define WRITE_EGR_PORT_BUFFER_CLK_SHUTDOWNr(u,r) bcm5354x_reg_set(u,R_EGR_PORT_BUFFER_CLK_SHUTDOWN,(r._egr_port_buffer_clk_shutdown))
#define READ_EGR_PORT_BUFFER_CLK_SHUTDOWNr(u,r) bcm5354x_reg_get(u,R_EGR_PORT_BUFFER_CLK_SHUTDOWN,&(r._egr_port_buffer_clk_shutdown))

/*******************************************************************************
 * End of 'EGR_PORT_BUFFER_CLK_SHUTDOWNr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  EGR_PORT_CREDIT_RESET
 * BLOCKS:   EPIPE
 * DESC:     To clear the port credit(per physical port)
 * SIZE:     1
 * FIELDS:
 *     VALUE            The flag to clear the port credit. If this bit is set, the requests from the port will be credit. Explicitly write to zero to clear the bit
 */
#define EGR_PORT_CREDIT_RESETm_MIN 0
#define EGR_PORT_CREDIT_RESETm_MAX 41
#define EGR_PORT_CREDIT_RESETm_CMAX(u) 41
#define EGR_PORT_CREDIT_RESETm_SIZE 1

/*
 * This structure should be used to declare and program EGR_PORT_CREDIT_RESET.
 */
typedef union EGR_PORT_CREDIT_RESETm_s {
	uint32 v[1];
	uint32 egr_port_credit_reset[1];
	uint32 _egr_port_credit_reset;
} EGR_PORT_CREDIT_RESETm_t;

#define EGR_PORT_CREDIT_RESETm_CLR(r) (r).egr_port_credit_reset[0] = 0
#define EGR_PORT_CREDIT_RESETm_SET(r,d) (r).egr_port_credit_reset[0] = d
#define EGR_PORT_CREDIT_RESETm_GET(r) (r).egr_port_credit_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_PORT_CREDIT_RESETm_VALUEf_GET(r) (((r).egr_port_credit_reset[0]) & 0x1)
#define EGR_PORT_CREDIT_RESETm_VALUEf_SET(r,f) (r).egr_port_credit_reset[0]=(((r).egr_port_credit_reset[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access EGR_PORT_CREDIT_RESET.
 */
#define WRITE_EGR_PORT_CREDIT_RESETm(u,i,r) bcm5354x_mem_set(u, M_EGR_PORT_CREDIT_RESET(i), &(r._egr_port_credit_reset), 1)
#define READ_EGR_PORT_CREDIT_RESETm(u,i,r) bcm5354x_mem_get(u, M_EGR_PORT_CREDIT_RESET(i), &(r._egr_port_credit_reset), 1)

/*******************************************************************************
 * End of 'EGR_PORT_CREDIT_RESETm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  EGR_PORT_REQUESTS
 * BLOCKS:   EPIPE
 * DESC:     This table contains the cell requests asserted by individual port blocks (XLPORT's and CMIC).
Meaning of cell request is different for different ports, but this register has no
understanding of those meanings. All it shows is the number of times cell_request signal
was asserted by each port to TP. 

 * SIZE:     6
 * FIELDS:
 *     OUTSTANDING_PORT_REQUESTS Number of cell requests.
 */
#define EGR_PORT_REQUESTSm_MIN 0
#define EGR_PORT_REQUESTSm_MAX 41
#define EGR_PORT_REQUESTSm_CMAX(u) 41
#define EGR_PORT_REQUESTSm_SIZE 1

/*
 * This structure should be used to declare and program EGR_PORT_REQUESTS.
 */
typedef union EGR_PORT_REQUESTSm_s {
	uint32 v[1];
	uint32 egr_port_requests[1];
	uint32 _egr_port_requests;
} EGR_PORT_REQUESTSm_t;

#define EGR_PORT_REQUESTSm_CLR(r) (r).egr_port_requests[0] = 0
#define EGR_PORT_REQUESTSm_SET(r,d) (r).egr_port_requests[0] = d
#define EGR_PORT_REQUESTSm_GET(r) (r).egr_port_requests[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_PORT_REQUESTSm_OUTSTANDING_PORT_REQUESTSf_GET(r) (((r).egr_port_requests[0]) & 0x3f)
#define EGR_PORT_REQUESTSm_OUTSTANDING_PORT_REQUESTSf_SET(r,f) (r).egr_port_requests[0]=(((r).egr_port_requests[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))

/*
 * These macros can be used to access EGR_PORT_REQUESTS.
 */
#define WRITE_EGR_PORT_REQUESTSm(u,i,r) bcm5354x_mem_set(u, M_EGR_PORT_REQUESTS(i), &(r._egr_port_requests), 1)
#define READ_EGR_PORT_REQUESTSm(u,i,r) bcm5354x_mem_get(u, M_EGR_PORT_REQUESTS(i), &(r._egr_port_requests), 1)

/*******************************************************************************
 * End of 'EGR_PORT_REQUESTSm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  EGR_VLAN
 * BLOCKS:   EPIPE
 * DESC:     Vlan Membership Table for Egress
 * SIZE:     81
 * FIELDS:
 *     UT_BITMAP        Alias for UT_PORT_BITMAP
 *     UT_BITMAP_HI     Alias for UT_PORT_BITMAP
 *     UT_BITMAP_LO     Alias for UT_PORT_BITMAP
 *     UT_PORT_BITMAP   Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed. For Q-in-Q, indicates on which port, the outer tag needs to be removed.
 *     UT_PORT_BITMAP_HI Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed. For Q-in-Q, indicates on which port, the outer tag needs to be removed.
 *     UT_PORT_BITMAP_LO Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed. For Q-in-Q, indicates on which port, the outer tag needs to be removed.
 *     PORT_BITMAP      Bitmap to indicate the port members that belong to this VLAN.
 *     PORT_BITMAP_HI   Upper 12 bits of the port bitmap
 *     PORT_BITMAP_LO   Lower 32 bits of the port bitmap
 *     STG              Spanning Tree Group Number. To be used for indexing VLAN_STG table.
 *     RESERVED_71      Reserved
 *     VALID            Indicates if the entry is valid.
 *     OUTER_TPID_INDEX Used when EGR_VLAN_CONTROL_1.OUTER_TPID_SEL is set and indicates which ofthe EGR_OUTER_TPID[xx] registers is to be used as the TPID for this VLAN
 *     REMARK_DOT1P     If this bit is set, (int_pri, CNG) are mapped to outer (CFI, 802.1p) bits in the EGR_MPLS_PRI_MAPPING table.
 *     DOT1P_MAPPING_PTR Selects one of 8 PRI(CNG) to EXP mapping profiles.
 *     EVEN_PARITY      PARITY BIT to make the entry parity even
 */
#define EGR_VLANm_MIN 0
#define EGR_VLANm_MAX 4095
#define EGR_VLANm_CMAX(u) 4095
#define EGR_VLANm_SIZE 11

/*
 * This structure should be used to declare and program EGR_VLAN.
 */
typedef union EGR_VLANm_s {
	uint32 v[3];
	uint32 egr_vlan[3];
	uint32 _egr_vlan;
} EGR_VLANm_t;

#define EGR_VLANm_CLR(r) sal_memset(&((r)._egr_vlan), 0, sizeof(EGR_VLANm_t))
#define EGR_VLANm_SET(r,i,d) (r).egr_vlan[i] = d
#define EGR_VLANm_GET(r,i) (r).egr_vlan[i]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_VLANm_UT_BITMAPf_GET(r) ((r).egr_vlan[0])
#define EGR_VLANm_UT_BITMAPf_SET(r,f) (r).egr_vlan[0]=((uint32)f)
#define EGR_VLANm_UT_BITMAP_HIf_GET(r) ((r).egr_vlan[0])
#define EGR_VLANm_UT_BITMAP_HIf_SET(r,f) (r).egr_vlan[0]=((uint32)f)
#define EGR_VLANm_UT_BITMAP_LOf_GET(r) ((r).egr_vlan[0])
#define EGR_VLANm_UT_BITMAP_LOf_SET(r,f) (r).egr_vlan[0]=((uint32)f)
#define EGR_VLANm_UT_PORT_BITMAPf_GET(r) ((r).egr_vlan[0])
#define EGR_VLANm_UT_PORT_BITMAPf_SET(r,f) (r).egr_vlan[0]=((uint32)f)
#define EGR_VLANm_UT_PORT_BITMAP_HIf_GET(r) ((r).egr_vlan[0])
#define EGR_VLANm_UT_PORT_BITMAP_HIf_SET(r,f) (r).egr_vlan[0]=((uint32)f)
#define EGR_VLANm_UT_PORT_BITMAP_LOf_GET(r) ((r).egr_vlan[0])
#define EGR_VLANm_UT_PORT_BITMAP_LOf_SET(r,f) (r).egr_vlan[0]=((uint32)f)
#define EGR_VLANm_PORT_BITMAPf_GET(r) ((r).egr_vlan[1])
#define EGR_VLANm_PORT_BITMAPf_SET(r,f) (r).egr_vlan[1]=((uint32)f)
#define EGR_VLANm_PORT_BITMAP_HIf_GET(r) ((r).egr_vlan[1])
#define EGR_VLANm_PORT_BITMAP_HIf_SET(r,f) (r).egr_vlan[1]=((uint32)f)
#define EGR_VLANm_PORT_BITMAP_LOf_GET(r) ((r).egr_vlan[1])
#define EGR_VLANm_PORT_BITMAP_LOf_SET(r,f) (r).egr_vlan[1]=((uint32)f)
#define EGR_VLANm_STGf_GET(r) (((r).egr_vlan[2]) & 0x7f)
#define EGR_VLANm_STGf_SET(r,f) (r).egr_vlan[2]=(((r).egr_vlan[2] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define EGR_VLANm_RESERVED_71f_GET(r) ((((r).egr_vlan[2]) >> 7) & 0x1)
#define EGR_VLANm_RESERVED_71f_SET(r,f) (r).egr_vlan[2]=(((r).egr_vlan[2] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define EGR_VLANm_VALIDf_GET(r) ((((r).egr_vlan[2]) >> 8) & 0x1)
#define EGR_VLANm_VALIDf_SET(r,f) (r).egr_vlan[2]=(((r).egr_vlan[2] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define EGR_VLANm_OUTER_TPID_INDEXf_GET(r) ((((r).egr_vlan[2]) >> 9) & 0x3)
#define EGR_VLANm_OUTER_TPID_INDEXf_SET(r,f) (r).egr_vlan[2]=(((r).egr_vlan[2] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define EGR_VLANm_REMARK_DOT1Pf_GET(r) ((((r).egr_vlan[2]) >> 11) & 0x1)
#define EGR_VLANm_REMARK_DOT1Pf_SET(r,f) (r).egr_vlan[2]=(((r).egr_vlan[2] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define EGR_VLANm_DOT1P_MAPPING_PTRf_GET(r) ((((r).egr_vlan[2]) >> 12) & 0xf)
#define EGR_VLANm_DOT1P_MAPPING_PTRf_SET(r,f) (r).egr_vlan[2]=(((r).egr_vlan[2] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define EGR_VLANm_EVEN_PARITYf_GET(r) ((((r).egr_vlan[2]) >> 16) & 0x1)
#define EGR_VLANm_EVEN_PARITYf_SET(r,f) (r).egr_vlan[2]=(((r).egr_vlan[2] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))

/*
 * These macros can be used to access EGR_VLAN.
 */
#define WRITE_EGR_VLANm(u,i,r) bcm5354x_mem_set(u, M_EGR_VLAN(i), &(r._egr_vlan), 3)
#define READ_EGR_VLANm(u,i,r) bcm5354x_mem_get(u, M_EGR_VLAN(i), &(r._egr_vlan), 3)

/*******************************************************************************
 * End of 'EGR_VLANm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  EGR_VLAN_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     Controls Vlan Translate and VLAN membership related functions.

 * SIZE:     32
 * FIELDS:
 *     VT_ENABLE        VLAN Translate is enabled on this port. If this bit is set, then the vid, pri obtained from the VLAN translation Lookup is used.
 *     VT_MISS_DROP     If this bit is set, and a lookup in the VLAN translation table results in a miss, then pkt is dropped.This bit is meaningful only when VT_ENABLE is set.
 *     VT_MISS_UT_DROP  If this bit is set, and a lookup in the VLAN translation table results in a miss, and pkt is untagged by vlan_table, then pkt is dropped.This bit is meaningful only when VT_ENABLE is set.
 *     VT_MISS_UNTAG    If this bit is set, it will force vlan translation misses to be untagged
 *     OUTER_TPID_SEL   If this bit is set, use the EGR_VLAN table OUTER_TPID_INDEX to index into the EGR_OUTER_TPID registers and obtain the outer TPID.Else, use the EGR_VLAN_CONTROL_1 register OUTER_TPID_INDEXfield to index into the EGR_OUTER_TPID registers and obtain the outer TPID.
 *     OUTER_TPID_INDEX Index into the EGR_OUTER_TPID[xx] register array.
 *     CFI_AS_CNG       The 4 bits are associated with the 4 EGR_OUTER_TPID registers. If one of these bits is set, the CFI bit in packets with the corresponding EGR_OUTER_TPID register indicates CNG.
 *     REMARK_OUTER_DOT1P If this bit is set, (int_pri, CNG) are mapped to outer (CFI, 802.1p) bits in the EGR_PRI_CNG_MAP table. Whether the CFI is used depends on the TPID's CFI_AS_CNG setting.
 *     REMARK_OUTER_DSCP If this bit is set, (int_pri, CNG) are mapped to outgoing IP header's DSCP in the EGR_DSCP table.
 *     INNER_TPID_ENABLE 
 */
#define EGR_VLAN_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_VLAN_CONTROL_1.
 */
typedef union EGR_VLAN_CONTROL_1r_s {
	uint32 v[1];
	uint32 egr_vlan_control_1[1];
	uint32 _egr_vlan_control_1;
} EGR_VLAN_CONTROL_1r_t;

#define EGR_VLAN_CONTROL_1r_CLR(r) (r).egr_vlan_control_1[0] = 0
#define EGR_VLAN_CONTROL_1r_SET(r,d) (r).egr_vlan_control_1[0] = d
#define EGR_VLAN_CONTROL_1r_GET(r) (r).egr_vlan_control_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_VLAN_CONTROL_1r_VT_ENABLEf_GET(r) (((r).egr_vlan_control_1[0]) & 0x1)
#define EGR_VLAN_CONTROL_1r_VT_ENABLEf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_GET(r) ((((r).egr_vlan_control_1[0]) >> 1) & 0x1)
#define EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_GET(r) ((((r).egr_vlan_control_1[0]) >> 2) & 0x1)
#define EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define EGR_VLAN_CONTROL_1r_VT_MISS_UNTAGf_GET(r) ((((r).egr_vlan_control_1[0]) >> 3) & 0x1)
#define EGR_VLAN_CONTROL_1r_VT_MISS_UNTAGf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define EGR_VLAN_CONTROL_1r_OUTER_TPID_SELf_GET(r) ((((r).egr_vlan_control_1[0]) >> 4) & 0x1)
#define EGR_VLAN_CONTROL_1r_OUTER_TPID_SELf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define EGR_VLAN_CONTROL_1r_OUTER_TPID_INDEXf_GET(r) ((((r).egr_vlan_control_1[0]) >> 5) & 0x3)
#define EGR_VLAN_CONTROL_1r_OUTER_TPID_INDEXf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x3 << 5)) | ((((uint32)f) & 0x3) << 5))
#define EGR_VLAN_CONTROL_1r_CFI_AS_CNGf_GET(r) ((((r).egr_vlan_control_1[0]) >> 7) & 0xf)
#define EGR_VLAN_CONTROL_1r_CFI_AS_CNGf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0xf << 7)) | ((((uint32)f) & 0xf) << 7))
#define EGR_VLAN_CONTROL_1r_REMARK_OUTER_DOT1Pf_GET(r) ((((r).egr_vlan_control_1[0]) >> 12) & 0x1)
#define EGR_VLAN_CONTROL_1r_REMARK_OUTER_DOT1Pf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define EGR_VLAN_CONTROL_1r_REMARK_OUTER_DSCPf_GET(r) ((((r).egr_vlan_control_1[0]) >> 13) & 0x1)
#define EGR_VLAN_CONTROL_1r_REMARK_OUTER_DSCPf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define EGR_VLAN_CONTROL_1r_INNER_TPID_ENABLEf_GET(r) ((((r).egr_vlan_control_1[0]) >> 14) & 0x1)
#define EGR_VLAN_CONTROL_1r_INNER_TPID_ENABLEf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))

/*
 * These macros can be used to access EGR_VLAN_CONTROL_1.
 */
#define WRITE_EGR_VLAN_CONTROL_1r(u,p,r) bcm5354x_reg_set(u,R_EGR_VLAN_CONTROL_1(p),(r._egr_vlan_control_1))
#define READ_EGR_VLAN_CONTROL_1r(u,p,r) bcm5354x_reg_get(u,R_EGR_VLAN_CONTROL_1(p),&(r._egr_vlan_control_1))

/*******************************************************************************
 * End of 'EGR_VLAN_CONTROL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  EGR_VLAN_STG
 * BLOCKS:   EPIPE
 * DESC:     Egress Spanning Tree Stage Table, FeatureSpecific-Ethernet
 * SIZE:     65
 * FIELDS:
 *     SP_TREE_PORT0    Spanning Tree State for Port 0.
 *     SP_TREE_PORT1    Spanning Tree State for Port 1.
 *     SP_TREE_PORT2    Spanning Tree State for Port 2.
 *     SP_TREE_PORT3    Spanning Tree State for Port 3.
 *     SP_TREE_PORT4    Spanning Tree State for Port 4.
 *     SP_TREE_PORT5    Spanning Tree State for Port 5.
 *     SP_TREE_PORT6    Spanning Tree State for Port 6.
 *     SP_TREE_PORT7    Spanning Tree State for Port 7.
 *     SP_TREE_PORT8    Spanning Tree State for Port 8.
 *     SP_TREE_PORT9    Spanning Tree State for Port 9.
 *     SP_TREE_PORT10   Spanning Tree State for Port 10.
 *     SP_TREE_PORT11   Spanning Tree State for Port 11.
 *     SP_TREE_PORT12   Spanning Tree State for Port 12.
 *     SP_TREE_PORT13   Spanning Tree State for Port 13.
 *     SP_TREE_PORT14   Spanning Tree State for Port 14.
 *     SP_TREE_PORT15   Spanning Tree State for Port 15.
 *     SP_TREE_PORT16   Spanning Tree State for Port 16.
 *     SP_TREE_PORT17   Spanning Tree State for Port 17.
 *     SP_TREE_PORT18   Spanning Tree State for Port 18.
 *     SP_TREE_PORT19   Spanning Tree State for Port 19.
 *     SP_TREE_PORT20   Spanning Tree State for Port 20.
 *     SP_TREE_PORT21   Spanning Tree State for Port 21.
 *     SP_TREE_PORT22   Spanning Tree State for Port 22.
 *     SP_TREE_PORT23   Spanning Tree State for Port 23.
 *     SP_TREE_PORT24   Spanning Tree State for Port 24.
 *     SP_TREE_PORT25   Spanning Tree State for Port 25.
 *     SP_TREE_PORT26   Spanning Tree State for Port 26.
 *     SP_TREE_PORT27   Spanning Tree State for Port 27.
 *     SP_TREE_PORT28   Spanning Tree State for Port 28.
 *     SP_TREE_PORT29   Spanning Tree State for Port 29.
 *     SP_TREE_PORT30   Spanning Tree State for Port 30.
 *     SP_TREE_PORT31   Spanning Tree State for Port 31.
 *     EVEN_PARITY      PARITY BIT to make the entry parity even.
 */
#define EGR_VLAN_STGm_MIN 0
#define EGR_VLAN_STGm_MAX 127
#define EGR_VLAN_STGm_CMAX(u) 127
#define EGR_VLAN_STGm_SIZE 9

/*
 * This structure should be used to declare and program EGR_VLAN_STG.
 */
typedef union EGR_VLAN_STGm_s {
	uint32 v[3];
	uint32 egr_vlan_stg[3];
	uint32 _egr_vlan_stg;
} EGR_VLAN_STGm_t;

#define EGR_VLAN_STGm_CLR(r) sal_memset(&((r)._egr_vlan_stg), 0, sizeof(EGR_VLAN_STGm_t))
#define EGR_VLAN_STGm_SET(r,i,d) (r).egr_vlan_stg[i] = d
#define EGR_VLAN_STGm_GET(r,i) (r).egr_vlan_stg[i]

/*
 * These macros can be used to access individual fields.
 */
#define EGR_VLAN_STGm_SP_TREE_PORT0f_GET(r) (((r).egr_vlan_stg[0]) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT0f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EGR_VLAN_STGm_SP_TREE_PORT1f_GET(r) ((((r).egr_vlan_stg[0]) >> 2) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT1f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define EGR_VLAN_STGm_SP_TREE_PORT2f_GET(r) ((((r).egr_vlan_stg[0]) >> 4) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT2f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define EGR_VLAN_STGm_SP_TREE_PORT3f_GET(r) ((((r).egr_vlan_stg[0]) >> 6) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT3f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define EGR_VLAN_STGm_SP_TREE_PORT4f_GET(r) ((((r).egr_vlan_stg[0]) >> 8) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT4f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define EGR_VLAN_STGm_SP_TREE_PORT5f_GET(r) ((((r).egr_vlan_stg[0]) >> 10) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT5f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define EGR_VLAN_STGm_SP_TREE_PORT6f_GET(r) ((((r).egr_vlan_stg[0]) >> 12) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT6f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define EGR_VLAN_STGm_SP_TREE_PORT7f_GET(r) ((((r).egr_vlan_stg[0]) >> 14) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT7f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define EGR_VLAN_STGm_SP_TREE_PORT8f_GET(r) ((((r).egr_vlan_stg[0]) >> 16) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT8f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define EGR_VLAN_STGm_SP_TREE_PORT9f_GET(r) ((((r).egr_vlan_stg[0]) >> 18) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT9f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define EGR_VLAN_STGm_SP_TREE_PORT10f_GET(r) ((((r).egr_vlan_stg[0]) >> 20) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT10f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define EGR_VLAN_STGm_SP_TREE_PORT11f_GET(r) ((((r).egr_vlan_stg[0]) >> 22) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT11f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define EGR_VLAN_STGm_SP_TREE_PORT12f_GET(r) ((((r).egr_vlan_stg[0]) >> 24) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT12f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define EGR_VLAN_STGm_SP_TREE_PORT13f_GET(r) ((((r).egr_vlan_stg[0]) >> 26) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT13f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define EGR_VLAN_STGm_SP_TREE_PORT14f_GET(r) ((((r).egr_vlan_stg[0]) >> 28) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT14f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define EGR_VLAN_STGm_SP_TREE_PORT15f_GET(r) ((((r).egr_vlan_stg[0]) >> 30) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT15f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define EGR_VLAN_STGm_SP_TREE_PORT16f_GET(r) (((r).egr_vlan_stg[1]) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT16f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define EGR_VLAN_STGm_SP_TREE_PORT17f_GET(r) ((((r).egr_vlan_stg[1]) >> 2) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT17f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define EGR_VLAN_STGm_SP_TREE_PORT18f_GET(r) ((((r).egr_vlan_stg[1]) >> 4) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT18f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define EGR_VLAN_STGm_SP_TREE_PORT19f_GET(r) ((((r).egr_vlan_stg[1]) >> 6) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT19f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define EGR_VLAN_STGm_SP_TREE_PORT20f_GET(r) ((((r).egr_vlan_stg[1]) >> 8) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT20f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define EGR_VLAN_STGm_SP_TREE_PORT21f_GET(r) ((((r).egr_vlan_stg[1]) >> 10) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT21f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define EGR_VLAN_STGm_SP_TREE_PORT22f_GET(r) ((((r).egr_vlan_stg[1]) >> 12) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT22f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define EGR_VLAN_STGm_SP_TREE_PORT23f_GET(r) ((((r).egr_vlan_stg[1]) >> 14) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT23f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define EGR_VLAN_STGm_SP_TREE_PORT24f_GET(r) ((((r).egr_vlan_stg[1]) >> 16) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT24f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define EGR_VLAN_STGm_SP_TREE_PORT25f_GET(r) ((((r).egr_vlan_stg[1]) >> 18) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT25f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define EGR_VLAN_STGm_SP_TREE_PORT26f_GET(r) ((((r).egr_vlan_stg[1]) >> 20) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT26f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define EGR_VLAN_STGm_SP_TREE_PORT27f_GET(r) ((((r).egr_vlan_stg[1]) >> 22) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT27f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define EGR_VLAN_STGm_SP_TREE_PORT28f_GET(r) ((((r).egr_vlan_stg[1]) >> 24) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT28f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define EGR_VLAN_STGm_SP_TREE_PORT29f_GET(r) ((((r).egr_vlan_stg[1]) >> 26) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT29f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define EGR_VLAN_STGm_SP_TREE_PORT30f_GET(r) ((((r).egr_vlan_stg[1]) >> 28) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT30f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define EGR_VLAN_STGm_SP_TREE_PORT31f_GET(r) ((((r).egr_vlan_stg[1]) >> 30) & 0x3)
#define EGR_VLAN_STGm_SP_TREE_PORT31f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define EGR_VLAN_STGm_EVEN_PARITYf_GET(r) (((r).egr_vlan_stg[2]) & 0x1)
#define EGR_VLAN_STGm_EVEN_PARITYf_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access EGR_VLAN_STG.
 */
#define WRITE_EGR_VLAN_STGm(u,i,r) bcm5354x_mem_set(u, M_EGR_VLAN_STG(i), &(r._egr_vlan_stg), 3)
#define READ_EGR_VLAN_STGm(u,i,r) bcm5354x_mem_get(u, M_EGR_VLAN_STG(i), &(r._egr_vlan_stg), 3)

/*******************************************************************************
 * End of 'EGR_VLAN_STGm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  EMIRROR_CONTROL_64
 * BLOCKS:   IPIPE
 * DESC:     Egress mirror bitmap register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Egress mirror bitmap
 *     BITMAP_LO        Overlay bitmap for ports 31:0
 */
#define EMIRROR_CONTROL_64r_SIZE 4

/*
 * This structure should be used to declare and program EMIRROR_CONTROL_64.
 */
typedef union EMIRROR_CONTROL_64r_s {
	uint32 v[1];
	uint32 emirror_control_64[1];
	uint32 _emirror_control_64;
} EMIRROR_CONTROL_64r_t;

#define EMIRROR_CONTROL_64r_CLR(r) (r).emirror_control_64[0] = 0
#define EMIRROR_CONTROL_64r_SET(r,d) (r).emirror_control_64[0] = d
#define EMIRROR_CONTROL_64r_GET(r) (r).emirror_control_64[0]

/*
 * These macros can be used to access individual fields.
 */
#define EMIRROR_CONTROL_64r_BITMAPf_GET(r) ((r).emirror_control_64[0])
#define EMIRROR_CONTROL_64r_BITMAPf_SET(r,f) (r).emirror_control_64[0]=((uint32)f)
#define EMIRROR_CONTROL_64r_BITMAP_LOf_GET(r) ((r).emirror_control_64[0])
#define EMIRROR_CONTROL_64r_BITMAP_LOf_SET(r,f) (r).emirror_control_64[0]=((uint32)f)

/*
 * These macros can be used to access EMIRROR_CONTROL_64.
 */
#define WRITE_EMIRROR_CONTROL_64r(u,p,r) bcm5354x_reg_set(u,R_EMIRROR_CONTROL_64(p),(r._emirror_control_64))
#define READ_EMIRROR_CONTROL_64r(u,p,r) bcm5354x_reg_get(u,R_EMIRROR_CONTROL_64(p),&(r._emirror_control_64))

/*******************************************************************************
 * End of 'EMIRROR_CONTROL_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  EM_MTP_INDEX
 * BLOCKS:   IPIPE
 * DESC:     Egress Mirror to Port Table
This index into this table is taken from MIRROR_CONTROL.EM_MTP_INDEX
 * SIZE:     15
 * FIELDS:
 *     PORT_NUM         Port if T==0
 *     TGID             Trunk ID value if T==1
 *     MODULE_ID        Module ID if T==0
 *     T                Trunked port (LAG) indication
 */
#define EM_MTP_INDEXm_MIN 0
#define EM_MTP_INDEXm_MAX 3
#define EM_MTP_INDEXm_CMAX(u) 3
#define EM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program EM_MTP_INDEX.
 */
typedef union EM_MTP_INDEXm_s {
	uint32 v[1];
	uint32 em_mtp_index[1];
	uint32 _em_mtp_index;
} EM_MTP_INDEXm_t;

#define EM_MTP_INDEXm_CLR(r) (r).em_mtp_index[0] = 0
#define EM_MTP_INDEXm_SET(r,d) (r).em_mtp_index[0] = d
#define EM_MTP_INDEXm_GET(r) (r).em_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 */
#define EM_MTP_INDEXm_PORT_NUMf_GET(r) (((r).em_mtp_index[0]) & 0x3f)
#define EM_MTP_INDEXm_PORT_NUMf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define EM_MTP_INDEXm_TGIDf_GET(r) (((r).em_mtp_index[0]) & 0x7)
#define EM_MTP_INDEXm_TGIDf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define EM_MTP_INDEXm_MODULE_IDf_GET(r) ((((r).em_mtp_index[0]) >> 6) & 0xff)
#define EM_MTP_INDEXm_MODULE_IDf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define EM_MTP_INDEXm_Tf_GET(r) ((((r).em_mtp_index[0]) >> 14) & 0x1)
#define EM_MTP_INDEXm_Tf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))

/*
 * These macros can be used to access EM_MTP_INDEX.
 */
#define WRITE_EM_MTP_INDEXm(u,i,r) bcm5354x_mem_set(u, M_EM_MTP_INDEX(i), &(r._em_mtp_index), 1)
#define READ_EM_MTP_INDEXm(u,i,r) bcm5354x_mem_get(u, M_EM_MTP_INDEX(i), &(r._em_mtp_index), 1)

/*******************************************************************************
 * End of 'EM_MTP_INDEXm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  EPC_LINK_BMAP_64
 * BLOCKS:   IPIPE
 * DESC:     Link status register under software control
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Link status bitmap 
 *     PORT_BITMAP_LO   Overlay bitmap for ports 31:0
 */
#define EPC_LINK_BMAP_64r_SIZE 4

/*
 * This structure should be used to declare and program EPC_LINK_BMAP_64.
 */
typedef union EPC_LINK_BMAP_64r_s {
	uint32 v[1];
	uint32 epc_link_bmap_64[1];
	uint32 _epc_link_bmap_64;
} EPC_LINK_BMAP_64r_t;

#define EPC_LINK_BMAP_64r_CLR(r) (r).epc_link_bmap_64[0] = 0
#define EPC_LINK_BMAP_64r_SET(r,d) (r).epc_link_bmap_64[0] = d
#define EPC_LINK_BMAP_64r_GET(r) (r).epc_link_bmap_64[0]

/*
 * These macros can be used to access individual fields.
 */
#define EPC_LINK_BMAP_64r_PORT_BITMAPf_GET(r) ((r).epc_link_bmap_64[0])
#define EPC_LINK_BMAP_64r_PORT_BITMAPf_SET(r,f) (r).epc_link_bmap_64[0]=((uint32)f)
#define EPC_LINK_BMAP_64r_PORT_BITMAP_LOf_GET(r) ((r).epc_link_bmap_64[0])
#define EPC_LINK_BMAP_64r_PORT_BITMAP_LOf_SET(r,f) (r).epc_link_bmap_64[0]=((uint32)f)

/*
 * These macros can be used to access EPC_LINK_BMAP_64.
 */
#define WRITE_EPC_LINK_BMAP_64r(u,r) bcm5354x_reg_set(u,R_EPC_LINK_BMAP_64,(r._epc_link_bmap_64))
#define READ_EPC_LINK_BMAP_64r(u,r) bcm5354x_reg_get(u,R_EPC_LINK_BMAP_64,&(r._epc_link_bmap_64))

/*******************************************************************************
 * End of 'EPC_LINK_BMAP_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  FLUSH_CONTROL
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Flush enable control register
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Flush enable bit to drop out all packets in Tx FIFO without egressing any packets when set.
 */
#define FLUSH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program FLUSH_CONTROL.
 */
typedef union FLUSH_CONTROLr_s {
	uint32 v[1];
	uint32 flush_control[1];
	uint32 _flush_control;
} FLUSH_CONTROLr_t;

#define FLUSH_CONTROLr_CLR(r) (r).flush_control[0] = 0
#define FLUSH_CONTROLr_SET(r,d) (r).flush_control[0] = d
#define FLUSH_CONTROLr_GET(r) (r).flush_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define FLUSH_CONTROLr_FLUSHf_GET(r) (((r).flush_control[0]) & 0x1)
#define FLUSH_CONTROLr_FLUSHf_SET(r,f) (r).flush_control[0]=(((r).flush_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access FLUSH_CONTROL.
 */
#define WRITE_FLUSH_CONTROLr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_FLUSH_CONTROL(bcm5354x_gport_lport_to_index_in_block[p]), (r._flush_control))
#define READ_FLUSH_CONTROLr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_FLUSH_CONTROL(bcm5354x_gport_lport_to_index_in_block[p]), &(r._flush_control))

/*******************************************************************************
 * End of 'FLUSH_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  FP_COUNTER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     COUNTER TABLE FOR THE FP, FeatureSpecific-FP
 * SIZE:     66
 * FIELDS:
 *     PACKET_COUNTER   Packet Counter
 *     BYTE_COUNTER     Byte Counter
 *     RESERVED         Reserved
 *     EVEN_PARITY      Even parity.
 */
#define FP_COUNTER_TABLEm_MIN 0
#define FP_COUNTER_TABLEm_MAX 1023
#define FP_COUNTER_TABLEm_CMAX(u) 1023
#define FP_COUNTER_TABLEm_SIZE 9

/*
 * This structure should be used to declare and program FP_COUNTER_TABLE.
 */
typedef union FP_COUNTER_TABLEm_s {
	uint32 v[3];
	uint32 fp_counter_table[3];
	uint32 _fp_counter_table;
} FP_COUNTER_TABLEm_t;

#define FP_COUNTER_TABLEm_CLR(r) sal_memset(&((r)._fp_counter_table), 0, sizeof(FP_COUNTER_TABLEm_t))
#define FP_COUNTER_TABLEm_SET(r,i,d) (r).fp_counter_table[i] = d
#define FP_COUNTER_TABLEm_GET(r,i) (r).fp_counter_table[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_COUNTER_TABLEm_PACKET_COUNTERf_GET(r) (((r).fp_counter_table[0]) & 0x1fffffff)
#define FP_COUNTER_TABLEm_PACKET_COUNTERf_SET(r,f) (r).fp_counter_table[0]=(((r).fp_counter_table[0] & ~((uint32)0x1fffffff)) | (((uint32)f) & 0x1fffffff))
#define FP_COUNTER_TABLEm_BYTE_COUNTERf_GET(r,a) field_get((r).fp_counter_table,29,63,a)
#define FP_COUNTER_TABLEm_BYTE_COUNTERf_SET(r,a) field_set((r).fp_counter_table,29,63,a)
#define FP_COUNTER_TABLEm_RESERVEDf_GET(r) (((r).fp_counter_table[2]) & 0x1)
#define FP_COUNTER_TABLEm_RESERVEDf_SET(r,f) (r).fp_counter_table[2]=(((r).fp_counter_table[2] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define FP_COUNTER_TABLEm_EVEN_PARITYf_GET(r) ((((r).fp_counter_table[2]) >> 1) & 0x1)
#define FP_COUNTER_TABLEm_EVEN_PARITYf_SET(r,f) (r).fp_counter_table[2]=(((r).fp_counter_table[2] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access FP_COUNTER_TABLE.
 */
#define WRITE_FP_COUNTER_TABLEm(u,i,r) bcm5354x_mem_set(u, M_FP_COUNTER_TABLE(i), &(r._fp_counter_table), 3)
#define READ_FP_COUNTER_TABLEm(u,i,r) bcm5354x_mem_get(u, M_FP_COUNTER_TABLE(i), &(r._fp_counter_table), 3)

/*******************************************************************************
 * End of 'FP_COUNTER_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  FP_GLOBAL_MASK_TCAM
 * BLOCKS:   IPIPE
 * DESC:     PORT BITMAP TCAM ENTRY FOR EACH IFP_TCAM ENTRY.
 * SIZE:     75
 * FIELDS:
 *     VALID            VALID BIT
 *     FULL_KEY         Field created for sbus access to the entire key portion of the TCAM
 *     IPBM             1 bit for each port in the port bit map 
 *     DGLP             DGLP 
 *     DW_IPBM_F0_DGLP  DGLP 
 *     DW_IPBM_F0_S_FIELD S_FIELD 
 *     S_FIELD          S_FIELD 
 *     DW_IPBM_F0_SVP_VALID SVP_VALID 
 *     RESERVED_KEY     RESERVED to match the TCAM width 
 *     FULL_MASK        Field created for sbus access to the entire mask portion of the TCAM
 *     IPBM_MASK        IPBM field MASK
 *     DGLP_MASK        DGLP 
 *     DW_IPBM_F0_DGLPMASK DGLP 
 *     S_FIELD_MASK     S_FIELD 
 *     DW_IPBM_F0_S_FIELDMASK S_FIELD 
 *     DW_IPBM_F0_SVP_VALIDMASK SVP_VALID 
 *     RESERVED_MASK    RESERVED MASK to match the TCAM width 
 */
#define FP_GLOBAL_MASK_TCAMm_MIN 0
#define FP_GLOBAL_MASK_TCAMm_MAX 1023
#define FP_GLOBAL_MASK_TCAMm_CMAX(u) 1023
#define FP_GLOBAL_MASK_TCAMm_SIZE 10

/*
 * This structure should be used to declare and program FP_GLOBAL_MASK_TCAM.
 */
typedef union FP_GLOBAL_MASK_TCAMm_s {
	uint32 v[3];
	uint32 fp_global_mask_tcam[3];
	uint32 _fp_global_mask_tcam;
} FP_GLOBAL_MASK_TCAMm_t;

#define FP_GLOBAL_MASK_TCAMm_CLR(r) sal_memset(&((r)._fp_global_mask_tcam), 0, sizeof(FP_GLOBAL_MASK_TCAMm_t))
#define FP_GLOBAL_MASK_TCAMm_SET(r,i,d) (r).fp_global_mask_tcam[i] = d
#define FP_GLOBAL_MASK_TCAMm_GET(r,i) (r).fp_global_mask_tcam[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_GLOBAL_MASK_TCAMm_VALIDf_GET(r) (((r).fp_global_mask_tcam[0]) & 0x1)
#define FP_GLOBAL_MASK_TCAMm_VALIDf_SET(r,f) (r).fp_global_mask_tcam[0]=(((r).fp_global_mask_tcam[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define FP_GLOBAL_MASK_TCAMm_FULL_KEYf_GET(r,a) field_get((r).fp_global_mask_tcam,1,37,a)
#define FP_GLOBAL_MASK_TCAMm_FULL_KEYf_SET(r,a) field_set((r).fp_global_mask_tcam,1,37,a)
#define FP_GLOBAL_MASK_TCAMm_IPBMf_GET(r) field32_get((r).fp_global_mask_tcam,1,32)
#define FP_GLOBAL_MASK_TCAMm_IPBMf_SET(r,f) field32_set((r).fp_global_mask_tcam,1,32,f)
#define FP_GLOBAL_MASK_TCAMm_DGLPf_GET(r) ((((r).fp_global_mask_tcam[0]) >> 1) & 0x7fff)
#define FP_GLOBAL_MASK_TCAMm_DGLPf_SET(r,f) (r).fp_global_mask_tcam[0]=(((r).fp_global_mask_tcam[0] & ~((uint32)0x7fff << 1)) | ((((uint32)f) & 0x7fff) << 1))
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_DGLPf_GET(r) ((((r).fp_global_mask_tcam[0]) >> 1) & 0x7fff)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_DGLPf_SET(r,f) (r).fp_global_mask_tcam[0]=(((r).fp_global_mask_tcam[0] & ~((uint32)0x7fff << 1)) | ((((uint32)f) & 0x7fff) << 1))
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_S_FIELDf_GET(r) ((((r).fp_global_mask_tcam[0]) >> 16) & 0x7fff)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_S_FIELDf_SET(r,f) (r).fp_global_mask_tcam[0]=(((r).fp_global_mask_tcam[0] & ~((uint32)0x7fff << 16)) | ((((uint32)f) & 0x7fff) << 16))
#define FP_GLOBAL_MASK_TCAMm_S_FIELDf_GET(r) ((((r).fp_global_mask_tcam[0]) >> 16) & 0x7fff)
#define FP_GLOBAL_MASK_TCAMm_S_FIELDf_SET(r,f) (r).fp_global_mask_tcam[0]=(((r).fp_global_mask_tcam[0] & ~((uint32)0x7fff << 16)) | ((((uint32)f) & 0x7fff) << 16))
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_SVP_VALIDf_GET(r) ((((r).fp_global_mask_tcam[0]) >> 31) & 0x1)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_SVP_VALIDf_SET(r,f) (r).fp_global_mask_tcam[0]=(((r).fp_global_mask_tcam[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define FP_GLOBAL_MASK_TCAMm_RESERVED_KEYf_GET(r) ((((r).fp_global_mask_tcam[1]) >> 1) & 0x1f)
#define FP_GLOBAL_MASK_TCAMm_RESERVED_KEYf_SET(r,f) (r).fp_global_mask_tcam[1]=(((r).fp_global_mask_tcam[1] & ~((uint32)0x1f << 1)) | ((((uint32)f) & 0x1f) << 1))
#define FP_GLOBAL_MASK_TCAMm_FULL_MASKf_GET(r,a) field_get((r).fp_global_mask_tcam,38,74,a)
#define FP_GLOBAL_MASK_TCAMm_FULL_MASKf_SET(r,a) field_set((r).fp_global_mask_tcam,38,74,a)
#define FP_GLOBAL_MASK_TCAMm_IPBM_MASKf_GET(r) field32_get((r).fp_global_mask_tcam,38,69)
#define FP_GLOBAL_MASK_TCAMm_IPBM_MASKf_SET(r,f) field32_set((r).fp_global_mask_tcam,38,69,f)
#define FP_GLOBAL_MASK_TCAMm_DGLP_MASKf_GET(r) ((((r).fp_global_mask_tcam[1]) >> 6) & 0x7fff)
#define FP_GLOBAL_MASK_TCAMm_DGLP_MASKf_SET(r,f) (r).fp_global_mask_tcam[1]=(((r).fp_global_mask_tcam[1] & ~((uint32)0x7fff << 6)) | ((((uint32)f) & 0x7fff) << 6))
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_DGLPMASKf_GET(r) ((((r).fp_global_mask_tcam[1]) >> 6) & 0x7fff)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_DGLPMASKf_SET(r,f) (r).fp_global_mask_tcam[1]=(((r).fp_global_mask_tcam[1] & ~((uint32)0x7fff << 6)) | ((((uint32)f) & 0x7fff) << 6))
#define FP_GLOBAL_MASK_TCAMm_S_FIELD_MASKf_GET(r) field32_get((r).fp_global_mask_tcam,52,67)
#define FP_GLOBAL_MASK_TCAMm_S_FIELD_MASKf_SET(r,f) field32_set((r).fp_global_mask_tcam,52,67,f)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_S_FIELDMASKf_GET(r) field32_get((r).fp_global_mask_tcam,53,67)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_S_FIELDMASKf_SET(r,f) field32_set((r).fp_global_mask_tcam,53,67,f)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_SVP_VALIDMASKf_GET(r) ((((r).fp_global_mask_tcam[2]) >> 4) & 0x1)
#define FP_GLOBAL_MASK_TCAMm_DW_IPBM_F0_SVP_VALIDMASKf_SET(r,f) (r).fp_global_mask_tcam[2]=(((r).fp_global_mask_tcam[2] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define FP_GLOBAL_MASK_TCAMm_RESERVED_MASKf_GET(r) ((((r).fp_global_mask_tcam[2]) >> 6) & 0x1f)
#define FP_GLOBAL_MASK_TCAMm_RESERVED_MASKf_SET(r,f) (r).fp_global_mask_tcam[2]=(((r).fp_global_mask_tcam[2] & ~((uint32)0x1f << 6)) | ((((uint32)f) & 0x1f) << 6))

/*
 * These macros can be used to access FP_GLOBAL_MASK_TCAM.
 */
#define WRITE_FP_GLOBAL_MASK_TCAMm(u,i,r) bcm5354x_tcam_mem_set(u, M_FP_GLOBAL_MASK_TCAM(i), &(r._fp_global_mask_tcam), 3, 1, 38, 37)
#define READ_FP_GLOBAL_MASK_TCAMm(u,i,r) bcm5354x_tcam_mem_get(u, M_FP_GLOBAL_MASK_TCAM(i), &(r._fp_global_mask_tcam), 3, 1, 38, 37)

/*******************************************************************************
 * End of 'FP_GLOBAL_MASK_TCAMm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  FP_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     METER TABLE STRUCTURES FOR THE FP, FeatureSpecific-FP
 * SIZE:     68
 * FIELDS:
 *     BUCKETCOUNT      Metering Bucket Count
 *     BUCKETSIZE       Threshold determines the size of Metering Bucket. This Threshold setting is not related to actual bandwidth rate number. The Bucket size is determined by the formula: BUCKETSIZE = (CBS or EBS or PBS in bits per second) / ((granularity for the current METER_GRAN in bytes per second) * 8)
 *     REFRESHCOUNT     Refresh count for Back Pressure Metering bucket. The Refresh count is determined by the formula: REFRESHCOUNT = (CIR or PIR in bits per second) / (refresh rate for the current METER_GRAN in bits per second)
 *     REFRESH_MODE     0 = trTCM refreshing mode1 = srTCM refreshing mode
 *     METER_GRAN       Selects the Bucket Count granularity when PKTS_BYTES = 0, or the number of tokens to subtract from the bucket when PKTS_BYTES == 1. For PKTS_BYTES = 0:   Refr Rate BC[0] BC BYTE BC MAX BS Gran BS MAX 0 8000bps 1/128Byte BC[7] 2Mbyte 512byte 2Mbyte 1 16000bps 1/64Byte BC[6] 4Mbyte 1Kbyte 4Mbyte 2 32000bps 1/32Byte BC[5] 8Mbyte 2Kbyte 8Mbyte 3 64000bps 1/16Byte BC[4] 16Mbyte 4Kbyte 16Mbyte 4 128000bps 1/8Byte BC[3] 32Mbyte 8Kbyte 32Mbyte 5 256000bps 1/4Byte BC[2] 64Mbyte 16Kbyte 64Mbyte 6 512000bps 1/2Byte BC[1] 128Mbyte 32Kbyte 128Mbyte 7 1000000bps 1Byte BC[0] 256Mbyte 64Kbyte 256Mbyte For PKTS_BYTES = 1:   Tokens Token Min Pkt Max Pkt Max Gbps Step Size Min Burst Max Burst   Per Pkt  Unit   Rate  Rate  Rate (Pkts/Sec) Size   Size 0 128000  1/128000 1   0.52   0.27   1       (1,4)   2.097 1 64000  1/64000   2   1.05   0.54   2       (1,8)   4.194 2 32000  1/32000   4   2.1    1.08   4       (1,16)  8.388 3 16000  1/16000   8   4.19   2.15   8       (1,32)  16.777 4 8000  1/8000    16   8.39   4.3    16      (1,65)  33.554 5 4000  1/4000    32   16.78  8.59   32      (1,131) 67.108 6 2000  1/2000    64   33.55  17.18  64      (1,262) 134.217 7 250   1/250     512  268.44 137.44 512     (1,2097) 1073.741
 *     PKTS_BYTES       Selects whether the meter operates on bytes or packets. This affects how the the METER_GRAN field is used. 0 = Meter operates on bytes (Default) 1 = Meter operates on packets 
 *     EVEN_PARITY      Even parity.
 */
#define FP_METER_TABLEm_MIN 0
#define FP_METER_TABLEm_MAX 1023
#define FP_METER_TABLEm_CMAX(u) 1023
#define FP_METER_TABLEm_SIZE 9

/*
 * This structure should be used to declare and program FP_METER_TABLE.
 */
typedef union FP_METER_TABLEm_s {
	uint32 v[3];
	uint32 fp_meter_table[3];
	uint32 _fp_meter_table;
} FP_METER_TABLEm_t;

#define FP_METER_TABLEm_CLR(r) sal_memset(&((r)._fp_meter_table), 0, sizeof(FP_METER_TABLEm_t))
#define FP_METER_TABLEm_SET(r,i,d) (r).fp_meter_table[i] = d
#define FP_METER_TABLEm_GET(r,i) (r).fp_meter_table[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_meter_table[0]) & 0x3fffffff)
#define FP_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_meter_table[0]=(((r).fp_meter_table[0] & ~((uint32)0x3fffffff)) | (((uint32)f) & 0x3fffffff))
#define FP_METER_TABLEm_BUCKETSIZEf_GET(r) field32_get((r).fp_meter_table,30,41)
#define FP_METER_TABLEm_BUCKETSIZEf_SET(r,f) field32_set((r).fp_meter_table,30,41,f)
#define FP_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_meter_table[1]) >> 10) & 0x7ffff)
#define FP_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_meter_table[1]=(((r).fp_meter_table[1] & ~((uint32)0x7ffff << 10)) | ((((uint32)f) & 0x7ffff) << 10))
#define FP_METER_TABLEm_REFRESH_MODEf_GET(r) ((((r).fp_meter_table[1]) >> 29) & 0x3)
#define FP_METER_TABLEm_REFRESH_MODEf_SET(r,f) (r).fp_meter_table[1]=(((r).fp_meter_table[1] & ~((uint32)0x3 << 29)) | ((((uint32)f) & 0x3) << 29))
#define FP_METER_TABLEm_METER_GRANf_GET(r) field32_get((r).fp_meter_table,63,65)
#define FP_METER_TABLEm_METER_GRANf_SET(r,f) field32_set((r).fp_meter_table,63,65,f)
#define FP_METER_TABLEm_PKTS_BYTESf_GET(r) ((((r).fp_meter_table[2]) >> 2) & 0x1)
#define FP_METER_TABLEm_PKTS_BYTESf_SET(r,f) (r).fp_meter_table[2]=(((r).fp_meter_table[2] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_METER_TABLEm_EVEN_PARITYf_GET(r) ((((r).fp_meter_table[2]) >> 3) & 0x1)
#define FP_METER_TABLEm_EVEN_PARITYf_SET(r,f) (r).fp_meter_table[2]=(((r).fp_meter_table[2] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))

/*
 * These macros can be used to access FP_METER_TABLE.
 */
#define WRITE_FP_METER_TABLEm(u,i,r) bcm5354x_mem_set(u, M_FP_METER_TABLE(i), &(r._fp_meter_table), 3)
#define READ_FP_METER_TABLEm(u,i,r) bcm5354x_mem_get(u, M_FP_METER_TABLE(i), &(r._fp_meter_table), 3)

/*******************************************************************************
 * End of 'FP_METER_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  FP_POLICY_TABLE
 * BLOCKS:   IPIPE
 * DESC:     POLICY TABLE FOR DETERMINING ACTIONS IN THE FP, FeatureSpecific-FP
 * SIZE:     245
 * FIELDS:
 *     IM0_MTP_INDEX    Overlay field added for TR compatibility
 *     MTP_INDEX0       MTP_INDEX0 is for Ingress Mirror only (IM0)
 *     EM0_MTP_INDEX    Overlay field added for TR compatibility
 *     MIRROR           Bits 8 & 9 are for Ingress Mirror only and bits 10 & 11 are for Egress Mirror only
 *     INGRESS_MIRROR   Overlay field added for TR compatibility
 *     EGRESS_MIRROR    Overlay field added for TR compatibility
 *     R_NEW_PKT_PRI    
 *     Y_NEW_PKT_PRI    
 *     G_NEW_PKT_PRI    
 *     R_COS_INT_PRI    
 *     Y_COS_INT_PRI    
 *     G_COS_INT_PRI    
 *     CPU_COS          CPU_COS
 *     REDIRECTION      REDIRECTION
 *     REDIRECTION_DGLP REDIRECTION_DGLP
 *     REDIRECTION_NHI  NHI for redirect_to_nhi. Valid values is same as depth of Next Hop Table
 *     REDIRECTION_PROFILE_INDEX REDIRECTION_PROFILE_INDEX
 *     REPLACE_PBM_BC_TYPE The replace pbm bc type is meant to distinguish whether the PBM to Broadcast is the VLAN PBM or picked from the redirection table
 *     REDIRECTION_TYPE REDIRECTION_TYPE
 *     REDIRECTION_NH   NH is the top bit in this field and is meant to distinguish between regular redirection and redirect_to_nhi
 *     MATCHED_RULE     
 *     ECMP_NH_INFO     ECMP_NH_INFO 
 *     PPD1_CLASS_TAG   PPD1_CLASS_TAG 
 *     NEXT_HOP_INDEX   NEXT_HOP_INDEX. Valid values is same as depth of Next Hop Table
 *     ECMP             ECMP falg.
 *     Y_NEW_DSCP       Y_NEW_DSCP 
 *     R_NEW_DSCP       R_NEW_DSCP 
 *     G_NEW_DSCP_TOS   G_NEW_DSCP
 *     METER_SHARING_MODE METER_SHARING_MODE 
 *     METER_SHARING_MODE_MODIFIER METER_SHARING_MODE_MODIFIER 
 *     METER_PAIR_MODE  METER_PAIR_MODE 
 *     METER_PAIR_MODE_MODIFIER METER_PAIR_MODE_MODIFIER 
 *     SHARED_METER_PAIR_INDEX SHARED_METER_PAIR_INDEX 
 *     RESERVED_115     RESERVED.
 *     METER_PAIR_INDEX METER_PAIR_INDEX 
 *     RESERVED_125     RESERVED.
 *     COUNTER_MODE     COUNTER_MODE 
 *     COUNTER_INDEX    COUNTER_INDEX 
 *     RESERVED_135     RESERVED.
 *     DO_NOT_URPF      DO_NOT_URPF.
 *     DO_NOT_CHANGE_TTL DO_NOT_CHANGE_TTL 
 *     MIRROR_OVERRIDE  MIRROR_OVERRIDE 
 *     GREEN_TO_PID     GREEN_TO_PID 
 *     CHANGE_CPU_COS   CHANGE_CPU_COS: 0==NOP, 1=CHANGE_CPU_COS 
 *     R_CHANGE_DSCP    R_CHANGE_DSCP 
 *     R_COPY_TO_CPU    R_COPY_TO_CPU 
 *     R_DROP_PRECEDENCE R_DROP_PRECEDENCE 
 *     R_DROP           R_DROP 
 *     R_CHANGE_ECN     R_CHANGE_ECN 
 *     R_CHANGE_COS_OR_INT_PRI R_CHANGE_COS_OR_INT_PRI 
 *     R_CHANGE_PKT_PRI R_CHANGE_PKT_PRI 
 *     Y_CHANGE_DSCP    Y_CHANGE_DSCP 
 *     Y_COPY_TO_CPU    Y_COPY_TO_CPU 
 *     Y_DROP_PRECEDENCE Y_DROP_PRECEDENCE 
 *     Y_DROP           Y_DROP 
 *     Y_CHANGE_ECN     Y_CHANGE_ECN 
 *     Y_CHANGE_COS_OR_INT_PRI Y_CHANGE_COS_OR_INT_PRI 
 *     Y_CHANGE_PKT_PRI Y_CHANGE_PKT_PRI 
 *     G_DROP_PRECEDENCE G_DROP_PRECEDENCE 
 *     G_CHANGE_ECN     G_CHANGE_ECN 
 *     G_L3SW_CHANGE_L2_FIELDS G_L3SW_CHANGE_L2_FIELDS 
 *     G_L3SW_CHANGE_MACDA_OR_VLAN G_L3SW_CHANGE_L2_FIELDS 
 *     G_DROP           G_DROP 
 *     G_PACKET_REDIRECTION G_PACKET_REDIRECTION 
 *     G_COPY_TO_CPU    G_COPY_TO_CPU 
 *     G_CHANGE_DSCP_TOS G_CHANGE_DSCP_TOS 
 *     G_CHANGE_COS_OR_INT_PRI G_CHANGE_COS_OR_INT_PRI 
 *     G_CHANGE_PKT_PRI G_CHANGE_PKT_PRI 
 *     OAM_SET          OAM fields
 *     PFC_STREAM_ID    Associated data for PFC_TRIGGER. 
 *     HEADER_ENCAP_INDEX Associated data for action (ASSIGN_HEADER_ENCAP_FIELDS). 
 *     OAM_TAG_STATUS_CHECK_CONTROL Expected tag status and mask.
 *     OAM_UP_MEP       Indicates that this LMEP is configured as an UP MEP.
 *     OAM_TX           Indicates TX direction OAM PDU or data packet. Used as MSB of OAM_LM_BASE_PTR.
 *     OAM_LMEP_MDL     Configured MDL value for the LMEP.
 *     PFC_TC           Associated data for PFC_TRIGGER. 
 *     OAM_SERVICE_PRI_MAPPING_PTR This field concatenated with the internal priority in Irsel2 to lookup ING_SERVICE_PRI_MAP.
 *     OAM_LM_BASE_PTR  Base pointer to 4k deep LM packet counter table. MSB bit is OAM_TX
 *     RESERVED0        RESERVED
 *     PFC_TRIGGER      action: Trigger PFC frame. 
 *     ASSIGN_HEADER_ENCAP_FIELDS For Custom Header, this action will enable Custom Header encapsulation and HEADER_ENCAP_INDEX will provide index to a table which provides Custom Header fields; For MIML, this action will assign HEADER_ENCAP_INDEX, which indexes to a table which provides subfieds of MIML header.
 *     OAM_DM_TYPE      OAM delay measurement type.
 *     OAM_DM_EN        Enables OAM delay measurement.
 *     OAM_LM_EN        Enables OAM loss measurement.
 *     OAM_LMEP_EN      Entry is enabled for OAM loss/delay measurement.
 *     R_NEW_INT_CN     New value for R_CHANGE_INT_CN action.
 *     Y_NEW_INT_CN     New value for Y_CHANGE_INT_CN action.
 *     G_NEW_INT_CN     Values are: 00: Reset internal CN, 01: Set internal CN to 0x1, 10: Set internal CN to 0x2, 11: Set internal CN to 0x3,
 *     R_CHANGE_INT_CN  Modify red packet internal CN value.
 *     Y_CHANGE_INT_CN  Modify yellow packet internal CN value.
 *     G_CHANGE_INT_CN  Modify green packet internal CN value.
 *     NEW_INPUT_PRIORITY New value for input priority.
 *     CHANGE_INPUT_PRIORITY Modify input priority value.
 *     PARITY           parity
 */
#define FP_POLICY_TABLEm_MIN 0
#define FP_POLICY_TABLEm_MAX 1023
#define FP_POLICY_TABLEm_CMAX(u) 1023
#define FP_POLICY_TABLEm_SIZE 31

/*
 * This structure should be used to declare and program FP_POLICY_TABLE.
 */
typedef union FP_POLICY_TABLEm_s {
	uint32 v[8];
	uint32 fp_policy_table[8];
	uint32 _fp_policy_table;
} FP_POLICY_TABLEm_t;

#define FP_POLICY_TABLEm_CLR(r) sal_memset(&((r)._fp_policy_table), 0, sizeof(FP_POLICY_TABLEm_t))
#define FP_POLICY_TABLEm_SET(r,i,d) (r).fp_policy_table[i] = d
#define FP_POLICY_TABLEm_GET(r,i) (r).fp_policy_table[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_POLICY_TABLEm_IM0_MTP_INDEXf_GET(r) (((r).fp_policy_table[0]) & 0x3)
#define FP_POLICY_TABLEm_IM0_MTP_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_POLICY_TABLEm_MTP_INDEX0f_GET(r) (((r).fp_policy_table[0]) & 0x3)
#define FP_POLICY_TABLEm_MTP_INDEX0f_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_POLICY_TABLEm_EM0_MTP_INDEXf_GET(r) ((((r).fp_policy_table[0]) >> 4) & 0x3)
#define FP_POLICY_TABLEm_EM0_MTP_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define FP_POLICY_TABLEm_MIRRORf_GET(r) ((((r).fp_policy_table[0]) >> 8) & 0xf)
#define FP_POLICY_TABLEm_MIRRORf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define FP_POLICY_TABLEm_INGRESS_MIRRORf_GET(r) ((((r).fp_policy_table[0]) >> 8) & 0x3)
#define FP_POLICY_TABLEm_INGRESS_MIRRORf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define FP_POLICY_TABLEm_EGRESS_MIRRORf_GET(r) ((((r).fp_policy_table[0]) >> 10) & 0x3)
#define FP_POLICY_TABLEm_EGRESS_MIRRORf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define FP_POLICY_TABLEm_R_NEW_PKT_PRIf_GET(r) ((((r).fp_policy_table[0]) >> 12) & 0x7)
#define FP_POLICY_TABLEm_R_NEW_PKT_PRIf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define FP_POLICY_TABLEm_Y_NEW_PKT_PRIf_GET(r) ((((r).fp_policy_table[0]) >> 15) & 0x7)
#define FP_POLICY_TABLEm_Y_NEW_PKT_PRIf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define FP_POLICY_TABLEm_G_NEW_PKT_PRIf_GET(r) ((((r).fp_policy_table[0]) >> 18) & 0x7)
#define FP_POLICY_TABLEm_G_NEW_PKT_PRIf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define FP_POLICY_TABLEm_R_COS_INT_PRIf_GET(r) ((((r).fp_policy_table[0]) >> 21) & 0x1f)
#define FP_POLICY_TABLEm_R_COS_INT_PRIf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x1f << 21)) | ((((uint32)f) & 0x1f) << 21))
#define FP_POLICY_TABLEm_Y_COS_INT_PRIf_GET(r) ((((r).fp_policy_table[0]) >> 26) & 0x1f)
#define FP_POLICY_TABLEm_Y_COS_INT_PRIf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32)0x1f << 26)) | ((((uint32)f) & 0x1f) << 26))
#define FP_POLICY_TABLEm_G_COS_INT_PRIf_GET(r) field32_get((r).fp_policy_table,31,35)
#define FP_POLICY_TABLEm_G_COS_INT_PRIf_SET(r,f) field32_set((r).fp_policy_table,31,35,f)
#define FP_POLICY_TABLEm_CPU_COSf_GET(r) ((((r).fp_policy_table[1]) >> 4) & 0x3f)
#define FP_POLICY_TABLEm_CPU_COSf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0x3f << 4)) | ((((uint32)f) & 0x3f) << 4))
#define FP_POLICY_TABLEm_REDIRECTIONf_GET(r) ((((r).fp_policy_table[1]) >> 10) & 0xffff)
#define FP_POLICY_TABLEm_REDIRECTIONf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0xffff << 10)) | ((((uint32)f) & 0xffff) << 10))
#define FP_POLICY_TABLEm_REDIRECTION_DGLPf_GET(r) ((((r).fp_policy_table[1]) >> 10) & 0x7fff)
#define FP_POLICY_TABLEm_REDIRECTION_DGLPf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0x7fff << 10)) | ((((uint32)f) & 0x7fff) << 10))
#define FP_POLICY_TABLEm_REDIRECTION_NHIf_GET(r) ((((r).fp_policy_table[1]) >> 10) & 0x1ff)
#define FP_POLICY_TABLEm_REDIRECTION_NHIf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0x1ff << 10)) | ((((uint32)f) & 0x1ff) << 10))
#define FP_POLICY_TABLEm_REDIRECTION_PROFILE_INDEXf_GET(r) ((((r).fp_policy_table[1]) >> 10) & 0xff)
#define FP_POLICY_TABLEm_REDIRECTION_PROFILE_INDEXf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0xff << 10)) | ((((uint32)f) & 0xff) << 10))
#define FP_POLICY_TABLEm_REPLACE_PBM_BC_TYPEf_GET(r) ((((r).fp_policy_table[1]) >> 21) & 0x1)
#define FP_POLICY_TABLEm_REPLACE_PBM_BC_TYPEf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define FP_POLICY_TABLEm_REDIRECTION_TYPEf_GET(r) ((((r).fp_policy_table[1]) >> 22) & 0x3)
#define FP_POLICY_TABLEm_REDIRECTION_TYPEf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define FP_POLICY_TABLEm_REDIRECTION_NHf_GET(r) ((((r).fp_policy_table[1]) >> 25) & 0x1)
#define FP_POLICY_TABLEm_REDIRECTION_NHf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define FP_POLICY_TABLEm_MATCHED_RULEf_GET(r) field32_get((r).fp_policy_table,58,65)
#define FP_POLICY_TABLEm_MATCHED_RULEf_SET(r,f) field32_set((r).fp_policy_table,58,65,f)
#define FP_POLICY_TABLEm_ECMP_NH_INFOf_GET(r) ((((r).fp_policy_table[2]) >> 2) & 0x7fff)
#define FP_POLICY_TABLEm_ECMP_NH_INFOf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x7fff << 2)) | ((((uint32)f) & 0x7fff) << 2))
#define FP_POLICY_TABLEm_PPD1_CLASS_TAGf_GET(r) ((((r).fp_policy_table[2]) >> 2) & 0x1fff)
#define FP_POLICY_TABLEm_PPD1_CLASS_TAGf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x1fff << 2)) | ((((uint32)f) & 0x1fff) << 2))
#define FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET(r) ((((r).fp_policy_table[2]) >> 2) & 0x1ff)
#define FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x1ff << 2)) | ((((uint32)f) & 0x1ff) << 2))
#define FP_POLICY_TABLEm_ECMPf_GET(r) ((((r).fp_policy_table[2]) >> 15) & 0x1)
#define FP_POLICY_TABLEm_ECMPf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define FP_POLICY_TABLEm_Y_NEW_DSCPf_GET(r) ((((r).fp_policy_table[2]) >> 17) & 0x3f)
#define FP_POLICY_TABLEm_Y_NEW_DSCPf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define FP_POLICY_TABLEm_R_NEW_DSCPf_GET(r) ((((r).fp_policy_table[2]) >> 23) & 0x3f)
#define FP_POLICY_TABLEm_R_NEW_DSCPf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32)0x3f << 23)) | ((((uint32)f) & 0x3f) << 23))
#define FP_POLICY_TABLEm_G_NEW_DSCP_TOSf_GET(r) field32_get((r).fp_policy_table,93,98)
#define FP_POLICY_TABLEm_G_NEW_DSCP_TOSf_SET(r,f) field32_set((r).fp_policy_table,93,98,f)
#define FP_POLICY_TABLEm_METER_SHARING_MODEf_GET(r) ((((r).fp_policy_table[3]) >> 3) & 0x3)
#define FP_POLICY_TABLEm_METER_SHARING_MODEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x3 << 3)) | ((((uint32)f) & 0x3) << 3))
#define FP_POLICY_TABLEm_METER_SHARING_MODE_MODIFIERf_GET(r) ((((r).fp_policy_table[3]) >> 5) & 0x1)
#define FP_POLICY_TABLEm_METER_SHARING_MODE_MODIFIERf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_POLICY_TABLEm_METER_PAIR_MODEf_GET(r) ((((r).fp_policy_table[3]) >> 6) & 0x7)
#define FP_POLICY_TABLEm_METER_PAIR_MODEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define FP_POLICY_TABLEm_METER_PAIR_MODE_MODIFIERf_GET(r) ((((r).fp_policy_table[3]) >> 9) & 0x1)
#define FP_POLICY_TABLEm_METER_PAIR_MODE_MODIFIERf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_POLICY_TABLEm_SHARED_METER_PAIR_INDEXf_GET(r) ((((r).fp_policy_table[3]) >> 10) & 0x1ff)
#define FP_POLICY_TABLEm_SHARED_METER_PAIR_INDEXf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x1ff << 10)) | ((((uint32)f) & 0x1ff) << 10))
#define FP_POLICY_TABLEm_RESERVED_115f_GET(r) ((((r).fp_policy_table[3]) >> 19) & 0x1)
#define FP_POLICY_TABLEm_RESERVED_115f_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_POLICY_TABLEm_METER_PAIR_INDEXf_GET(r) ((((r).fp_policy_table[3]) >> 20) & 0x1ff)
#define FP_POLICY_TABLEm_METER_PAIR_INDEXf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x1ff << 20)) | ((((uint32)f) & 0x1ff) << 20))
#define FP_POLICY_TABLEm_RESERVED_125f_GET(r) ((((r).fp_policy_table[3]) >> 29) & 0x1)
#define FP_POLICY_TABLEm_RESERVED_125f_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define FP_POLICY_TABLEm_COUNTER_MODEf_GET(r) field32_get((r).fp_policy_table,126,128)
#define FP_POLICY_TABLEm_COUNTER_MODEf_SET(r,f) field32_set((r).fp_policy_table,126,128,f)
#define FP_POLICY_TABLEm_COUNTER_INDEXf_GET(r) ((((r).fp_policy_table[4]) >> 1) & 0x3f)
#define FP_POLICY_TABLEm_COUNTER_INDEXf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x3f << 1)) | ((((uint32)f) & 0x3f) << 1))
#define FP_POLICY_TABLEm_RESERVED_135f_GET(r) ((((r).fp_policy_table[4]) >> 7) & 0x1)
#define FP_POLICY_TABLEm_RESERVED_135f_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_POLICY_TABLEm_DO_NOT_URPFf_GET(r) ((((r).fp_policy_table[4]) >> 8) & 0x1)
#define FP_POLICY_TABLEm_DO_NOT_URPFf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_GET(r) ((((r).fp_policy_table[4]) >> 9) & 0x1)
#define FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_POLICY_TABLEm_MIRROR_OVERRIDEf_GET(r) ((((r).fp_policy_table[4]) >> 10) & 0x1)
#define FP_POLICY_TABLEm_MIRROR_OVERRIDEf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define FP_POLICY_TABLEm_GREEN_TO_PIDf_GET(r) ((((r).fp_policy_table[4]) >> 11) & 0x1)
#define FP_POLICY_TABLEm_GREEN_TO_PIDf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_POLICY_TABLEm_CHANGE_CPU_COSf_GET(r) ((((r).fp_policy_table[4]) >> 12) & 0x1)
#define FP_POLICY_TABLEm_CHANGE_CPU_COSf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_POLICY_TABLEm_R_CHANGE_DSCPf_GET(r) ((((r).fp_policy_table[4]) >> 13) & 0x3)
#define FP_POLICY_TABLEm_R_CHANGE_DSCPf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define FP_POLICY_TABLEm_R_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[4]) >> 15) & 0x7)
#define FP_POLICY_TABLEm_R_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define FP_POLICY_TABLEm_R_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[4]) >> 18) & 0x3)
#define FP_POLICY_TABLEm_R_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define FP_POLICY_TABLEm_R_DROPf_GET(r) ((((r).fp_policy_table[4]) >> 20) & 0x3)
#define FP_POLICY_TABLEm_R_DROPf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define FP_POLICY_TABLEm_R_CHANGE_ECNf_GET(r) ((((r).fp_policy_table[4]) >> 22) & 0x3)
#define FP_POLICY_TABLEm_R_CHANGE_ECNf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define FP_POLICY_TABLEm_R_CHANGE_COS_OR_INT_PRIf_GET(r) ((((r).fp_policy_table[4]) >> 24) & 0x7)
#define FP_POLICY_TABLEm_R_CHANGE_COS_OR_INT_PRIf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define FP_POLICY_TABLEm_R_CHANGE_PKT_PRIf_GET(r) ((((r).fp_policy_table[4]) >> 27) & 0x7)
#define FP_POLICY_TABLEm_R_CHANGE_PKT_PRIf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define FP_POLICY_TABLEm_Y_CHANGE_DSCPf_GET(r) ((((r).fp_policy_table[4]) >> 30) & 0x3)
#define FP_POLICY_TABLEm_Y_CHANGE_DSCPf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define FP_POLICY_TABLEm_Y_COPY_TO_CPUf_GET(r) (((r).fp_policy_table[5]) & 0x7)
#define FP_POLICY_TABLEm_Y_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define FP_POLICY_TABLEm_Y_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[5]) >> 3) & 0x3)
#define FP_POLICY_TABLEm_Y_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x3 << 3)) | ((((uint32)f) & 0x3) << 3))
#define FP_POLICY_TABLEm_Y_DROPf_GET(r) ((((r).fp_policy_table[5]) >> 5) & 0x3)
#define FP_POLICY_TABLEm_Y_DROPf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x3 << 5)) | ((((uint32)f) & 0x3) << 5))
#define FP_POLICY_TABLEm_Y_CHANGE_ECNf_GET(r) ((((r).fp_policy_table[5]) >> 7) & 0x3)
#define FP_POLICY_TABLEm_Y_CHANGE_ECNf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define FP_POLICY_TABLEm_Y_CHANGE_COS_OR_INT_PRIf_GET(r) ((((r).fp_policy_table[5]) >> 9) & 0x7)
#define FP_POLICY_TABLEm_Y_CHANGE_COS_OR_INT_PRIf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define FP_POLICY_TABLEm_Y_CHANGE_PKT_PRIf_GET(r) ((((r).fp_policy_table[5]) >> 12) & 0x7)
#define FP_POLICY_TABLEm_Y_CHANGE_PKT_PRIf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define FP_POLICY_TABLEm_G_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[5]) >> 15) & 0x3)
#define FP_POLICY_TABLEm_G_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x3 << 15)) | ((((uint32)f) & 0x3) << 15))
#define FP_POLICY_TABLEm_G_CHANGE_ECNf_GET(r) ((((r).fp_policy_table[5]) >> 17) & 0x3)
#define FP_POLICY_TABLEm_G_CHANGE_ECNf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x3 << 17)) | ((((uint32)f) & 0x3) << 17))
#define FP_POLICY_TABLEm_G_L3SW_CHANGE_L2_FIELDSf_GET(r) ((((r).fp_policy_table[5]) >> 19) & 0x7)
#define FP_POLICY_TABLEm_G_L3SW_CHANGE_L2_FIELDSf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define FP_POLICY_TABLEm_G_L3SW_CHANGE_MACDA_OR_VLANf_GET(r) ((((r).fp_policy_table[5]) >> 19) & 0x7)
#define FP_POLICY_TABLEm_G_L3SW_CHANGE_MACDA_OR_VLANf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define FP_POLICY_TABLEm_G_DROPf_GET(r) ((((r).fp_policy_table[5]) >> 22) & 0x3)
#define FP_POLICY_TABLEm_G_DROPf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define FP_POLICY_TABLEm_G_PACKET_REDIRECTIONf_GET(r) ((((r).fp_policy_table[5]) >> 24) & 0x7)
#define FP_POLICY_TABLEm_G_PACKET_REDIRECTIONf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define FP_POLICY_TABLEm_G_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[5]) >> 27) & 0x7)
#define FP_POLICY_TABLEm_G_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define FP_POLICY_TABLEm_G_CHANGE_DSCP_TOSf_GET(r) field32_get((r).fp_policy_table,190,192)
#define FP_POLICY_TABLEm_G_CHANGE_DSCP_TOSf_SET(r,f) field32_set((r).fp_policy_table,190,192,f)
#define FP_POLICY_TABLEm_G_CHANGE_COS_OR_INT_PRIf_GET(r) ((((r).fp_policy_table[6]) >> 1) & 0x7)
#define FP_POLICY_TABLEm_G_CHANGE_COS_OR_INT_PRIf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define FP_POLICY_TABLEm_G_CHANGE_PKT_PRIf_GET(r) ((((r).fp_policy_table[6]) >> 4) & 0x7)
#define FP_POLICY_TABLEm_G_CHANGE_PKT_PRIf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_POLICY_TABLEm_OAM_SETf_GET(r) field32_get((r).fp_policy_table,199,229)
#define FP_POLICY_TABLEm_OAM_SETf_SET(r,f) field32_set((r).fp_policy_table,199,229,f)
#define FP_POLICY_TABLEm_PFC_STREAM_IDf_GET(r) ((((r).fp_policy_table[6]) >> 7) & 0xff)
#define FP_POLICY_TABLEm_PFC_STREAM_IDf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define FP_POLICY_TABLEm_HEADER_ENCAP_INDEXf_GET(r) ((((r).fp_policy_table[6]) >> 7) & 0x3f)
#define FP_POLICY_TABLEm_HEADER_ENCAP_INDEXf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x3f << 7)) | ((((uint32)f) & 0x3f) << 7))
#define FP_POLICY_TABLEm_OAM_TAG_STATUS_CHECK_CONTROLf_GET(r) ((((r).fp_policy_table[6]) >> 7) & 0xf)
#define FP_POLICY_TABLEm_OAM_TAG_STATUS_CHECK_CONTROLf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0xf << 7)) | ((((uint32)f) & 0xf) << 7))
#define FP_POLICY_TABLEm_OAM_UP_MEPf_GET(r) ((((r).fp_policy_table[6]) >> 12) & 0x1)
#define FP_POLICY_TABLEm_OAM_UP_MEPf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_POLICY_TABLEm_OAM_TXf_GET(r) ((((r).fp_policy_table[6]) >> 13) & 0x1)
#define FP_POLICY_TABLEm_OAM_TXf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_POLICY_TABLEm_OAM_LMEP_MDLf_GET(r) ((((r).fp_policy_table[6]) >> 14) & 0x7)
#define FP_POLICY_TABLEm_OAM_LMEP_MDLf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define FP_POLICY_TABLEm_PFC_TCf_GET(r) ((((r).fp_policy_table[6]) >> 17) & 0xff)
#define FP_POLICY_TABLEm_PFC_TCf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0xff << 17)) | ((((uint32)f) & 0xff) << 17))
#define FP_POLICY_TABLEm_OAM_SERVICE_PRI_MAPPING_PTRf_GET(r) ((((r).fp_policy_table[6]) >> 17) & 0xf)
#define FP_POLICY_TABLEm_OAM_SERVICE_PRI_MAPPING_PTRf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0xf << 17)) | ((((uint32)f) & 0xf) << 17))
#define FP_POLICY_TABLEm_OAM_LM_BASE_PTRf_GET(r) ((((r).fp_policy_table[6]) >> 21) & 0x7ff)
#define FP_POLICY_TABLEm_OAM_LM_BASE_PTRf_SET(r,f) (r).fp_policy_table[6]=(((r).fp_policy_table[6] & ~((uint32)0x7ff << 21)) | ((((uint32)f) & 0x7ff) << 21))
#define FP_POLICY_TABLEm_RESERVED0f_GET(r) (((r).fp_policy_table[7]) & 0x3)
#define FP_POLICY_TABLEm_RESERVED0f_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_POLICY_TABLEm_PFC_TRIGGERf_GET(r) (((r).fp_policy_table[7]) & 0x1)
#define FP_POLICY_TABLEm_PFC_TRIGGERf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define FP_POLICY_TABLEm_ASSIGN_HEADER_ENCAP_FIELDSf_GET(r) ((((r).fp_policy_table[7]) >> 1) & 0x1)
#define FP_POLICY_TABLEm_ASSIGN_HEADER_ENCAP_FIELDSf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_POLICY_TABLEm_OAM_DM_TYPEf_GET(r) ((((r).fp_policy_table[7]) >> 2) & 0x1)
#define FP_POLICY_TABLEm_OAM_DM_TYPEf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_POLICY_TABLEm_OAM_DM_ENf_GET(r) ((((r).fp_policy_table[7]) >> 3) & 0x1)
#define FP_POLICY_TABLEm_OAM_DM_ENf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define FP_POLICY_TABLEm_OAM_LM_ENf_GET(r) ((((r).fp_policy_table[7]) >> 4) & 0x1)
#define FP_POLICY_TABLEm_OAM_LM_ENf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define FP_POLICY_TABLEm_OAM_LMEP_ENf_GET(r) ((((r).fp_policy_table[7]) >> 5) & 0x1)
#define FP_POLICY_TABLEm_OAM_LMEP_ENf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_POLICY_TABLEm_R_NEW_INT_CNf_GET(r) ((((r).fp_policy_table[7]) >> 6) & 0x3)
#define FP_POLICY_TABLEm_R_NEW_INT_CNf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define FP_POLICY_TABLEm_Y_NEW_INT_CNf_GET(r) ((((r).fp_policy_table[7]) >> 8) & 0x3)
#define FP_POLICY_TABLEm_Y_NEW_INT_CNf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define FP_POLICY_TABLEm_G_NEW_INT_CNf_GET(r) ((((r).fp_policy_table[7]) >> 10) & 0x3)
#define FP_POLICY_TABLEm_G_NEW_INT_CNf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define FP_POLICY_TABLEm_R_CHANGE_INT_CNf_GET(r) ((((r).fp_policy_table[7]) >> 12) & 0x1)
#define FP_POLICY_TABLEm_R_CHANGE_INT_CNf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_POLICY_TABLEm_Y_CHANGE_INT_CNf_GET(r) ((((r).fp_policy_table[7]) >> 13) & 0x1)
#define FP_POLICY_TABLEm_Y_CHANGE_INT_CNf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_POLICY_TABLEm_G_CHANGE_INT_CNf_GET(r) ((((r).fp_policy_table[7]) >> 14) & 0x1)
#define FP_POLICY_TABLEm_G_CHANGE_INT_CNf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define FP_POLICY_TABLEm_NEW_INPUT_PRIORITYf_GET(r) ((((r).fp_policy_table[7]) >> 15) & 0xf)
#define FP_POLICY_TABLEm_NEW_INPUT_PRIORITYf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0xf << 15)) | ((((uint32)f) & 0xf) << 15))
#define FP_POLICY_TABLEm_CHANGE_INPUT_PRIORITYf_GET(r) ((((r).fp_policy_table[7]) >> 19) & 0x1)
#define FP_POLICY_TABLEm_CHANGE_INPUT_PRIORITYf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_POLICY_TABLEm_PARITYf_GET(r) ((((r).fp_policy_table[7]) >> 20) & 0x1)
#define FP_POLICY_TABLEm_PARITYf_SET(r,f) (r).fp_policy_table[7]=(((r).fp_policy_table[7] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))

/*
 * These macros can be used to access FP_POLICY_TABLE.
 */
#define WRITE_FP_POLICY_TABLEm(u,i,r) bcm5354x_mem_set(u, M_FP_POLICY_TABLE(i), &(r._fp_policy_table), 8)
#define READ_FP_POLICY_TABLEm(u,i,r) bcm5354x_mem_get(u, M_FP_POLICY_TABLE(i), &(r._fp_policy_table), 8)

/*******************************************************************************
 * End of 'FP_POLICY_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  FP_PORT_FIELD_SEL
 * BLOCKS:   IPIPE
 * DESC:     FIELD SELECT VALUE FOR EACH SLICE IN THE ContentAware Processor, FeatureSpecific-FP
 * SIZE:     180
 * FIELDS:
 *     SLICE0_F1        F1 field for slice 0.
 *     SLICE0_F2        F2 field for slice 0
 *     SLICE0_F3        F3 field for slice 0
 *     SLICE0_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE0_DOUBLE_WIDE_MODE Double wide mode for slice 0 (0 == single wide, 1 == double wide)
 *     SLICE1_F1        F1 field for slice 1.
 *     SLICE1_F2        F2 field for slice 1
 *     SLICE1_F3        F3 field for slice 1
 *     SLICE1_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE1_DOUBLE_WIDE_MODE Double wide mode for slice 1 (0 == single wide, 1 == double wide)
 *     SLICE2_F1        F1 field for slice 2.
 *     SLICE2_F2        F2 field for slice 2
 *     SLICE2_F3        F3 field for slice 2
 *     SLICE2_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE2_DOUBLE_WIDE_MODE Double wide mode for slice 2 (0 == single wide, 1 == double wide)
 *     SLICE3_F1        F1 field for slice 3.
 *     SLICE3_F2        F2 field for slice 3
 *     SLICE3_F3        F3 field for slice 3
 *     SLICE3_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE3_DOUBLE_WIDE_MODE Double wide mode for slice 3 (0 == single wide, 1 == double wide)
 *     SLICE4_F1        F1 field for slice 4.
 *     SLICE4_F2        F2 field for slice 4
 *     SLICE4_F3        F3 field for slice 4
 *     SLICE4_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE4_DOUBLE_WIDE_MODE Double wide mode for slice 4 (0 == single wide, 1 == double wide)
 *     SLICE5_F1        F1 field for slice 5.
 *     SLICE5_F2        F2 field for slice 5
 *     SLICE5_F3        F3 field for slice 5
 *     SLICE5_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE5_DOUBLE_WIDE_MODE Double wide mode for slice 5 (0 == single wide, 1 == double wide)
 *     SLICE6_F1        F1 field for slice 6.
 *     SLICE6_F2        F2 field for slice 6
 *     SLICE6_F3        F3 field for slice 6
 *     SLICE6_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE6_DOUBLE_WIDE_MODE Double wide mode for slice 6 (0 == single wide, 1 == double wide)
 *     SLICE7_F1        F1 field for slice 7.
 *     SLICE7_F2        F2 field for slice 7
 *     SLICE7_F3        F3 field for slice 7
 *     SLICE7_DOUBLE_WIDE_KEY_SELECT 
 *     SLICE7_DOUBLE_WIDE_MODE Double wide mode for slice 7 (0 == single wide, 1 == double wide)
 *     SLICE1_0_PAIRING Slice pairing for slices 0/1
 *     SLICE3_2_PAIRING Slice pairing for slices 2/3
 *     SLICE5_4_PAIRING Slice pairing for slices 4/5
 *     SLICE7_6_PAIRING Slice pairing for slices 6/7
 *     SLICE0_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE1_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE2_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE3_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE4_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE5_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE6_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE7_D_TYPE_SEL Represents DVP_ENABLE,NHI_ENABLE to select the D_FIELD
 *     SLICE0_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE1_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE2_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE3_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE4_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE5_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE6_S_TYPE_SEL Represents selection controls to select the S_FIELD
 *     SLICE7_S_TYPE_SEL Represents selection controls to select the S_FIELD
 */
#define FP_PORT_FIELD_SELm_MIN 0
#define FP_PORT_FIELD_SELm_MAX 63
#define FP_PORT_FIELD_SELm_CMAX(u) 63
#define FP_PORT_FIELD_SELm_SIZE 23

/*
 * This structure should be used to declare and program FP_PORT_FIELD_SEL.
 */
typedef union FP_PORT_FIELD_SELm_s {
	uint32 v[6];
	uint32 fp_port_field_sel[6];
	uint32 _fp_port_field_sel;
} FP_PORT_FIELD_SELm_t;

#define FP_PORT_FIELD_SELm_CLR(r) sal_memset(&((r)._fp_port_field_sel), 0, sizeof(FP_PORT_FIELD_SELm_t))
#define FP_PORT_FIELD_SELm_SET(r,i,d) (r).fp_port_field_sel[i] = d
#define FP_PORT_FIELD_SELm_GET(r,i) (r).fp_port_field_sel[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_PORT_FIELD_SELm_SLICE0_F1f_GET(r) (((r).fp_port_field_sel[0]) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE0_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define FP_PORT_FIELD_SELm_SLICE0_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 4) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE0_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0x1f << 4)) | ((((uint32)f) & 0x1f) << 4))
#define FP_PORT_FIELD_SELm_SLICE0_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 9) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE0_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0xf << 9)) | ((((uint32)f) & 0xf) << 9))
#define FP_PORT_FIELD_SELm_SLICE0_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[0]) >> 13) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE0_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0x7 << 13)) | ((((uint32)f) & 0x7) << 13))
#define FP_PORT_FIELD_SELm_SLICE0_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[0]) >> 16) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE0_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define FP_PORT_FIELD_SELm_SLICE1_F1f_GET(r) ((((r).fp_port_field_sel[0]) >> 17) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE1_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0xf << 17)) | ((((uint32)f) & 0xf) << 17))
#define FP_PORT_FIELD_SELm_SLICE1_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 21) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE1_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0x1f << 21)) | ((((uint32)f) & 0x1f) << 21))
#define FP_PORT_FIELD_SELm_SLICE1_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 26) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE1_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32)0xf << 26)) | ((((uint32)f) & 0xf) << 26))
#define FP_PORT_FIELD_SELm_SLICE1_DOUBLE_WIDE_KEY_SELECTf_GET(r) field32_get((r).fp_port_field_sel,30,32)
#define FP_PORT_FIELD_SELm_SLICE1_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) field32_set((r).fp_port_field_sel,30,32,f)
#define FP_PORT_FIELD_SELm_SLICE1_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[1]) >> 1) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE1_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_PORT_FIELD_SELm_SLICE2_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 2) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE2_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0xf << 2)) | ((((uint32)f) & 0xf) << 2))
#define FP_PORT_FIELD_SELm_SLICE2_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 6) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE2_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0x1f << 6)) | ((((uint32)f) & 0x1f) << 6))
#define FP_PORT_FIELD_SELm_SLICE2_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 11) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE2_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0xf << 11)) | ((((uint32)f) & 0xf) << 11))
#define FP_PORT_FIELD_SELm_SLICE2_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[1]) >> 15) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE2_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define FP_PORT_FIELD_SELm_SLICE2_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[1]) >> 18) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE2_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define FP_PORT_FIELD_SELm_SLICE3_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 19) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE3_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0xf << 19)) | ((((uint32)f) & 0xf) << 19))
#define FP_PORT_FIELD_SELm_SLICE3_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 23) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE3_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0x1f << 23)) | ((((uint32)f) & 0x1f) << 23))
#define FP_PORT_FIELD_SELm_SLICE3_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 28) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE3_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define FP_PORT_FIELD_SELm_SLICE3_DOUBLE_WIDE_KEY_SELECTf_GET(r) (((r).fp_port_field_sel[2]) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE3_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define FP_PORT_FIELD_SELm_SLICE3_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[2]) >> 3) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE3_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define FP_PORT_FIELD_SELm_SLICE4_F1f_GET(r) ((((r).fp_port_field_sel[2]) >> 4) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE4_F1f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define FP_PORT_FIELD_SELm_SLICE4_F2f_GET(r) ((((r).fp_port_field_sel[2]) >> 8) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE4_F2f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0x1f << 8)) | ((((uint32)f) & 0x1f) << 8))
#define FP_PORT_FIELD_SELm_SLICE4_F3f_GET(r) ((((r).fp_port_field_sel[2]) >> 13) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE4_F3f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0xf << 13)) | ((((uint32)f) & 0xf) << 13))
#define FP_PORT_FIELD_SELm_SLICE4_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[2]) >> 17) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE4_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0x7 << 17)) | ((((uint32)f) & 0x7) << 17))
#define FP_PORT_FIELD_SELm_SLICE4_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[2]) >> 20) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE4_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_PORT_FIELD_SELm_SLICE5_F1f_GET(r) ((((r).fp_port_field_sel[2]) >> 21) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE5_F1f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0xf << 21)) | ((((uint32)f) & 0xf) << 21))
#define FP_PORT_FIELD_SELm_SLICE5_F2f_GET(r) ((((r).fp_port_field_sel[2]) >> 25) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE5_F2f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32)0x1f << 25)) | ((((uint32)f) & 0x1f) << 25))
#define FP_PORT_FIELD_SELm_SLICE5_F3f_GET(r) field32_get((r).fp_port_field_sel,94,97)
#define FP_PORT_FIELD_SELm_SLICE5_F3f_SET(r,f) field32_set((r).fp_port_field_sel,94,97,f)
#define FP_PORT_FIELD_SELm_SLICE5_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[3]) >> 2) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE5_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0x7 << 2)) | ((((uint32)f) & 0x7) << 2))
#define FP_PORT_FIELD_SELm_SLICE5_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[3]) >> 5) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE5_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_PORT_FIELD_SELm_SLICE6_F1f_GET(r) ((((r).fp_port_field_sel[3]) >> 6) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE6_F1f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0xf << 6)) | ((((uint32)f) & 0xf) << 6))
#define FP_PORT_FIELD_SELm_SLICE6_F2f_GET(r) ((((r).fp_port_field_sel[3]) >> 10) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE6_F2f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0x1f << 10)) | ((((uint32)f) & 0x1f) << 10))
#define FP_PORT_FIELD_SELm_SLICE6_F3f_GET(r) ((((r).fp_port_field_sel[3]) >> 15) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE6_F3f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0xf << 15)) | ((((uint32)f) & 0xf) << 15))
#define FP_PORT_FIELD_SELm_SLICE6_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[3]) >> 19) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE6_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define FP_PORT_FIELD_SELm_SLICE6_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[3]) >> 22) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE6_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define FP_PORT_FIELD_SELm_SLICE7_F1f_GET(r) ((((r).fp_port_field_sel[3]) >> 23) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE7_F1f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0xf << 23)) | ((((uint32)f) & 0xf) << 23))
#define FP_PORT_FIELD_SELm_SLICE7_F2f_GET(r) ((((r).fp_port_field_sel[3]) >> 27) & 0x1f)
#define FP_PORT_FIELD_SELm_SLICE7_F2f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32)0x1f << 27)) | ((((uint32)f) & 0x1f) << 27))
#define FP_PORT_FIELD_SELm_SLICE7_F3f_GET(r) (((r).fp_port_field_sel[4]) & 0xf)
#define FP_PORT_FIELD_SELm_SLICE7_F3f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define FP_PORT_FIELD_SELm_SLICE7_DOUBLE_WIDE_KEY_SELECTf_GET(r) ((((r).fp_port_field_sel[4]) >> 4) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE7_DOUBLE_WIDE_KEY_SELECTf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_PORT_FIELD_SELm_SLICE7_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_port_field_sel[4]) >> 7) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE7_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_PORT_FIELD_SELm_SLICE1_0_PAIRINGf_GET(r) ((((r).fp_port_field_sel[4]) >> 8) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE1_0_PAIRINGf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_PORT_FIELD_SELm_SLICE3_2_PAIRINGf_GET(r) ((((r).fp_port_field_sel[4]) >> 9) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE3_2_PAIRINGf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_PORT_FIELD_SELm_SLICE5_4_PAIRINGf_GET(r) ((((r).fp_port_field_sel[4]) >> 10) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE5_4_PAIRINGf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define FP_PORT_FIELD_SELm_SLICE7_6_PAIRINGf_GET(r) ((((r).fp_port_field_sel[4]) >> 11) & 0x1)
#define FP_PORT_FIELD_SELm_SLICE7_6_PAIRINGf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_PORT_FIELD_SELm_SLICE0_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[4]) >> 12) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE0_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define FP_PORT_FIELD_SELm_SLICE1_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[4]) >> 15) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE1_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define FP_PORT_FIELD_SELm_SLICE2_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[4]) >> 18) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE2_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define FP_PORT_FIELD_SELm_SLICE3_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[4]) >> 21) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE3_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x7 << 21)) | ((((uint32)f) & 0x7) << 21))
#define FP_PORT_FIELD_SELm_SLICE4_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[4]) >> 24) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE4_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define FP_PORT_FIELD_SELm_SLICE5_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[4]) >> 27) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE5_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define FP_PORT_FIELD_SELm_SLICE6_D_TYPE_SELf_GET(r) field32_get((r).fp_port_field_sel,158,160)
#define FP_PORT_FIELD_SELm_SLICE6_D_TYPE_SELf_SET(r,f) field32_set((r).fp_port_field_sel,158,160,f)
#define FP_PORT_FIELD_SELm_SLICE7_D_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[5]) >> 1) & 0x7)
#define FP_PORT_FIELD_SELm_SLICE7_D_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define FP_PORT_FIELD_SELm_SLICE0_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[5]) >> 4) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE0_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define FP_PORT_FIELD_SELm_SLICE1_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[5]) >> 6) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE1_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define FP_PORT_FIELD_SELm_SLICE2_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[5]) >> 8) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE2_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define FP_PORT_FIELD_SELm_SLICE3_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[5]) >> 10) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE3_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define FP_PORT_FIELD_SELm_SLICE4_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[5]) >> 12) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE4_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define FP_PORT_FIELD_SELm_SLICE5_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[5]) >> 14) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE5_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define FP_PORT_FIELD_SELm_SLICE6_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[5]) >> 16) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE6_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define FP_PORT_FIELD_SELm_SLICE7_S_TYPE_SELf_GET(r) ((((r).fp_port_field_sel[5]) >> 18) & 0x3)
#define FP_PORT_FIELD_SELm_SLICE7_S_TYPE_SELf_SET(r,f) (r).fp_port_field_sel[5]=(((r).fp_port_field_sel[5] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))

/*
 * These macros can be used to access FP_PORT_FIELD_SEL.
 */
#define WRITE_FP_PORT_FIELD_SELm(u,i,r) bcm5354x_mem_set(u, M_FP_PORT_FIELD_SEL(i), &(r._fp_port_field_sel), 6)
#define READ_FP_PORT_FIELD_SELm(u,i,r) bcm5354x_mem_get(u, M_FP_PORT_FIELD_SEL(i), &(r._fp_port_field_sel), 6)

/*******************************************************************************
 * End of 'FP_PORT_FIELD_SELm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  FP_SLICE_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     FP_SLICE_ENABLE
 * SIZE:     32
 * FIELDS:
 *     FP_SLICE_ENABLE_ALL Overlay for all SLICE enable bits
 *     FP_SLICE_ENABLE_SLICE_0 FP_SLICE_ENABLE FOR IFP SLICE 0
 *     FP_SLICE_ENABLE_SLICE_1 FP_SLICE_ENABLE FOR IFP SLICE 1
 *     FP_SLICE_ENABLE_SLICE_2 FP_SLICE_ENABLE FOR IFP SLICE 2
 *     FP_SLICE_ENABLE_SLICE_3 FP_SLICE_ENABLE FOR IFP SLICE 3
 *     FP_SLICE_ENABLE_SLICE_4 FP_SLICE_ENABLE FOR IFP SLICE 4
 *     FP_SLICE_ENABLE_SLICE_5 FP_SLICE_ENABLE FOR IFP SLICE 5
 *     FP_SLICE_ENABLE_SLICE_6 FP_SLICE_ENABLE FOR IFP SLICE 6
 *     FP_SLICE_ENABLE_SLICE_7 FP_SLICE_ENABLE FOR IFP SLICE 7
 *     FP_LOOKUP_ENABLE_ALL Overlay for all look up enable bits
 *     FP_LOOKUP_ENABLE_SLICE_0 LOOKUP ENABLE FOR IFP SLICE 0
 *     FP_LOOKUP_ENABLE_SLICE_1 LOOKUP ENABLE FOR IFP SLICE 1
 *     FP_LOOKUP_ENABLE_SLICE_2 LOOKUP ENABLE FOR IFP SLICE 2
 *     FP_LOOKUP_ENABLE_SLICE_3 LOOKUP ENABLE FOR IFP SLICE 3
 *     FP_LOOKUP_ENABLE_SLICE_4 LOOKUP ENABLE FOR IFP SLICE 4
 *     FP_LOOKUP_ENABLE_SLICE_5 LOOKUP ENABLE FOR IFP SLICE 5
 *     FP_LOOKUP_ENABLE_SLICE_6 LOOKUP ENABLE FOR IFP SLICE 6
 *     FP_LOOKUP_ENABLE_SLICE_7 LOOKUP ENABLE FOR IFP SLICE 7
 */
#define FP_SLICE_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program FP_SLICE_ENABLE.
 */
typedef union FP_SLICE_ENABLEr_s {
	uint32 v[1];
	uint32 fp_slice_enable[1];
	uint32 _fp_slice_enable;
} FP_SLICE_ENABLEr_t;

#define FP_SLICE_ENABLEr_CLR(r) (r).fp_slice_enable[0] = 0
#define FP_SLICE_ENABLEr_SET(r,d) (r).fp_slice_enable[0] = d
#define FP_SLICE_ENABLEr_GET(r) (r).fp_slice_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_ALLf_GET(r) (((r).fp_slice_enable[0]) & 0xff)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_ALLf_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_GET(r) (((r).fp_slice_enable[0]) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_GET(r) ((((r).fp_slice_enable[0]) >> 1) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_GET(r) ((((r).fp_slice_enable[0]) >> 2) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_GET(r) ((((r).fp_slice_enable[0]) >> 3) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_GET(r) ((((r).fp_slice_enable[0]) >> 4) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_GET(r) ((((r).fp_slice_enable[0]) >> 5) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_GET(r) ((((r).fp_slice_enable[0]) >> 6) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_GET(r) ((((r).fp_slice_enable[0]) >> 7) & 0x1)
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_ALLf_GET(r) ((((r).fp_slice_enable[0]) >> 8) & 0xff)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_ALLf_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_GET(r) ((((r).fp_slice_enable[0]) >> 8) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_GET(r) ((((r).fp_slice_enable[0]) >> 9) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_GET(r) ((((r).fp_slice_enable[0]) >> 10) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_GET(r) ((((r).fp_slice_enable[0]) >> 11) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_GET(r) ((((r).fp_slice_enable[0]) >> 12) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_GET(r) ((((r).fp_slice_enable[0]) >> 13) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_GET(r) ((((r).fp_slice_enable[0]) >> 14) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_GET(r) ((((r).fp_slice_enable[0]) >> 15) & 0x1)
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))

/*
 * These macros can be used to access FP_SLICE_ENABLE.
 */
#define WRITE_FP_SLICE_ENABLEr(u,r) bcm5354x_reg_set(u,R_FP_SLICE_ENABLE,(r._fp_slice_enable))
#define READ_FP_SLICE_ENABLEr(u,r) bcm5354x_reg_get(u,R_FP_SLICE_ENABLE,&(r._fp_slice_enable))

/*******************************************************************************
 * End of 'FP_SLICE_ENABLEr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  FP_SLICE_MAP
 * BLOCKS:   IPIPE
 * DESC:     SLICE MAPPING CONTROLS FOR IFP, FeatureSpecific-FP
 * SIZE:     48
 * FIELDS:
 *     VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 0 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 1 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 2 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 3 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 4 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 5 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 6 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBER_ENTRY_0 MAPS VIRTUAL SLICE 7 TO A PHYSICAL SLICE NUMBER FOR ENTRY 0
 *     VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 0 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 1 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 2 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 3 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 4 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 5 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 6 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 *     VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUP_ENTRY_0 MAPS VIRTUAL SLICE 7 TO A VIRTUAL SLICE GROUP FOR ENTRY 0
 */
#define FP_SLICE_MAPm_MIN 0
#define FP_SLICE_MAPm_MAX 0
#define FP_SLICE_MAPm_CMAX(u) 0
#define FP_SLICE_MAPm_SIZE 6

/*
 * This structure should be used to declare and program FP_SLICE_MAP.
 */
typedef union FP_SLICE_MAPm_s {
	uint32 v[2];
	uint32 fp_slice_map[2];
	uint32 _fp_slice_map;
} FP_SLICE_MAPm_t;

#define FP_SLICE_MAPm_CLR(r) sal_memset(&((r)._fp_slice_map), 0, sizeof(FP_SLICE_MAPm_t))
#define FP_SLICE_MAPm_SET(r,i,d) (r).fp_slice_map[i] = d
#define FP_SLICE_MAPm_GET(r,i) (r).fp_slice_map[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) (((r).fp_slice_map[0]) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 3) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 6) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 9) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 12) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 15) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 18) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBER_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 21) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBER_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 21)) | ((((uint32)f) & 0x7) << 21))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 24) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[0]) >> 27) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) field32_get((r).fp_slice_map,30,32)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) field32_set((r).fp_slice_map,30,32,f)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[1]) >> 1) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[1]) >> 4) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[1]) >> 7) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32)0x7 << 7)) | ((((uint32)f) & 0x7) << 7))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[1]) >> 10) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define FP_SLICE_MAPm_VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUP_ENTRY_0f_GET(r) ((((r).fp_slice_map[1]) >> 13) & 0x7)
#define FP_SLICE_MAPm_VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUP_ENTRY_0f_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32)0x7 << 13)) | ((((uint32)f) & 0x7) << 13))

/*
 * These macros can be used to access FP_SLICE_MAP.
 */
#define WRITE_FP_SLICE_MAPm(u,r) bcm5354x_mem_set(u, M_FP_SLICE_MAP, &(r._fp_slice_map), 2)
#define READ_FP_SLICE_MAPm(u,r) bcm5354x_mem_get(u, M_FP_SLICE_MAP, &(r._fp_slice_map), 2)

/*******************************************************************************
 * End of 'FP_SLICE_MAPm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  FP_STORM_CONTROL_METERS
 * BLOCKS:   IPIPE
 * DESC:     Storm control meters used in conjunction with the settings in the per port STORM_CONTROL_METERCONFIG register
 * SIZE:     54
 * FIELDS:
 *     BUCKETCOUNT      Bucket Count
 *     BUCKETSIZE       Bucket Size for Storm Control Meters 3'd0 = 4K Bytes 3'd1 = 16K Bytes 3'd2 = 64K Bytes 3'd3 = 256K Bytes 3'd4 = 1M Bytes 3'd5 = 4M Bytes 3'd6 = 8M Bytes 3'd7 = 16M Bytes
 *     REFRESHCOUNT     Refresh count for Storm Control Metering bucket.Every unit of REFRESH represents 64,000 bps, (bits per second). Example 1: To set metering rate to 500 Mbps (500,000,000 bps), should set REFRESH = 7812, Example 2: To set metering rate to 1 Gbps (1,000,000,000 bps), should set REFRESH = 15624.
 *     EVEN_PARITY      Even parity
 */
#define FP_STORM_CONTROL_METERSm_MIN 0
#define FP_STORM_CONTROL_METERSm_MAX 127
#define FP_STORM_CONTROL_METERSm_CMAX(u) 127
#define FP_STORM_CONTROL_METERSm_SIZE 7

/*
 * This structure should be used to declare and program FP_STORM_CONTROL_METERS.
 */
typedef union FP_STORM_CONTROL_METERSm_s {
	uint32 v[2];
	uint32 fp_storm_control_meters[2];
	uint32 _fp_storm_control_meters;
} FP_STORM_CONTROL_METERSm_t;

#define FP_STORM_CONTROL_METERSm_CLR(r) sal_memset(&((r)._fp_storm_control_meters), 0, sizeof(FP_STORM_CONTROL_METERSm_t))
#define FP_STORM_CONTROL_METERSm_SET(r,i,d) (r).fp_storm_control_meters[i] = d
#define FP_STORM_CONTROL_METERSm_GET(r,i) (r).fp_storm_control_meters[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_STORM_CONTROL_METERSm_BUCKETCOUNTf_GET(r) (((r).fp_storm_control_meters[0]) & 0x3fffffff)
#define FP_STORM_CONTROL_METERSm_BUCKETCOUNTf_SET(r,f) (r).fp_storm_control_meters[0]=(((r).fp_storm_control_meters[0] & ~((uint32)0x3fffffff)) | (((uint32)f) & 0x3fffffff))
#define FP_STORM_CONTROL_METERSm_BUCKETSIZEf_GET(r) field32_get((r).fp_storm_control_meters,30,32)
#define FP_STORM_CONTROL_METERSm_BUCKETSIZEf_SET(r,f) field32_set((r).fp_storm_control_meters,30,32,f)
#define FP_STORM_CONTROL_METERSm_REFRESHCOUNTf_GET(r) ((((r).fp_storm_control_meters[1]) >> 1) & 0xfffff)
#define FP_STORM_CONTROL_METERSm_REFRESHCOUNTf_SET(r,f) (r).fp_storm_control_meters[1]=(((r).fp_storm_control_meters[1] & ~((uint32)0xfffff << 1)) | ((((uint32)f) & 0xfffff) << 1))
#define FP_STORM_CONTROL_METERSm_EVEN_PARITYf_GET(r) ((((r).fp_storm_control_meters[1]) >> 21) & 0x1)
#define FP_STORM_CONTROL_METERSm_EVEN_PARITYf_SET(r,f) (r).fp_storm_control_meters[1]=(((r).fp_storm_control_meters[1] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))

/*
 * These macros can be used to access FP_STORM_CONTROL_METERS.
 */
#define WRITE_FP_STORM_CONTROL_METERSm(u,i,r) bcm5354x_mem_set(u, M_FP_STORM_CONTROL_METERS(i), &(r._fp_storm_control_meters), 2)
#define READ_FP_STORM_CONTROL_METERSm(u,i,r) bcm5354x_mem_get(u, M_FP_STORM_CONTROL_METERS(i), &(r._fp_storm_control_meters), 2)

/*******************************************************************************
 * End of 'FP_STORM_CONTROL_METERSm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  FP_TCAM
 * BLOCKS:   IPIPE
 * DESC:     TCAM FOR FP
 * SIZE:     470
 * FIELDS:
 *     VALID            VALID BIT
 *     FULL_KEY         Field created for sbus access to the entire key portion of the TCAM
 *     DOUBLE_WIDE_MODE DOUBLE_WIDE_MODE
 *     DW_DOUBLE_WIDE_MODE DW_DOUBLE_WIDE_MODE
 *     DATA_KEY         SW overlay for all (F1-F4) DW Key bits
 *     DWF4             DWF4
 *     DWF4_0_PORT_FIELD_SEL_TABLE_INDEX PORT_FIELD_SEL_TABLE_INDEX 
 *     DWF4_0_PORT_FIELD_SEL_TABLE_INDEX_MASK PORT_FIELD_SEL_TABLE_INDEX 
 *     F4               F4
 *     DWF4_1_TCP_FN    TCP_FN 
 *     DWF4_1_TCP_FN_MASK TCP_FN 
 *     DWF4_1_SPARE     SPARE 
 *     DWF4_1_SPARE_MASK SPARE 
 *     DWF3             DWF3 field
 *     FIXED            FIXED BITS
 *     FIXED_HIGIG      HIGIG 
 *     FIXED_FORWARDING_TYPE FORWARDING_TYPE 
 *     FIXED_SVP_OR_L3IIF L3_TYPE 
 *     FIXED_L3_TYPE    L3_TYPE 
 *     FIXED_L4_VALID   L4_VALID 
 *     FIXED_L3_ROUTABLE L3_ROUTABLE 
 *     FIXED_TUNNEL_TYPE_LOOPBACK_TYPE TUNNEL_TYPE 
 *     FIXED_DROP       DROP 
 *     FIXED_MIRROR_ONLY Mirror only copy of packet. (Only possible for HG). 
 *     FIXED_MIML_PRESENT MIML Present. 
 *     FIXED_CUSTOM_HEADER_PRESENT CUSTOM_HEADER Present. 
 *     F3               F3 field
 *     F3_12_AUX_TAG_2  AUX Tag 2. One of Assigned_VNTAG, CNTAG or EHTAG, based on FP_SLICE_KEY_CONTROL.SLICE<0-11>_AUX_TAG_2_SEL setting
 *     F3_9_UDF1_95_64  UDF1_95_64 
 *     F3_7_RANGE_CHECK_RESULTS RANGE_CHECK_RESULTS 
 *     F3_8_IPV6_FL     IPV6_FL 
 *     F3_3_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F3_4_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F3_5_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F3_6_LOOKUP_STATUS LOOKUP_STATUS 
 *     F3_10_D_FIELD    D_FIELD 
 *     F3_11_SGLP       SGLP 
 *     F3_2_D_FIELD     D_FIELD 
 *     F3_0_CLASSIDS    CLASSIDS 
 *     F3_1_CLASSIDS    CLASSIDS 
 *     F3_0_FORWARDING_FIELD FORWARDING_FIELD 
 *     F3_1_FORWARDING_FIELD FORWARDING_FIELD 
 *     DWF2             DWF2 field
 *     DWF2_1_SIP       SIP 
 *     DWF2_1_SIP_MASK  SIP 
 *     DWF2_2_DIP       DIP 
 *     DWF2_2_DIP_MASK  DIP 
 *     DWF2_3_UDF2      UDF2 
 *     DWF2_3_UDF2_MASK UDF2 
 *     DWF2_6_PAYLOAD_SIP Payload IPV6 SIP 
 *     DWF2_6_PAYLOAD_SIP_MASK Payload IPV6 SIP 
 *     DWF2_7_PAYLOAD_DIP Payload IPV6 DIP 
 *     DWF2_7_PAYLOAD_DIP_MASK Payload IPV6 DIP 
 *     DWF2_0_SPARE     SPARE 
 *     DWF2_0_SPARE_MASK SPARE 
 *     DWF2_4_PAYLOAD_OUTER_VLAN_TAG Payload outer_vlan_tag 
 *     DWF2_4_PAYLOAD_OUTER_VLAN_TAG_MASK Payload outer_vlan_tag 
 *     DWF2_5_PAYLOAD_L4_DST Payload L4_DST 
 *     DWF2_5_PAYLOAD_L4_DST_MASK Payload L4_DST 
 *     F3_11_SVP        SVP 
 *     F3_10_D_TYPE     D_TYPE 
 *     F3_2_D_TYPE      D_TYPE 
 *     F3_4_INNER_VLAN_TAG INNER_VLAN_TAG 
 *     F3_5_ETHERTYPE   ETHERTYPE 
 *     F3_6_INNER_VLAN_TAG INNER_VLAN_TAG 
 *     F3_3_PACKET_FORMAT PACKET_FORMAT 
 *     F3_10_DGLP       DGLP 
 *     F3_2_S_FIELD     S_FIELD 
 *     F3_8_PACKET_FORMAT PACKET_FORMAT 
 *     F3_3_SWITCHING_TAG_STATUS SWITCHING_TAG_STATUS 
 *     F3_3_MH_OPCODE   MH_OPCODE 
 *     F3_0_SVP_L3IIF_OVERLAY SVP_L3IIF_OVERLAY 
 *     F3_1_OUTER_VLAN_ID OUTER_VLAN_ID 
 *     F3_7_INTERFACE_CLASSID INTERFACE_CLASSID 
 *     F3_8_SWITCHING_TAG_STATUS SWITCHING_TAG_STATUS 
 *     F3_3_PKT_RESOLUTION PKT_RESOLUTION 
 *     F3_8_INNER_TPID_ENCODE INNER_TPID_ENCODE 
 *     F3_8_OUTER_TPID_ENCODE OUTER_TPID_ENCODE 
 *     F3_11_SVP_VALID  SVP_VALID 
 *     DWF2_0_LOOKUP_STATUS LOOKUP_STATUS 
 *     DWF2_0_LOOKUP_STATUS_MASK LOOKUP_STATUS 
 *     DWF2_4_PAYLOAD_ETHERTYPE Payload Ethertype 
 *     DWF2_4_PAYLOAD_ETHERTYPE_MASK Payload Ethertype 
 *     DWF2_5_PAYLOAD_L4_SRC Payload L4_SRC 
 *     DWF2_5_PAYLOAD_L4_SRC_MASK Payload L4_SRC 
 *     F3_11_SPARE      SPARE 
 *     F3_8_SPARE       SPARE 
 *     F3_3_IP_INFO     IP_INFO 
 *     F3_4_SPARE       SPARE 
 *     F3_5_SPARE       SPARE 
 *     F3_6_SPARE       SPARE 
 *     F3_7_SPARE       SPARE 
 *     F3_9_MPLS_INFO   MPLS_INFO 
 *     F3_12_AUX_TAG_VALID_2 AUX Tag Valid 2
 *     F3_10_SPARE      SPARE 
 *     F3_12_SPARE      SPARE 
 *     F3_3_SPARE       SPARE 
 *     F3_2_SVP_VALID   SVP_VALID 
 *     F3_2_MH_OPCODE   MH_OPCODE 
 *     F3_9_SPARE       SPARE 
 *     F3_1_SPARE       SPARE 
 *     F2               F2 field
 *     F2_15_PAYLOAD_SIP Payload IPV6 SIP 
 *     F2_16_PAYLOAD_DIP Payload IPV6 DIP 
 *     F2_2_SIP         SIP 
 *     F2_3_DIP         DIP 
 *     F2_8_UDF1        UDF1
 *     F2_9_UDF2        UDF2
 *     F2_10_SIP_127_64 SIP_127_64 
 *     F2_12_MIML_SA    MIML SA 
 *     F2_11_DIP_127_96 DIP_127_96 
 *     F2_13_PAYLOAD_OUTER_VLAN_TAG Payload outer_vlan_tag 
 *     F2_14_PAYLOAD_L4_DST Payload L4_DST 
 *     F2_5_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F2_6_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F2_7_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F2_0_TTL_FN      TTL_FN 
 *     F2_1_TTL_FN      TTL_FN 
 *     F2_4_TTL_FN      TTL_FN 
 *     DWF2_4_PAYLOAD_MACSA Payload MACSA 
 *     DWF2_4_PAYLOAD_MACSA_MASK Payload MACSA 
 *     DWF2_0_RANGE_CHECK_RESULTS RANGE_CHECK_RESULTS 
 *     DWF2_0_RANGE_CHECK_RESULTS_MASK RANGE_CHECK_RESULTS 
 *     DWF2_5_PAYLOAD_TOS_FN Payload TOS_FN 
 *     DWF2_5_PAYLOAD_TOS_FN_MASK Payload TOS_FN 
 *     F2_0_TCP_FN      TCP_FN 
 *     F2_1_TCP_FN      TCP_FN 
 *     F2_4_TCP_FN      TCP_FN 
 *     F2_4_IPV6_FL     IPV6_FL 
 *     F2_0_IPFLAG      IPFLAG 
 *     F2_1_IP_FRAG_INFO IP_FRAG_INFO 
 *     F2_13_PAYLOAD_ETHERTYPE Payload Ethertype 
 *     F2_14_PAYLOAD_L4_SRC Payload L4_SRC 
 *     F2_5_ETHERTYPE   ETHERTYPE 
 *     F2_6_ETHERTYPE   ETHERTYPE 
 *     F2_7_ETHERTYPE   EtherType 
 *     DWF2_5_PAYLOAD_IP_PROTOCOL_LAST_NH Payload IP_PROTOCOL_LAST_NH 
 *     DWF2_5_PAYLOAD_IP_PROTOCOL_LAST_NH_MASK Payload IP_PROTOCOL_LAST_NH 
 *     F2_0_TOS_FN      TOS_FN 
 *     F2_1_TOS_FN      TOS_FN 
 *     DWF2_5_PAYLOAD_DIP Payload IPV4 DIP 
 *     DWF2_5_PAYLOAD_DIP_MASK Payload IPV4 DIP 
 *     F2_0_L4_DST      L4_DST 
 *     F2_1_L4_DST      L4_DST 
 *     F2_11_SA         SA 
 *     F2_13_PAYLOAD_MACSA Payload MACSA 
 *     F2_5_SA          SA 
 *     F2_6_SA          SA 
 *     DWF2_0_INTERFACE_CLASSID INTERFACE_CLASSID 
 *     DWF2_0_INTERFACE_CLASSID_MASK INTERFACE_CLASSID 
 *     F2_14_PAYLOAD_TOS_FN Payload TOS_FN 
 *     F2_7_TTL_FN      TTL_FN 
 *     F2_4_TOS_FN      TOS_FN 
 *     DWF2_0_DIP       DIP 
 *     DWF2_0_DIP_MASK  DIP 
 *     F2_0_L4_SRC      L4_SRC 
 *     F2_1_L4_SRC      L4_SRC 
 *     F2_14_PAYLOAD_IP_PROTOCOL_LAST_NH Payload IP_PROTOCOL_LAST_NH 
 *     F2_7_IP_PROTOCOL_LAST_NH IP_PROTOCOL_LAST_NH 
 *     F2_4_LAST_NH     LAST_NH 
 *     F2_12_MIML_DA    MIML DA 
 *     F2_14_PAYLOAD_DIP Payload IPV4 DIP 
 *     F2_7_DIP         DIP 
 *     F2_4_INT_CN      CongestionClass field in the HiGig header.
 *     F2_4_SPARE       SPARE 
 *     DWF2_4_PAYLOAD_MACDA Payload MACDA 
 *     DWF2_4_PAYLOAD_MACDA_MASK Payload MACDA 
 *     DWF2_5_PAYLOAD_SIP Payload IPV4 SIP 
 *     DWF2_5_PAYLOAD_SIP_MASK Payload IPV4 SIP 
 *     F2_0_IP_PROTOCOL_LAST_NH IP_PROTOCOL_LAST_NH 
 *     F2_1_IP_PROTOCOL_LAST_NH IP_PROTOCOL_LAST_NH 
 *     F2_10_DIP_127_64 DIP_127_64 
 *     F2_4_DIP_127_64  DIP_127_64 
 *     F2_0_DIP         DIP
 *     F2_1_DIP         DIP
 *     DWF2_0_SIP       SIP 
 *     DWF2_0_SIP_MASK  SIP 
 *     F2_11_DA         DA 
 *     F2_13_PAYLOAD_MACDA Payload MACDA 
 *     F2_5_DA          DA 
 *     F2_7_DA          DA 
 *     F2_14_PAYLOAD_SIP Payload IPV4 SIP 
 *     F2_6_SIP         SIP
 *     DWF2_5_SPARE     SPARE. 
 *     DWF2_5_SPARE_MASK SPARE. 
 *     F2_0_SIP         SIP
 *     F2_1_SIP         SIP
 *     F2_12_MIML_TAG   MIML TAG 
 *     DWF1             DWF1 field
 *     DWF1_1_PAYLOAD_L4_DST Payload L4_DST 
 *     DWF1_1_PAYLOAD_L4_DST_MASK Payload L4_DST 
 *     DWF1_0_TTL_FN1   TTL_FN1 
 *     DWF1_0_TTL_FN1_MASK TTL_FN1 
 *     F2_12_SPARE      SPARE 
 *     F2_14_SPARE      SPARE. 
 *     F2_6_SPARE       SPARE 
 *     DWF1_0_IP_FRAG_INFO IP_FRAG_INFO 
 *     DWF1_0_IP_FRAG_INFO_MASK IP_FRAG_INFO 
 *     DWF1_0_L4_DST    L4_DST 
 *     DWF1_0_L4_DST_MASK L4_DST 
 *     DWF1_1_PAYLOAD_L4_SRC Payload L4_SRC 
 *     DWF1_1_PAYLOAD_L4_SRC_MASK Payload L4_SRC 
 *     F1               F1 field
 *     F1_13_AUX_TAG_1  AUX Tag 1. EHTAG, based on FP_SLICE_KEY_CONTROL.SLICE<0-7>_AUX_TAG_1_SEL setting
 *     F1_9_UDF1_31_0   UDF1_31_0
 *     F1_3_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F1_4_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F1_5_LOOKUP_STATUS LOOKUP_STATUS 
 *     F1_6_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F1_7_OUTER_VLAN_TAG OUTER_VLAN_TAG 
 *     F1_10_D_FIELD    D_FIELD 
 *     F1_11_SGLP       SGLP 
 *     F1_1_D_FIELD     D_FIELD 
 *     F1_2_D_FIELD     D_FIELD 
 *     F1_0_CLASSIDS    CLASSIDS 
 *     F1_12_OUTER_VLAN_ID OUTER_VLAN_ID 
 *     F1_8_IP_PROTOCOL_LAST_NH IP_PROTOCOL_LAST_NH 
 *     DWF1_0_L4_SRC    L4_SRC 
 *     DWF1_0_L4_SRC_MASK L4_SRC 
 *     DWF1_1_PAYLOAD_TOS_FN Payload TOS_FN 
 *     DWF1_1_PAYLOAD_TOS_FN_MASK Payload TOS_FN 
 *     F1_8_TOS_FN      TOS_FN
 *     F1_0_FORWARDING_FIELD FORWARDING_FIELD 
 *     F1_12_CLASSIDS   CLASSIDS 
 *     F1_11_SVP        SVP 
 *     F1_10_D_TYPE     D_TYPE 
 *     F1_1_D_TYPE      D_TYPE 
 *     F1_2_D_TYPE      D_TYPE 
 *     F1_3_INNER_VLAN_TAG INNER_VLAN_TAG 
 *     F1_4_ETHERTYPE   ETHERTYPE 
 *     F1_5_INNER_VLAN_TAG INNER_VLAN_TAG 
 *     DWF1_1_PAYLOAD_IP_PROTOCOL_LAST_NH Payload IP_PROTOCOL_LAST_NH 
 *     DWF1_1_PAYLOAD_IP_PROTOCOL_LAST_NH_MASK Payload IP_PROTOCOL_LAST_NH 
 *     F1_7_CLASSIDS_11_6 CLASSIDS
 *     F1_8_CLASSIDS_11_6 CLASSIDS
 *     F1_6_PACKET_FORMAT PACKET_FORMAT 
 *     DWF1_0_D_FIELD   D_FIELD 
 *     DWF1_0_D_FIELD_MASK D_FIELD 
 *     F1_10_DGLP       DGLP 
 *     F1_1_S_FIELD     S_FIELD 
 *     F1_2_MH_OPCODE   MH_OPCODE 
 *     F1_6_SWITCHING_TAG_STATUS SWITHCING_TAG_STATUS 
 *     F1_2_CLASSIDS    CLASSIDS 
 *     F1_7_FORWARDING_FIELD FORWARDING_FIELD 
 *     F1_8_FORWARDING_FIELD FORWARDING_FIELD 
 *     F1_6_MH_OPCODE   MH_OPCODE 
 *     DWF1_1_SPARE     SPARE. 
 *     DWF1_1_SPARE_MASK SPARE. 
 *     F1_0_SVP_L3_IIF  SVP_L3_IIF 
 *     F1_12_SVP        SVP 
 *     F1_6_PKT_RESOLUTION PKT_RESOLUTION 
 *     F1_11_SVP_VALID  SVP_VALID 
 *     F1_11_SPARE      SPARE 
 *     F1_6_IP_INFO     IP_INFO 
 *     F1_4_SPARE       SPARE 
 *     F1_3_OUTER_TPID_ENCODE OUTER_TPID_ENCODE 
 *     F1_5_INNER_TPID_ENCODE INNER_TPID_ENCODE 
 *     F1_9_MPLS_INFO   MPLS_INFO 
 *     F1_13_AUX_TAG_VALID_1 AUX Tag Valid 1
 *     F1_10_SPARE      SPARE 
 *     F1_13_SPARE      SPARE 
 *     F1_2_SPARE       SPARE 
 *     F1_6_SPARE       SPARE 
 *     DWF1_0_D_TYPE    D_TYPE 
 *     DWF1_0_D_TYPE_MASK D_TYPE 
 *     F1_1_SVP_VALID   SVP_VALID 
 *     F1_1_MH_OPCODE   MH_OPCODE 
 *     F1_3_SPARE       SPARE 
 *     F1_5_SPARE       SPARE 
 *     F1_9_SPARE       SPARE 
 *     F1_7_MPLS_INFO   MPLS_INFO 
 *     F1_8_INT_CN      CongestionClass field in the HiGig header.
 *     DWF1_0_INT_CN    CongestionClass field in the HiGig header. 
 *     DWF1_0_INT_CN_MASK CongestionClass field in the HiGig header. 
 *     F1_7_SPARE       SPARE 
 *     F1_8_SPARE       SPARE 
 *     RESERVED         RESERVED
 *     DWF1_0_SPARE     SPARE 
 *     DWF1_0_SPARE_MASK SPARE 
 *     FULL_MASK        Field created for sbus access to the entire mask portion of the TCAM
 *     DOUBLE_WIDE_MODE_MASK DOUBLE_WIDE_MODE_MASK
 *     DW_DOUBLE_WIDE_MODE_MASK DW_DOUBLE_WIDE_MODE_MASK
 *     DATA_MASK        SW overlay for all (F1-F4) DW mask bits
 *     DWF4_MASK        DWF4 MASK
 *     F4_MASK          F4 MASK
 *     DWF3_MASK        DWF3 field MASK
 *     FIXED_MASK       FIXED MASK
 *     FIXED_HIGIG_MASK HIGIG 
 *     FIXED_FORWARDING_TYPE_MASK FORWARDING_TYPE 
 *     FIXED_SVP_OR_L3IIF_MASK L3_TYPE 
 *     FIXED_L3_TYPE_MASK L3_TYPE 
 *     FIXED_L4_VALID_MASK L4_VALID 
 *     FIXED_L3_ROUTABLE_MASK L3_ROUTABLE 
 *     FIXED_TUNNEL_TYPE_LOOPBACK_TYPE_MASK TUNNEL_TYPE 
 *     FIXED_DROP_MASK  DROP 
 *     FIXED_MIRROR_ONLY_MASK Mirror only copy of packet. (Only possible for HG). 
 *     FIXED_MIML_PRESENT_MASK MIML Present. 
 *     FIXED_CUSTOM_HEADER_PRESENT_MASK CUSTOM_HEADER Present. 
 *     F3_MASK          F3 field MASK
 *     F3_12_AUX_TAG_2_MASK AUX Tag 2. One of Assigned_VNTAG, CNTAG or EHTAG, based on FP_SLICE_KEY_CONTROL.SLICE<0-11>_AUX_TAG_2_SEL setting
 *     F3_9_UDF1_95_64_MASK UDF1_95_64 
 *     F3_7_RANGE_CHECK_RESULTS_MASK RANGE_CHECK_RESULTS 
 *     F3_8_IPV6_FL_MASK IPV6_FL 
 *     F3_3_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F3_4_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F3_5_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F3_6_LOOKUP_STATUS_MASK LOOKUP_STATUS 
 *     F3_10_D_FIELD_MASK D_FIELD 
 *     F3_11_SGLP_MASK  SGLP 
 *     F3_2_D_FIELD_MASK D_FIELD 
 *     F3_0_CLASSIDS_MASK CLASSIDS 
 *     F3_1_CLASSIDS_MASK CLASSIDS 
 *     F3_0_FORWARDING_FIELD_MASK FORWARDING_FIELD 
 *     F3_1_FORWARDING_FIELD_MASK FORWARDING_FIELD 
 *     DWF2_MASK        DWF2 field MASK
 *     F3_11_SVP_MASK   SVP 
 *     F3_10_D_TYPE_MASK D_TYPE 
 *     F3_2_D_TYPE_MASK D_TYPE 
 *     F3_4_INNER_VLAN_TAG_MASK INNER_VLAN_TAG 
 *     F3_5_ETHERTYPE_MASK ETHERTYPE 
 *     F3_6_INNER_VLAN_TAG_MASK INNER_VLAN_TAG 
 *     F3_3_PACKET_FORMAT_MASK PACKET_FORMAT 
 *     F3_10_DGLP_MASK  DGLP 
 *     F3_2_S_FIELD_MASK S_FIELD 
 *     F3_8_PACKET_FORMAT_MASK PACKET_FORMAT 
 *     F3_3_SWITCHING_TAG_STATUS_MASK SWITCHING_TAG_STATUS 
 *     F3_3_MH_OPCODE_MASK MH_OPCODE 
 *     F3_0_SVP_L3IIF_OVERLAY_MASK SVP_L3IIF_OVERLAY 
 *     F3_1_OUTER_VLAN_ID_MASK OUTER_VLAN_ID 
 *     F3_7_INTERFACE_CLASSID_MASK INTERFACE_CLASSID 
 *     F3_8_SWITCHING_TAG_STATUS_MASK SWITCHING_TAG_STATUS 
 *     F3_3_PKT_RESOLUTION_MASK PKT_RESOLUTION 
 *     F3_8_INNER_TPID_ENCODE_MASK INNER_TPID_ENCODE 
 *     F3_8_OUTER_TPID_ENCODE_MASK OUTER_TPID_ENCODE 
 *     F3_11_SVP_VALID_MASK SVP_VALID 
 *     F3_11_SPARE_MASK SPARE 
 *     F3_8_SPARE_MASK  SPARE 
 *     F3_3_IP_INFO_MASK IP_INFO 
 *     F3_4_SPARE_MASK  SPARE 
 *     F3_5_SPARE_MASK  SPARE 
 *     F3_6_SPARE_MASK  SPARE 
 *     F3_7_SPARE_MASK  SPARE 
 *     F3_9_MPLS_INFO_MASK MPLS_INFO 
 *     F3_12_AUX_TAG_VALID_2_MASK AUX Tag Valid 2
 *     F3_10_SPARE_MASK SPARE 
 *     F3_12_SPARE_MASK SPARE 
 *     F3_3_SPARE_MASK  SPARE 
 *     F3_2_SVP_VALID_MASK SVP_VALID 
 *     F3_2_MH_OPCODE_MASK MH_OPCODE 
 *     F3_9_SPARE_MASK  SPARE 
 *     F3_1_SPARE_MASK  SPARE 
 *     F2_15_PAYLOAD_SIP_MASK Payload IPV6 SIP 
 *     F2_16_PAYLOAD_DIP_MASK Payload IPV6 DIP 
 *     F2_2_SIP_MASK    SIP 
 *     F2_3_DIP_MASK    DIP 
 *     F2_8_UDF1_MASK   UDF1
 *     F2_9_UDF2_MASK   UDF2
 *     F2_MASK          F2 field MASK
 *     F2_10_SIP_127_64_MASK SIP_127_64 
 *     F2_12_MIML_SA_MASK MIML SA 
 *     F2_11_DIP_127_96_MASK DIP_127_96 
 *     F2_13_PAYLOAD_OUTER_VLAN_TAG_MASK Payload outer_vlan_tag 
 *     F2_14_PAYLOAD_L4_DST_MASK Payload L4_DST 
 *     F2_5_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F2_6_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F2_7_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F2_0_TTL_FN_MASK TTL_FN 
 *     F2_1_TTL_FN_MASK TTL_FN 
 *     F2_4_TTL_FN_MASK TTL_FN 
 *     F2_0_TCP_FN_MASK TCP_FN 
 *     F2_1_TCP_FN_MASK TCP_FN 
 *     F2_4_TCP_FN_MASK TCP_FN 
 *     F2_4_IPV6_FL_MASK IPV6_FL 
 *     F2_0_IPFLAG_MASK IPFLAG 
 *     F2_1_IP_FRAG_INFO_MASK IP_FRAG_INFO 
 *     F2_13_PAYLOAD_ETHERTYPE_MASK Payload Ethertype 
 *     F2_14_PAYLOAD_L4_SRC_MASK Payload L4_SRC 
 *     F2_5_ETHERTYPE_MASK ETHERTYPE 
 *     F2_6_ETHERTYPE_MASK ETHERTYPE 
 *     F2_7_ETHERTYPE_MASK EtherType 
 *     F2_0_TOS_FN_MASK TOS_FN 
 *     F2_1_TOS_FN_MASK TOS_FN 
 *     F2_0_L4_DST_MASK L4_DST 
 *     F2_1_L4_DST_MASK L4_DST 
 *     F2_11_SA_MASK    SA 
 *     F2_13_PAYLOAD_MACSA_MASK Payload MACSA 
 *     F2_5_SA_MASK     SA 
 *     F2_6_SA_MASK     SA 
 *     F2_14_PAYLOAD_TOS_FN_MASK Payload TOS_FN 
 *     F2_7_TTL_FN_MASK TTL_FN 
 *     F2_4_TOS_FN_MASK TOS_FN 
 *     F2_0_L4_SRC_MASK L4_SRC 
 *     F2_1_L4_SRC_MASK L4_SRC 
 *     F2_14_PAYLOAD_IP_PROTOCOL_LAST_NH_MASK Payload IP_PROTOCOL_LAST_NH 
 *     F2_7_IP_PROTOCOL_LAST_NH_MASK IP_PROTOCOL_LAST_NH 
 *     F2_4_LAST_NH_MASK LAST_NH 
 *     F2_12_MIML_DA_MASK MIML DA 
 *     F2_14_PAYLOAD_DIP_MASK Payload IPV4 DIP 
 *     F2_7_DIP_MASK    DIP 
 *     F2_4_INT_CN_MASK CongestionClass field in the HiGig header.
 *     F2_4_SPARE_MASK  SPARE 
 *     F2_0_IP_PROTOCOL_LAST_NH_MASK IP_PROTOCOL_LAST_NH 
 *     F2_1_IP_PROTOCOL_LAST_NH_MASK IP_PROTOCOL_LAST_NH 
 *     F2_10_DIP_127_64_MASK DIP_127_64 
 *     F2_4_DIP_127_64_MASK DIP_127_64 
 *     F2_0_DIP_MASK    DIP
 *     F2_1_DIP_MASK    DIP
 *     F2_11_DA_MASK    DA 
 *     F2_13_PAYLOAD_MACDA_MASK Payload MACDA 
 *     F2_5_DA_MASK     DA 
 *     F2_7_DA_MASK     DA 
 *     F2_14_PAYLOAD_SIP_MASK Payload IPV4 SIP 
 *     F2_6_SIP_MASK    SIP
 *     F2_0_SIP_MASK    SIP
 *     F2_1_SIP_MASK    SIP
 *     F2_12_MIML_TAG_MASK MIML TAG 
 *     DWF1_MASK        DWF1 field MASK
 *     F2_12_SPARE_MASK SPARE 
 *     F2_14_SPARE_MASK SPARE. 
 *     F2_6_SPARE_MASK  SPARE 
 *     F1_MASK          F1 field MASK
 *     F1_13_AUX_TAG_1_MASK AUX Tag 1. EHTAG, based on FP_SLICE_KEY_CONTROL.SLICE<0-7>_AUX_TAG_1_SEL setting
 *     F1_9_UDF1_31_0_MASK UDF1_31_0
 *     F1_3_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F1_4_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F1_5_LOOKUP_STATUS_MASK LOOKUP_STATUS 
 *     F1_6_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F1_7_OUTER_VLAN_TAG_MASK OUTER_VLAN_TAG 
 *     F1_10_D_FIELD_MASK D_FIELD 
 *     F1_11_SGLP_MASK  SGLP 
 *     F1_1_D_FIELD_MASK D_FIELD 
 *     F1_2_D_FIELD_MASK D_FIELD 
 *     F1_0_CLASSIDS_MASK CLASSIDS 
 *     F1_12_OUTER_VLAN_ID_MASK OUTER_VLAN_ID 
 *     F1_8_IP_PROTOCOL_LAST_NH_MASK IP_PROTOCOL_LAST_NH 
 *     F1_8_TOS_FN_MASK TOS_FN
 *     F1_0_FORWARDING_FIELD_MASK FORWARDING_FIELD 
 *     F1_12_CLASSIDS_MASK CLASSIDS 
 *     F1_11_SVP_MASK   SVP 
 *     F1_10_D_TYPE_MASK D_TYPE 
 *     F1_1_D_TYPE_MASK D_TYPE 
 *     F1_2_D_TYPE_MASK D_TYPE 
 *     F1_3_INNER_VLAN_TAG_MASK INNER_VLAN_TAG 
 *     F1_4_ETHERTYPE_MASK ETHERTYPE 
 *     F1_5_INNER_VLAN_TAG_MASK INNER_VLAN_TAG 
 *     F1_7_CLASSIDS_11_6_MASK CLASSIDS
 *     F1_8_CLASSIDS_11_6_MASK CLASSIDS
 *     F1_6_PACKET_FORMAT_MASK PACKET_FORMAT 
 *     F1_10_DGLP_MASK  DGLP 
 *     F1_1_S_FIELD_MASK S_FIELD 
 *     F1_2_MH_OPCODE_MASK MH_OPCODE 
 *     F1_6_SWITCHING_TAG_STATUS_MASK SWITHCING_TAG_STATUS 
 *     F1_2_CLASSIDS_MASK CLASSIDS 
 *     F1_7_FORWARDING_FIELD_MASK FORWARDING_FIELD 
 *     F1_8_FORWARDING_FIELD_MASK FORWARDING_FIELD 
 *     F1_6_MH_OPCODE_MASK MH_OPCODE 
 *     F1_0_SVP_L3_IIF_MASK SVP_L3_IIF 
 *     F1_12_SVP_MASK   SVP 
 *     F1_6_PKT_RESOLUTION_MASK PKT_RESOLUTION 
 *     F1_11_SVP_VALID_MASK SVP_VALID 
 *     F1_11_SPARE_MASK SPARE 
 *     F1_6_IP_INFO_MASK IP_INFO 
 *     F1_4_SPARE_MASK  SPARE 
 *     F1_3_OUTER_TPID_ENCODE_MASK OUTER_TPID_ENCODE 
 *     F1_5_INNER_TPID_ENCODE_MASK INNER_TPID_ENCODE 
 *     F1_9_MPLS_INFO_MASK MPLS_INFO 
 *     F1_13_AUX_TAG_VALID_1_MASK AUX Tag Valid 1
 *     F1_10_SPARE_MASK SPARE 
 *     F1_13_SPARE_MASK SPARE 
 *     F1_2_SPARE_MASK  SPARE 
 *     F1_6_SPARE_MASK  SPARE 
 *     F1_1_SVP_VALID_MASK SVP_VALID 
 *     F1_1_MH_OPCODE_MASK MH_OPCODE 
 *     F1_3_SPARE_MASK  SPARE 
 *     F1_5_SPARE_MASK  SPARE 
 *     F1_9_SPARE_MASK  SPARE 
 *     F1_7_MPLS_INFO_MASK MPLS_INFO 
 *     F1_8_INT_CN_MASK CongestionClass field in the HiGig header.
 *     F1_7_SPARE_MASK  SPARE 
 *     F1_8_SPARE_MASK  SPARE 
 *     RESERVED_MASK    RESERVED_MASK
 */
#define FP_TCAMm_MIN 0
#define FP_TCAMm_MAX 1023
#define FP_TCAMm_CMAX(u) 1023
#define FP_TCAMm_SIZE 59

/*
 * This structure should be used to declare and program FP_TCAM.
 */
typedef union FP_TCAMm_s {
	uint32 v[15];
	uint32 fp_tcam[15];
	uint32 _fp_tcam;
} FP_TCAMm_t;

#define FP_TCAMm_CLR(r) sal_memset(&((r)._fp_tcam), 0, sizeof(FP_TCAMm_t))
#define FP_TCAMm_SET(r,i,d) (r).fp_tcam[i] = d
#define FP_TCAMm_GET(r,i) (r).fp_tcam[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_TCAMm_VALIDf_GET(r) (((r).fp_tcam[0]) & 0x3)
#define FP_TCAMm_VALIDf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_TCAMm_FULL_KEYf_GET(r,a) field_get((r).fp_tcam,2,235,a)
#define FP_TCAMm_FULL_KEYf_SET(r,a) field_set((r).fp_tcam,2,235,a)
#define FP_TCAMm_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_tcam[0]) >> 2) & 0x1)
#define FP_TCAMm_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_TCAMm_DW_DOUBLE_WIDE_MODEf_GET(r) ((((r).fp_tcam[0]) >> 2) & 0x1)
#define FP_TCAMm_DW_DOUBLE_WIDE_MODEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_TCAMm_DATA_KEYf_GET(r,a) field_get((r).fp_tcam,3,235,a)
#define FP_TCAMm_DATA_KEYf_SET(r,a) field_set((r).fp_tcam,3,235,a)
#define FP_TCAMm_DWF4f_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x7f)
#define FP_TCAMm_DWF4f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x7f << 3)) | ((((uint32)f) & 0x7f) << 3))
#define FP_TCAMm_DWF4_0_PORT_FIELD_SEL_TABLE_INDEXf_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x7f)
#define FP_TCAMm_DWF4_0_PORT_FIELD_SEL_TABLE_INDEXf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x7f << 3)) | ((((uint32)f) & 0x7f) << 3))
#define FP_TCAMm_DWF4_0_PORT_FIELD_SEL_TABLE_INDEX_MASKf_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x7f)
#define FP_TCAMm_DWF4_0_PORT_FIELD_SEL_TABLE_INDEX_MASKf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x7f << 3)) | ((((uint32)f) & 0x7f) << 3))
#define FP_TCAMm_F4f_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x7f)
#define FP_TCAMm_F4f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x7f << 3)) | ((((uint32)f) & 0x7f) << 3))
#define FP_TCAMm_DWF4_1_TCP_FNf_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x3f)
#define FP_TCAMm_DWF4_1_TCP_FNf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x3f << 3)) | ((((uint32)f) & 0x3f) << 3))
#define FP_TCAMm_DWF4_1_TCP_FN_MASKf_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x3f)
#define FP_TCAMm_DWF4_1_TCP_FN_MASKf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x3f << 3)) | ((((uint32)f) & 0x3f) << 3))
#define FP_TCAMm_DWF4_1_SPAREf_GET(r) ((((r).fp_tcam[0]) >> 9) & 0x1)
#define FP_TCAMm_DWF4_1_SPAREf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_TCAMm_DWF4_1_SPARE_MASKf_GET(r) ((((r).fp_tcam[0]) >> 9) & 0x1)
#define FP_TCAMm_DWF4_1_SPARE_MASKf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_TCAMm_DWF3f_GET(r) field32_get((r).fp_tcam,10,41)
#define FP_TCAMm_DWF3f_SET(r,f) field32_set((r).fp_tcam,10,41,f)
#define FP_TCAMm_FIXEDf_GET(r) ((((r).fp_tcam[0]) >> 10) & 0x7ffff)
#define FP_TCAMm_FIXEDf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x7ffff << 10)) | ((((uint32)f) & 0x7ffff) << 10))
#define FP_TCAMm_FIXED_HIGIGf_GET(r) ((((r).fp_tcam[0]) >> 10) & 0x1)
#define FP_TCAMm_FIXED_HIGIGf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define FP_TCAMm_FIXED_FORWARDING_TYPEf_GET(r) ((((r).fp_tcam[0]) >> 11) & 0x7)
#define FP_TCAMm_FIXED_FORWARDING_TYPEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x7 << 11)) | ((((uint32)f) & 0x7) << 11))
#define FP_TCAMm_FIXED_SVP_OR_L3IIFf_GET(r) ((((r).fp_tcam[0]) >> 14) & 0x1)
#define FP_TCAMm_FIXED_SVP_OR_L3IIFf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define FP_TCAMm_FIXED_L3_TYPEf_GET(r) ((((r).fp_tcam[0]) >> 15) & 0xf)
#define FP_TCAMm_FIXED_L3_TYPEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0xf << 15)) | ((((uint32)f) & 0xf) << 15))
#define FP_TCAMm_FIXED_L4_VALIDf_GET(r) ((((r).fp_tcam[0]) >> 19) & 0x1)
#define FP_TCAMm_FIXED_L4_VALIDf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_TCAMm_FIXED_L3_ROUTABLEf_GET(r) ((((r).fp_tcam[0]) >> 20) & 0x1)
#define FP_TCAMm_FIXED_L3_ROUTABLEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_TCAMm_FIXED_TUNNEL_TYPE_LOOPBACK_TYPEf_GET(r) ((((r).fp_tcam[0]) >> 21) & 0xf)
#define FP_TCAMm_FIXED_TUNNEL_TYPE_LOOPBACK_TYPEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0xf << 21)) | ((((uint32)f) & 0xf) << 21))
#define FP_TCAMm_FIXED_DROPf_GET(r) ((((r).fp_tcam[0]) >> 25) & 0x1)
#define FP_TCAMm_FIXED_DROPf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define FP_TCAMm_FIXED_MIRROR_ONLYf_GET(r) ((((r).fp_tcam[0]) >> 26) & 0x1)
#define FP_TCAMm_FIXED_MIRROR_ONLYf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define FP_TCAMm_FIXED_MIML_PRESENTf_GET(r) ((((r).fp_tcam[0]) >> 27) & 0x1)
#define FP_TCAMm_FIXED_MIML_PRESENTf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define FP_TCAMm_FIXED_CUSTOM_HEADER_PRESENTf_GET(r) ((((r).fp_tcam[0]) >> 28) & 0x1)
#define FP_TCAMm_FIXED_CUSTOM_HEADER_PRESENTf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define FP_TCAMm_F3f_GET(r,a) field_get((r).fp_tcam,29,65,a)
#define FP_TCAMm_F3f_SET(r,a) field_set((r).fp_tcam,29,65,a)
#define FP_TCAMm_F3_12_AUX_TAG_2f_GET(r) field32_get((r).fp_tcam,29,60)
#define FP_TCAMm_F3_12_AUX_TAG_2f_SET(r,f) field32_set((r).fp_tcam,29,60,f)
#define FP_TCAMm_F3_9_UDF1_95_64f_GET(r) field32_get((r).fp_tcam,29,60)
#define FP_TCAMm_F3_9_UDF1_95_64f_SET(r,f) field32_set((r).fp_tcam,29,60,f)
#define FP_TCAMm_F3_7_RANGE_CHECK_RESULTSf_GET(r) field32_get((r).fp_tcam,29,52)
#define FP_TCAMm_F3_7_RANGE_CHECK_RESULTSf_SET(r,f) field32_set((r).fp_tcam,29,52,f)
#define FP_TCAMm_F3_8_IPV6_FLf_GET(r) field32_get((r).fp_tcam,29,48)
#define FP_TCAMm_F3_8_IPV6_FLf_SET(r,f) field32_set((r).fp_tcam,29,48,f)
#define FP_TCAMm_F3_3_OUTER_VLAN_TAGf_GET(r) field32_get((r).fp_tcam,29,44)
#define FP_TCAMm_F3_3_OUTER_VLAN_TAGf_SET(r,f) field32_set((r).fp_tcam,29,44,f)
#define FP_TCAMm_F3_4_OUTER_VLAN_TAGf_GET(r) field32_get((r).fp_tcam,29,44)
#define FP_TCAMm_F3_4_OUTER_VLAN_TAGf_SET(r,f) field32_set((r).fp_tcam,29,44,f)
#define FP_TCAMm_F3_5_OUTER_VLAN_TAGf_GET(r) field32_get((r).fp_tcam,29,44)
#define FP_TCAMm_F3_5_OUTER_VLAN_TAGf_SET(r,f) field32_set((r).fp_tcam,29,44,f)
#define FP_TCAMm_F3_6_LOOKUP_STATUSf_GET(r) field32_get((r).fp_tcam,29,44)
#define FP_TCAMm_F3_6_LOOKUP_STATUSf_SET(r,f) field32_set((r).fp_tcam,29,44,f)
#define FP_TCAMm_F3_10_D_FIELDf_GET(r) field32_get((r).fp_tcam,29,43)
#define FP_TCAMm_F3_10_D_FIELDf_SET(r,f) field32_set((r).fp_tcam,29,43,f)
#define FP_TCAMm_F3_11_SGLPf_GET(r) field32_get((r).fp_tcam,29,43)
#define FP_TCAMm_F3_11_SGLPf_SET(r,f) field32_set((r).fp_tcam,29,43,f)
#define FP_TCAMm_F3_2_D_FIELDf_GET(r) field32_get((r).fp_tcam,29,43)
#define FP_TCAMm_F3_2_D_FIELDf_SET(r,f) field32_set((r).fp_tcam,29,43,f)
#define FP_TCAMm_F3_0_CLASSIDSf_GET(r) field32_get((r).fp_tcam,29,40)
#define FP_TCAMm_F3_0_CLASSIDSf_SET(r,f) field32_set((r).fp_tcam,29,40,f)
#define FP_TCAMm_F3_1_CLASSIDSf_GET(r) field32_get((r).fp_tcam,29,40)
#define FP_TCAMm_F3_1_CLASSIDSf_SET(r,f) field32_set((r).fp_tcam,29,40,f)
#define FP_TCAMm_F3_0_FORWARDING_FIELDf_GET(r) ((((r).fp_tcam[1]) >> 9) & 0xfff)
#define FP_TCAMm_F3_0_FORWARDING_FIELDf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xfff << 9)) | ((((uint32)f) & 0xfff) << 9))
#define FP_TCAMm_F3_1_FORWARDING_FIELDf_GET(r) ((((r).fp_tcam[1]) >> 9) & 0xfff)
#define FP_TCAMm_F3_1_FORWARDING_FIELDf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xfff << 9)) | ((((uint32)f) & 0xfff) << 9))
#define FP_TCAMm_DWF2f_GET(r,a) field_get((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2f_SET(r,a) field_set((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_1_SIPf_GET(r,a) field_get((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_1_SIPf_SET(r,a) field_set((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_1_SIP_MASKf_GET(r,a) field_get((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_1_SIP_MASKf_SET(r,a) field_set((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_2_DIPf_GET(r,a) field_get((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_2_DIPf_SET(r,a) field_set((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_2_DIP_MASKf_GET(r,a) field_get((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_2_DIP_MASKf_SET(r,a) field_set((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_3_UDF2f_GET(r,a) field_get((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_3_UDF2f_SET(r,a) field_set((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_3_UDF2_MASKf_GET(r,a) field_get((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_3_UDF2_MASKf_SET(r,a) field_set((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_6_PAYLOAD_SIPf_GET(r,a) field_get((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_6_PAYLOAD_SIPf_SET(r,a) field_set((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_6_PAYLOAD_SIP_MASKf_GET(r,a) field_get((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_6_PAYLOAD_SIP_MASKf_SET(r,a) field_set((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_7_PAYLOAD_DIPf_GET(r,a) field_get((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_7_PAYLOAD_DIPf_SET(r,a) field_set((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_7_PAYLOAD_DIP_MASKf_GET(r,a) field_get((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_7_PAYLOAD_DIP_MASKf_SET(r,a) field_set((r).fp_tcam,42,169,a)
#define FP_TCAMm_DWF2_0_SPAREf_GET(r) ((((r).fp_tcam[1]) >> 10) & 0xffff)
#define FP_TCAMm_DWF2_0_SPAREf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 10)) | ((((uint32)f) & 0xffff) << 10))
#define FP_TCAMm_DWF2_0_SPARE_MASKf_GET(r) ((((r).fp_tcam[1]) >> 10) & 0xffff)
#define FP_TCAMm_DWF2_0_SPARE_MASKf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 10)) | ((((uint32)f) & 0xffff) << 10))
#define FP_TCAMm_DWF2_4_PAYLOAD_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[1]) >> 10) & 0xffff)
#define FP_TCAMm_DWF2_4_PAYLOAD_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 10)) | ((((uint32)f) & 0xffff) << 10))
#define FP_TCAMm_DWF2_4_PAYLOAD_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[1]) >> 10) & 0xffff)
#define FP_TCAMm_DWF2_4_PAYLOAD_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 10)) | ((((uint32)f) & 0xffff) << 10))
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_DSTf_GET(r) ((((r).fp_tcam[1]) >> 10) & 0xffff)
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_DSTf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 10)) | ((((uint32)f) & 0xffff) << 10))
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_DST_MASKf_GET(r) ((((r).fp_tcam[1]) >> 10) & 0xffff)
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_DST_MASKf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 10)) | ((((uint32)f) & 0xffff) << 10))
#define FP_TCAMm_F3_11_SVPf_GET(r) ((((r).fp_tcam[1]) >> 12) & 0x1fff)
#define FP_TCAMm_F3_11_SVPf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x1fff << 12)) | ((((uint32)f) & 0x1fff) << 12))
#define FP_TCAMm_F3_10_D_TYPEf_GET(r) ((((r).fp_tcam[1]) >> 12) & 0x7)
#define FP_TCAMm_F3_10_D_TYPEf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define FP_TCAMm_F3_2_D_TYPEf_GET(r) ((((r).fp_tcam[1]) >> 12) & 0x7)
#define FP_TCAMm_F3_2_D_TYPEf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define FP_TCAMm_F3_4_INNER_VLAN_TAGf_GET(r) ((((r).fp_tcam[1]) >> 13) & 0xffff)
#define FP_TCAMm_F3_4_INNER_VLAN_TAGf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 13)) | ((((uint32)f) & 0xffff) << 13))
#define FP_TCAMm_F3_5_ETHERTYPEf_GET(r) ((((r).fp_tcam[1]) >> 13) & 0xffff)
#define FP_TCAMm_F3_5_ETHERTYPEf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 13)) | ((((uint32)f) & 0xffff) << 13))
#define FP_TCAMm_F3_6_INNER_VLAN_TAGf_GET(r) ((((r).fp_tcam[1]) >> 13) & 0xffff)
#define FP_TCAMm_F3_6_INNER_VLAN_TAGf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xffff << 13)) | ((((uint32)f) & 0xffff) << 13))
#define FP_TCAMm_F3_3_PACKET_FORMATf_GET(r) ((((r).fp_tcam[1]) >> 13) & 0xf)
#define FP_TCAMm_F3_3_PACKET_FORMATf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xf << 13)) | ((((uint32)f) & 0xf) << 13))
#define FP_TCAMm_F3_10_DGLPf_GET(r) ((((r).fp_tcam[1]) >> 15) & 0x7fff)
#define FP_TCAMm_F3_10_DGLPf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x7fff << 15)) | ((((uint32)f) & 0x7fff) << 15))
#define FP_TCAMm_F3_2_S_FIELDf_GET(r) ((((r).fp_tcam[1]) >> 15) & 0x7fff)
#define FP_TCAMm_F3_2_S_FIELDf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x7fff << 15)) | ((((uint32)f) & 0x7fff) << 15))
#define FP_TCAMm_F3_8_PACKET_FORMATf_GET(r) ((((r).fp_tcam[1]) >> 17) & 0xf)
#define FP_TCAMm_F3_8_PACKET_FORMATf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xf << 17)) | ((((uint32)f) & 0xf) << 17))
#define FP_TCAMm_F3_3_SWITCHING_TAG_STATUSf_GET(r) ((((r).fp_tcam[1]) >> 17) & 0x3)
#define FP_TCAMm_F3_3_SWITCHING_TAG_STATUSf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x3 << 17)) | ((((uint32)f) & 0x3) << 17))
#define FP_TCAMm_F3_3_MH_OPCODEf_GET(r) ((((r).fp_tcam[1]) >> 19) & 0x7)
#define FP_TCAMm_F3_3_MH_OPCODEf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define FP_TCAMm_F3_0_SVP_L3IIF_OVERLAYf_GET(r) field32_get((r).fp_tcam,53,65)
#define FP_TCAMm_F3_0_SVP_L3IIF_OVERLAYf_SET(r,f) field32_set((r).fp_tcam,53,65,f)
#define FP_TCAMm_F3_1_OUTER_VLAN_IDf_GET(r) field32_get((r).fp_tcam,53,64)
#define FP_TCAMm_F3_1_OUTER_VLAN_IDf_SET(r,f) field32_set((r).fp_tcam,53,64,f)
#define FP_TCAMm_F3_7_INTERFACE_CLASSIDf_GET(r) ((((r).fp_tcam[1]) >> 21) & 0xff)
#define FP_TCAMm_F3_7_INTERFACE_CLASSIDf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0xff << 21)) | ((((uint32)f) & 0xff) << 21))
#define FP_TCAMm_F3_8_SWITCHING_TAG_STATUSf_GET(r) ((((r).fp_tcam[1]) >> 21) & 0x3)
#define FP_TCAMm_F3_8_SWITCHING_TAG_STATUSf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define FP_TCAMm_F3_3_PKT_RESOLUTIONf_GET(r) ((((r).fp_tcam[1]) >> 22) & 0x1f)
#define FP_TCAMm_F3_3_PKT_RESOLUTIONf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x1f << 22)) | ((((uint32)f) & 0x1f) << 22))
#define FP_TCAMm_F3_8_INNER_TPID_ENCODEf_GET(r) ((((r).fp_tcam[1]) >> 23) & 0x3)
#define FP_TCAMm_F3_8_INNER_TPID_ENCODEf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x3 << 23)) | ((((uint32)f) & 0x3) << 23))
#define FP_TCAMm_F3_8_OUTER_TPID_ENCODEf_GET(r) ((((r).fp_tcam[1]) >> 25) & 0x3)
#define FP_TCAMm_F3_8_OUTER_TPID_ENCODEf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x3 << 25)) | ((((uint32)f) & 0x3) << 25))
#define FP_TCAMm_F3_11_SVP_VALIDf_GET(r) ((((r).fp_tcam[1]) >> 25) & 0x1)
#define FP_TCAMm_F3_11_SVP_VALIDf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define FP_TCAMm_DWF2_0_LOOKUP_STATUSf_GET(r) field32_get((r).fp_tcam,58,73)
#define FP_TCAMm_DWF2_0_LOOKUP_STATUSf_SET(r,f) field32_set((r).fp_tcam,58,73,f)
#define FP_TCAMm_DWF2_0_LOOKUP_STATUS_MASKf_GET(r) field32_get((r).fp_tcam,58,73)
#define FP_TCAMm_DWF2_0_LOOKUP_STATUS_MASKf_SET(r,f) field32_set((r).fp_tcam,58,73,f)
#define FP_TCAMm_DWF2_4_PAYLOAD_ETHERTYPEf_GET(r) field32_get((r).fp_tcam,58,73)
#define FP_TCAMm_DWF2_4_PAYLOAD_ETHERTYPEf_SET(r,f) field32_set((r).fp_tcam,58,73,f)
#define FP_TCAMm_DWF2_4_PAYLOAD_ETHERTYPE_MASKf_GET(r) field32_get((r).fp_tcam,58,73)
#define FP_TCAMm_DWF2_4_PAYLOAD_ETHERTYPE_MASKf_SET(r,f) field32_set((r).fp_tcam,58,73,f)
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_SRCf_GET(r) field32_get((r).fp_tcam,58,73)
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_SRCf_SET(r,f) field32_set((r).fp_tcam,58,73,f)
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_SRC_MASKf_GET(r) field32_get((r).fp_tcam,58,73)
#define FP_TCAMm_DWF2_5_PAYLOAD_L4_SRC_MASKf_SET(r,f) field32_set((r).fp_tcam,58,73,f)
#define FP_TCAMm_F3_11_SPAREf_GET(r) field32_get((r).fp_tcam,58,65)
#define FP_TCAMm_F3_11_SPAREf_SET(r,f) field32_set((r).fp_tcam,58,65,f)
#define FP_TCAMm_F3_8_SPAREf_GET(r) field32_get((r).fp_tcam,59,65)
#define FP_TCAMm_F3_8_SPAREf_SET(r,f) field32_set((r).fp_tcam,59,65,f)
#define FP_TCAMm_F3_3_IP_INFOf_GET(r) ((((r).fp_tcam[1]) >> 27) & 0x7)
#define FP_TCAMm_F3_3_IP_INFOf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define FP_TCAMm_F3_4_SPAREf_GET(r) field32_get((r).fp_tcam,61,65)
#define FP_TCAMm_F3_4_SPAREf_SET(r,f) field32_set((r).fp_tcam,61,65,f)
#define FP_TCAMm_F3_5_SPAREf_GET(r) field32_get((r).fp_tcam,61,65)
#define FP_TCAMm_F3_5_SPAREf_SET(r,f) field32_set((r).fp_tcam,61,65,f)
#define FP_TCAMm_F3_6_SPAREf_GET(r) field32_get((r).fp_tcam,61,65)
#define FP_TCAMm_F3_6_SPAREf_SET(r,f) field32_set((r).fp_tcam,61,65,f)
#define FP_TCAMm_F3_7_SPAREf_GET(r) field32_get((r).fp_tcam,61,65)
#define FP_TCAMm_F3_7_SPAREf_SET(r,f) field32_set((r).fp_tcam,61,65,f)
#define FP_TCAMm_F3_9_MPLS_INFOf_GET(r) ((((r).fp_tcam[1]) >> 29) & 0x3)
#define FP_TCAMm_F3_9_MPLS_INFOf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x3 << 29)) | ((((uint32)f) & 0x3) << 29))
#define FP_TCAMm_F3_12_AUX_TAG_VALID_2f_GET(r) ((((r).fp_tcam[1]) >> 29) & 0x1)
#define FP_TCAMm_F3_12_AUX_TAG_VALID_2f_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define FP_TCAMm_F3_10_SPAREf_GET(r) field32_get((r).fp_tcam,62,65)
#define FP_TCAMm_F3_10_SPAREf_SET(r,f) field32_set((r).fp_tcam,62,65,f)
#define FP_TCAMm_F3_12_SPAREf_GET(r) field32_get((r).fp_tcam,62,65)
#define FP_TCAMm_F3_12_SPAREf_SET(r,f) field32_set((r).fp_tcam,62,65,f)
#define FP_TCAMm_F3_3_SPAREf_GET(r) field32_get((r).fp_tcam,62,65)
#define FP_TCAMm_F3_3_SPAREf_SET(r,f) field32_set((r).fp_tcam,62,65,f)
#define FP_TCAMm_F3_2_SVP_VALIDf_GET(r) ((((r).fp_tcam[1]) >> 30) & 0x1)
#define FP_TCAMm_F3_2_SVP_VALIDf_SET(r,f) (r).fp_tcam[1]=(((r).fp_tcam[1] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define FP_TCAMm_F3_2_MH_OPCODEf_GET(r) field32_get((r).fp_tcam,63,65)
#define FP_TCAMm_F3_2_MH_OPCODEf_SET(r,f) field32_set((r).fp_tcam,63,65,f)
#define FP_TCAMm_F3_9_SPAREf_GET(r) field32_get((r).fp_tcam,63,65)
#define FP_TCAMm_F3_9_SPAREf_SET(r,f) field32_set((r).fp_tcam,63,65,f)
#define FP_TCAMm_F3_1_SPAREf_GET(r) ((((r).fp_tcam[2]) >> 1) & 0x1)
#define FP_TCAMm_F3_1_SPAREf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_TCAMm_F2f_GET(r,a) field_get((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2f_SET(r,a) field_set((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_15_PAYLOAD_SIPf_GET(r,a) field_get((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_15_PAYLOAD_SIPf_SET(r,a) field_set((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_16_PAYLOAD_DIPf_GET(r,a) field_get((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_16_PAYLOAD_DIPf_SET(r,a) field_set((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_2_SIPf_GET(r,a) field_get((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_2_SIPf_SET(r,a) field_set((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_3_DIPf_GET(r,a) field_get((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_3_DIPf_SET(r,a) field_set((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_8_UDF1f_GET(r,a) field_get((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_8_UDF1f_SET(r,a) field_set((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_9_UDF2f_GET(r,a) field_get((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_9_UDF2f_SET(r,a) field_set((r).fp_tcam,66,193,a)
#define FP_TCAMm_F2_10_SIP_127_64f_GET(r,a) field_get((r).fp_tcam,66,129,a)
#define FP_TCAMm_F2_10_SIP_127_64f_SET(r,a) field_set((r).fp_tcam,66,129,a)
#define FP_TCAMm_F2_12_MIML_SAf_GET(r,a) field_get((r).fp_tcam,66,113,a)
#define FP_TCAMm_F2_12_MIML_SAf_SET(r,a) field_set((r).fp_tcam,66,113,a)
#define FP_TCAMm_F2_11_DIP_127_96f_GET(r) field32_get((r).fp_tcam,66,97)
#define FP_TCAMm_F2_11_DIP_127_96f_SET(r,f) field32_set((r).fp_tcam,66,97,f)
#define FP_TCAMm_F2_13_PAYLOAD_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[2]) >> 2) & 0xffff)
#define FP_TCAMm_F2_13_PAYLOAD_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xffff << 2)) | ((((uint32)f) & 0xffff) << 2))
#define FP_TCAMm_F2_14_PAYLOAD_L4_DSTf_GET(r) ((((r).fp_tcam[2]) >> 2) & 0xffff)
#define FP_TCAMm_F2_14_PAYLOAD_L4_DSTf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xffff << 2)) | ((((uint32)f) & 0xffff) << 2))
#define FP_TCAMm_F2_5_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[2]) >> 2) & 0xffff)
#define FP_TCAMm_F2_5_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xffff << 2)) | ((((uint32)f) & 0xffff) << 2))
#define FP_TCAMm_F2_6_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[2]) >> 2) & 0xffff)
#define FP_TCAMm_F2_6_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xffff << 2)) | ((((uint32)f) & 0xffff) << 2))
#define FP_TCAMm_F2_7_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[2]) >> 2) & 0xffff)
#define FP_TCAMm_F2_7_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xffff << 2)) | ((((uint32)f) & 0xffff) << 2))
#define FP_TCAMm_F2_0_TTL_FNf_GET(r) ((((r).fp_tcam[2]) >> 2) & 0xff)
#define FP_TCAMm_F2_0_TTL_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define FP_TCAMm_F2_1_TTL_FNf_GET(r) ((((r).fp_tcam[2]) >> 2) & 0xff)
#define FP_TCAMm_F2_1_TTL_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define FP_TCAMm_F2_4_TTL_FNf_GET(r) ((((r).fp_tcam[2]) >> 2) & 0xff)
#define FP_TCAMm_F2_4_TTL_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define FP_TCAMm_DWF2_4_PAYLOAD_MACSAf_GET(r,a) field_get((r).fp_tcam,74,121,a)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACSAf_SET(r,a) field_set((r).fp_tcam,74,121,a)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACSA_MASKf_GET(r,a) field_get((r).fp_tcam,74,121,a)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACSA_MASKf_SET(r,a) field_set((r).fp_tcam,74,121,a)
#define FP_TCAMm_DWF2_0_RANGE_CHECK_RESULTSf_GET(r) field32_get((r).fp_tcam,74,97)
#define FP_TCAMm_DWF2_0_RANGE_CHECK_RESULTSf_SET(r,f) field32_set((r).fp_tcam,74,97,f)
#define FP_TCAMm_DWF2_0_RANGE_CHECK_RESULTS_MASKf_GET(r) field32_get((r).fp_tcam,74,97)
#define FP_TCAMm_DWF2_0_RANGE_CHECK_RESULTS_MASKf_SET(r,f) field32_set((r).fp_tcam,74,97,f)
#define FP_TCAMm_DWF2_5_PAYLOAD_TOS_FNf_GET(r) ((((r).fp_tcam[2]) >> 10) & 0xff)
#define FP_TCAMm_DWF2_5_PAYLOAD_TOS_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 10)) | ((((uint32)f) & 0xff) << 10))
#define FP_TCAMm_DWF2_5_PAYLOAD_TOS_FN_MASKf_GET(r) ((((r).fp_tcam[2]) >> 10) & 0xff)
#define FP_TCAMm_DWF2_5_PAYLOAD_TOS_FN_MASKf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 10)) | ((((uint32)f) & 0xff) << 10))
#define FP_TCAMm_F2_0_TCP_FNf_GET(r) ((((r).fp_tcam[2]) >> 10) & 0x3f)
#define FP_TCAMm_F2_0_TCP_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3f << 10)) | ((((uint32)f) & 0x3f) << 10))
#define FP_TCAMm_F2_1_TCP_FNf_GET(r) ((((r).fp_tcam[2]) >> 10) & 0x3f)
#define FP_TCAMm_F2_1_TCP_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3f << 10)) | ((((uint32)f) & 0x3f) << 10))
#define FP_TCAMm_F2_4_TCP_FNf_GET(r) ((((r).fp_tcam[2]) >> 10) & 0x3f)
#define FP_TCAMm_F2_4_TCP_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3f << 10)) | ((((uint32)f) & 0x3f) << 10))
#define FP_TCAMm_F2_4_IPV6_FLf_GET(r) field32_get((r).fp_tcam,80,99)
#define FP_TCAMm_F2_4_IPV6_FLf_SET(r,f) field32_set((r).fp_tcam,80,99,f)
#define FP_TCAMm_F2_0_IPFLAGf_GET(r) ((((r).fp_tcam[2]) >> 16) & 0x3)
#define FP_TCAMm_F2_0_IPFLAGf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define FP_TCAMm_F2_1_IP_FRAG_INFOf_GET(r) ((((r).fp_tcam[2]) >> 16) & 0x3)
#define FP_TCAMm_F2_1_IP_FRAG_INFOf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define FP_TCAMm_F2_13_PAYLOAD_ETHERTYPEf_GET(r) field32_get((r).fp_tcam,82,97)
#define FP_TCAMm_F2_13_PAYLOAD_ETHERTYPEf_SET(r,f) field32_set((r).fp_tcam,82,97,f)
#define FP_TCAMm_F2_14_PAYLOAD_L4_SRCf_GET(r) field32_get((r).fp_tcam,82,97)
#define FP_TCAMm_F2_14_PAYLOAD_L4_SRCf_SET(r,f) field32_set((r).fp_tcam,82,97,f)
#define FP_TCAMm_F2_5_ETHERTYPEf_GET(r) field32_get((r).fp_tcam,82,97)
#define FP_TCAMm_F2_5_ETHERTYPEf_SET(r,f) field32_set((r).fp_tcam,82,97,f)
#define FP_TCAMm_F2_6_ETHERTYPEf_GET(r) field32_get((r).fp_tcam,82,97)
#define FP_TCAMm_F2_6_ETHERTYPEf_SET(r,f) field32_set((r).fp_tcam,82,97,f)
#define FP_TCAMm_F2_7_ETHERTYPEf_GET(r) field32_get((r).fp_tcam,82,97)
#define FP_TCAMm_F2_7_ETHERTYPEf_SET(r,f) field32_set((r).fp_tcam,82,97,f)
#define FP_TCAMm_DWF2_5_PAYLOAD_IP_PROTOCOL_LAST_NHf_GET(r) ((((r).fp_tcam[2]) >> 18) & 0xff)
#define FP_TCAMm_DWF2_5_PAYLOAD_IP_PROTOCOL_LAST_NHf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 18)) | ((((uint32)f) & 0xff) << 18))
#define FP_TCAMm_DWF2_5_PAYLOAD_IP_PROTOCOL_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[2]) >> 18) & 0xff)
#define FP_TCAMm_DWF2_5_PAYLOAD_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 18)) | ((((uint32)f) & 0xff) << 18))
#define FP_TCAMm_F2_0_TOS_FNf_GET(r) ((((r).fp_tcam[2]) >> 18) & 0xff)
#define FP_TCAMm_F2_0_TOS_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 18)) | ((((uint32)f) & 0xff) << 18))
#define FP_TCAMm_F2_1_TOS_FNf_GET(r) ((((r).fp_tcam[2]) >> 18) & 0xff)
#define FP_TCAMm_F2_1_TOS_FNf_SET(r,f) (r).fp_tcam[2]=(((r).fp_tcam[2] & ~((uint32)0xff << 18)) | ((((uint32)f) & 0xff) << 18))
#define FP_TCAMm_DWF2_5_PAYLOAD_DIPf_GET(r) field32_get((r).fp_tcam,90,121)
#define FP_TCAMm_DWF2_5_PAYLOAD_DIPf_SET(r,f) field32_set((r).fp_tcam,90,121,f)
#define FP_TCAMm_DWF2_5_PAYLOAD_DIP_MASKf_GET(r) field32_get((r).fp_tcam,90,121)
#define FP_TCAMm_DWF2_5_PAYLOAD_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,90,121,f)
#define FP_TCAMm_F2_0_L4_DSTf_GET(r) field32_get((r).fp_tcam,90,105)
#define FP_TCAMm_F2_0_L4_DSTf_SET(r,f) field32_set((r).fp_tcam,90,105,f)
#define FP_TCAMm_F2_1_L4_DSTf_GET(r) field32_get((r).fp_tcam,90,105)
#define FP_TCAMm_F2_1_L4_DSTf_SET(r,f) field32_set((r).fp_tcam,90,105,f)
#define FP_TCAMm_F2_11_SAf_GET(r,a) field_get((r).fp_tcam,98,145,a)
#define FP_TCAMm_F2_11_SAf_SET(r,a) field_set((r).fp_tcam,98,145,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACSAf_GET(r,a) field_get((r).fp_tcam,98,145,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACSAf_SET(r,a) field_set((r).fp_tcam,98,145,a)
#define FP_TCAMm_F2_5_SAf_GET(r,a) field_get((r).fp_tcam,98,145,a)
#define FP_TCAMm_F2_5_SAf_SET(r,a) field_set((r).fp_tcam,98,145,a)
#define FP_TCAMm_F2_6_SAf_GET(r,a) field_get((r).fp_tcam,98,145,a)
#define FP_TCAMm_F2_6_SAf_SET(r,a) field_set((r).fp_tcam,98,145,a)
#define FP_TCAMm_DWF2_0_INTERFACE_CLASSIDf_GET(r) ((((r).fp_tcam[3]) >> 2) & 0xff)
#define FP_TCAMm_DWF2_0_INTERFACE_CLASSIDf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define FP_TCAMm_DWF2_0_INTERFACE_CLASSID_MASKf_GET(r) ((((r).fp_tcam[3]) >> 2) & 0xff)
#define FP_TCAMm_DWF2_0_INTERFACE_CLASSID_MASKf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define FP_TCAMm_F2_14_PAYLOAD_TOS_FNf_GET(r) ((((r).fp_tcam[3]) >> 2) & 0xff)
#define FP_TCAMm_F2_14_PAYLOAD_TOS_FNf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define FP_TCAMm_F2_7_TTL_FNf_GET(r) ((((r).fp_tcam[3]) >> 2) & 0xff)
#define FP_TCAMm_F2_7_TTL_FNf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define FP_TCAMm_F2_4_TOS_FNf_GET(r) ((((r).fp_tcam[3]) >> 4) & 0xff)
#define FP_TCAMm_F2_4_TOS_FNf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 4)) | ((((uint32)f) & 0xff) << 4))
#define FP_TCAMm_DWF2_0_DIPf_GET(r) field32_get((r).fp_tcam,106,137)
#define FP_TCAMm_DWF2_0_DIPf_SET(r,f) field32_set((r).fp_tcam,106,137,f)
#define FP_TCAMm_DWF2_0_DIP_MASKf_GET(r) field32_get((r).fp_tcam,106,137)
#define FP_TCAMm_DWF2_0_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,106,137,f)
#define FP_TCAMm_F2_0_L4_SRCf_GET(r) ((((r).fp_tcam[3]) >> 10) & 0xffff)
#define FP_TCAMm_F2_0_L4_SRCf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xffff << 10)) | ((((uint32)f) & 0xffff) << 10))
#define FP_TCAMm_F2_1_L4_SRCf_GET(r) ((((r).fp_tcam[3]) >> 10) & 0xffff)
#define FP_TCAMm_F2_1_L4_SRCf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xffff << 10)) | ((((uint32)f) & 0xffff) << 10))
#define FP_TCAMm_F2_14_PAYLOAD_IP_PROTOCOL_LAST_NHf_GET(r) ((((r).fp_tcam[3]) >> 10) & 0xff)
#define FP_TCAMm_F2_14_PAYLOAD_IP_PROTOCOL_LAST_NHf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 10)) | ((((uint32)f) & 0xff) << 10))
#define FP_TCAMm_F2_7_IP_PROTOCOL_LAST_NHf_GET(r) ((((r).fp_tcam[3]) >> 10) & 0xff)
#define FP_TCAMm_F2_7_IP_PROTOCOL_LAST_NHf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 10)) | ((((uint32)f) & 0xff) << 10))
#define FP_TCAMm_F2_4_LAST_NHf_GET(r) ((((r).fp_tcam[3]) >> 12) & 0xff)
#define FP_TCAMm_F2_4_LAST_NHf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0xff << 12)) | ((((uint32)f) & 0xff) << 12))
#define FP_TCAMm_F2_12_MIML_DAf_GET(r,a) field_get((r).fp_tcam,114,161,a)
#define FP_TCAMm_F2_12_MIML_DAf_SET(r,a) field_set((r).fp_tcam,114,161,a)
#define FP_TCAMm_F2_14_PAYLOAD_DIPf_GET(r) field32_get((r).fp_tcam,114,145)
#define FP_TCAMm_F2_14_PAYLOAD_DIPf_SET(r,f) field32_set((r).fp_tcam,114,145,f)
#define FP_TCAMm_F2_7_DIPf_GET(r) field32_get((r).fp_tcam,114,145)
#define FP_TCAMm_F2_7_DIPf_SET(r,f) field32_set((r).fp_tcam,114,145,f)
#define FP_TCAMm_F2_4_INT_CNf_GET(r) ((((r).fp_tcam[3]) >> 20) & 0x3)
#define FP_TCAMm_F2_4_INT_CNf_SET(r,f) (r).fp_tcam[3]=(((r).fp_tcam[3] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define FP_TCAMm_F2_4_SPAREf_GET(r) field32_get((r).fp_tcam,118,129)
#define FP_TCAMm_F2_4_SPAREf_SET(r,f) field32_set((r).fp_tcam,118,129,f)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACDAf_GET(r,a) field_get((r).fp_tcam,122,169,a)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACDAf_SET(r,a) field_set((r).fp_tcam,122,169,a)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACDA_MASKf_GET(r,a) field_get((r).fp_tcam,122,169,a)
#define FP_TCAMm_DWF2_4_PAYLOAD_MACDA_MASKf_SET(r,a) field_set((r).fp_tcam,122,169,a)
#define FP_TCAMm_DWF2_5_PAYLOAD_SIPf_GET(r) field32_get((r).fp_tcam,122,153)
#define FP_TCAMm_DWF2_5_PAYLOAD_SIPf_SET(r,f) field32_set((r).fp_tcam,122,153,f)
#define FP_TCAMm_DWF2_5_PAYLOAD_SIP_MASKf_GET(r) field32_get((r).fp_tcam,122,153)
#define FP_TCAMm_DWF2_5_PAYLOAD_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,122,153,f)
#define FP_TCAMm_F2_0_IP_PROTOCOL_LAST_NHf_GET(r) field32_get((r).fp_tcam,122,129)
#define FP_TCAMm_F2_0_IP_PROTOCOL_LAST_NHf_SET(r,f) field32_set((r).fp_tcam,122,129,f)
#define FP_TCAMm_F2_1_IP_PROTOCOL_LAST_NHf_GET(r) field32_get((r).fp_tcam,122,129)
#define FP_TCAMm_F2_1_IP_PROTOCOL_LAST_NHf_SET(r,f) field32_set((r).fp_tcam,122,129,f)
#define FP_TCAMm_F2_10_DIP_127_64f_GET(r,a) field_get((r).fp_tcam,130,193,a)
#define FP_TCAMm_F2_10_DIP_127_64f_SET(r,a) field_set((r).fp_tcam,130,193,a)
#define FP_TCAMm_F2_4_DIP_127_64f_GET(r,a) field_get((r).fp_tcam,130,193,a)
#define FP_TCAMm_F2_4_DIP_127_64f_SET(r,a) field_set((r).fp_tcam,130,193,a)
#define FP_TCAMm_F2_0_DIPf_GET(r) field32_get((r).fp_tcam,130,161)
#define FP_TCAMm_F2_0_DIPf_SET(r,f) field32_set((r).fp_tcam,130,161,f)
#define FP_TCAMm_F2_1_DIPf_GET(r) field32_get((r).fp_tcam,130,161)
#define FP_TCAMm_F2_1_DIPf_SET(r,f) field32_set((r).fp_tcam,130,161,f)
#define FP_TCAMm_DWF2_0_SIPf_GET(r) field32_get((r).fp_tcam,138,169)
#define FP_TCAMm_DWF2_0_SIPf_SET(r,f) field32_set((r).fp_tcam,138,169,f)
#define FP_TCAMm_DWF2_0_SIP_MASKf_GET(r) field32_get((r).fp_tcam,138,169)
#define FP_TCAMm_DWF2_0_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,138,169,f)
#define FP_TCAMm_F2_11_DAf_GET(r,a) field_get((r).fp_tcam,146,193,a)
#define FP_TCAMm_F2_11_DAf_SET(r,a) field_set((r).fp_tcam,146,193,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACDAf_GET(r,a) field_get((r).fp_tcam,146,193,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACDAf_SET(r,a) field_set((r).fp_tcam,146,193,a)
#define FP_TCAMm_F2_5_DAf_GET(r,a) field_get((r).fp_tcam,146,193,a)
#define FP_TCAMm_F2_5_DAf_SET(r,a) field_set((r).fp_tcam,146,193,a)
#define FP_TCAMm_F2_7_DAf_GET(r,a) field_get((r).fp_tcam,146,193,a)
#define FP_TCAMm_F2_7_DAf_SET(r,a) field_set((r).fp_tcam,146,193,a)
#define FP_TCAMm_F2_14_PAYLOAD_SIPf_GET(r) field32_get((r).fp_tcam,146,177)
#define FP_TCAMm_F2_14_PAYLOAD_SIPf_SET(r,f) field32_set((r).fp_tcam,146,177,f)
#define FP_TCAMm_F2_6_SIPf_GET(r) field32_get((r).fp_tcam,146,177)
#define FP_TCAMm_F2_6_SIPf_SET(r,f) field32_set((r).fp_tcam,146,177,f)
#define FP_TCAMm_DWF2_5_SPAREf_GET(r) field32_get((r).fp_tcam,154,169)
#define FP_TCAMm_DWF2_5_SPAREf_SET(r,f) field32_set((r).fp_tcam,154,169,f)
#define FP_TCAMm_DWF2_5_SPARE_MASKf_GET(r) field32_get((r).fp_tcam,154,169)
#define FP_TCAMm_DWF2_5_SPARE_MASKf_SET(r,f) field32_set((r).fp_tcam,154,169,f)
#define FP_TCAMm_F2_0_SIPf_GET(r) field32_get((r).fp_tcam,162,193)
#define FP_TCAMm_F2_0_SIPf_SET(r,f) field32_set((r).fp_tcam,162,193,f)
#define FP_TCAMm_F2_1_SIPf_GET(r) field32_get((r).fp_tcam,162,193)
#define FP_TCAMm_F2_1_SIPf_SET(r,f) field32_set((r).fp_tcam,162,193,f)
#define FP_TCAMm_F2_12_MIML_TAGf_GET(r) ((((r).fp_tcam[5]) >> 2) & 0xffff)
#define FP_TCAMm_F2_12_MIML_TAGf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xffff << 2)) | ((((uint32)f) & 0xffff) << 2))
#define FP_TCAMm_DWF1f_GET(r,a) field_get((r).fp_tcam,170,235,a)
#define FP_TCAMm_DWF1f_SET(r,a) field_set((r).fp_tcam,170,235,a)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_DSTf_GET(r) ((((r).fp_tcam[5]) >> 10) & 0xffff)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_DSTf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xffff << 10)) | ((((uint32)f) & 0xffff) << 10))
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_DST_MASKf_GET(r) ((((r).fp_tcam[5]) >> 10) & 0xffff)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_DST_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xffff << 10)) | ((((uint32)f) & 0xffff) << 10))
#define FP_TCAMm_DWF1_0_TTL_FN1f_GET(r) ((((r).fp_tcam[5]) >> 10) & 0xff)
#define FP_TCAMm_DWF1_0_TTL_FN1f_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xff << 10)) | ((((uint32)f) & 0xff) << 10))
#define FP_TCAMm_DWF1_0_TTL_FN1_MASKf_GET(r) ((((r).fp_tcam[5]) >> 10) & 0xff)
#define FP_TCAMm_DWF1_0_TTL_FN1_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0xff << 10)) | ((((uint32)f) & 0xff) << 10))
#define FP_TCAMm_F2_12_SPAREf_GET(r) field32_get((r).fp_tcam,178,193)
#define FP_TCAMm_F2_12_SPAREf_SET(r,f) field32_set((r).fp_tcam,178,193,f)
#define FP_TCAMm_F2_14_SPAREf_GET(r) field32_get((r).fp_tcam,178,193)
#define FP_TCAMm_F2_14_SPAREf_SET(r,f) field32_set((r).fp_tcam,178,193,f)
#define FP_TCAMm_F2_6_SPAREf_GET(r) field32_get((r).fp_tcam,178,193)
#define FP_TCAMm_F2_6_SPAREf_SET(r,f) field32_set((r).fp_tcam,178,193,f)
#define FP_TCAMm_DWF1_0_IP_FRAG_INFOf_GET(r) ((((r).fp_tcam[5]) >> 18) & 0x3)
#define FP_TCAMm_DWF1_0_IP_FRAG_INFOf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define FP_TCAMm_DWF1_0_IP_FRAG_INFO_MASKf_GET(r) ((((r).fp_tcam[5]) >> 18) & 0x3)
#define FP_TCAMm_DWF1_0_IP_FRAG_INFO_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define FP_TCAMm_DWF1_0_L4_DSTf_GET(r) field32_get((r).fp_tcam,180,195)
#define FP_TCAMm_DWF1_0_L4_DSTf_SET(r,f) field32_set((r).fp_tcam,180,195,f)
#define FP_TCAMm_DWF1_0_L4_DST_MASKf_GET(r) field32_get((r).fp_tcam,180,195)
#define FP_TCAMm_DWF1_0_L4_DST_MASKf_SET(r,f) field32_set((r).fp_tcam,180,195,f)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_SRCf_GET(r) field32_get((r).fp_tcam,186,201)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_SRCf_SET(r,f) field32_set((r).fp_tcam,186,201,f)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_SRC_MASKf_GET(r) field32_get((r).fp_tcam,186,201)
#define FP_TCAMm_DWF1_1_PAYLOAD_L4_SRC_MASKf_SET(r,f) field32_set((r).fp_tcam,186,201,f)
#define FP_TCAMm_F1f_GET(r,a) field_get((r).fp_tcam,194,230,a)
#define FP_TCAMm_F1f_SET(r,a) field_set((r).fp_tcam,194,230,a)
#define FP_TCAMm_F1_13_AUX_TAG_1f_GET(r) field32_get((r).fp_tcam,194,225)
#define FP_TCAMm_F1_13_AUX_TAG_1f_SET(r,f) field32_set((r).fp_tcam,194,225,f)
#define FP_TCAMm_F1_9_UDF1_31_0f_GET(r) field32_get((r).fp_tcam,194,225)
#define FP_TCAMm_F1_9_UDF1_31_0f_SET(r,f) field32_set((r).fp_tcam,194,225,f)
#define FP_TCAMm_F1_3_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0xffff)
#define FP_TCAMm_F1_3_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 2)) | ((((uint32)f) & 0xffff) << 2))
#define FP_TCAMm_F1_4_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0xffff)
#define FP_TCAMm_F1_4_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 2)) | ((((uint32)f) & 0xffff) << 2))
#define FP_TCAMm_F1_5_LOOKUP_STATUSf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0xffff)
#define FP_TCAMm_F1_5_LOOKUP_STATUSf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 2)) | ((((uint32)f) & 0xffff) << 2))
#define FP_TCAMm_F1_6_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0xffff)
#define FP_TCAMm_F1_6_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 2)) | ((((uint32)f) & 0xffff) << 2))
#define FP_TCAMm_F1_7_OUTER_VLAN_TAGf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0xffff)
#define FP_TCAMm_F1_7_OUTER_VLAN_TAGf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 2)) | ((((uint32)f) & 0xffff) << 2))
#define FP_TCAMm_F1_10_D_FIELDf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0x7fff)
#define FP_TCAMm_F1_10_D_FIELDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7fff << 2)) | ((((uint32)f) & 0x7fff) << 2))
#define FP_TCAMm_F1_11_SGLPf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0x7fff)
#define FP_TCAMm_F1_11_SGLPf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7fff << 2)) | ((((uint32)f) & 0x7fff) << 2))
#define FP_TCAMm_F1_1_D_FIELDf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0x7fff)
#define FP_TCAMm_F1_1_D_FIELDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7fff << 2)) | ((((uint32)f) & 0x7fff) << 2))
#define FP_TCAMm_F1_2_D_FIELDf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0x7fff)
#define FP_TCAMm_F1_2_D_FIELDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7fff << 2)) | ((((uint32)f) & 0x7fff) << 2))
#define FP_TCAMm_F1_0_CLASSIDSf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0xfff)
#define FP_TCAMm_F1_0_CLASSIDSf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xfff << 2)) | ((((uint32)f) & 0xfff) << 2))
#define FP_TCAMm_F1_12_OUTER_VLAN_IDf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0xfff)
#define FP_TCAMm_F1_12_OUTER_VLAN_IDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xfff << 2)) | ((((uint32)f) & 0xfff) << 2))
#define FP_TCAMm_F1_8_IP_PROTOCOL_LAST_NHf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0xff)
#define FP_TCAMm_F1_8_IP_PROTOCOL_LAST_NHf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define FP_TCAMm_DWF1_0_L4_SRCf_GET(r) ((((r).fp_tcam[6]) >> 4) & 0xffff)
#define FP_TCAMm_DWF1_0_L4_SRCf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 4)) | ((((uint32)f) & 0xffff) << 4))
#define FP_TCAMm_DWF1_0_L4_SRC_MASKf_GET(r) ((((r).fp_tcam[6]) >> 4) & 0xffff)
#define FP_TCAMm_DWF1_0_L4_SRC_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xffff << 4)) | ((((uint32)f) & 0xffff) << 4))
#define FP_TCAMm_DWF1_1_PAYLOAD_TOS_FNf_GET(r) ((((r).fp_tcam[6]) >> 10) & 0xff)
#define FP_TCAMm_DWF1_1_PAYLOAD_TOS_FNf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 10)) | ((((uint32)f) & 0xff) << 10))
#define FP_TCAMm_DWF1_1_PAYLOAD_TOS_FN_MASKf_GET(r) ((((r).fp_tcam[6]) >> 10) & 0xff)
#define FP_TCAMm_DWF1_1_PAYLOAD_TOS_FN_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 10)) | ((((uint32)f) & 0xff) << 10))
#define FP_TCAMm_F1_8_TOS_FNf_GET(r) ((((r).fp_tcam[6]) >> 10) & 0xff)
#define FP_TCAMm_F1_8_TOS_FNf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 10)) | ((((uint32)f) & 0xff) << 10))
#define FP_TCAMm_F1_0_FORWARDING_FIELDf_GET(r) ((((r).fp_tcam[6]) >> 14) & 0xfff)
#define FP_TCAMm_F1_0_FORWARDING_FIELDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xfff << 14)) | ((((uint32)f) & 0xfff) << 14))
#define FP_TCAMm_F1_12_CLASSIDSf_GET(r) ((((r).fp_tcam[6]) >> 14) & 0xfff)
#define FP_TCAMm_F1_12_CLASSIDSf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xfff << 14)) | ((((uint32)f) & 0xfff) << 14))
#define FP_TCAMm_F1_11_SVPf_GET(r) ((((r).fp_tcam[6]) >> 17) & 0x1fff)
#define FP_TCAMm_F1_11_SVPf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x1fff << 17)) | ((((uint32)f) & 0x1fff) << 17))
#define FP_TCAMm_F1_10_D_TYPEf_GET(r) ((((r).fp_tcam[6]) >> 17) & 0x7)
#define FP_TCAMm_F1_10_D_TYPEf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7 << 17)) | ((((uint32)f) & 0x7) << 17))
#define FP_TCAMm_F1_1_D_TYPEf_GET(r) ((((r).fp_tcam[6]) >> 17) & 0x7)
#define FP_TCAMm_F1_1_D_TYPEf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7 << 17)) | ((((uint32)f) & 0x7) << 17))
#define FP_TCAMm_F1_2_D_TYPEf_GET(r) ((((r).fp_tcam[6]) >> 17) & 0x7)
#define FP_TCAMm_F1_2_D_TYPEf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7 << 17)) | ((((uint32)f) & 0x7) << 17))
#define FP_TCAMm_F1_3_INNER_VLAN_TAGf_GET(r) field32_get((r).fp_tcam,210,225)
#define FP_TCAMm_F1_3_INNER_VLAN_TAGf_SET(r,f) field32_set((r).fp_tcam,210,225,f)
#define FP_TCAMm_F1_4_ETHERTYPEf_GET(r) field32_get((r).fp_tcam,210,225)
#define FP_TCAMm_F1_4_ETHERTYPEf_SET(r,f) field32_set((r).fp_tcam,210,225,f)
#define FP_TCAMm_F1_5_INNER_VLAN_TAGf_GET(r) field32_get((r).fp_tcam,210,225)
#define FP_TCAMm_F1_5_INNER_VLAN_TAGf_SET(r,f) field32_set((r).fp_tcam,210,225,f)
#define FP_TCAMm_DWF1_1_PAYLOAD_IP_PROTOCOL_LAST_NHf_GET(r) ((((r).fp_tcam[6]) >> 18) & 0xff)
#define FP_TCAMm_DWF1_1_PAYLOAD_IP_PROTOCOL_LAST_NHf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 18)) | ((((uint32)f) & 0xff) << 18))
#define FP_TCAMm_DWF1_1_PAYLOAD_IP_PROTOCOL_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[6]) >> 18) & 0xff)
#define FP_TCAMm_DWF1_1_PAYLOAD_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xff << 18)) | ((((uint32)f) & 0xff) << 18))
#define FP_TCAMm_F1_7_CLASSIDS_11_6f_GET(r) ((((r).fp_tcam[6]) >> 18) & 0x3f)
#define FP_TCAMm_F1_7_CLASSIDS_11_6f_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))
#define FP_TCAMm_F1_8_CLASSIDS_11_6f_GET(r) ((((r).fp_tcam[6]) >> 18) & 0x3f)
#define FP_TCAMm_F1_8_CLASSIDS_11_6f_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))
#define FP_TCAMm_F1_6_PACKET_FORMATf_GET(r) ((((r).fp_tcam[6]) >> 18) & 0xf)
#define FP_TCAMm_F1_6_PACKET_FORMATf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0xf << 18)) | ((((uint32)f) & 0xf) << 18))
#define FP_TCAMm_DWF1_0_D_FIELDf_GET(r) field32_get((r).fp_tcam,212,226)
#define FP_TCAMm_DWF1_0_D_FIELDf_SET(r,f) field32_set((r).fp_tcam,212,226,f)
#define FP_TCAMm_DWF1_0_D_FIELD_MASKf_GET(r) field32_get((r).fp_tcam,212,226)
#define FP_TCAMm_DWF1_0_D_FIELD_MASKf_SET(r,f) field32_set((r).fp_tcam,212,226,f)
#define FP_TCAMm_F1_10_DGLPf_GET(r) field32_get((r).fp_tcam,212,226)
#define FP_TCAMm_F1_10_DGLPf_SET(r,f) field32_set((r).fp_tcam,212,226,f)
#define FP_TCAMm_F1_1_S_FIELDf_GET(r) field32_get((r).fp_tcam,212,226)
#define FP_TCAMm_F1_1_S_FIELDf_SET(r,f) field32_set((r).fp_tcam,212,226,f)
#define FP_TCAMm_F1_2_MH_OPCODEf_GET(r) ((((r).fp_tcam[6]) >> 20) & 0x7)
#define FP_TCAMm_F1_2_MH_OPCODEf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7 << 20)) | ((((uint32)f) & 0x7) << 20))
#define FP_TCAMm_F1_6_SWITCHING_TAG_STATUSf_GET(r) ((((r).fp_tcam[6]) >> 22) & 0x3)
#define FP_TCAMm_F1_6_SWITCHING_TAG_STATUSf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define FP_TCAMm_F1_2_CLASSIDSf_GET(r) field32_get((r).fp_tcam,215,226)
#define FP_TCAMm_F1_2_CLASSIDSf_SET(r,f) field32_set((r).fp_tcam,215,226,f)
#define FP_TCAMm_F1_7_FORWARDING_FIELDf_GET(r) field32_get((r).fp_tcam,216,227)
#define FP_TCAMm_F1_7_FORWARDING_FIELDf_SET(r,f) field32_set((r).fp_tcam,216,227,f)
#define FP_TCAMm_F1_8_FORWARDING_FIELDf_GET(r) field32_get((r).fp_tcam,216,227)
#define FP_TCAMm_F1_8_FORWARDING_FIELDf_SET(r,f) field32_set((r).fp_tcam,216,227,f)
#define FP_TCAMm_F1_6_MH_OPCODEf_GET(r) ((((r).fp_tcam[6]) >> 24) & 0x7)
#define FP_TCAMm_F1_6_MH_OPCODEf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define FP_TCAMm_DWF1_1_SPAREf_GET(r) field32_get((r).fp_tcam,218,235)
#define FP_TCAMm_DWF1_1_SPAREf_SET(r,f) field32_set((r).fp_tcam,218,235,f)
#define FP_TCAMm_DWF1_1_SPARE_MASKf_GET(r) field32_get((r).fp_tcam,218,235)
#define FP_TCAMm_DWF1_1_SPARE_MASKf_SET(r,f) field32_set((r).fp_tcam,218,235,f)
#define FP_TCAMm_F1_0_SVP_L3_IIFf_GET(r) field32_get((r).fp_tcam,218,230)
#define FP_TCAMm_F1_0_SVP_L3_IIFf_SET(r,f) field32_set((r).fp_tcam,218,230,f)
#define FP_TCAMm_F1_12_SVPf_GET(r) field32_get((r).fp_tcam,218,230)
#define FP_TCAMm_F1_12_SVPf_SET(r,f) field32_set((r).fp_tcam,218,230,f)
#define FP_TCAMm_F1_6_PKT_RESOLUTIONf_GET(r) ((((r).fp_tcam[6]) >> 27) & 0x1f)
#define FP_TCAMm_F1_6_PKT_RESOLUTIONf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x1f << 27)) | ((((uint32)f) & 0x1f) << 27))
#define FP_TCAMm_F1_11_SVP_VALIDf_GET(r) ((((r).fp_tcam[6]) >> 30) & 0x1)
#define FP_TCAMm_F1_11_SVP_VALIDf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define FP_TCAMm_F1_11_SPAREf_GET(r) field32_get((r).fp_tcam,223,230)
#define FP_TCAMm_F1_11_SPAREf_SET(r,f) field32_set((r).fp_tcam,223,230,f)
#define FP_TCAMm_F1_6_IP_INFOf_GET(r) (((r).fp_tcam[7]) & 0x7)
#define FP_TCAMm_F1_6_IP_INFOf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define FP_TCAMm_F1_4_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 2) & 0x1f)
#define FP_TCAMm_F1_4_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1f << 2)) | ((((uint32)f) & 0x1f) << 2))
#define FP_TCAMm_F1_3_OUTER_TPID_ENCODEf_GET(r) ((((r).fp_tcam[7]) >> 2) & 0x3)
#define FP_TCAMm_F1_3_OUTER_TPID_ENCODEf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define FP_TCAMm_F1_5_INNER_TPID_ENCODEf_GET(r) ((((r).fp_tcam[7]) >> 2) & 0x3)
#define FP_TCAMm_F1_5_INNER_TPID_ENCODEf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define FP_TCAMm_F1_9_MPLS_INFOf_GET(r) ((((r).fp_tcam[7]) >> 2) & 0x3)
#define FP_TCAMm_F1_9_MPLS_INFOf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define FP_TCAMm_F1_13_AUX_TAG_VALID_1f_GET(r) ((((r).fp_tcam[7]) >> 2) & 0x1)
#define FP_TCAMm_F1_13_AUX_TAG_VALID_1f_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_TCAMm_F1_10_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 3) & 0xf)
#define FP_TCAMm_F1_10_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xf << 3)) | ((((uint32)f) & 0xf) << 3))
#define FP_TCAMm_F1_13_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 3) & 0xf)
#define FP_TCAMm_F1_13_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xf << 3)) | ((((uint32)f) & 0xf) << 3))
#define FP_TCAMm_F1_2_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 3) & 0xf)
#define FP_TCAMm_F1_2_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xf << 3)) | ((((uint32)f) & 0xf) << 3))
#define FP_TCAMm_F1_6_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 3) & 0xf)
#define FP_TCAMm_F1_6_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xf << 3)) | ((((uint32)f) & 0xf) << 3))
#define FP_TCAMm_DWF1_0_D_TYPEf_GET(r) ((((r).fp_tcam[7]) >> 3) & 0x7)
#define FP_TCAMm_DWF1_0_D_TYPEf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define FP_TCAMm_DWF1_0_D_TYPE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 3) & 0x7)
#define FP_TCAMm_DWF1_0_D_TYPE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define FP_TCAMm_F1_1_SVP_VALIDf_GET(r) ((((r).fp_tcam[7]) >> 3) & 0x1)
#define FP_TCAMm_F1_1_SVP_VALIDf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define FP_TCAMm_F1_1_MH_OPCODEf_GET(r) ((((r).fp_tcam[7]) >> 4) & 0x7)
#define FP_TCAMm_F1_1_MH_OPCODEf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_TCAMm_F1_3_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 4) & 0x7)
#define FP_TCAMm_F1_3_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_TCAMm_F1_5_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 4) & 0x7)
#define FP_TCAMm_F1_5_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_TCAMm_F1_9_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 4) & 0x7)
#define FP_TCAMm_F1_9_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define FP_TCAMm_F1_7_MPLS_INFOf_GET(r) ((((r).fp_tcam[7]) >> 4) & 0x3)
#define FP_TCAMm_F1_7_MPLS_INFOf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define FP_TCAMm_F1_8_INT_CNf_GET(r) ((((r).fp_tcam[7]) >> 4) & 0x3)
#define FP_TCAMm_F1_8_INT_CNf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define FP_TCAMm_DWF1_0_INT_CNf_GET(r) ((((r).fp_tcam[7]) >> 6) & 0x3)
#define FP_TCAMm_DWF1_0_INT_CNf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define FP_TCAMm_DWF1_0_INT_CN_MASKf_GET(r) ((((r).fp_tcam[7]) >> 6) & 0x3)
#define FP_TCAMm_DWF1_0_INT_CN_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define FP_TCAMm_F1_7_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 6) & 0x1)
#define FP_TCAMm_F1_7_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define FP_TCAMm_F1_8_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 6) & 0x1)
#define FP_TCAMm_F1_8_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define FP_TCAMm_RESERVEDf_GET(r) ((((r).fp_tcam[7]) >> 7) & 0x1f)
#define FP_TCAMm_RESERVEDf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1f << 7)) | ((((uint32)f) & 0x1f) << 7))
#define FP_TCAMm_DWF1_0_SPAREf_GET(r) ((((r).fp_tcam[7]) >> 8) & 0xf)
#define FP_TCAMm_DWF1_0_SPAREf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define FP_TCAMm_DWF1_0_SPARE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 8) & 0xf)
#define FP_TCAMm_DWF1_0_SPARE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define FP_TCAMm_FULL_MASKf_GET(r,a) field_get((r).fp_tcam,236,469,a)
#define FP_TCAMm_FULL_MASKf_SET(r,a) field_set((r).fp_tcam,236,469,a)
#define FP_TCAMm_DOUBLE_WIDE_MODE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 12) & 0x1)
#define FP_TCAMm_DOUBLE_WIDE_MODE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_TCAMm_DW_DOUBLE_WIDE_MODE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 12) & 0x1)
#define FP_TCAMm_DW_DOUBLE_WIDE_MODE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_TCAMm_DATA_MASKf_GET(r,a) field_get((r).fp_tcam,237,469,a)
#define FP_TCAMm_DATA_MASKf_SET(r,a) field_set((r).fp_tcam,237,469,a)
#define FP_TCAMm_DWF4_MASKf_GET(r) ((((r).fp_tcam[7]) >> 13) & 0x7f)
#define FP_TCAMm_DWF4_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7f << 13)) | ((((uint32)f) & 0x7f) << 13))
#define FP_TCAMm_F4_MASKf_GET(r) ((((r).fp_tcam[7]) >> 13) & 0x7f)
#define FP_TCAMm_F4_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7f << 13)) | ((((uint32)f) & 0x7f) << 13))
#define FP_TCAMm_DWF3_MASKf_GET(r) field32_get((r).fp_tcam,244,275)
#define FP_TCAMm_DWF3_MASKf_SET(r,f) field32_set((r).fp_tcam,244,275,f)
#define FP_TCAMm_FIXED_MASKf_GET(r) field32_get((r).fp_tcam,244,262)
#define FP_TCAMm_FIXED_MASKf_SET(r,f) field32_set((r).fp_tcam,244,262,f)
#define FP_TCAMm_FIXED_HIGIG_MASKf_GET(r) ((((r).fp_tcam[7]) >> 20) & 0x1)
#define FP_TCAMm_FIXED_HIGIG_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_TCAMm_FIXED_FORWARDING_TYPE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 21) & 0x7)
#define FP_TCAMm_FIXED_FORWARDING_TYPE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x7 << 21)) | ((((uint32)f) & 0x7) << 21))
#define FP_TCAMm_FIXED_SVP_OR_L3IIF_MASKf_GET(r) ((((r).fp_tcam[7]) >> 24) & 0x1)
#define FP_TCAMm_FIXED_SVP_OR_L3IIF_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define FP_TCAMm_FIXED_L3_TYPE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 25) & 0xf)
#define FP_TCAMm_FIXED_L3_TYPE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0xf << 25)) | ((((uint32)f) & 0xf) << 25))
#define FP_TCAMm_FIXED_L4_VALID_MASKf_GET(r) ((((r).fp_tcam[7]) >> 29) & 0x1)
#define FP_TCAMm_FIXED_L4_VALID_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define FP_TCAMm_FIXED_L3_ROUTABLE_MASKf_GET(r) ((((r).fp_tcam[7]) >> 30) & 0x1)
#define FP_TCAMm_FIXED_L3_ROUTABLE_MASKf_SET(r,f) (r).fp_tcam[7]=(((r).fp_tcam[7] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define FP_TCAMm_FIXED_TUNNEL_TYPE_LOOPBACK_TYPE_MASKf_GET(r) field32_get((r).fp_tcam,255,258)
#define FP_TCAMm_FIXED_TUNNEL_TYPE_LOOPBACK_TYPE_MASKf_SET(r,f) field32_set((r).fp_tcam,255,258,f)
#define FP_TCAMm_FIXED_DROP_MASKf_GET(r) ((((r).fp_tcam[8]) >> 3) & 0x1)
#define FP_TCAMm_FIXED_DROP_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define FP_TCAMm_FIXED_MIRROR_ONLY_MASKf_GET(r) ((((r).fp_tcam[8]) >> 4) & 0x1)
#define FP_TCAMm_FIXED_MIRROR_ONLY_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define FP_TCAMm_FIXED_MIML_PRESENT_MASKf_GET(r) ((((r).fp_tcam[8]) >> 5) & 0x1)
#define FP_TCAMm_FIXED_MIML_PRESENT_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_TCAMm_FIXED_CUSTOM_HEADER_PRESENT_MASKf_GET(r) ((((r).fp_tcam[8]) >> 6) & 0x1)
#define FP_TCAMm_FIXED_CUSTOM_HEADER_PRESENT_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define FP_TCAMm_F3_MASKf_GET(r,a) field_get((r).fp_tcam,263,299,a)
#define FP_TCAMm_F3_MASKf_SET(r,a) field_set((r).fp_tcam,263,299,a)
#define FP_TCAMm_F3_12_AUX_TAG_2_MASKf_GET(r) field32_get((r).fp_tcam,263,294)
#define FP_TCAMm_F3_12_AUX_TAG_2_MASKf_SET(r,f) field32_set((r).fp_tcam,263,294,f)
#define FP_TCAMm_F3_9_UDF1_95_64_MASKf_GET(r) field32_get((r).fp_tcam,263,294)
#define FP_TCAMm_F3_9_UDF1_95_64_MASKf_SET(r,f) field32_set((r).fp_tcam,263,294,f)
#define FP_TCAMm_F3_7_RANGE_CHECK_RESULTS_MASKf_GET(r) ((((r).fp_tcam[8]) >> 7) & 0xffffff)
#define FP_TCAMm_F3_7_RANGE_CHECK_RESULTS_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xffffff << 7)) | ((((uint32)f) & 0xffffff) << 7))
#define FP_TCAMm_F3_8_IPV6_FL_MASKf_GET(r) ((((r).fp_tcam[8]) >> 7) & 0xfffff)
#define FP_TCAMm_F3_8_IPV6_FL_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xfffff << 7)) | ((((uint32)f) & 0xfffff) << 7))
#define FP_TCAMm_F3_3_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[8]) >> 7) & 0xffff)
#define FP_TCAMm_F3_3_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F3_4_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[8]) >> 7) & 0xffff)
#define FP_TCAMm_F3_4_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F3_5_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[8]) >> 7) & 0xffff)
#define FP_TCAMm_F3_5_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F3_6_LOOKUP_STATUS_MASKf_GET(r) ((((r).fp_tcam[8]) >> 7) & 0xffff)
#define FP_TCAMm_F3_6_LOOKUP_STATUS_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xffff << 7)) | ((((uint32)f) & 0xffff) << 7))
#define FP_TCAMm_F3_10_D_FIELD_MASKf_GET(r) ((((r).fp_tcam[8]) >> 7) & 0x7fff)
#define FP_TCAMm_F3_10_D_FIELD_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x7fff << 7)) | ((((uint32)f) & 0x7fff) << 7))
#define FP_TCAMm_F3_11_SGLP_MASKf_GET(r) ((((r).fp_tcam[8]) >> 7) & 0x7fff)
#define FP_TCAMm_F3_11_SGLP_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x7fff << 7)) | ((((uint32)f) & 0x7fff) << 7))
#define FP_TCAMm_F3_2_D_FIELD_MASKf_GET(r) ((((r).fp_tcam[8]) >> 7) & 0x7fff)
#define FP_TCAMm_F3_2_D_FIELD_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x7fff << 7)) | ((((uint32)f) & 0x7fff) << 7))
#define FP_TCAMm_F3_0_CLASSIDS_MASKf_GET(r) ((((r).fp_tcam[8]) >> 7) & 0xfff)
#define FP_TCAMm_F3_0_CLASSIDS_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xfff << 7)) | ((((uint32)f) & 0xfff) << 7))
#define FP_TCAMm_F3_1_CLASSIDS_MASKf_GET(r) ((((r).fp_tcam[8]) >> 7) & 0xfff)
#define FP_TCAMm_F3_1_CLASSIDS_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xfff << 7)) | ((((uint32)f) & 0xfff) << 7))
#define FP_TCAMm_F3_0_FORWARDING_FIELD_MASKf_GET(r) ((((r).fp_tcam[8]) >> 19) & 0xfff)
#define FP_TCAMm_F3_0_FORWARDING_FIELD_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xfff << 19)) | ((((uint32)f) & 0xfff) << 19))
#define FP_TCAMm_F3_1_FORWARDING_FIELD_MASKf_GET(r) ((((r).fp_tcam[8]) >> 19) & 0xfff)
#define FP_TCAMm_F3_1_FORWARDING_FIELD_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xfff << 19)) | ((((uint32)f) & 0xfff) << 19))
#define FP_TCAMm_DWF2_MASKf_GET(r,a) field_get((r).fp_tcam,276,403,a)
#define FP_TCAMm_DWF2_MASKf_SET(r,a) field_set((r).fp_tcam,276,403,a)
#define FP_TCAMm_F3_11_SVP_MASKf_GET(r) field32_get((r).fp_tcam,278,290)
#define FP_TCAMm_F3_11_SVP_MASKf_SET(r,f) field32_set((r).fp_tcam,278,290,f)
#define FP_TCAMm_F3_10_D_TYPE_MASKf_GET(r) ((((r).fp_tcam[8]) >> 22) & 0x7)
#define FP_TCAMm_F3_10_D_TYPE_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x7 << 22)) | ((((uint32)f) & 0x7) << 22))
#define FP_TCAMm_F3_2_D_TYPE_MASKf_GET(r) ((((r).fp_tcam[8]) >> 22) & 0x7)
#define FP_TCAMm_F3_2_D_TYPE_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x7 << 22)) | ((((uint32)f) & 0x7) << 22))
#define FP_TCAMm_F3_4_INNER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,279,294)
#define FP_TCAMm_F3_4_INNER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,279,294,f)
#define FP_TCAMm_F3_5_ETHERTYPE_MASKf_GET(r) field32_get((r).fp_tcam,279,294)
#define FP_TCAMm_F3_5_ETHERTYPE_MASKf_SET(r,f) field32_set((r).fp_tcam,279,294,f)
#define FP_TCAMm_F3_6_INNER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,279,294)
#define FP_TCAMm_F3_6_INNER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,279,294,f)
#define FP_TCAMm_F3_3_PACKET_FORMAT_MASKf_GET(r) ((((r).fp_tcam[8]) >> 23) & 0xf)
#define FP_TCAMm_F3_3_PACKET_FORMAT_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xf << 23)) | ((((uint32)f) & 0xf) << 23))
#define FP_TCAMm_F3_10_DGLP_MASKf_GET(r) field32_get((r).fp_tcam,281,295)
#define FP_TCAMm_F3_10_DGLP_MASKf_SET(r,f) field32_set((r).fp_tcam,281,295,f)
#define FP_TCAMm_F3_2_S_FIELD_MASKf_GET(r) field32_get((r).fp_tcam,281,295)
#define FP_TCAMm_F3_2_S_FIELD_MASKf_SET(r,f) field32_set((r).fp_tcam,281,295,f)
#define FP_TCAMm_F3_8_PACKET_FORMAT_MASKf_GET(r) ((((r).fp_tcam[8]) >> 27) & 0xf)
#define FP_TCAMm_F3_8_PACKET_FORMAT_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0xf << 27)) | ((((uint32)f) & 0xf) << 27))
#define FP_TCAMm_F3_3_SWITCHING_TAG_STATUS_MASKf_GET(r) ((((r).fp_tcam[8]) >> 27) & 0x3)
#define FP_TCAMm_F3_3_SWITCHING_TAG_STATUS_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x3 << 27)) | ((((uint32)f) & 0x3) << 27))
#define FP_TCAMm_F3_3_MH_OPCODE_MASKf_GET(r) ((((r).fp_tcam[8]) >> 29) & 0x7)
#define FP_TCAMm_F3_3_MH_OPCODE_MASKf_SET(r,f) (r).fp_tcam[8]=(((r).fp_tcam[8] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))
#define FP_TCAMm_F3_0_SVP_L3IIF_OVERLAY_MASKf_GET(r) field32_get((r).fp_tcam,287,299)
#define FP_TCAMm_F3_0_SVP_L3IIF_OVERLAY_MASKf_SET(r,f) field32_set((r).fp_tcam,287,299,f)
#define FP_TCAMm_F3_1_OUTER_VLAN_ID_MASKf_GET(r) field32_get((r).fp_tcam,287,298)
#define FP_TCAMm_F3_1_OUTER_VLAN_ID_MASKf_SET(r,f) field32_set((r).fp_tcam,287,298,f)
#define FP_TCAMm_F3_7_INTERFACE_CLASSID_MASKf_GET(r) field32_get((r).fp_tcam,287,294)
#define FP_TCAMm_F3_7_INTERFACE_CLASSID_MASKf_SET(r,f) field32_set((r).fp_tcam,287,294,f)
#define FP_TCAMm_F3_8_SWITCHING_TAG_STATUS_MASKf_GET(r) field32_get((r).fp_tcam,287,288)
#define FP_TCAMm_F3_8_SWITCHING_TAG_STATUS_MASKf_SET(r,f) field32_set((r).fp_tcam,287,288,f)
#define FP_TCAMm_F3_3_PKT_RESOLUTION_MASKf_GET(r) (((r).fp_tcam[9]) & 0x1f)
#define FP_TCAMm_F3_3_PKT_RESOLUTION_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))
#define FP_TCAMm_F3_8_INNER_TPID_ENCODE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 1) & 0x3)
#define FP_TCAMm_F3_8_INNER_TPID_ENCODE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3 << 1)) | ((((uint32)f) & 0x3) << 1))
#define FP_TCAMm_F3_8_OUTER_TPID_ENCODE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 3) & 0x3)
#define FP_TCAMm_F3_8_OUTER_TPID_ENCODE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3 << 3)) | ((((uint32)f) & 0x3) << 3))
#define FP_TCAMm_F3_11_SVP_VALID_MASKf_GET(r) ((((r).fp_tcam[9]) >> 3) & 0x1)
#define FP_TCAMm_F3_11_SVP_VALID_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define FP_TCAMm_F3_11_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 4) & 0xff)
#define FP_TCAMm_F3_11_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xff << 4)) | ((((uint32)f) & 0xff) << 4))
#define FP_TCAMm_F3_8_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 5) & 0x7f)
#define FP_TCAMm_F3_8_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7f << 5)) | ((((uint32)f) & 0x7f) << 5))
#define FP_TCAMm_F3_3_IP_INFO_MASKf_GET(r) ((((r).fp_tcam[9]) >> 5) & 0x7)
#define FP_TCAMm_F3_3_IP_INFO_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7 << 5)) | ((((uint32)f) & 0x7) << 5))
#define FP_TCAMm_F3_4_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 7) & 0x1f)
#define FP_TCAMm_F3_4_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1f << 7)) | ((((uint32)f) & 0x1f) << 7))
#define FP_TCAMm_F3_5_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 7) & 0x1f)
#define FP_TCAMm_F3_5_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1f << 7)) | ((((uint32)f) & 0x1f) << 7))
#define FP_TCAMm_F3_6_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 7) & 0x1f)
#define FP_TCAMm_F3_6_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1f << 7)) | ((((uint32)f) & 0x1f) << 7))
#define FP_TCAMm_F3_7_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 7) & 0x1f)
#define FP_TCAMm_F3_7_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1f << 7)) | ((((uint32)f) & 0x1f) << 7))
#define FP_TCAMm_F3_9_MPLS_INFO_MASKf_GET(r) ((((r).fp_tcam[9]) >> 7) & 0x3)
#define FP_TCAMm_F3_9_MPLS_INFO_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define FP_TCAMm_F3_12_AUX_TAG_VALID_2_MASKf_GET(r) ((((r).fp_tcam[9]) >> 7) & 0x1)
#define FP_TCAMm_F3_12_AUX_TAG_VALID_2_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define FP_TCAMm_F3_10_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 8) & 0xf)
#define FP_TCAMm_F3_10_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define FP_TCAMm_F3_12_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 8) & 0xf)
#define FP_TCAMm_F3_12_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define FP_TCAMm_F3_3_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 8) & 0xf)
#define FP_TCAMm_F3_3_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define FP_TCAMm_F3_2_SVP_VALID_MASKf_GET(r) ((((r).fp_tcam[9]) >> 8) & 0x1)
#define FP_TCAMm_F3_2_SVP_VALID_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_TCAMm_F3_2_MH_OPCODE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 9) & 0x7)
#define FP_TCAMm_F3_2_MH_OPCODE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define FP_TCAMm_F3_9_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 9) & 0x7)
#define FP_TCAMm_F3_9_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define FP_TCAMm_F3_1_SPARE_MASKf_GET(r) ((((r).fp_tcam[9]) >> 11) & 0x1)
#define FP_TCAMm_F3_1_SPARE_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define FP_TCAMm_F2_15_PAYLOAD_SIP_MASKf_GET(r,a) field_get((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_15_PAYLOAD_SIP_MASKf_SET(r,a) field_set((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_16_PAYLOAD_DIP_MASKf_GET(r,a) field_get((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_16_PAYLOAD_DIP_MASKf_SET(r,a) field_set((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_2_SIP_MASKf_GET(r,a) field_get((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_2_SIP_MASKf_SET(r,a) field_set((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_3_DIP_MASKf_GET(r,a) field_get((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_3_DIP_MASKf_SET(r,a) field_set((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_8_UDF1_MASKf_GET(r,a) field_get((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_8_UDF1_MASKf_SET(r,a) field_set((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_9_UDF2_MASKf_GET(r,a) field_get((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_9_UDF2_MASKf_SET(r,a) field_set((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_MASKf_GET(r,a) field_get((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_MASKf_SET(r,a) field_set((r).fp_tcam,300,427,a)
#define FP_TCAMm_F2_10_SIP_127_64_MASKf_GET(r,a) field_get((r).fp_tcam,300,363,a)
#define FP_TCAMm_F2_10_SIP_127_64_MASKf_SET(r,a) field_set((r).fp_tcam,300,363,a)
#define FP_TCAMm_F2_12_MIML_SA_MASKf_GET(r,a) field_get((r).fp_tcam,300,347,a)
#define FP_TCAMm_F2_12_MIML_SA_MASKf_SET(r,a) field_set((r).fp_tcam,300,347,a)
#define FP_TCAMm_F2_11_DIP_127_96_MASKf_GET(r) field32_get((r).fp_tcam,300,331)
#define FP_TCAMm_F2_11_DIP_127_96_MASKf_SET(r,f) field32_set((r).fp_tcam,300,331,f)
#define FP_TCAMm_F2_13_PAYLOAD_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0xffff)
#define FP_TCAMm_F2_13_PAYLOAD_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F2_14_PAYLOAD_L4_DST_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0xffff)
#define FP_TCAMm_F2_14_PAYLOAD_L4_DST_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F2_5_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0xffff)
#define FP_TCAMm_F2_5_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F2_6_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0xffff)
#define FP_TCAMm_F2_6_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F2_7_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0xffff)
#define FP_TCAMm_F2_7_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F2_0_TTL_FN_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0xff)
#define FP_TCAMm_F2_0_TTL_FN_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xff << 12)) | ((((uint32)f) & 0xff) << 12))
#define FP_TCAMm_F2_1_TTL_FN_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0xff)
#define FP_TCAMm_F2_1_TTL_FN_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xff << 12)) | ((((uint32)f) & 0xff) << 12))
#define FP_TCAMm_F2_4_TTL_FN_MASKf_GET(r) ((((r).fp_tcam[9]) >> 12) & 0xff)
#define FP_TCAMm_F2_4_TTL_FN_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0xff << 12)) | ((((uint32)f) & 0xff) << 12))
#define FP_TCAMm_F2_0_TCP_FN_MASKf_GET(r) ((((r).fp_tcam[9]) >> 20) & 0x3f)
#define FP_TCAMm_F2_0_TCP_FN_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define FP_TCAMm_F2_1_TCP_FN_MASKf_GET(r) ((((r).fp_tcam[9]) >> 20) & 0x3f)
#define FP_TCAMm_F2_1_TCP_FN_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define FP_TCAMm_F2_4_TCP_FN_MASKf_GET(r) ((((r).fp_tcam[9]) >> 20) & 0x3f)
#define FP_TCAMm_F2_4_TCP_FN_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define FP_TCAMm_F2_4_IPV6_FL_MASKf_GET(r) field32_get((r).fp_tcam,314,333)
#define FP_TCAMm_F2_4_IPV6_FL_MASKf_SET(r,f) field32_set((r).fp_tcam,314,333,f)
#define FP_TCAMm_F2_0_IPFLAG_MASKf_GET(r) ((((r).fp_tcam[9]) >> 26) & 0x3)
#define FP_TCAMm_F2_0_IPFLAG_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define FP_TCAMm_F2_1_IP_FRAG_INFO_MASKf_GET(r) ((((r).fp_tcam[9]) >> 26) & 0x3)
#define FP_TCAMm_F2_1_IP_FRAG_INFO_MASKf_SET(r,f) (r).fp_tcam[9]=(((r).fp_tcam[9] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define FP_TCAMm_F2_13_PAYLOAD_ETHERTYPE_MASKf_GET(r) field32_get((r).fp_tcam,316,331)
#define FP_TCAMm_F2_13_PAYLOAD_ETHERTYPE_MASKf_SET(r,f) field32_set((r).fp_tcam,316,331,f)
#define FP_TCAMm_F2_14_PAYLOAD_L4_SRC_MASKf_GET(r) field32_get((r).fp_tcam,316,331)
#define FP_TCAMm_F2_14_PAYLOAD_L4_SRC_MASKf_SET(r,f) field32_set((r).fp_tcam,316,331,f)
#define FP_TCAMm_F2_5_ETHERTYPE_MASKf_GET(r) field32_get((r).fp_tcam,316,331)
#define FP_TCAMm_F2_5_ETHERTYPE_MASKf_SET(r,f) field32_set((r).fp_tcam,316,331,f)
#define FP_TCAMm_F2_6_ETHERTYPE_MASKf_GET(r) field32_get((r).fp_tcam,316,331)
#define FP_TCAMm_F2_6_ETHERTYPE_MASKf_SET(r,f) field32_set((r).fp_tcam,316,331,f)
#define FP_TCAMm_F2_7_ETHERTYPE_MASKf_GET(r) field32_get((r).fp_tcam,316,331)
#define FP_TCAMm_F2_7_ETHERTYPE_MASKf_SET(r,f) field32_set((r).fp_tcam,316,331,f)
#define FP_TCAMm_F2_0_TOS_FN_MASKf_GET(r) field32_get((r).fp_tcam,316,323)
#define FP_TCAMm_F2_0_TOS_FN_MASKf_SET(r,f) field32_set((r).fp_tcam,316,323,f)
#define FP_TCAMm_F2_1_TOS_FN_MASKf_GET(r) field32_get((r).fp_tcam,316,323)
#define FP_TCAMm_F2_1_TOS_FN_MASKf_SET(r,f) field32_set((r).fp_tcam,316,323,f)
#define FP_TCAMm_F2_0_L4_DST_MASKf_GET(r) ((((r).fp_tcam[10]) >> 4) & 0xffff)
#define FP_TCAMm_F2_0_L4_DST_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xffff << 4)) | ((((uint32)f) & 0xffff) << 4))
#define FP_TCAMm_F2_1_L4_DST_MASKf_GET(r) ((((r).fp_tcam[10]) >> 4) & 0xffff)
#define FP_TCAMm_F2_1_L4_DST_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xffff << 4)) | ((((uint32)f) & 0xffff) << 4))
#define FP_TCAMm_F2_11_SA_MASKf_GET(r,a) field_get((r).fp_tcam,332,379,a)
#define FP_TCAMm_F2_11_SA_MASKf_SET(r,a) field_set((r).fp_tcam,332,379,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACSA_MASKf_GET(r,a) field_get((r).fp_tcam,332,379,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACSA_MASKf_SET(r,a) field_set((r).fp_tcam,332,379,a)
#define FP_TCAMm_F2_5_SA_MASKf_GET(r,a) field_get((r).fp_tcam,332,379,a)
#define FP_TCAMm_F2_5_SA_MASKf_SET(r,a) field_set((r).fp_tcam,332,379,a)
#define FP_TCAMm_F2_6_SA_MASKf_GET(r,a) field_get((r).fp_tcam,332,379,a)
#define FP_TCAMm_F2_6_SA_MASKf_SET(r,a) field_set((r).fp_tcam,332,379,a)
#define FP_TCAMm_F2_14_PAYLOAD_TOS_FN_MASKf_GET(r) ((((r).fp_tcam[10]) >> 12) & 0xff)
#define FP_TCAMm_F2_14_PAYLOAD_TOS_FN_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xff << 12)) | ((((uint32)f) & 0xff) << 12))
#define FP_TCAMm_F2_7_TTL_FN_MASKf_GET(r) ((((r).fp_tcam[10]) >> 12) & 0xff)
#define FP_TCAMm_F2_7_TTL_FN_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xff << 12)) | ((((uint32)f) & 0xff) << 12))
#define FP_TCAMm_F2_4_TOS_FN_MASKf_GET(r) ((((r).fp_tcam[10]) >> 14) & 0xff)
#define FP_TCAMm_F2_4_TOS_FN_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xff << 14)) | ((((uint32)f) & 0xff) << 14))
#define FP_TCAMm_F2_0_L4_SRC_MASKf_GET(r) field32_get((r).fp_tcam,340,355)
#define FP_TCAMm_F2_0_L4_SRC_MASKf_SET(r,f) field32_set((r).fp_tcam,340,355,f)
#define FP_TCAMm_F2_1_L4_SRC_MASKf_GET(r) field32_get((r).fp_tcam,340,355)
#define FP_TCAMm_F2_1_L4_SRC_MASKf_SET(r,f) field32_set((r).fp_tcam,340,355,f)
#define FP_TCAMm_F2_14_PAYLOAD_IP_PROTOCOL_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[10]) >> 20) & 0xff)
#define FP_TCAMm_F2_14_PAYLOAD_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xff << 20)) | ((((uint32)f) & 0xff) << 20))
#define FP_TCAMm_F2_7_IP_PROTOCOL_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[10]) >> 20) & 0xff)
#define FP_TCAMm_F2_7_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xff << 20)) | ((((uint32)f) & 0xff) << 20))
#define FP_TCAMm_F2_4_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[10]) >> 22) & 0xff)
#define FP_TCAMm_F2_4_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0xff << 22)) | ((((uint32)f) & 0xff) << 22))
#define FP_TCAMm_F2_12_MIML_DA_MASKf_GET(r,a) field_get((r).fp_tcam,348,395,a)
#define FP_TCAMm_F2_12_MIML_DA_MASKf_SET(r,a) field_set((r).fp_tcam,348,395,a)
#define FP_TCAMm_F2_14_PAYLOAD_DIP_MASKf_GET(r) field32_get((r).fp_tcam,348,379)
#define FP_TCAMm_F2_14_PAYLOAD_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,348,379,f)
#define FP_TCAMm_F2_7_DIP_MASKf_GET(r) field32_get((r).fp_tcam,348,379)
#define FP_TCAMm_F2_7_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,348,379,f)
#define FP_TCAMm_F2_4_INT_CN_MASKf_GET(r) ((((r).fp_tcam[10]) >> 30) & 0x3)
#define FP_TCAMm_F2_4_INT_CN_MASKf_SET(r,f) (r).fp_tcam[10]=(((r).fp_tcam[10] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define FP_TCAMm_F2_4_SPARE_MASKf_GET(r) (((r).fp_tcam[11]) & 0xfff)
#define FP_TCAMm_F2_4_SPARE_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define FP_TCAMm_F2_0_IP_PROTOCOL_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[11]) >> 4) & 0xff)
#define FP_TCAMm_F2_0_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0xff << 4)) | ((((uint32)f) & 0xff) << 4))
#define FP_TCAMm_F2_1_IP_PROTOCOL_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[11]) >> 4) & 0xff)
#define FP_TCAMm_F2_1_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[11]=(((r).fp_tcam[11] & ~((uint32)0xff << 4)) | ((((uint32)f) & 0xff) << 4))
#define FP_TCAMm_F2_10_DIP_127_64_MASKf_GET(r,a) field_get((r).fp_tcam,364,427,a)
#define FP_TCAMm_F2_10_DIP_127_64_MASKf_SET(r,a) field_set((r).fp_tcam,364,427,a)
#define FP_TCAMm_F2_4_DIP_127_64_MASKf_GET(r,a) field_get((r).fp_tcam,364,427,a)
#define FP_TCAMm_F2_4_DIP_127_64_MASKf_SET(r,a) field_set((r).fp_tcam,364,427,a)
#define FP_TCAMm_F2_0_DIP_MASKf_GET(r) field32_get((r).fp_tcam,364,395)
#define FP_TCAMm_F2_0_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,364,395,f)
#define FP_TCAMm_F2_1_DIP_MASKf_GET(r) field32_get((r).fp_tcam,364,395)
#define FP_TCAMm_F2_1_DIP_MASKf_SET(r,f) field32_set((r).fp_tcam,364,395,f)
#define FP_TCAMm_F2_11_DA_MASKf_GET(r,a) field_get((r).fp_tcam,380,427,a)
#define FP_TCAMm_F2_11_DA_MASKf_SET(r,a) field_set((r).fp_tcam,380,427,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACDA_MASKf_GET(r,a) field_get((r).fp_tcam,380,427,a)
#define FP_TCAMm_F2_13_PAYLOAD_MACDA_MASKf_SET(r,a) field_set((r).fp_tcam,380,427,a)
#define FP_TCAMm_F2_5_DA_MASKf_GET(r,a) field_get((r).fp_tcam,380,427,a)
#define FP_TCAMm_F2_5_DA_MASKf_SET(r,a) field_set((r).fp_tcam,380,427,a)
#define FP_TCAMm_F2_7_DA_MASKf_GET(r,a) field_get((r).fp_tcam,380,427,a)
#define FP_TCAMm_F2_7_DA_MASKf_SET(r,a) field_set((r).fp_tcam,380,427,a)
#define FP_TCAMm_F2_14_PAYLOAD_SIP_MASKf_GET(r) field32_get((r).fp_tcam,380,411)
#define FP_TCAMm_F2_14_PAYLOAD_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,380,411,f)
#define FP_TCAMm_F2_6_SIP_MASKf_GET(r) field32_get((r).fp_tcam,380,411)
#define FP_TCAMm_F2_6_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,380,411,f)
#define FP_TCAMm_F2_0_SIP_MASKf_GET(r) field32_get((r).fp_tcam,396,427)
#define FP_TCAMm_F2_0_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,396,427,f)
#define FP_TCAMm_F2_1_SIP_MASKf_GET(r) field32_get((r).fp_tcam,396,427)
#define FP_TCAMm_F2_1_SIP_MASKf_SET(r,f) field32_set((r).fp_tcam,396,427,f)
#define FP_TCAMm_F2_12_MIML_TAG_MASKf_GET(r) ((((r).fp_tcam[12]) >> 12) & 0xffff)
#define FP_TCAMm_F2_12_MIML_TAG_MASKf_SET(r,f) (r).fp_tcam[12]=(((r).fp_tcam[12] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_DWF1_MASKf_GET(r,a) field_get((r).fp_tcam,404,469,a)
#define FP_TCAMm_DWF1_MASKf_SET(r,a) field_set((r).fp_tcam,404,469,a)
#define FP_TCAMm_F2_12_SPARE_MASKf_GET(r) field32_get((r).fp_tcam,412,427)
#define FP_TCAMm_F2_12_SPARE_MASKf_SET(r,f) field32_set((r).fp_tcam,412,427,f)
#define FP_TCAMm_F2_14_SPARE_MASKf_GET(r) field32_get((r).fp_tcam,412,427)
#define FP_TCAMm_F2_14_SPARE_MASKf_SET(r,f) field32_set((r).fp_tcam,412,427,f)
#define FP_TCAMm_F2_6_SPARE_MASKf_GET(r) field32_get((r).fp_tcam,412,427)
#define FP_TCAMm_F2_6_SPARE_MASKf_SET(r,f) field32_set((r).fp_tcam,412,427,f)
#define FP_TCAMm_F1_MASKf_GET(r,a) field_get((r).fp_tcam,428,464,a)
#define FP_TCAMm_F1_MASKf_SET(r,a) field_set((r).fp_tcam,428,464,a)
#define FP_TCAMm_F1_13_AUX_TAG_1_MASKf_GET(r) field32_get((r).fp_tcam,428,459)
#define FP_TCAMm_F1_13_AUX_TAG_1_MASKf_SET(r,f) field32_set((r).fp_tcam,428,459,f)
#define FP_TCAMm_F1_9_UDF1_31_0_MASKf_GET(r) field32_get((r).fp_tcam,428,459)
#define FP_TCAMm_F1_9_UDF1_31_0_MASKf_SET(r,f) field32_set((r).fp_tcam,428,459,f)
#define FP_TCAMm_F1_3_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[13]) >> 12) & 0xffff)
#define FP_TCAMm_F1_3_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F1_4_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[13]) >> 12) & 0xffff)
#define FP_TCAMm_F1_4_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F1_5_LOOKUP_STATUS_MASKf_GET(r) ((((r).fp_tcam[13]) >> 12) & 0xffff)
#define FP_TCAMm_F1_5_LOOKUP_STATUS_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F1_6_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[13]) >> 12) & 0xffff)
#define FP_TCAMm_F1_6_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F1_7_OUTER_VLAN_TAG_MASKf_GET(r) ((((r).fp_tcam[13]) >> 12) & 0xffff)
#define FP_TCAMm_F1_7_OUTER_VLAN_TAG_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xffff << 12)) | ((((uint32)f) & 0xffff) << 12))
#define FP_TCAMm_F1_10_D_FIELD_MASKf_GET(r) ((((r).fp_tcam[13]) >> 12) & 0x7fff)
#define FP_TCAMm_F1_10_D_FIELD_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x7fff << 12)) | ((((uint32)f) & 0x7fff) << 12))
#define FP_TCAMm_F1_11_SGLP_MASKf_GET(r) ((((r).fp_tcam[13]) >> 12) & 0x7fff)
#define FP_TCAMm_F1_11_SGLP_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x7fff << 12)) | ((((uint32)f) & 0x7fff) << 12))
#define FP_TCAMm_F1_1_D_FIELD_MASKf_GET(r) ((((r).fp_tcam[13]) >> 12) & 0x7fff)
#define FP_TCAMm_F1_1_D_FIELD_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x7fff << 12)) | ((((uint32)f) & 0x7fff) << 12))
#define FP_TCAMm_F1_2_D_FIELD_MASKf_GET(r) ((((r).fp_tcam[13]) >> 12) & 0x7fff)
#define FP_TCAMm_F1_2_D_FIELD_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x7fff << 12)) | ((((uint32)f) & 0x7fff) << 12))
#define FP_TCAMm_F1_0_CLASSIDS_MASKf_GET(r) ((((r).fp_tcam[13]) >> 12) & 0xfff)
#define FP_TCAMm_F1_0_CLASSIDS_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))
#define FP_TCAMm_F1_12_OUTER_VLAN_ID_MASKf_GET(r) ((((r).fp_tcam[13]) >> 12) & 0xfff)
#define FP_TCAMm_F1_12_OUTER_VLAN_ID_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))
#define FP_TCAMm_F1_8_IP_PROTOCOL_LAST_NH_MASKf_GET(r) ((((r).fp_tcam[13]) >> 12) & 0xff)
#define FP_TCAMm_F1_8_IP_PROTOCOL_LAST_NH_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xff << 12)) | ((((uint32)f) & 0xff) << 12))
#define FP_TCAMm_F1_8_TOS_FN_MASKf_GET(r) ((((r).fp_tcam[13]) >> 20) & 0xff)
#define FP_TCAMm_F1_8_TOS_FN_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xff << 20)) | ((((uint32)f) & 0xff) << 20))
#define FP_TCAMm_F1_0_FORWARDING_FIELD_MASKf_GET(r) field32_get((r).fp_tcam,440,451)
#define FP_TCAMm_F1_0_FORWARDING_FIELD_MASKf_SET(r,f) field32_set((r).fp_tcam,440,451,f)
#define FP_TCAMm_F1_12_CLASSIDS_MASKf_GET(r) field32_get((r).fp_tcam,440,451)
#define FP_TCAMm_F1_12_CLASSIDS_MASKf_SET(r,f) field32_set((r).fp_tcam,440,451,f)
#define FP_TCAMm_F1_11_SVP_MASKf_GET(r) field32_get((r).fp_tcam,443,455)
#define FP_TCAMm_F1_11_SVP_MASKf_SET(r,f) field32_set((r).fp_tcam,443,455,f)
#define FP_TCAMm_F1_10_D_TYPE_MASKf_GET(r) ((((r).fp_tcam[13]) >> 27) & 0x7)
#define FP_TCAMm_F1_10_D_TYPE_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define FP_TCAMm_F1_1_D_TYPE_MASKf_GET(r) ((((r).fp_tcam[13]) >> 27) & 0x7)
#define FP_TCAMm_F1_1_D_TYPE_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define FP_TCAMm_F1_2_D_TYPE_MASKf_GET(r) ((((r).fp_tcam[13]) >> 27) & 0x7)
#define FP_TCAMm_F1_2_D_TYPE_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define FP_TCAMm_F1_3_INNER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,444,459)
#define FP_TCAMm_F1_3_INNER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,444,459,f)
#define FP_TCAMm_F1_4_ETHERTYPE_MASKf_GET(r) field32_get((r).fp_tcam,444,459)
#define FP_TCAMm_F1_4_ETHERTYPE_MASKf_SET(r,f) field32_set((r).fp_tcam,444,459,f)
#define FP_TCAMm_F1_5_INNER_VLAN_TAG_MASKf_GET(r) field32_get((r).fp_tcam,444,459)
#define FP_TCAMm_F1_5_INNER_VLAN_TAG_MASKf_SET(r,f) field32_set((r).fp_tcam,444,459,f)
#define FP_TCAMm_F1_7_CLASSIDS_11_6_MASKf_GET(r) field32_get((r).fp_tcam,444,449)
#define FP_TCAMm_F1_7_CLASSIDS_11_6_MASKf_SET(r,f) field32_set((r).fp_tcam,444,449,f)
#define FP_TCAMm_F1_8_CLASSIDS_11_6_MASKf_GET(r) field32_get((r).fp_tcam,444,449)
#define FP_TCAMm_F1_8_CLASSIDS_11_6_MASKf_SET(r,f) field32_set((r).fp_tcam,444,449,f)
#define FP_TCAMm_F1_6_PACKET_FORMAT_MASKf_GET(r) ((((r).fp_tcam[13]) >> 28) & 0xf)
#define FP_TCAMm_F1_6_PACKET_FORMAT_MASKf_SET(r,f) (r).fp_tcam[13]=(((r).fp_tcam[13] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define FP_TCAMm_F1_10_DGLP_MASKf_GET(r) field32_get((r).fp_tcam,446,460)
#define FP_TCAMm_F1_10_DGLP_MASKf_SET(r,f) field32_set((r).fp_tcam,446,460,f)
#define FP_TCAMm_F1_1_S_FIELD_MASKf_GET(r) field32_get((r).fp_tcam,446,460)
#define FP_TCAMm_F1_1_S_FIELD_MASKf_SET(r,f) field32_set((r).fp_tcam,446,460,f)
#define FP_TCAMm_F1_2_MH_OPCODE_MASKf_GET(r) field32_get((r).fp_tcam,446,448)
#define FP_TCAMm_F1_2_MH_OPCODE_MASKf_SET(r,f) field32_set((r).fp_tcam,446,448,f)
#define FP_TCAMm_F1_6_SWITCHING_TAG_STATUS_MASKf_GET(r) (((r).fp_tcam[14]) & 0x3)
#define FP_TCAMm_F1_6_SWITCHING_TAG_STATUS_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define FP_TCAMm_F1_2_CLASSIDS_MASKf_GET(r) ((((r).fp_tcam[14]) >> 1) & 0xfff)
#define FP_TCAMm_F1_2_CLASSIDS_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xfff << 1)) | ((((uint32)f) & 0xfff) << 1))
#define FP_TCAMm_F1_7_FORWARDING_FIELD_MASKf_GET(r) ((((r).fp_tcam[14]) >> 2) & 0xfff)
#define FP_TCAMm_F1_7_FORWARDING_FIELD_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xfff << 2)) | ((((uint32)f) & 0xfff) << 2))
#define FP_TCAMm_F1_8_FORWARDING_FIELD_MASKf_GET(r) ((((r).fp_tcam[14]) >> 2) & 0xfff)
#define FP_TCAMm_F1_8_FORWARDING_FIELD_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xfff << 2)) | ((((uint32)f) & 0xfff) << 2))
#define FP_TCAMm_F1_6_MH_OPCODE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 2) & 0x7)
#define FP_TCAMm_F1_6_MH_OPCODE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 2)) | ((((uint32)f) & 0x7) << 2))
#define FP_TCAMm_F1_0_SVP_L3_IIF_MASKf_GET(r) ((((r).fp_tcam[14]) >> 4) & 0x1fff)
#define FP_TCAMm_F1_0_SVP_L3_IIF_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1fff << 4)) | ((((uint32)f) & 0x1fff) << 4))
#define FP_TCAMm_F1_12_SVP_MASKf_GET(r) ((((r).fp_tcam[14]) >> 4) & 0x1fff)
#define FP_TCAMm_F1_12_SVP_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1fff << 4)) | ((((uint32)f) & 0x1fff) << 4))
#define FP_TCAMm_F1_6_PKT_RESOLUTION_MASKf_GET(r) ((((r).fp_tcam[14]) >> 5) & 0x1f)
#define FP_TCAMm_F1_6_PKT_RESOLUTION_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1f << 5)) | ((((uint32)f) & 0x1f) << 5))
#define FP_TCAMm_F1_11_SVP_VALID_MASKf_GET(r) ((((r).fp_tcam[14]) >> 8) & 0x1)
#define FP_TCAMm_F1_11_SVP_VALID_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_TCAMm_F1_11_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 9) & 0xff)
#define FP_TCAMm_F1_11_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xff << 9)) | ((((uint32)f) & 0xff) << 9))
#define FP_TCAMm_F1_6_IP_INFO_MASKf_GET(r) ((((r).fp_tcam[14]) >> 10) & 0x7)
#define FP_TCAMm_F1_6_IP_INFO_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define FP_TCAMm_F1_4_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 12) & 0x1f)
#define FP_TCAMm_F1_4_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1f << 12)) | ((((uint32)f) & 0x1f) << 12))
#define FP_TCAMm_F1_3_OUTER_TPID_ENCODE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 12) & 0x3)
#define FP_TCAMm_F1_3_OUTER_TPID_ENCODE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define FP_TCAMm_F1_5_INNER_TPID_ENCODE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 12) & 0x3)
#define FP_TCAMm_F1_5_INNER_TPID_ENCODE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define FP_TCAMm_F1_9_MPLS_INFO_MASKf_GET(r) ((((r).fp_tcam[14]) >> 12) & 0x3)
#define FP_TCAMm_F1_9_MPLS_INFO_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define FP_TCAMm_F1_13_AUX_TAG_VALID_1_MASKf_GET(r) ((((r).fp_tcam[14]) >> 12) & 0x1)
#define FP_TCAMm_F1_13_AUX_TAG_VALID_1_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_TCAMm_F1_10_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 13) & 0xf)
#define FP_TCAMm_F1_10_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xf << 13)) | ((((uint32)f) & 0xf) << 13))
#define FP_TCAMm_F1_13_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 13) & 0xf)
#define FP_TCAMm_F1_13_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xf << 13)) | ((((uint32)f) & 0xf) << 13))
#define FP_TCAMm_F1_2_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 13) & 0xf)
#define FP_TCAMm_F1_2_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xf << 13)) | ((((uint32)f) & 0xf) << 13))
#define FP_TCAMm_F1_6_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 13) & 0xf)
#define FP_TCAMm_F1_6_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0xf << 13)) | ((((uint32)f) & 0xf) << 13))
#define FP_TCAMm_F1_1_SVP_VALID_MASKf_GET(r) ((((r).fp_tcam[14]) >> 13) & 0x1)
#define FP_TCAMm_F1_1_SVP_VALID_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_TCAMm_F1_1_MH_OPCODE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 14) & 0x7)
#define FP_TCAMm_F1_1_MH_OPCODE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define FP_TCAMm_F1_3_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 14) & 0x7)
#define FP_TCAMm_F1_3_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define FP_TCAMm_F1_5_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 14) & 0x7)
#define FP_TCAMm_F1_5_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define FP_TCAMm_F1_9_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 14) & 0x7)
#define FP_TCAMm_F1_9_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x7 << 14)) | ((((uint32)f) & 0x7) << 14))
#define FP_TCAMm_F1_7_MPLS_INFO_MASKf_GET(r) ((((r).fp_tcam[14]) >> 14) & 0x3)
#define FP_TCAMm_F1_7_MPLS_INFO_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define FP_TCAMm_F1_8_INT_CN_MASKf_GET(r) ((((r).fp_tcam[14]) >> 14) & 0x3)
#define FP_TCAMm_F1_8_INT_CN_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define FP_TCAMm_F1_7_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 16) & 0x1)
#define FP_TCAMm_F1_7_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define FP_TCAMm_F1_8_SPARE_MASKf_GET(r) ((((r).fp_tcam[14]) >> 16) & 0x1)
#define FP_TCAMm_F1_8_SPARE_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define FP_TCAMm_RESERVED_MASKf_GET(r) ((((r).fp_tcam[14]) >> 17) & 0x1f)
#define FP_TCAMm_RESERVED_MASKf_SET(r,f) (r).fp_tcam[14]=(((r).fp_tcam[14] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))

/*
 * These macros can be used to access FP_TCAM.
 */
#define WRITE_FP_TCAMm(u,i,r) bcm5354x_tcam_mem_set(u, M_FP_TCAM(i), &(r._fp_tcam), 15, 2, 236, 234)
#define READ_FP_TCAMm(u,i,r) bcm5354x_tcam_mem_get(u, M_FP_TCAM(i), &(r._fp_tcam), 15, 2, 236, 234)

/*******************************************************************************
 * End of 'FP_TCAMm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  FP_UDF_OFFSET
 * BLOCKS:   IPIPE
 * DESC:     IFP UDF offset table
 * SIZE:     70
 * FIELDS:
 *     UDF1_OFFSET0     Offset value for UDF1.0
 *     UDF1_ADD_GRE_OPTIONS0 Control bit to enable adding GRE option headers
 *     UDF1_ADD_IPV4_OPTIONS0 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET1     Offset value for UDF1.1
 *     UDF1_ADD_GRE_OPTIONS1 Control bit to enable adding GRE option headers
 *     UDF1_ADD_IPV4_OPTIONS1 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET2     Offset value for UDF1.2
 *     UDF1_ADD_GRE_OPTIONS2 Control bit to enable adding GRE option headers
 *     UDF1_ADD_IPV4_OPTIONS2 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET3     Offset value for UDF1.3
 *     UDF1_ADD_GRE_OPTIONS3 Control bit to enable adding GRE option headers
 *     UDF1_ADD_IPV4_OPTIONS3 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET0     Offset value for UDF2.0
 *     UDF2_ADD_GRE_OPTIONS0 Control bit to enable adding GRE option headers
 *     UDF2_ADD_IPV4_OPTIONS0 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET1     Offset value for UDF2.1
 *     UDF2_ADD_GRE_OPTIONS1 Control bit to enable adding GRE option headers
 *     UDF2_ADD_IPV4_OPTIONS1 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET2     Offset value for UDF2.2
 *     UDF2_ADD_GRE_OPTIONS2 Control bit to enable adding GRE option headers
 *     UDF2_ADD_IPV4_OPTIONS2 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET3     Offset value for UDF2.3
 *     UDF2_ADD_GRE_OPTIONS3 Control bit to enable adding GRE option headers
 *     UDF2_ADD_IPV4_OPTIONS3 Control bit to enable adding the IPv4 header option length
 *     PORT_FIELD_SEL_INDEX0 Used to index into the FP_PORT_FIELD_SEL table (if packet indexing is enabled) and FP_PORT_SELECT_TYPE equals 0
 *     PORT_FIELD_SEL_INDEX1 Used to index into the FP_PORT_FIELD_SEL table (if packet indexing is enabled) and FP_PORT_SELECT_TYPE equals 1
 *     RESERVED         reserved field.
 *     EVEN_PARITY      PARITY BIT to make the entry parity even.
 */
#define FP_UDF_OFFSETm_MIN 0
#define FP_UDF_OFFSETm_MAX 383
#define FP_UDF_OFFSETm_CMAX(u) 383
#define FP_UDF_OFFSETm_SIZE 9

/*
 * This structure should be used to declare and program FP_UDF_OFFSET.
 */
typedef union FP_UDF_OFFSETm_s {
	uint32 v[3];
	uint32 fp_udf_offset[3];
	uint32 _fp_udf_offset;
} FP_UDF_OFFSETm_t;

#define FP_UDF_OFFSETm_CLR(r) sal_memset(&((r)._fp_udf_offset), 0, sizeof(FP_UDF_OFFSETm_t))
#define FP_UDF_OFFSETm_SET(r,i,d) (r).fp_udf_offset[i] = d
#define FP_UDF_OFFSETm_GET(r,i) (r).fp_udf_offset[i]

/*
 * These macros can be used to access individual fields.
 */
#define FP_UDF_OFFSETm_UDF1_OFFSET0f_GET(r) (((r).fp_udf_offset[0]) & 0x1f)
#define FP_UDF_OFFSETm_UDF1_OFFSET0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS0f_GET(r) ((((r).fp_udf_offset[0]) >> 5) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET(r) ((((r).fp_udf_offset[0]) >> 6) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define FP_UDF_OFFSETm_UDF1_OFFSET1f_GET(r) ((((r).fp_udf_offset[0]) >> 7) & 0x1f)
#define FP_UDF_OFFSETm_UDF1_OFFSET1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1f << 7)) | ((((uint32)f) & 0x1f) << 7))
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS1f_GET(r) ((((r).fp_udf_offset[0]) >> 12) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET(r) ((((r).fp_udf_offset[0]) >> 13) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define FP_UDF_OFFSETm_UDF1_OFFSET2f_GET(r) ((((r).fp_udf_offset[0]) >> 14) & 0x1f)
#define FP_UDF_OFFSETm_UDF1_OFFSET2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1f << 14)) | ((((uint32)f) & 0x1f) << 14))
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS2f_GET(r) ((((r).fp_udf_offset[0]) >> 19) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET(r) ((((r).fp_udf_offset[0]) >> 20) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define FP_UDF_OFFSETm_UDF1_OFFSET3f_GET(r) ((((r).fp_udf_offset[0]) >> 21) & 0x1f)
#define FP_UDF_OFFSETm_UDF1_OFFSET3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1f << 21)) | ((((uint32)f) & 0x1f) << 21))
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS3f_GET(r) ((((r).fp_udf_offset[0]) >> 26) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_GRE_OPTIONS3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET(r) ((((r).fp_udf_offset[0]) >> 27) & 0x1)
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define FP_UDF_OFFSETm_UDF2_OFFSET0f_GET(r) field32_get((r).fp_udf_offset,28,32)
#define FP_UDF_OFFSETm_UDF2_OFFSET0f_SET(r,f) field32_set((r).fp_udf_offset,28,32,f)
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS0f_GET(r) ((((r).fp_udf_offset[1]) >> 1) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS0f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET(r) ((((r).fp_udf_offset[1]) >> 2) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define FP_UDF_OFFSETm_UDF2_OFFSET1f_GET(r) ((((r).fp_udf_offset[1]) >> 3) & 0x1f)
#define FP_UDF_OFFSETm_UDF2_OFFSET1f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1f << 3)) | ((((uint32)f) & 0x1f) << 3))
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS1f_GET(r) ((((r).fp_udf_offset[1]) >> 8) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS1f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET(r) ((((r).fp_udf_offset[1]) >> 9) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define FP_UDF_OFFSETm_UDF2_OFFSET2f_GET(r) ((((r).fp_udf_offset[1]) >> 10) & 0x1f)
#define FP_UDF_OFFSETm_UDF2_OFFSET2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1f << 10)) | ((((uint32)f) & 0x1f) << 10))
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS2f_GET(r) ((((r).fp_udf_offset[1]) >> 15) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET(r) ((((r).fp_udf_offset[1]) >> 16) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define FP_UDF_OFFSETm_UDF2_OFFSET3f_GET(r) ((((r).fp_udf_offset[1]) >> 17) & 0x1f)
#define FP_UDF_OFFSETm_UDF2_OFFSET3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS3f_GET(r) ((((r).fp_udf_offset[1]) >> 22) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_GRE_OPTIONS3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET(r) ((((r).fp_udf_offset[1]) >> 23) & 0x1)
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX0f_GET(r) ((((r).fp_udf_offset[1]) >> 24) & 0x3f)
#define FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX0f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))
#define FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX1f_GET(r) field32_get((r).fp_udf_offset,62,67)
#define FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX1f_SET(r,f) field32_set((r).fp_udf_offset,62,67,f)
#define FP_UDF_OFFSETm_RESERVEDf_GET(r) ((((r).fp_udf_offset[2]) >> 4) & 0x1)
#define FP_UDF_OFFSETm_RESERVEDf_SET(r,f) (r).fp_udf_offset[2]=(((r).fp_udf_offset[2] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define FP_UDF_OFFSETm_EVEN_PARITYf_GET(r) ((((r).fp_udf_offset[2]) >> 5) & 0x1)
#define FP_UDF_OFFSETm_EVEN_PARITYf_SET(r,f) (r).fp_udf_offset[2]=(((r).fp_udf_offset[2] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))

/*
 * These macros can be used to access FP_UDF_OFFSET.
 */
#define WRITE_FP_UDF_OFFSETm(u,i,r) bcm5354x_mem_set(u, M_FP_UDF_OFFSET(i), &(r._fp_udf_offset), 3)
#define READ_FP_UDF_OFFSETm(u,i,r) bcm5354x_mem_get(u, M_FP_UDF_OFFSET(i), &(r._fp_udf_offset), 3)

/*******************************************************************************
 * End of 'FP_UDF_OFFSETm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  FRM_LENGTH
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Maximum Frame Length.
 * SIZE:     32
 * FIELDS:
 *     MAXFR            Defines a 14-Bit maximum frame length used by the MAC receive logic to check frames.
 */
#define FRM_LENGTHr_SIZE 4

/*
 * This structure should be used to declare and program FRM_LENGTH.
 */
typedef union FRM_LENGTHr_s {
	uint32 v[1];
	uint32 frm_length[1];
	uint32 _frm_length;
} FRM_LENGTHr_t;

#define FRM_LENGTHr_CLR(r) (r).frm_length[0] = 0
#define FRM_LENGTHr_SET(r,d) (r).frm_length[0] = d
#define FRM_LENGTHr_GET(r) (r).frm_length[0]

/*
 * These macros can be used to access individual fields.
 */
#define FRM_LENGTHr_MAXFRf_GET(r) (((r).frm_length[0]) & 0x3fff)
#define FRM_LENGTHr_MAXFRf_SET(r,f) (r).frm_length[0]=(((r).frm_length[0] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))

/*
 * These macros can be used to access FRM_LENGTH.
 */
#define WRITE_FRM_LENGTHr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_FRM_LENGTH(bcm5354x_gport_lport_to_index_in_block[p]), (r._frm_length))
#define READ_FRM_LENGTHr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_FRM_LENGTH(bcm5354x_gport_lport_to_index_in_block[p]), &(r._frm_length))

/*******************************************************************************
 * End of 'FRM_LENGTHr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GBLLIMITRESETLIMIT
 * BLOCKS:   MMU
 * DESC:     Global cell set/reset limit
 * SIZE:     32
 * FIELDS:
 *     GBLCELLRESETLIMIT After the available cell counter global shared pool is depleted below the reset level, the backpressure state of the shared pool is reset.(TOTALDYNCELLUSED<GBLCELLRESETLIMIT)The RESETLIMIT can be set to the same value or a value lower than the CELLSETLIMIT.
 */
#define GBLLIMITRESETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program GBLLIMITRESETLIMIT.
 */
typedef union GBLLIMITRESETLIMITr_s {
	uint32 v[1];
	uint32 gbllimitresetlimit[1];
	uint32 _gbllimitresetlimit;
} GBLLIMITRESETLIMITr_t;

#define GBLLIMITRESETLIMITr_CLR(r) (r).gbllimitresetlimit[0] = 0
#define GBLLIMITRESETLIMITr_SET(r,d) (r).gbllimitresetlimit[0] = d
#define GBLLIMITRESETLIMITr_GET(r) (r).gbllimitresetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define GBLLIMITRESETLIMITr_GBLCELLRESETLIMITf_GET(r) (((r).gbllimitresetlimit[0]) & 0x3ffff)
#define GBLLIMITRESETLIMITr_GBLCELLRESETLIMITf_SET(r,f) (r).gbllimitresetlimit[0]=(((r).gbllimitresetlimit[0] & ~((uint32)0x3ffff)) | (((uint32)f) & 0x3ffff))

/*
 * These macros can be used to access GBLLIMITRESETLIMIT.
 */
#define WRITE_GBLLIMITRESETLIMITr(u,r) bcm5354x_reg_set(u,R_GBLLIMITRESETLIMIT,(r._gbllimitresetlimit))
#define READ_GBLLIMITRESETLIMITr(u,r) bcm5354x_reg_get(u,R_GBLLIMITRESETLIMIT,&(r._gbllimitresetlimit))

/*******************************************************************************
 * End of 'GBLLIMITRESETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GBLLIMITSETLIMIT
 * BLOCKS:   MMU
 * DESC:     Global cell set/reset limit
 * SIZE:     32
 * FIELDS:
 *     GBLCELLSETLIMIT  After the available cell counter in the global shared pool is depleted below the RESET level, the counter must rise above this XOFF threshold for the backpressure state of the shared pool is set.(criterion:TOTALDYNCELLUSED>=GBLCELLSETLIMIT)
 */
#define GBLLIMITSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program GBLLIMITSETLIMIT.
 */
typedef union GBLLIMITSETLIMITr_s {
	uint32 v[1];
	uint32 gbllimitsetlimit[1];
	uint32 _gbllimitsetlimit;
} GBLLIMITSETLIMITr_t;

#define GBLLIMITSETLIMITr_CLR(r) (r).gbllimitsetlimit[0] = 0
#define GBLLIMITSETLIMITr_SET(r,d) (r).gbllimitsetlimit[0] = d
#define GBLLIMITSETLIMITr_GET(r) (r).gbllimitsetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define GBLLIMITSETLIMITr_GBLCELLSETLIMITf_GET(r) (((r).gbllimitsetlimit[0]) & 0x3ffff)
#define GBLLIMITSETLIMITr_GBLCELLSETLIMITf_SET(r,f) (r).gbllimitsetlimit[0]=(((r).gbllimitsetlimit[0] & ~((uint32)0x3ffff)) | (((uint32)f) & 0x3ffff))

/*
 * These macros can be used to access GBLLIMITSETLIMIT.
 */
#define WRITE_GBLLIMITSETLIMITr(u,r) bcm5354x_reg_set(u,R_GBLLIMITSETLIMIT,(r._gbllimitsetlimit))
#define READ_GBLLIMITSETLIMITr(u,r) bcm5354x_reg_get(u,R_GBLLIMITSETLIMIT,&(r._gbllimitsetlimit))

/*******************************************************************************
 * End of 'GBLLIMITSETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  GLP
 * BLOCKS:  
 * DESC:     Global Logical Port
 * SIZE:     15
 * FIELDS:
 *     TGID             
 *     PORT             Port number if T=0
 *     MODID            if T=1 then GLP is TGID otherwise GLP is {MODID, PORT}
 *     T                if T=1 then GLP is TGID otherwise GLP is {MODID, PORT}
 */
#define GLP_SIZE 2

/*
 * This structure should be used to declare and program GLP.
 */
typedef union GLP_s {
	uint32 v[1];
	uint32 glp[1];
	uint32 _glp;
} GLP_t;

#define GLP_CLR(r) (r).glp[0] = 0
#define GLP_SET(r,d) (r).glp[0] = d
#define GLP_GET(r) (r).glp[0]

/*
 * These macros can be used to access individual fields.
 */
#define GLP_TGIDf_GET(r) (((r).glp[0]) & 0x7f)
#define GLP_TGIDf_SET(r,f) (r).glp[0]=(((r).glp[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define GLP_PORTf_GET(r) (((r).glp[0]) & 0x3f)
#define GLP_PORTf_SET(r,f) (r).glp[0]=(((r).glp[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define GLP_MODIDf_GET(r) ((((r).glp[0]) >> 6) & 0xff)
#define GLP_MODIDf_SET(r,f) (r).glp[0]=(((r).glp[0] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define GLP_Tf_GET(r) ((((r).glp[0]) >> 14) & 0x1)
#define GLP_Tf_SET(r,f) (r).glp[0]=(((r).glp[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))

/*******************************************************************************
 * End of 'GLP'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GMII_EEE_DELAY_ENTRY_TIMER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     GMII_EEE LPI timer
 * SIZE:     32
 * FIELDS:
 *     GMII_EEE_LPI_TIMER This is the duration for which condition to move to LPI state must be satisfied, at the end of which MAC transitions to LPI State. The decrement unit is 1 micro-second.This register is meant for 1000 Mbps speed.
 */
#define GMII_EEE_DELAY_ENTRY_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program GMII_EEE_DELAY_ENTRY_TIMER.
 */
typedef union GMII_EEE_DELAY_ENTRY_TIMERr_s {
	uint32 v[1];
	uint32 gmii_eee_delay_entry_timer[1];
	uint32 _gmii_eee_delay_entry_timer;
} GMII_EEE_DELAY_ENTRY_TIMERr_t;

#define GMII_EEE_DELAY_ENTRY_TIMERr_CLR(r) (r).gmii_eee_delay_entry_timer[0] = 0
#define GMII_EEE_DELAY_ENTRY_TIMERr_SET(r,d) (r).gmii_eee_delay_entry_timer[0] = d
#define GMII_EEE_DELAY_ENTRY_TIMERr_GET(r) (r).gmii_eee_delay_entry_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define GMII_EEE_DELAY_ENTRY_TIMERr_GMII_EEE_LPI_TIMERf_GET(r) ((r).gmii_eee_delay_entry_timer[0])
#define GMII_EEE_DELAY_ENTRY_TIMERr_GMII_EEE_LPI_TIMERf_SET(r,f) (r).gmii_eee_delay_entry_timer[0]=((uint32)f)

/*
 * These macros can be used to access GMII_EEE_DELAY_ENTRY_TIMER.
 */
#define WRITE_GMII_EEE_DELAY_ENTRY_TIMERr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GMII_EEE_DELAY_ENTRY_TIMER(bcm5354x_gport_lport_to_index_in_block[p]), (r._gmii_eee_delay_entry_timer))
#define READ_GMII_EEE_DELAY_ENTRY_TIMERr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GMII_EEE_DELAY_ENTRY_TIMER(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gmii_eee_delay_entry_timer))

/*******************************************************************************
 * End of 'GMII_EEE_DELAY_ENTRY_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GMII_EEE_WAKE_TIMER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     GMII_EEE Wake timer
 * SIZE:     32
 * FIELDS:
 *     GMII_EEE_WAKE_TIMER This is the duration for which MAC must wait to go back to ACTIVE state from LPI state when it receives packet for transmission. The decrement unit is 1 micro-second.This register is meant for 1000 Mbps speed.
 */
#define GMII_EEE_WAKE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program GMII_EEE_WAKE_TIMER.
 */
typedef union GMII_EEE_WAKE_TIMERr_s {
	uint32 v[1];
	uint32 gmii_eee_wake_timer[1];
	uint32 _gmii_eee_wake_timer;
} GMII_EEE_WAKE_TIMERr_t;

#define GMII_EEE_WAKE_TIMERr_CLR(r) (r).gmii_eee_wake_timer[0] = 0
#define GMII_EEE_WAKE_TIMERr_SET(r,d) (r).gmii_eee_wake_timer[0] = d
#define GMII_EEE_WAKE_TIMERr_GET(r) (r).gmii_eee_wake_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define GMII_EEE_WAKE_TIMERr_GMII_EEE_WAKE_TIMERf_GET(r) (((r).gmii_eee_wake_timer[0]) & 0xffff)
#define GMII_EEE_WAKE_TIMERr_GMII_EEE_WAKE_TIMERf_SET(r,f) (r).gmii_eee_wake_timer[0]=(((r).gmii_eee_wake_timer[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access GMII_EEE_WAKE_TIMER.
 */
#define WRITE_GMII_EEE_WAKE_TIMERr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GMII_EEE_WAKE_TIMER(bcm5354x_gport_lport_to_index_in_block[p]), (r._gmii_eee_wake_timer))
#define READ_GMII_EEE_WAKE_TIMERr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GMII_EEE_WAKE_TIMER(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gmii_eee_wake_timer))

/*******************************************************************************
 * End of 'GMII_EEE_WAKE_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GPORT_CONFIG
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     GPORT configuration Register
 * SIZE:     32
 * FIELDS:
 *     GPORT_EN         Enable GPORT. GPORT will not read GBOD buffer/Write GBODE buffer if this bit is disabled. 
 *     CLR_CNT          Clear all 8 GE port statistic Counters.
 */
#define GPORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_CONFIG.
 */
typedef union GPORT_CONFIGr_s {
	uint32 v[1];
	uint32 gport_config[1];
	uint32 _gport_config;
} GPORT_CONFIGr_t;

#define GPORT_CONFIGr_CLR(r) (r).gport_config[0] = 0
#define GPORT_CONFIGr_SET(r,d) (r).gport_config[0] = d
#define GPORT_CONFIGr_GET(r) (r).gport_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPORT_CONFIGr_GPORT_ENf_GET(r) (((r).gport_config[0]) & 0x1)
#define GPORT_CONFIGr_GPORT_ENf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define GPORT_CONFIGr_CLR_CNTf_GET(r) ((((r).gport_config[0]) >> 1) & 0x1)
#define GPORT_CONFIGr_CLR_CNTf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access GPORT_CONFIG.
 */
#define WRITE_GPORT_CONFIGr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GPORT_CONFIG, (r._gport_config))
#define READ_GPORT_CONFIGr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GPORT_CONFIG, &(r._gport_config))

/*******************************************************************************
 * End of 'GPORT_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GPORT_LINK_STATUS_TO_CMIC
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     This is used to swizzle the gp_to_cmic_link_status from [7:0] to [0:7].
 * SIZE:     32
 * FIELDS:
 *     TRANSPOSE         a value of 1 will swizzle the gp_to_cmic_link_status from [7:0] to [0:7].  This may be needed due to physical mirroring of the gport block. 
 */
#define GPORT_LINK_STATUS_TO_CMICr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_LINK_STATUS_TO_CMIC.
 */
typedef union GPORT_LINK_STATUS_TO_CMICr_s {
	uint32 v[1];
	uint32 gport_link_status_to_cmic[1];
	uint32 _gport_link_status_to_cmic;
} GPORT_LINK_STATUS_TO_CMICr_t;

#define GPORT_LINK_STATUS_TO_CMICr_CLR(r) (r).gport_link_status_to_cmic[0] = 0
#define GPORT_LINK_STATUS_TO_CMICr_SET(r,d) (r).gport_link_status_to_cmic[0] = d
#define GPORT_LINK_STATUS_TO_CMICr_GET(r) (r).gport_link_status_to_cmic[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPORT_LINK_STATUS_TO_CMICr_TRANSPOSEf_GET(r) (((r).gport_link_status_to_cmic[0]) & 0x1)
#define GPORT_LINK_STATUS_TO_CMICr_TRANSPOSEf_SET(r,f) (r).gport_link_status_to_cmic[0]=(((r).gport_link_status_to_cmic[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access GPORT_LINK_STATUS_TO_CMIC.
 */
#define WRITE_GPORT_LINK_STATUS_TO_CMICr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GPORT_LINK_STATUS_TO_CMIC, (r._gport_link_status_to_cmic))
#define READ_GPORT_LINK_STATUS_TO_CMICr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GPORT_LINK_STATUS_TO_CMIC, &(r._gport_link_status_to_cmic))

/*******************************************************************************
 * End of 'GPORT_LINK_STATUS_TO_CMICr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GPORT_RSV_MASK
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     GPORT RSV MASK register, used to purge packet data received from the MACs
 * SIZE:     32
 * FIELDS:
 *     MASK             Control which RSV bits cause packets to be purged
 */
#define GPORT_RSV_MASKr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_RSV_MASK.
 */
typedef union GPORT_RSV_MASKr_s {
	uint32 v[1];
	uint32 gport_rsv_mask[1];
	uint32 _gport_rsv_mask;
} GPORT_RSV_MASKr_t;

#define GPORT_RSV_MASKr_CLR(r) (r).gport_rsv_mask[0] = 0
#define GPORT_RSV_MASKr_SET(r,d) (r).gport_rsv_mask[0] = d
#define GPORT_RSV_MASKr_GET(r) (r).gport_rsv_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPORT_RSV_MASKr_MASKf_GET(r) (((r).gport_rsv_mask[0]) & 0x3ffff)
#define GPORT_RSV_MASKr_MASKf_SET(r,f) (r).gport_rsv_mask[0]=(((r).gport_rsv_mask[0] & ~((uint32)0x3ffff)) | (((uint32)f) & 0x3ffff))

/*
 * These macros can be used to access GPORT_RSV_MASK.
 */
#define WRITE_GPORT_RSV_MASKr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GPORT_RSV_MASK, (r._gport_rsv_mask))
#define READ_GPORT_RSV_MASKr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GPORT_RSV_MASK, &(r._gport_rsv_mask))

/*******************************************************************************
 * End of 'GPORT_RSV_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GPORT_SGMII0_CTRL_REG
 * BLOCKS:   PMQ0 PMQ1 PMQ2
 * DESC:     Controls for TSC.  GPORT_SGMII0_CTRL_REG exists on a per PGW_GE8P basis to control quad-lane SGMII0.  There are 2 quad-lane SGMII per PGW_GE8P
 * SIZE:     32
 * FIELDS:
 *     RSTB_PLL         Resets PLL on SGMII0 (active low).
 *     RSTB_MDIOREGS    Resets MDIO on SGMII0 (active low).
 *     RSTB_HW          Resets the entire SGMII0 (active low)
 *     PWRDWN           TSC Power Down. Powers down TSC analog circuits.
 *     IDDQ             Shutdown analog clocks but leave analog section powered.  
 *     REFSEL           Reference clock selection:000: Internal REFCLK from on-die REFCLK rounting channel001: XTAL010: XTAL bypass / External REFCLK from pads011: XTAL bypass / External REFCLK from pads with 100 ohm termination1xx: internal single-ended REFCLK CMOS
 */
#define GPORT_SGMII0_CTRL_REGr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_SGMII0_CTRL_REG.
 */
typedef union GPORT_SGMII0_CTRL_REGr_s {
	uint32 v[1];
	uint32 gport_sgmii0_ctrl_reg[1];
	uint32 _gport_sgmii0_ctrl_reg;
} GPORT_SGMII0_CTRL_REGr_t;

#define GPORT_SGMII0_CTRL_REGr_CLR(r) (r).gport_sgmii0_ctrl_reg[0] = 0
#define GPORT_SGMII0_CTRL_REGr_SET(r,d) (r).gport_sgmii0_ctrl_reg[0] = d
#define GPORT_SGMII0_CTRL_REGr_GET(r) (r).gport_sgmii0_ctrl_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPORT_SGMII0_CTRL_REGr_RSTB_PLLf_GET(r) (((r).gport_sgmii0_ctrl_reg[0]) & 0x1)
#define GPORT_SGMII0_CTRL_REGr_RSTB_PLLf_SET(r,f) (r).gport_sgmii0_ctrl_reg[0]=(((r).gport_sgmii0_ctrl_reg[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define GPORT_SGMII0_CTRL_REGr_RSTB_MDIOREGSf_GET(r) ((((r).gport_sgmii0_ctrl_reg[0]) >> 1) & 0x1)
#define GPORT_SGMII0_CTRL_REGr_RSTB_MDIOREGSf_SET(r,f) (r).gport_sgmii0_ctrl_reg[0]=(((r).gport_sgmii0_ctrl_reg[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define GPORT_SGMII0_CTRL_REGr_RSTB_HWf_GET(r) ((((r).gport_sgmii0_ctrl_reg[0]) >> 2) & 0x1)
#define GPORT_SGMII0_CTRL_REGr_RSTB_HWf_SET(r,f) (r).gport_sgmii0_ctrl_reg[0]=(((r).gport_sgmii0_ctrl_reg[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define GPORT_SGMII0_CTRL_REGr_PWRDWNf_GET(r) ((((r).gport_sgmii0_ctrl_reg[0]) >> 3) & 0x1)
#define GPORT_SGMII0_CTRL_REGr_PWRDWNf_SET(r,f) (r).gport_sgmii0_ctrl_reg[0]=(((r).gport_sgmii0_ctrl_reg[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define GPORT_SGMII0_CTRL_REGr_IDDQf_GET(r) ((((r).gport_sgmii0_ctrl_reg[0]) >> 4) & 0x1)
#define GPORT_SGMII0_CTRL_REGr_IDDQf_SET(r,f) (r).gport_sgmii0_ctrl_reg[0]=(((r).gport_sgmii0_ctrl_reg[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define GPORT_SGMII0_CTRL_REGr_REFSELf_GET(r) ((((r).gport_sgmii0_ctrl_reg[0]) >> 5) & 0x7)
#define GPORT_SGMII0_CTRL_REGr_REFSELf_SET(r,f) (r).gport_sgmii0_ctrl_reg[0]=(((r).gport_sgmii0_ctrl_reg[0] & ~((uint32)0x7 << 5)) | ((((uint32)f) & 0x7) << 5))

/*
 * These macros can be used to access GPORT_SGMII0_CTRL_REG.
 */
#define WRITE_GPORT_SGMII0_CTRL_REGr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pmq_lport_to_blockid[p], R_GPORT_SGMII0_CTRL_REG, (r._gport_sgmii0_ctrl_reg))
#define READ_GPORT_SGMII0_CTRL_REGr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pmq_lport_to_blockid[p], R_GPORT_SGMII0_CTRL_REG, &(r._gport_sgmii0_ctrl_reg))

/*******************************************************************************
 * End of 'GPORT_SGMII0_CTRL_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GPORT_STAT_UPDATE_MASK
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     GPORT STAT_UPDATE MASK register, used to control the statistic counter update in the Ingress
 * SIZE:     32
 * FIELDS:
 *     MASK             Control which RSV event should have the statistic counter updated in the Ingress.
 */
#define GPORT_STAT_UPDATE_MASKr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_STAT_UPDATE_MASK.
 */
typedef union GPORT_STAT_UPDATE_MASKr_s {
	uint32 v[1];
	uint32 gport_stat_update_mask[1];
	uint32 _gport_stat_update_mask;
} GPORT_STAT_UPDATE_MASKr_t;

#define GPORT_STAT_UPDATE_MASKr_CLR(r) (r).gport_stat_update_mask[0] = 0
#define GPORT_STAT_UPDATE_MASKr_SET(r,d) (r).gport_stat_update_mask[0] = d
#define GPORT_STAT_UPDATE_MASKr_GET(r) (r).gport_stat_update_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPORT_STAT_UPDATE_MASKr_MASKf_GET(r) (((r).gport_stat_update_mask[0]) & 0x3ffff)
#define GPORT_STAT_UPDATE_MASKr_MASKf_SET(r,f) (r).gport_stat_update_mask[0]=(((r).gport_stat_update_mask[0] & ~((uint32)0x3ffff)) | (((uint32)f) & 0x3ffff))

/*
 * These macros can be used to access GPORT_STAT_UPDATE_MASK.
 */
#define WRITE_GPORT_STAT_UPDATE_MASKr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GPORT_STAT_UPDATE_MASK, (r._gport_stat_update_mask))
#define READ_GPORT_STAT_UPDATE_MASKr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GPORT_STAT_UPDATE_MASK, &(r._gport_stat_update_mask))

/*******************************************************************************
 * End of 'GPORT_STAT_UPDATE_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GPORT_WC_UCMEM_CTRL
 * BLOCKS:   PMQ0 PMQ1 PMQ2
 * DESC:     PORT to TSC micro-controller Memory (extmem) Control Register.  Configures FSM in Port.
 * SIZE:     32
 * FIELDS:
 *     ACCESS_MODE      External Memory Controls Access   1'b0 - access registers in QTC   1'b1 - access ucode memory in QTC
 *     RSVD3_1          reserved
 */
#define GPORT_WC_UCMEM_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_WC_UCMEM_CTRL.
 */
typedef union GPORT_WC_UCMEM_CTRLr_s {
	uint32 v[1];
	uint32 gport_wc_ucmem_ctrl[1];
	uint32 _gport_wc_ucmem_ctrl;
} GPORT_WC_UCMEM_CTRLr_t;

#define GPORT_WC_UCMEM_CTRLr_CLR(r) (r).gport_wc_ucmem_ctrl[0] = 0
#define GPORT_WC_UCMEM_CTRLr_SET(r,d) (r).gport_wc_ucmem_ctrl[0] = d
#define GPORT_WC_UCMEM_CTRLr_GET(r) (r).gport_wc_ucmem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPORT_WC_UCMEM_CTRLr_ACCESS_MODEf_GET(r) (((r).gport_wc_ucmem_ctrl[0]) & 0x1)
#define GPORT_WC_UCMEM_CTRLr_ACCESS_MODEf_SET(r,f) (r).gport_wc_ucmem_ctrl[0]=(((r).gport_wc_ucmem_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define GPORT_WC_UCMEM_CTRLr_RSVD3_1f_GET(r) ((((r).gport_wc_ucmem_ctrl[0]) >> 1) & 0x7)
#define GPORT_WC_UCMEM_CTRLr_RSVD3_1f_SET(r,f) (r).gport_wc_ucmem_ctrl[0]=(((r).gport_wc_ucmem_ctrl[0] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))

/*
 * These macros can be used to access GPORT_WC_UCMEM_CTRL.
 */
#define WRITE_GPORT_WC_UCMEM_CTRLr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pmq_lport_to_blockid[p], R_GPORT_WC_UCMEM_CTRL, (r._gport_wc_ucmem_ctrl))
#define READ_GPORT_WC_UCMEM_CTRLr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pmq_lport_to_blockid[p], R_GPORT_WC_UCMEM_CTRL, &(r._gport_wc_ucmem_ctrl))

/*******************************************************************************
 * End of 'GPORT_WC_UCMEM_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  GPORT_WC_UCMEM_DATA
 * BLOCKS:   PMQ0 PMQ1 PMQ2
 * DESC:     Warpcore External Memory Interface to program micro-controller memory
 * SIZE:     128
 * FIELDS:
 *     UC_DATA           16-Bytes of data for TSC uC memory or TSC registers. In TSC ucode mem access mode (GPORT_WC_UCMEM_CTRL == 1), the 16-Bytes of data are written to TSC on sbus writes or saved to this IDX on sbus reads. The TSC ucode mem address is part of the sbus address and forwarded to TSC accordingly. TSC regsiter mode accesses (GPORT_WC_UCMEM_CTRL == 0) do not use the sbus address, so extra steps must be taken to perform TSC reg reads.  Another difference from ucode mem accesses is that rd/wr data is only 2B. TSC register reads are indirect and must be done in two steps:  write followed by read.  The write is used to save the needed TSC register address for the subsequent TSC reg read. TSC register writes are done in one step. While in TSC reg mode ( GPORT_WC_UCMEM_CTRL == 0), an sbus write to this memory, with bit [48] == 1 indicates single step TSC reg write. If  bit [48] == 0, a two-step read is indicated, and the address in bits[31:0] is saved. A subsequent sbus read will perform the TSC reg read using the saved address.  The read data will be stored in bits [47:32].  
 */
#define GPORT_WC_UCMEM_DATAm_MIN 0
#define GPORT_WC_UCMEM_DATAm_MAX 2047
#define GPORT_WC_UCMEM_DATAm_CMAX(u) 2047
#define GPORT_WC_UCMEM_DATAm_SIZE 16

/*
 * This structure should be used to declare and program GPORT_WC_UCMEM_DATA.
 */
typedef union GPORT_WC_UCMEM_DATAm_s {
	uint32 v[4];
	uint32 gport_wc_ucmem_data[4];
	uint32 _gport_wc_ucmem_data;
} GPORT_WC_UCMEM_DATAm_t;

#define GPORT_WC_UCMEM_DATAm_CLR(r) sal_memset(&((r)._gport_wc_ucmem_data), 0, sizeof(GPORT_WC_UCMEM_DATAm_t))
#define GPORT_WC_UCMEM_DATAm_SET(r,i,d) (r).gport_wc_ucmem_data[i] = d
#define GPORT_WC_UCMEM_DATAm_GET(r,i) (r).gport_wc_ucmem_data[i]

/*
 * These macros can be used to access individual fields.
 */
#define GPORT_WC_UCMEM_DATAm_UC_DATAf_GET(r,a) field_get((r).gport_wc_ucmem_data,0,127,a)
#define GPORT_WC_UCMEM_DATAm_UC_DATAf_SET(r,a) field_set((r).gport_wc_ucmem_data,0,127,a)

/*
 * These macros can be used to access GPORT_WC_UCMEM_DATA.
 */
#define WRITE_GPORT_WC_UCMEM_DATAm(u,p,i,r) bcm5354x_mem_set(u, bcm5354x_pmq_lport_to_blockid[p], M_GPORT_WC_UCMEM_DATA(i), &(r._gport_wc_ucmem_data), 4)
#define READ_GPORT_WC_UCMEM_DATAm(u,p,i,r) bcm5354x_mem_get(u, bcm5354x_pmq_lport_to_blockid[p], M_GPORT_WC_UCMEM_DATA(i), &(r._gport_wc_ucmem_data), 4)

/*******************************************************************************
 * End of 'GPORT_WC_UCMEM_DATAm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GPORT_XGXS0_CTRL_REG
 * BLOCKS:   PMQ0 PMQ1 PMQ2
 * DESC:     Controls for TSC.  GPORT_XGXS0_CTRL_REG exists on a per XLPORT basis to control each TSC4 or one of the 3 TSC4s contained within a TSC12.  There are 4 XLPORTS per PGW and effectively four TSC4s per PGW. 
 * SIZE:     32
 * FIELDS:
 *     PLLBYP           Bypass refclk PLL and run transmit and receive clocks from refclk pin.
 *     RSTB_PLL         Resets PLL on this TSC (active low).
 *     RSTB_HW          Hard reset (active low).  Resets everything.
 *     RSTB_REFCLK      Resets refclk based logic in TSC.  This is needed to configure clock switches correctly at start up
 *     REFOUT_EN        Enables LCREFOUT to be driven by this TSC.
 *     REFIN_EN         Selects between pad and LCREF as source of refclk into this TSC PLL
 *     PWRDWN           TSC Power Down. Powers down TSC analog circuits.
 *     TSCCLK_EN        TSC clock enable.
 *     IDDQ              Shutdown analog clocks but leave analog section powered.  
 */
#define GPORT_XGXS0_CTRL_REGr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_XGXS0_CTRL_REG.
 */
typedef union GPORT_XGXS0_CTRL_REGr_s {
	uint32 v[1];
	uint32 gport_xgxs0_ctrl_reg[1];
	uint32 _gport_xgxs0_ctrl_reg;
} GPORT_XGXS0_CTRL_REGr_t;

#define GPORT_XGXS0_CTRL_REGr_CLR(r) (r).gport_xgxs0_ctrl_reg[0] = 0
#define GPORT_XGXS0_CTRL_REGr_SET(r,d) (r).gport_xgxs0_ctrl_reg[0] = d
#define GPORT_XGXS0_CTRL_REGr_GET(r) (r).gport_xgxs0_ctrl_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define GPORT_XGXS0_CTRL_REGr_PLLBYPf_GET(r) (((r).gport_xgxs0_ctrl_reg[0]) & 0x1)
#define GPORT_XGXS0_CTRL_REGr_PLLBYPf_SET(r,f) (r).gport_xgxs0_ctrl_reg[0]=(((r).gport_xgxs0_ctrl_reg[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define GPORT_XGXS0_CTRL_REGr_RSTB_PLLf_GET(r) ((((r).gport_xgxs0_ctrl_reg[0]) >> 1) & 0x1)
#define GPORT_XGXS0_CTRL_REGr_RSTB_PLLf_SET(r,f) (r).gport_xgxs0_ctrl_reg[0]=(((r).gport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define GPORT_XGXS0_CTRL_REGr_RSTB_HWf_GET(r) ((((r).gport_xgxs0_ctrl_reg[0]) >> 2) & 0x1)
#define GPORT_XGXS0_CTRL_REGr_RSTB_HWf_SET(r,f) (r).gport_xgxs0_ctrl_reg[0]=(((r).gport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define GPORT_XGXS0_CTRL_REGr_RSTB_REFCLKf_GET(r) ((((r).gport_xgxs0_ctrl_reg[0]) >> 3) & 0x1)
#define GPORT_XGXS0_CTRL_REGr_RSTB_REFCLKf_SET(r,f) (r).gport_xgxs0_ctrl_reg[0]=(((r).gport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define GPORT_XGXS0_CTRL_REGr_REFOUT_ENf_GET(r) ((((r).gport_xgxs0_ctrl_reg[0]) >> 4) & 0x1)
#define GPORT_XGXS0_CTRL_REGr_REFOUT_ENf_SET(r,f) (r).gport_xgxs0_ctrl_reg[0]=(((r).gport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define GPORT_XGXS0_CTRL_REGr_REFIN_ENf_GET(r) ((((r).gport_xgxs0_ctrl_reg[0]) >> 5) & 0x1)
#define GPORT_XGXS0_CTRL_REGr_REFIN_ENf_SET(r,f) (r).gport_xgxs0_ctrl_reg[0]=(((r).gport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define GPORT_XGXS0_CTRL_REGr_PWRDWNf_GET(r) ((((r).gport_xgxs0_ctrl_reg[0]) >> 6) & 0x1)
#define GPORT_XGXS0_CTRL_REGr_PWRDWNf_SET(r,f) (r).gport_xgxs0_ctrl_reg[0]=(((r).gport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define GPORT_XGXS0_CTRL_REGr_TSCCLK_ENf_GET(r) ((((r).gport_xgxs0_ctrl_reg[0]) >> 7) & 0x1)
#define GPORT_XGXS0_CTRL_REGr_TSCCLK_ENf_SET(r,f) (r).gport_xgxs0_ctrl_reg[0]=(((r).gport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define GPORT_XGXS0_CTRL_REGr_IDDQf_GET(r) ((((r).gport_xgxs0_ctrl_reg[0]) >> 8) & 0x1)
#define GPORT_XGXS0_CTRL_REGr_IDDQf_SET(r,f) (r).gport_xgxs0_ctrl_reg[0]=(((r).gport_xgxs0_ctrl_reg[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))

/*
 * These macros can be used to access GPORT_XGXS0_CTRL_REG.
 */
#define WRITE_GPORT_XGXS0_CTRL_REGr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pmq_lport_to_blockid[p], R_GPORT_XGXS0_CTRL_REG, (r._gport_xgxs0_ctrl_reg))
#define READ_GPORT_XGXS0_CTRL_REGr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pmq_lport_to_blockid[p], R_GPORT_XGXS0_CTRL_REG, &(r._gport_xgxs0_ctrl_reg))

/*******************************************************************************
 * End of 'GPORT_XGXS0_CTRL_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GRALN
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Receive Alignment Error Frame Counter
 * SIZE:     32
 */
#define GRALNr_SIZE 4

/*
 * This structure should be used to declare and program GRALN.
 */
typedef union GRALNr_s {
	uint32 v[1];
	uint32 graln[1];
	uint32 _graln;
} GRALNr_t;

#define GRALNr_CLR(r) (r).graln[0] = 0
#define GRALNr_SET(r,d) (r).graln[0] = d
#define GRALNr_GET(r) (r).graln[0]


/*
 * These macros can be used to access GRALN.
 */
#define WRITE_GRALNr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GRALN(bcm5354x_gport_lport_to_index_in_block[p]), (r._graln))
#define READ_GRALNr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GRALN(bcm5354x_gport_lport_to_index_in_block[p]), &(r._graln))

/*******************************************************************************
 * End of 'GRALNr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GRBCA
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Receive Broadcast Frame Counter
 * SIZE:     32
 */
#define GRBCAr_SIZE 4

/*
 * This structure should be used to declare and program GRBCA.
 */
typedef union GRBCAr_s {
	uint32 v[1];
	uint32 grbca[1];
	uint32 _grbca;
} GRBCAr_t;

#define GRBCAr_CLR(r) (r).grbca[0] = 0
#define GRBCAr_SET(r,d) (r).grbca[0] = d
#define GRBCAr_GET(r) (r).grbca[0]


/*
 * These macros can be used to access GRBCA.
 */
#define WRITE_GRBCAr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GRBCA(bcm5354x_gport_lport_to_index_in_block[p]), (r._grbca))
#define READ_GRBCAr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GRBCA(bcm5354x_gport_lport_to_index_in_block[p]), &(r._grbca))

/*******************************************************************************
 * End of 'GRBCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GRBYT
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Receive Byte Counter
 * SIZE:     32
 */
#define GRBYTr_SIZE 4

/*
 * This structure should be used to declare and program GRBYT.
 */
typedef union GRBYTr_s {
	uint32 v[1];
	uint32 grbyt[1];
	uint32 _grbyt;
} GRBYTr_t;

#define GRBYTr_CLR(r) (r).grbyt[0] = 0
#define GRBYTr_SET(r,d) (r).grbyt[0] = d
#define GRBYTr_GET(r) (r).grbyt[0]


/*
 * These macros can be used to access GRBYT.
 */
#define WRITE_GRBYTr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GRBYT(bcm5354x_gport_lport_to_index_in_block[p]), (r._grbyt))
#define READ_GRBYTr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GRBYT(bcm5354x_gport_lport_to_index_in_block[p]), &(r._grbyt))

/*******************************************************************************
 * End of 'GRBYTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GRFCS
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Receive FCS Error Frame Counter
 * SIZE:     32
 */
#define GRFCSr_SIZE 4

/*
 * This structure should be used to declare and program GRFCS.
 */
typedef union GRFCSr_s {
	uint32 v[1];
	uint32 grfcs[1];
	uint32 _grfcs;
} GRFCSr_t;

#define GRFCSr_CLR(r) (r).grfcs[0] = 0
#define GRFCSr_SET(r,d) (r).grfcs[0] = d
#define GRFCSr_GET(r) (r).grfcs[0]


/*
 * These macros can be used to access GRFCS.
 */
#define WRITE_GRFCSr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GRFCS(bcm5354x_gport_lport_to_index_in_block[p]), (r._grfcs))
#define READ_GRFCSr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GRFCS(bcm5354x_gport_lport_to_index_in_block[p]), &(r._grfcs))

/*******************************************************************************
 * End of 'GRFCSr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GRMCA
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Receive Multicast Frame Counter
 * SIZE:     32
 */
#define GRMCAr_SIZE 4

/*
 * This structure should be used to declare and program GRMCA.
 */
typedef union GRMCAr_s {
	uint32 v[1];
	uint32 grmca[1];
	uint32 _grmca;
} GRMCAr_t;

#define GRMCAr_CLR(r) (r).grmca[0] = 0
#define GRMCAr_SET(r,d) (r).grmca[0] = d
#define GRMCAr_GET(r) (r).grmca[0]


/*
 * These macros can be used to access GRMCA.
 */
#define WRITE_GRMCAr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GRMCA(bcm5354x_gport_lport_to_index_in_block[p]), (r._grmca))
#define READ_GRMCAr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GRMCA(bcm5354x_gport_lport_to_index_in_block[p]), &(r._grmca))

/*******************************************************************************
 * End of 'GRMCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GROVR
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Receive Oversized Frame Counter
 * SIZE:     32
 */
#define GROVRr_SIZE 4

/*
 * This structure should be used to declare and program GROVR.
 */
typedef union GROVRr_s {
	uint32 v[1];
	uint32 grovr[1];
	uint32 _grovr;
} GROVRr_t;

#define GROVRr_CLR(r) (r).grovr[0] = 0
#define GROVRr_SET(r,d) (r).grovr[0] = d
#define GROVRr_GET(r) (r).grovr[0]


/*
 * These macros can be used to access GROVR.
 */
#define WRITE_GROVRr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GROVR(bcm5354x_gport_lport_to_index_in_block[p]), (r._grovr))
#define READ_GROVRr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GROVR(bcm5354x_gport_lport_to_index_in_block[p]), &(r._grovr))

/*******************************************************************************
 * End of 'GROVRr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GRPKT
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Receive frame Counter
 * SIZE:     32
 */
#define GRPKTr_SIZE 4

/*
 * This structure should be used to declare and program GRPKT.
 */
typedef union GRPKTr_s {
	uint32 v[1];
	uint32 grpkt[1];
	uint32 _grpkt;
} GRPKTr_t;

#define GRPKTr_CLR(r) (r).grpkt[0] = 0
#define GRPKTr_SET(r,d) (r).grpkt[0] = d
#define GRPKTr_GET(r) (r).grpkt[0]


/*
 * These macros can be used to access GRPKT.
 */
#define WRITE_GRPKTr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GRPKT(bcm5354x_gport_lport_to_index_in_block[p]), (r._grpkt))
#define READ_GRPKTr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GRPKT(bcm5354x_gport_lport_to_index_in_block[p]), &(r._grpkt))

/*******************************************************************************
 * End of 'GRPKTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GRUC
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Receive Unicast Counter
 * SIZE:     32
 */
#define GRUCr_SIZE 4

/*
 * This structure should be used to declare and program GRUC.
 */
typedef union GRUCr_s {
	uint32 v[1];
	uint32 gruc[1];
	uint32 _gruc;
} GRUCr_t;

#define GRUCr_CLR(r) (r).gruc[0] = 0
#define GRUCr_SET(r,d) (r).gruc[0] = d
#define GRUCr_GET(r) (r).gruc[0]


/*
 * These macros can be used to access GRUC.
 */
#define WRITE_GRUCr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GRUC(bcm5354x_gport_lport_to_index_in_block[p]), (r._gruc))
#define READ_GRUCr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GRUC(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gruc))

/*******************************************************************************
 * End of 'GRUCr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GRXPF
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Receive Pause Frame Counter
 * SIZE:     32
 */
#define GRXPFr_SIZE 4

/*
 * This structure should be used to declare and program GRXPF.
 */
typedef union GRXPFr_s {
	uint32 v[1];
	uint32 grxpf[1];
	uint32 _grxpf;
} GRXPFr_t;

#define GRXPFr_CLR(r) (r).grxpf[0] = 0
#define GRXPFr_SET(r,d) (r).grxpf[0] = d
#define GRXPFr_GET(r) (r).grxpf[0]


/*
 * These macros can be used to access GRXPF.
 */
#define WRITE_GRXPFr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GRXPF(bcm5354x_gport_lport_to_index_in_block[p]), (r._grxpf))
#define READ_GRXPFr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GRXPF(bcm5354x_gport_lport_to_index_in_block[p]), &(r._grxpf))

/*******************************************************************************
 * End of 'GRXPFr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GRX_EEE_LPI_DURATION_COUNTER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     RX EEE LPI Duration Counter.
 * SIZE:     32
 */
#define GRX_EEE_LPI_DURATION_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program GRX_EEE_LPI_DURATION_COUNTER.
 */
typedef union GRX_EEE_LPI_DURATION_COUNTERr_s {
	uint32 v[1];
	uint32 grx_eee_lpi_duration_counter[1];
	uint32 _grx_eee_lpi_duration_counter;
} GRX_EEE_LPI_DURATION_COUNTERr_t;

#define GRX_EEE_LPI_DURATION_COUNTERr_CLR(r) (r).grx_eee_lpi_duration_counter[0] = 0
#define GRX_EEE_LPI_DURATION_COUNTERr_SET(r,d) (r).grx_eee_lpi_duration_counter[0] = d
#define GRX_EEE_LPI_DURATION_COUNTERr_GET(r) (r).grx_eee_lpi_duration_counter[0]


/*
 * These macros can be used to access GRX_EEE_LPI_DURATION_COUNTER.
 */
#define WRITE_GRX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GRX_EEE_LPI_DURATION_COUNTER(bcm5354x_gport_lport_to_index_in_block[p]), (r._grx_eee_lpi_duration_counter))
#define READ_GRX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GRX_EEE_LPI_DURATION_COUNTER(bcm5354x_gport_lport_to_index_in_block[p]), &(r._grx_eee_lpi_duration_counter))

/*******************************************************************************
 * End of 'GRX_EEE_LPI_DURATION_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GRX_EEE_LPI_EVENT_COUNTER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     RX EEE LPI Event Counter.
 * SIZE:     32
 */
#define GRX_EEE_LPI_EVENT_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program GRX_EEE_LPI_EVENT_COUNTER.
 */
typedef union GRX_EEE_LPI_EVENT_COUNTERr_s {
	uint32 v[1];
	uint32 grx_eee_lpi_event_counter[1];
	uint32 _grx_eee_lpi_event_counter;
} GRX_EEE_LPI_EVENT_COUNTERr_t;

#define GRX_EEE_LPI_EVENT_COUNTERr_CLR(r) (r).grx_eee_lpi_event_counter[0] = 0
#define GRX_EEE_LPI_EVENT_COUNTERr_SET(r,d) (r).grx_eee_lpi_event_counter[0] = d
#define GRX_EEE_LPI_EVENT_COUNTERr_GET(r) (r).grx_eee_lpi_event_counter[0]


/*
 * These macros can be used to access GRX_EEE_LPI_EVENT_COUNTER.
 */
#define WRITE_GRX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GRX_EEE_LPI_EVENT_COUNTER(bcm5354x_gport_lport_to_index_in_block[p]), (r._grx_eee_lpi_event_counter))
#define READ_GRX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GRX_EEE_LPI_EVENT_COUNTER(bcm5354x_gport_lport_to_index_in_block[p]), &(r._grx_eee_lpi_event_counter))

/*******************************************************************************
 * End of 'GRX_EEE_LPI_EVENT_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GTBCA
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Transmit Broadcast Frame Counter
 * SIZE:     32
 */
#define GTBCAr_SIZE 4

/*
 * This structure should be used to declare and program GTBCA.
 */
typedef union GTBCAr_s {
	uint32 v[1];
	uint32 gtbca[1];
	uint32 _gtbca;
} GTBCAr_t;

#define GTBCAr_CLR(r) (r).gtbca[0] = 0
#define GTBCAr_SET(r,d) (r).gtbca[0] = d
#define GTBCAr_GET(r) (r).gtbca[0]


/*
 * These macros can be used to access GTBCA.
 */
#define WRITE_GTBCAr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GTBCA(bcm5354x_gport_lport_to_index_in_block[p]), (r._gtbca))
#define READ_GTBCAr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GTBCA(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gtbca))

/*******************************************************************************
 * End of 'GTBCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GTBYT
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Transmit Byte Counter
 * SIZE:     32
 */
#define GTBYTr_SIZE 4

/*
 * This structure should be used to declare and program GTBYT.
 */
typedef union GTBYTr_s {
	uint32 v[1];
	uint32 gtbyt[1];
	uint32 _gtbyt;
} GTBYTr_t;

#define GTBYTr_CLR(r) (r).gtbyt[0] = 0
#define GTBYTr_SET(r,d) (r).gtbyt[0] = d
#define GTBYTr_GET(r) (r).gtbyt[0]


/*
 * These macros can be used to access GTBYT.
 */
#define WRITE_GTBYTr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GTBYT(bcm5354x_gport_lport_to_index_in_block[p]), (r._gtbyt))
#define READ_GTBYTr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GTBYT(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gtbyt))

/*******************************************************************************
 * End of 'GTBYTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GTFCS
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Transmit FCS Error Counter
 * SIZE:     32
 */
#define GTFCSr_SIZE 4

/*
 * This structure should be used to declare and program GTFCS.
 */
typedef union GTFCSr_s {
	uint32 v[1];
	uint32 gtfcs[1];
	uint32 _gtfcs;
} GTFCSr_t;

#define GTFCSr_CLR(r) (r).gtfcs[0] = 0
#define GTFCSr_SET(r,d) (r).gtfcs[0] = d
#define GTFCSr_GET(r) (r).gtfcs[0]


/*
 * These macros can be used to access GTFCS.
 */
#define WRITE_GTFCSr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GTFCS(bcm5354x_gport_lport_to_index_in_block[p]), (r._gtfcs))
#define READ_GTFCSr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GTFCS(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gtfcs))

/*******************************************************************************
 * End of 'GTFCSr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GTMCA
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Transmit Multicast Frame Counter
 * SIZE:     32
 */
#define GTMCAr_SIZE 4

/*
 * This structure should be used to declare and program GTMCA.
 */
typedef union GTMCAr_s {
	uint32 v[1];
	uint32 gtmca[1];
	uint32 _gtmca;
} GTMCAr_t;

#define GTMCAr_CLR(r) (r).gtmca[0] = 0
#define GTMCAr_SET(r,d) (r).gtmca[0] = d
#define GTMCAr_GET(r) (r).gtmca[0]


/*
 * These macros can be used to access GTMCA.
 */
#define WRITE_GTMCAr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GTMCA(bcm5354x_gport_lport_to_index_in_block[p]), (r._gtmca))
#define READ_GTMCAr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GTMCA(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gtmca))

/*******************************************************************************
 * End of 'GTMCAr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GTOVR
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Transmit Oversize Packet Counter
 * SIZE:     32
 */
#define GTOVRr_SIZE 4

/*
 * This structure should be used to declare and program GTOVR.
 */
typedef union GTOVRr_s {
	uint32 v[1];
	uint32 gtovr[1];
	uint32 _gtovr;
} GTOVRr_t;

#define GTOVRr_CLR(r) (r).gtovr[0] = 0
#define GTOVRr_SET(r,d) (r).gtovr[0] = d
#define GTOVRr_GET(r) (r).gtovr[0]


/*
 * These macros can be used to access GTOVR.
 */
#define WRITE_GTOVRr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GTOVR(bcm5354x_gport_lport_to_index_in_block[p]), (r._gtovr))
#define READ_GTOVRr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GTOVR(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gtovr))

/*******************************************************************************
 * End of 'GTOVRr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GTPKT
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Transmit frame Counter
 * SIZE:     32
 */
#define GTPKTr_SIZE 4

/*
 * This structure should be used to declare and program GTPKT.
 */
typedef union GTPKTr_s {
	uint32 v[1];
	uint32 gtpkt[1];
	uint32 _gtpkt;
} GTPKTr_t;

#define GTPKTr_CLR(r) (r).gtpkt[0] = 0
#define GTPKTr_SET(r,d) (r).gtpkt[0] = d
#define GTPKTr_GET(r) (r).gtpkt[0]


/*
 * These macros can be used to access GTPKT.
 */
#define WRITE_GTPKTr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GTPKT(bcm5354x_gport_lport_to_index_in_block[p]), (r._gtpkt))
#define READ_GTPKTr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GTPKT(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gtpkt))

/*******************************************************************************
 * End of 'GTPKTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GTUC
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Transmit Unicast Counter
 * SIZE:     32
 */
#define GTUCr_SIZE 4

/*
 * This structure should be used to declare and program GTUC.
 */
typedef union GTUCr_s {
	uint32 v[1];
	uint32 gtuc[1];
	uint32 _gtuc;
} GTUCr_t;

#define GTUCr_CLR(r) (r).gtuc[0] = 0
#define GTUCr_SET(r,d) (r).gtuc[0] = d
#define GTUCr_GET(r) (r).gtuc[0]


/*
 * These macros can be used to access GTUC.
 */
#define WRITE_GTUCr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GTUC(bcm5354x_gport_lport_to_index_in_block[p]), (r._gtuc))
#define READ_GTUCr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GTUC(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gtuc))

/*******************************************************************************
 * End of 'GTUCr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GTXPF
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Transmit Pause Control Frame Counter
 * SIZE:     32
 */
#define GTXPFr_SIZE 4

/*
 * This structure should be used to declare and program GTXPF.
 */
typedef union GTXPFr_s {
	uint32 v[1];
	uint32 gtxpf[1];
	uint32 _gtxpf;
} GTXPFr_t;

#define GTXPFr_CLR(r) (r).gtxpf[0] = 0
#define GTXPFr_SET(r,d) (r).gtxpf[0] = d
#define GTXPFr_GET(r) (r).gtxpf[0]


/*
 * These macros can be used to access GTXPF.
 */
#define WRITE_GTXPFr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GTXPF(bcm5354x_gport_lport_to_index_in_block[p]), (r._gtxpf))
#define READ_GTXPFr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GTXPF(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gtxpf))

/*******************************************************************************
 * End of 'GTXPFr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GTX_EEE_LPI_DURATION_COUNTER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     TX EEE LPI Duration Counter.
 * SIZE:     32
 */
#define GTX_EEE_LPI_DURATION_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program GTX_EEE_LPI_DURATION_COUNTER.
 */
typedef union GTX_EEE_LPI_DURATION_COUNTERr_s {
	uint32 v[1];
	uint32 gtx_eee_lpi_duration_counter[1];
	uint32 _gtx_eee_lpi_duration_counter;
} GTX_EEE_LPI_DURATION_COUNTERr_t;

#define GTX_EEE_LPI_DURATION_COUNTERr_CLR(r) (r).gtx_eee_lpi_duration_counter[0] = 0
#define GTX_EEE_LPI_DURATION_COUNTERr_SET(r,d) (r).gtx_eee_lpi_duration_counter[0] = d
#define GTX_EEE_LPI_DURATION_COUNTERr_GET(r) (r).gtx_eee_lpi_duration_counter[0]


/*
 * These macros can be used to access GTX_EEE_LPI_DURATION_COUNTER.
 */
#define WRITE_GTX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GTX_EEE_LPI_DURATION_COUNTER(bcm5354x_gport_lport_to_index_in_block[p]), (r._gtx_eee_lpi_duration_counter))
#define READ_GTX_EEE_LPI_DURATION_COUNTERr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GTX_EEE_LPI_DURATION_COUNTER(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gtx_eee_lpi_duration_counter))

/*******************************************************************************
 * End of 'GTX_EEE_LPI_DURATION_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  GTX_EEE_LPI_EVENT_COUNTER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     TX EEE LPI Event Counter.
 * SIZE:     32
 */
#define GTX_EEE_LPI_EVENT_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program GTX_EEE_LPI_EVENT_COUNTER.
 */
typedef union GTX_EEE_LPI_EVENT_COUNTERr_s {
	uint32 v[1];
	uint32 gtx_eee_lpi_event_counter[1];
	uint32 _gtx_eee_lpi_event_counter;
} GTX_EEE_LPI_EVENT_COUNTERr_t;

#define GTX_EEE_LPI_EVENT_COUNTERr_CLR(r) (r).gtx_eee_lpi_event_counter[0] = 0
#define GTX_EEE_LPI_EVENT_COUNTERr_SET(r,d) (r).gtx_eee_lpi_event_counter[0] = d
#define GTX_EEE_LPI_EVENT_COUNTERr_GET(r) (r).gtx_eee_lpi_event_counter[0]


/*
 * These macros can be used to access GTX_EEE_LPI_EVENT_COUNTER.
 */
#define WRITE_GTX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_GTX_EEE_LPI_EVENT_COUNTER(bcm5354x_gport_lport_to_index_in_block[p]), (r._gtx_eee_lpi_event_counter))
#define READ_GTX_EEE_LPI_EVENT_COUNTERr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_GTX_EEE_LPI_EVENT_COUNTER(bcm5354x_gport_lport_to_index_in_block[p]), &(r._gtx_eee_lpi_event_counter))

/*******************************************************************************
 * End of 'GTX_EEE_LPI_EVENT_COUNTERr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Hash Control Register
 * SIZE:     32
 * FIELDS:
 *     NON_UC_TRUNK_HASH_MOD_PORT_ENABLE If set to 1, enable factoring MOD_ID/port into non-unicast trunk block mask hashing
 *     NON_UC_TRUNK_HASH_SRC_ENABLE If set to 1, enable factoring source MAC or source IP into non-unicast trunk block mask hashing
 *     NON_UC_TRUNK_HASH_DST_ENABLE If set to 1, enable factoring destination MAC or destination IP into non-unicast trunk block mask hashing
 *     UC_TRUNK_HASH_USE_SRC_PORT If set to 1, use source port in unicast trunk hash
 *     ECMP_HASH_UDF    ECMP hash offset.
 *     ECMP_HASH_USE_DIP Use DIP for ECMP hashing.
 *     ECMP_HASH_SEL    Selects ECMP hashing algorithm.
 *     L2_AND_VLAN_MAC_HASH_SELECT Selects hashing algorithm used for L2 table lookups
 *     L3_HASH_SELECT   Selects hashing algorithm used for L3 table lookups
 *     ENABLE_DRACO1_5_HASH If set to 1, enable using Draco 1.5 hashing for unicast trunk
 *     USE_TCP_UDP_PORTS If set to 1, use TCP/UDP ports for unicast trunk hashing
 */
#define HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program HASH_CONTROL.
 */
typedef union HASH_CONTROLr_s {
	uint32 v[1];
	uint32 hash_control[1];
	uint32 _hash_control;
} HASH_CONTROLr_t;

#define HASH_CONTROLr_CLR(r) (r).hash_control[0] = 0
#define HASH_CONTROLr_SET(r,d) (r).hash_control[0] = d
#define HASH_CONTROLr_GET(r) (r).hash_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET(r) (((r).hash_control[0]) & 0x1)
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET(r) ((((r).hash_control[0]) >> 1) & 0x1)
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET(r) ((((r).hash_control[0]) >> 2) & 0x1)
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET(r) ((((r).hash_control[0]) >> 3) & 0x1)
#define HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define HASH_CONTROLr_ECMP_HASH_UDFf_GET(r) ((((r).hash_control[0]) >> 4) & 0xff)
#define HASH_CONTROLr_ECMP_HASH_UDFf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0xff << 4)) | ((((uint32)f) & 0xff) << 4))
#define HASH_CONTROLr_ECMP_HASH_USE_DIPf_GET(r) ((((r).hash_control[0]) >> 12) & 0x1)
#define HASH_CONTROLr_ECMP_HASH_USE_DIPf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define HASH_CONTROLr_ECMP_HASH_SELf_GET(r) ((((r).hash_control[0]) >> 13) & 0x3)
#define HASH_CONTROLr_ECMP_HASH_SELf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET(r) ((((r).hash_control[0]) >> 15) & 0x7)
#define HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define HASH_CONTROLr_L3_HASH_SELECTf_GET(r) ((((r).hash_control[0]) >> 18) & 0x7)
#define HASH_CONTROLr_L3_HASH_SELECTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET(r) ((((r).hash_control[0]) >> 21) & 0x1)
#define HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET(r) ((((r).hash_control[0]) >> 22) & 0x1)
#define HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))

/*
 * These macros can be used to access HASH_CONTROL.
 */
#define WRITE_HASH_CONTROLr(u,r) bcm5354x_reg_set(u,R_HASH_CONTROL,(r._hash_control))
#define READ_HASH_CONTROLr(u,r) bcm5354x_reg_get(u,R_HASH_CONTROL,&(r._hash_control))

/*******************************************************************************
 * End of 'HASH_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLCOSCELLMAXLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLMAXLIMIT     A queue can be put into HOL drop state when the HOL cell count reaches (>=) the value set in this register.
 *     CELLMAXRESUMELIMIT A queue can be brought out of HOL drop state due to reaching the max cell limit, when the HOL cell count goes below (<) the value set in this register.
 */
#define HOLCOSCELLMAXLIMITr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSCELLMAXLIMIT.
 */
typedef union HOLCOSCELLMAXLIMITr_s {
	uint32 v[1];
	uint32 holcoscellmaxlimit[1];
	uint32 _holcoscellmaxlimit;
} HOLCOSCELLMAXLIMITr_t;

#define HOLCOSCELLMAXLIMITr_CLR(r) (r).holcoscellmaxlimit[0] = 0
#define HOLCOSCELLMAXLIMITr_SET(r,d) (r).holcoscellmaxlimit[0] = d
#define HOLCOSCELLMAXLIMITr_GET(r) (r).holcoscellmaxlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSCELLMAXLIMITr_CELLMAXLIMITf_GET(r) (((r).holcoscellmaxlimit[0]) & 0xfff)
#define HOLCOSCELLMAXLIMITr_CELLMAXLIMITf_SET(r,f) (r).holcoscellmaxlimit[0]=(((r).holcoscellmaxlimit[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define HOLCOSCELLMAXLIMITr_CELLMAXRESUMELIMITf_GET(r) ((((r).holcoscellmaxlimit[0]) >> 12) & 0xfff)
#define HOLCOSCELLMAXLIMITr_CELLMAXRESUMELIMITf_SET(r,f) (r).holcoscellmaxlimit[0]=(((r).holcoscellmaxlimit[0] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))

/*
 * These macros can be used to access HOLCOSCELLMAXLIMIT.
 */
#define WRITE_HOLCOSCELLMAXLIMITr(u,p, cos,r) bcm5354x_reg_set(u, R_HOLCOSCELLMAXLIMIT(cos,p), (r._holcoscellmaxlimit))
#define READ_HOLCOSCELLMAXLIMITr(u,p, cos,r) bcm5354x_reg_get(u,R_HOLCOSCELLMAXLIMIT(cos,p),&(r._holcoscellmaxlimit))

/*******************************************************************************
 * End of 'HOLCOSCELLMAXLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLCOSMINXQCNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     HOLCOSMINXQCNT   Number of reserved XQ packet pointers for a COS/egress port. This register is required to avoid starvation. If other COS queues have consumed all the dynamic XQ pointers, traffic should keep flowing for this COS.HOLCOSPKTSETLIMIT.PKTSETLIMIT must be greater than the HOLCOSMINXQCNT in order to make use of the dynamic XQ pointers. The value in this register should be greater than the MISCCONFIG.SKIDMARKER.
 */
#define HOLCOSMINXQCNTr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSMINXQCNT.
 */
typedef union HOLCOSMINXQCNTr_s {
	uint32 v[1];
	uint32 holcosminxqcnt[1];
	uint32 _holcosminxqcnt;
} HOLCOSMINXQCNTr_t;

#define HOLCOSMINXQCNTr_CLR(r) (r).holcosminxqcnt[0] = 0
#define HOLCOSMINXQCNTr_SET(r,d) (r).holcosminxqcnt[0] = d
#define HOLCOSMINXQCNTr_GET(r) (r).holcosminxqcnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSMINXQCNTr_HOLCOSMINXQCNTf_GET(r) (((r).holcosminxqcnt[0]) & 0x1ff)
#define HOLCOSMINXQCNTr_HOLCOSMINXQCNTf_SET(r,f) (r).holcosminxqcnt[0]=(((r).holcosminxqcnt[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))

/*
 * These macros can be used to access HOLCOSMINXQCNT.
 */
#define WRITE_HOLCOSMINXQCNTr(u,p, cos,r) bcm5354x_reg_set(u, R_HOLCOSMINXQCNT(cos,p), (r._holcosminxqcnt))
#define READ_HOLCOSMINXQCNTr(u,p, cos,r) bcm5354x_reg_get(u,R_HOLCOSMINXQCNT(cos,p),&(r._holcosminxqcnt))

/*******************************************************************************
 * End of 'HOLCOSMINXQCNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLCOSPKTRESETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTRESETLIMIT    HOL for a COSn will be de-activated when packet count for COSn is smallerthan value in this register. Default value is half of packet set limit
 */
#define HOLCOSPKTRESETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSPKTRESETLIMIT.
 */
typedef union HOLCOSPKTRESETLIMITr_s {
	uint32 v[1];
	uint32 holcospktresetlimit[1];
	uint32 _holcospktresetlimit;
} HOLCOSPKTRESETLIMITr_t;

#define HOLCOSPKTRESETLIMITr_CLR(r) (r).holcospktresetlimit[0] = 0
#define HOLCOSPKTRESETLIMITr_SET(r,d) (r).holcospktresetlimit[0] = d
#define HOLCOSPKTRESETLIMITr_GET(r) (r).holcospktresetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSPKTRESETLIMITr_PKTRESETLIMITf_GET(r) (((r).holcospktresetlimit[0]) & 0x1ff)
#define HOLCOSPKTRESETLIMITr_PKTRESETLIMITf_SET(r,f) (r).holcospktresetlimit[0]=(((r).holcospktresetlimit[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))

/*
 * These macros can be used to access HOLCOSPKTRESETLIMIT.
 */
#define WRITE_HOLCOSPKTRESETLIMITr(u,p, cos,r) bcm5354x_reg_set(u, R_HOLCOSPKTRESETLIMIT(cos,p), (r._holcospktresetlimit))
#define READ_HOLCOSPKTRESETLIMITr(u,p, cos,r) bcm5354x_reg_get(u,R_HOLCOSPKTRESETLIMIT(cos,p),&(r._holcospktresetlimit))

/*******************************************************************************
 * End of 'HOLCOSPKTRESETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLCOSPKTSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      HOL for a COSn will be activated when packet count for COSn is greater than or equal to the value in this register. Note: Do not modify this register when traffic is active 
 */
#define HOLCOSPKTSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSPKTSETLIMIT.
 */
typedef union HOLCOSPKTSETLIMITr_s {
	uint32 v[1];
	uint32 holcospktsetlimit[1];
	uint32 _holcospktsetlimit;
} HOLCOSPKTSETLIMITr_t;

#define HOLCOSPKTSETLIMITr_CLR(r) (r).holcospktsetlimit[0] = 0
#define HOLCOSPKTSETLIMITr_SET(r,d) (r).holcospktsetlimit[0] = d
#define HOLCOSPKTSETLIMITr_GET(r) (r).holcospktsetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLCOSPKTSETLIMITr_PKTSETLIMITf_GET(r) (((r).holcospktsetlimit[0]) & 0x1ff)
#define HOLCOSPKTSETLIMITr_PKTSETLIMITf_SET(r,f) (r).holcospktsetlimit[0]=(((r).holcospktsetlimit[0] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))

/*
 * These macros can be used to access HOLCOSPKTSETLIMIT.
 */
#define WRITE_HOLCOSPKTSETLIMITr(u,p, cos,r) bcm5354x_reg_set(u, R_HOLCOSPKTSETLIMIT(cos,p), (r._holcospktsetlimit))
#define READ_HOLCOSPKTSETLIMITr(u,p, cos,r) bcm5354x_reg_get(u,R_HOLCOSPKTSETLIMIT(cos,p),&(r._holcospktsetlimit))

/*******************************************************************************
 * End of 'HOLCOSPKTSETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLD_COS
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS0 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 */
#define HOLD_COSr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS.
 */
typedef union HOLD_COSr_s {
	uint32 v[1];
	uint32 hold_cos[1];
	uint32 _hold_cos;
} HOLD_COSr_t;

#define HOLD_COSr_CLR(r) (r).hold_cos[0] = 0
#define HOLD_COSr_SET(r,d) (r).hold_cos[0] = d
#define HOLD_COSr_GET(r) (r).hold_cos[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLD_COSr_COUNTf_GET(r) (((r).hold_cos[0]) & 0x3ffffff)
#define HOLD_COSr_COUNTf_SET(r,f) (r).hold_cos[0]=(((r).hold_cos[0] & ~((uint32)0x3ffffff)) | (((uint32)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS.
 */
#define WRITE_HOLD_COSr(u,i,r) bcm5354x_reg_set(u,R_HOLD_COS(i),(r._hold_cos))
#define READ_HOLD_COSr(u,i,r) bcm5354x_reg_get(u,R_HOLD_COS(i),&(r._hold_cos))

/*******************************************************************************
 * End of 'HOLD_COSr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLD_COS0
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS0 Counter
 * SIZE:     32
 */
#define HOLD_COS0r_SIZE 4

/* HOLD_COS0r is element of HOLD_COS */

/*
 * This structure should be used to declare and program HOLD_COS0.
 */
typedef union HOLD_COS0r_s {
	uint32 v[1];
	uint32 hold_cos0[1];
	uint32 _hold_cos0;
} HOLD_COS0r_t;

#define HOLD_COS0r_CLR(r) (r).hold_cos0[0] = 0
#define HOLD_COS0r_SET(r,d) (r).hold_cos0[0] = d
#define HOLD_COS0r_GET(r) (r).hold_cos0[0]


/*
 * These macros can be used to access HOLD_COS0.
 */
#define WRITE_HOLD_COS0r(u,r) bcm5354x_reg_set(u,R_HOLD_COS0,(r._hold_cos0))
#define READ_HOLD_COS0r(u,r) bcm5354x_reg_get(u,R_HOLD_COS0,&(r._hold_cos0))

/*******************************************************************************
 * End of 'HOLD_COS0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLD_COS1
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS1 Counter
 * SIZE:     32
 */
#define HOLD_COS1r_SIZE 4

/* HOLD_COS1r is element of HOLD_COS */

/*
 * This structure should be used to declare and program HOLD_COS1.
 */
typedef union HOLD_COS1r_s {
	uint32 v[1];
	uint32 hold_cos1[1];
	uint32 _hold_cos1;
} HOLD_COS1r_t;

#define HOLD_COS1r_CLR(r) (r).hold_cos1[0] = 0
#define HOLD_COS1r_SET(r,d) (r).hold_cos1[0] = d
#define HOLD_COS1r_GET(r) (r).hold_cos1[0]


/*
 * These macros can be used to access HOLD_COS1.
 */
#define WRITE_HOLD_COS1r(u,r) bcm5354x_reg_set(u,R_HOLD_COS1,(r._hold_cos1))
#define READ_HOLD_COS1r(u,r) bcm5354x_reg_get(u,R_HOLD_COS1,&(r._hold_cos1))

/*******************************************************************************
 * End of 'HOLD_COS1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLD_COS2
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS2 Counter
 * SIZE:     32
 */
#define HOLD_COS2r_SIZE 4

/* HOLD_COS2r is element of HOLD_COS */

/*
 * This structure should be used to declare and program HOLD_COS2.
 */
typedef union HOLD_COS2r_s {
	uint32 v[1];
	uint32 hold_cos2[1];
	uint32 _hold_cos2;
} HOLD_COS2r_t;

#define HOLD_COS2r_CLR(r) (r).hold_cos2[0] = 0
#define HOLD_COS2r_SET(r,d) (r).hold_cos2[0] = d
#define HOLD_COS2r_GET(r) (r).hold_cos2[0]


/*
 * These macros can be used to access HOLD_COS2.
 */
#define WRITE_HOLD_COS2r(u,r) bcm5354x_reg_set(u,R_HOLD_COS2,(r._hold_cos2))
#define READ_HOLD_COS2r(u,r) bcm5354x_reg_get(u,R_HOLD_COS2,&(r._hold_cos2))

/*******************************************************************************
 * End of 'HOLD_COS2r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLD_COS3
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS3 Counter
 * SIZE:     32
 */
#define HOLD_COS3r_SIZE 4

/* HOLD_COS3r is element of HOLD_COS */

/*
 * This structure should be used to declare and program HOLD_COS3.
 */
typedef union HOLD_COS3r_s {
	uint32 v[1];
	uint32 hold_cos3[1];
	uint32 _hold_cos3;
} HOLD_COS3r_t;

#define HOLD_COS3r_CLR(r) (r).hold_cos3[0] = 0
#define HOLD_COS3r_SET(r,d) (r).hold_cos3[0] = d
#define HOLD_COS3r_GET(r) (r).hold_cos3[0]


/*
 * These macros can be used to access HOLD_COS3.
 */
#define WRITE_HOLD_COS3r(u,r) bcm5354x_reg_set(u,R_HOLD_COS3,(r._hold_cos3))
#define READ_HOLD_COS3r(u,r) bcm5354x_reg_get(u,R_HOLD_COS3,&(r._hold_cos3))

/*******************************************************************************
 * End of 'HOLD_COS3r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLD_COS4
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS4 Counter
 * SIZE:     32
 */
#define HOLD_COS4r_SIZE 4

/* HOLD_COS4r is element of HOLD_COS */

/*
 * This structure should be used to declare and program HOLD_COS4.
 */
typedef union HOLD_COS4r_s {
	uint32 v[1];
	uint32 hold_cos4[1];
	uint32 _hold_cos4;
} HOLD_COS4r_t;

#define HOLD_COS4r_CLR(r) (r).hold_cos4[0] = 0
#define HOLD_COS4r_SET(r,d) (r).hold_cos4[0] = d
#define HOLD_COS4r_GET(r) (r).hold_cos4[0]


/*
 * These macros can be used to access HOLD_COS4.
 */
#define WRITE_HOLD_COS4r(u,r) bcm5354x_reg_set(u,R_HOLD_COS4,(r._hold_cos4))
#define READ_HOLD_COS4r(u,r) bcm5354x_reg_get(u,R_HOLD_COS4,&(r._hold_cos4))

/*******************************************************************************
 * End of 'HOLD_COS4r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLD_COS5
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS5 Counter
 * SIZE:     32
 */
#define HOLD_COS5r_SIZE 4

/* HOLD_COS5r is element of HOLD_COS */

/*
 * This structure should be used to declare and program HOLD_COS5.
 */
typedef union HOLD_COS5r_s {
	uint32 v[1];
	uint32 hold_cos5[1];
	uint32 _hold_cos5;
} HOLD_COS5r_t;

#define HOLD_COS5r_CLR(r) (r).hold_cos5[0] = 0
#define HOLD_COS5r_SET(r,d) (r).hold_cos5[0] = d
#define HOLD_COS5r_GET(r) (r).hold_cos5[0]


/*
 * These macros can be used to access HOLD_COS5.
 */
#define WRITE_HOLD_COS5r(u,r) bcm5354x_reg_set(u,R_HOLD_COS5,(r._hold_cos5))
#define READ_HOLD_COS5r(u,r) bcm5354x_reg_get(u,R_HOLD_COS5,&(r._hold_cos5))

/*******************************************************************************
 * End of 'HOLD_COS5r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLD_COS6
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS6 Counter
 * SIZE:     32
 */
#define HOLD_COS6r_SIZE 4

/* HOLD_COS6r is element of HOLD_COS */

/*
 * This structure should be used to declare and program HOLD_COS6.
 */
typedef union HOLD_COS6r_s {
	uint32 v[1];
	uint32 hold_cos6[1];
	uint32 _hold_cos6;
} HOLD_COS6r_t;

#define HOLD_COS6r_CLR(r) (r).hold_cos6[0] = 0
#define HOLD_COS6r_SET(r,d) (r).hold_cos6[0] = d
#define HOLD_COS6r_GET(r) (r).hold_cos6[0]


/*
 * These macros can be used to access HOLD_COS6.
 */
#define WRITE_HOLD_COS6r(u,r) bcm5354x_reg_set(u,R_HOLD_COS6,(r._hold_cos6))
#define READ_HOLD_COS6r(u,r) bcm5354x_reg_get(u,R_HOLD_COS6,&(r._hold_cos6))

/*******************************************************************************
 * End of 'HOLD_COS6r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLD_COS7
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS7 Counter
 * SIZE:     32
 */
#define HOLD_COS7r_SIZE 4

/* HOLD_COS7r is element of HOLD_COS */

/*
 * This structure should be used to declare and program HOLD_COS7.
 */
typedef union HOLD_COS7r_s {
	uint32 v[1];
	uint32 hold_cos7[1];
	uint32 _hold_cos7;
} HOLD_COS7r_t;

#define HOLD_COS7r_CLR(r) (r).hold_cos7[0] = 0
#define HOLD_COS7r_SET(r,d) (r).hold_cos7[0] = d
#define HOLD_COS7r_GET(r) (r).hold_cos7[0]


/*
 * These macros can be used to access HOLD_COS7.
 */
#define WRITE_HOLD_COS7r(u,r) bcm5354x_reg_set(u,R_HOLD_COS7,(r._hold_cos7))
#define READ_HOLD_COS7r(u,r) bcm5354x_reg_get(u,R_HOLD_COS7,&(r._hold_cos7))

/*******************************************************************************
 * End of 'HOLD_COS7r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  HOLD_COS_PORT_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS Counter Port Select Register
 * SIZE:     32
 * FIELDS:
 *     PORT_NUM         Port number
 */
#define HOLD_COS_PORT_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS_PORT_SELECT.
 */
typedef union HOLD_COS_PORT_SELECTr_s {
	uint32 v[1];
	uint32 hold_cos_port_select[1];
	uint32 _hold_cos_port_select;
} HOLD_COS_PORT_SELECTr_t;

#define HOLD_COS_PORT_SELECTr_CLR(r) (r).hold_cos_port_select[0] = 0
#define HOLD_COS_PORT_SELECTr_SET(r,d) (r).hold_cos_port_select[0] = d
#define HOLD_COS_PORT_SELECTr_GET(r) (r).hold_cos_port_select[0]

/*
 * These macros can be used to access individual fields.
 */
#define HOLD_COS_PORT_SELECTr_PORT_NUMf_GET(r) (((r).hold_cos_port_select[0]) & 0x1f)
#define HOLD_COS_PORT_SELECTr_PORT_NUMf_SET(r,f) (r).hold_cos_port_select[0]=(((r).hold_cos_port_select[0] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))

/*
 * These macros can be used to access HOLD_COS_PORT_SELECT.
 */
#define WRITE_HOLD_COS_PORT_SELECTr(u,r) bcm5354x_reg_set(u,R_HOLD_COS_PORT_SELECT,(r._hold_cos_port_select))
#define READ_HOLD_COS_PORT_SELECTr(u,r) bcm5354x_reg_get(u,R_HOLD_COS_PORT_SELECT,&(r._hold_cos_port_select))

/*******************************************************************************
 * End of 'HOLD_COS_PORT_SELECTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  IARB_TDM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     TDM TABLE configuration
 * SIZE:     32
 * FIELDS:
 *     DISABLE          Disable TDM, set to 1 when changing tdm_mode or slot mapping
 *     TDM_WRAP_PTR     Indicates max valid entry in the TDM TABLE
 *     IDLE_PORT_NUM_SEL If 1, drives logic port 63 as IDLE port number on ipad bus, else drives logic port 0.
 */
#define IARB_TDM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IARB_TDM_CONTROL.
 */
typedef union IARB_TDM_CONTROLr_s {
	uint32 v[1];
	uint32 iarb_tdm_control[1];
	uint32 _iarb_tdm_control;
} IARB_TDM_CONTROLr_t;

#define IARB_TDM_CONTROLr_CLR(r) (r).iarb_tdm_control[0] = 0
#define IARB_TDM_CONTROLr_SET(r,d) (r).iarb_tdm_control[0] = d
#define IARB_TDM_CONTROLr_GET(r) (r).iarb_tdm_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define IARB_TDM_CONTROLr_DISABLEf_GET(r) (((r).iarb_tdm_control[0]) & 0x1)
#define IARB_TDM_CONTROLr_DISABLEf_SET(r,f) (r).iarb_tdm_control[0]=(((r).iarb_tdm_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define IARB_TDM_CONTROLr_TDM_WRAP_PTRf_GET(r) ((((r).iarb_tdm_control[0]) >> 1) & 0x7f)
#define IARB_TDM_CONTROLr_TDM_WRAP_PTRf_SET(r,f) (r).iarb_tdm_control[0]=(((r).iarb_tdm_control[0] & ~((uint32)0x7f << 1)) | ((((uint32)f) & 0x7f) << 1))
#define IARB_TDM_CONTROLr_IDLE_PORT_NUM_SELf_GET(r) ((((r).iarb_tdm_control[0]) >> 8) & 0x1)
#define IARB_TDM_CONTROLr_IDLE_PORT_NUM_SELf_SET(r,f) (r).iarb_tdm_control[0]=(((r).iarb_tdm_control[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))

/*
 * These macros can be used to access IARB_TDM_CONTROL.
 */
#define WRITE_IARB_TDM_CONTROLr(u,r) bcm5354x_reg_set(u,R_IARB_TDM_CONTROL,(r._iarb_tdm_control))
#define READ_IARB_TDM_CONTROLr(u,r) bcm5354x_reg_get(u,R_IARB_TDM_CONTROL,&(r._iarb_tdm_control))

/*******************************************************************************
 * End of 'IARB_TDM_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  IARB_TDM_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Arbiter TDM Table. Must be programmed with the values specified in SDK per index as part of initialization before traffic is enabled 
 * SIZE:     7
 * FIELDS:
 *     PORT_NUM         Indicates port number id. Valid values are 0-30. Value 30 means IDLE slot. Value as programmed in SDK.
 *     RESERVED0        Reserved. Need to be programmed as zero.
 */
#define IARB_TDM_TABLEm_MIN 0
#define IARB_TDM_TABLEm_MAX 127
#define IARB_TDM_TABLEm_CMAX(u) 127
#define IARB_TDM_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program IARB_TDM_TABLE.
 */
typedef union IARB_TDM_TABLEm_s {
	uint32 v[1];
	uint32 iarb_tdm_table[1];
	uint32 _iarb_tdm_table;
} IARB_TDM_TABLEm_t;

#define IARB_TDM_TABLEm_CLR(r) (r).iarb_tdm_table[0] = 0
#define IARB_TDM_TABLEm_SET(r,d) (r).iarb_tdm_table[0] = d
#define IARB_TDM_TABLEm_GET(r) (r).iarb_tdm_table[0]

/*
 * These macros can be used to access individual fields.
 */
#define IARB_TDM_TABLEm_PORT_NUMf_GET(r) (((r).iarb_tdm_table[0]) & 0x3f)
#define IARB_TDM_TABLEm_PORT_NUMf_SET(r,f) (r).iarb_tdm_table[0]=(((r).iarb_tdm_table[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define IARB_TDM_TABLEm_RESERVED0f_GET(r) ((((r).iarb_tdm_table[0]) >> 6) & 0x1)
#define IARB_TDM_TABLEm_RESERVED0f_SET(r,f) (r).iarb_tdm_table[0]=(((r).iarb_tdm_table[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))

/*
 * These macros can be used to access IARB_TDM_TABLE.
 */
#define WRITE_IARB_TDM_TABLEm(u,i,r) bcm5354x_mem_set(u, M_IARB_TDM_TABLE(i), &(r._iarb_tdm_table), 1)
#define READ_IARB_TDM_TABLEm(u,i,r) bcm5354x_mem_get(u, M_IARB_TDM_TABLE(i), &(r._iarb_tdm_table), 1)

/*******************************************************************************
 * End of 'IARB_TDM_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  IBPPKTSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      Ingress Back Pressure thresholdThis is the number of packets an ingress port (IBPPKTCOUNT) may have in the system before entering Back Pressure state.(criterion: IBPPKTCOUNT>=PKTSETLIMIT)This will work at both PAUSE mode and PFC mode.Note: Do not modify this register when traffic is active 
 *     RESETLIMITSEL    IBP Packet Reset Threshold SelectWhen Back pressure status is set, packet counts have to fall below Reset Threshold in order to clear BKP status. (criterion: IBPPKTCOUNT<selected threshold))0: 75.0% of IBP Packet Set Limit.1: 50.0% of IBP Packet Set Limit.  2: 25.0% of IBP Packet Set Limit.  3: 100% of IBP Packet Set Limit.  This will work at both PAUSE mode and PFC mode.Note: Do not modify this register when traffic is active 
 */
#define IBPPKTSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program IBPPKTSETLIMIT.
 */
typedef union IBPPKTSETLIMITr_s {
	uint32 v[1];
	uint32 ibppktsetlimit[1];
	uint32 _ibppktsetlimit;
} IBPPKTSETLIMITr_t;

#define IBPPKTSETLIMITr_CLR(r) (r).ibppktsetlimit[0] = 0
#define IBPPKTSETLIMITr_SET(r,d) (r).ibppktsetlimit[0] = d
#define IBPPKTSETLIMITr_GET(r) (r).ibppktsetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define IBPPKTSETLIMITr_PKTSETLIMITf_GET(r) (((r).ibppktsetlimit[0]) & 0xfff)
#define IBPPKTSETLIMITr_PKTSETLIMITf_SET(r,f) (r).ibppktsetlimit[0]=(((r).ibppktsetlimit[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define IBPPKTSETLIMITr_RESETLIMITSELf_GET(r) ((((r).ibppktsetlimit[0]) >> 12) & 0x3)
#define IBPPKTSETLIMITr_RESETLIMITSELf_SET(r,f) (r).ibppktsetlimit[0]=(((r).ibppktsetlimit[0] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))

/*
 * These macros can be used to access IBPPKTSETLIMIT.
 */
#define WRITE_IBPPKTSETLIMITr(u,p,r) bcm5354x_reg_set(u,R_IBPPKTSETLIMIT(p),(r._ibppktsetlimit))
#define READ_IBPPKTSETLIMITr(u,p,r) bcm5354x_reg_get(u,R_IBPPKTSETLIMIT(p),&(r._ibppktsetlimit))

/*******************************************************************************
 * End of 'IBPPKTSETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  IFP_REDIRECTION_PROFILE
 * BLOCKS:   IPIPE
 * DESC:     This table is used to specify redirect information for a redirect action that came from the IFP. The index to this table is specified by the FP_POLICY_TABLE.REDIRECTION field
 * SIZE:     56
 * FIELDS:
 *     BITMAP           ContentAware Engine redirection port bitmap. May be used for either port_bitmap or l3_bitmap, depending on the ContentAware Engine action.
 *     BITMAP_LO        Overlay bitmap for ports 31:0
 *     MC_INDEX         When FP redirection is to an IPMC or L2MC group, then this field gives the multicast index
 *     RESERVED_1       RESERVED
 *     HIGIG_TRUNK_OVERRIDE When ContentAware Engine redirection is to a broadcast outgoing VLAN, then this field gives the HiGig trunk override value.
 *     RESERVED         RESERVED
 */
#define IFP_REDIRECTION_PROFILEm_MIN 0
#define IFP_REDIRECTION_PROFILEm_MAX 255
#define IFP_REDIRECTION_PROFILEm_CMAX(u) 255
#define IFP_REDIRECTION_PROFILEm_SIZE 7

/*
 * This structure should be used to declare and program IFP_REDIRECTION_PROFILE.
 */
typedef union IFP_REDIRECTION_PROFILEm_s {
	uint32 v[2];
	uint32 ifp_redirection_profile[2];
	uint32 _ifp_redirection_profile;
} IFP_REDIRECTION_PROFILEm_t;

#define IFP_REDIRECTION_PROFILEm_CLR(r) sal_memset(&((r)._ifp_redirection_profile), 0, sizeof(IFP_REDIRECTION_PROFILEm_t))
#define IFP_REDIRECTION_PROFILEm_SET(r,i,d) (r).ifp_redirection_profile[i] = d
#define IFP_REDIRECTION_PROFILEm_GET(r,i) (r).ifp_redirection_profile[i]

/*
 * These macros can be used to access individual fields.
 */
#define IFP_REDIRECTION_PROFILEm_BITMAPf_GET(r) ((r).ifp_redirection_profile[0])
#define IFP_REDIRECTION_PROFILEm_BITMAPf_SET(r,f) (r).ifp_redirection_profile[0]=((uint32)f)
#define IFP_REDIRECTION_PROFILEm_BITMAP_LOf_GET(r) ((r).ifp_redirection_profile[0])
#define IFP_REDIRECTION_PROFILEm_BITMAP_LOf_SET(r,f) (r).ifp_redirection_profile[0]=((uint32)f)
#define IFP_REDIRECTION_PROFILEm_MC_INDEXf_GET(r) (((r).ifp_redirection_profile[1]) & 0x1ff)
#define IFP_REDIRECTION_PROFILEm_MC_INDEXf_SET(r,f) (r).ifp_redirection_profile[1]=(((r).ifp_redirection_profile[1] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define IFP_REDIRECTION_PROFILEm_RESERVED_1f_GET(r) ((((r).ifp_redirection_profile[1]) >> 9) & 0x7)
#define IFP_REDIRECTION_PROFILEm_RESERVED_1f_SET(r,f) (r).ifp_redirection_profile[1]=(((r).ifp_redirection_profile[1] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define IFP_REDIRECTION_PROFILEm_HIGIG_TRUNK_OVERRIDEf_GET(r) ((((r).ifp_redirection_profile[1]) >> 12) & 0x1)
#define IFP_REDIRECTION_PROFILEm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).ifp_redirection_profile[1]=(((r).ifp_redirection_profile[1] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define IFP_REDIRECTION_PROFILEm_RESERVEDf_GET(r) ((((r).ifp_redirection_profile[1]) >> 13) & 0x7ff)
#define IFP_REDIRECTION_PROFILEm_RESERVEDf_SET(r,f) (r).ifp_redirection_profile[1]=(((r).ifp_redirection_profile[1] & ~((uint32)0x7ff << 13)) | ((((uint32)f) & 0x7ff) << 13))

/*
 * These macros can be used to access IFP_REDIRECTION_PROFILE.
 */
#define WRITE_IFP_REDIRECTION_PROFILEm(u,i,r) bcm5354x_mem_set(u, M_IFP_REDIRECTION_PROFILE(i), &(r._ifp_redirection_profile), 2)
#define READ_IFP_REDIRECTION_PROFILEm(u,i,r) bcm5354x_mem_get(u, M_IFP_REDIRECTION_PROFILE(i), &(r._ifp_redirection_profile), 2)

/*******************************************************************************
 * End of 'IFP_REDIRECTION_PROFILEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  IFP_SINGLE_WIDE_F1_0
 * BLOCKS:  
 * DESC:     Position and description of bits in FP FIELDS
 * SIZE:     37
 * FIELDS:
 *     CLASSIDS         CLASSIDS 
 *     FORWARDING_FIELD FORWARDING_FIELD 
 *     SVP_L3_IIF       SVP_L3_IIF 
 */
#define IFP_SINGLE_WIDE_F1_0_SIZE 5

/*
 * This structure should be used to declare and program IFP_SINGLE_WIDE_F1_0.
 */
typedef union IFP_SINGLE_WIDE_F1_0_s {
	uint32 v[2];
	uint32 ifp_single_wide_f1_0[2];
	uint32 _ifp_single_wide_f1_0;
} IFP_SINGLE_WIDE_F1_0_t;

#define IFP_SINGLE_WIDE_F1_0_CLR(r) sal_memset(&((r)._ifp_single_wide_f1_0), 0, sizeof(IFP_SINGLE_WIDE_F1_0_t))
#define IFP_SINGLE_WIDE_F1_0_SET(r,i,d) (r).ifp_single_wide_f1_0[i] = d
#define IFP_SINGLE_WIDE_F1_0_GET(r,i) (r).ifp_single_wide_f1_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define IFP_SINGLE_WIDE_F1_0_CLASSIDSf_GET(r) (((r).ifp_single_wide_f1_0[0]) & 0xfff)
#define IFP_SINGLE_WIDE_F1_0_CLASSIDSf_SET(r,f) (r).ifp_single_wide_f1_0[0]=(((r).ifp_single_wide_f1_0[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define IFP_SINGLE_WIDE_F1_0_FORWARDING_FIELDf_GET(r) ((((r).ifp_single_wide_f1_0[0]) >> 12) & 0xfff)
#define IFP_SINGLE_WIDE_F1_0_FORWARDING_FIELDf_SET(r,f) (r).ifp_single_wide_f1_0[0]=(((r).ifp_single_wide_f1_0[0] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))
#define IFP_SINGLE_WIDE_F1_0_SVP_L3_IIFf_GET(r) field32_get((r).ifp_single_wide_f1_0,24,36)
#define IFP_SINGLE_WIDE_F1_0_SVP_L3_IIFf_SET(r,f) field32_set((r).ifp_single_wide_f1_0,24,36,f)

/*******************************************************************************
 * End of 'IFP_SINGLE_WIDE_F1_0'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  IFP_SINGLE_WIDE_F1_4
 * BLOCKS:  
 * DESC:     Position and description of bits in FP FIELDS
 * SIZE:     37
 * FIELDS:
 *     OUTER_VLAN_TAG   OUTER_VLAN_TAG 
 *     ETHERTYPE        ETHERTYPE 
 *     SPARE            SPARE 
 */
#define IFP_SINGLE_WIDE_F1_4_SIZE 5

/*
 * This structure should be used to declare and program IFP_SINGLE_WIDE_F1_4.
 */
typedef union IFP_SINGLE_WIDE_F1_4_s {
	uint32 v[2];
	uint32 ifp_single_wide_f1_4[2];
	uint32 _ifp_single_wide_f1_4;
} IFP_SINGLE_WIDE_F1_4_t;

#define IFP_SINGLE_WIDE_F1_4_CLR(r) sal_memset(&((r)._ifp_single_wide_f1_4), 0, sizeof(IFP_SINGLE_WIDE_F1_4_t))
#define IFP_SINGLE_WIDE_F1_4_SET(r,i,d) (r).ifp_single_wide_f1_4[i] = d
#define IFP_SINGLE_WIDE_F1_4_GET(r,i) (r).ifp_single_wide_f1_4[i]

/*
 * These macros can be used to access individual fields.
 */
#define IFP_SINGLE_WIDE_F1_4_OUTER_VLAN_TAGf_GET(r) (((r).ifp_single_wide_f1_4[0]) & 0xffff)
#define IFP_SINGLE_WIDE_F1_4_OUTER_VLAN_TAGf_SET(r,f) (r).ifp_single_wide_f1_4[0]=(((r).ifp_single_wide_f1_4[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define IFP_SINGLE_WIDE_F1_4_ETHERTYPEf_GET(r) ((((r).ifp_single_wide_f1_4[0]) >> 16) & 0xffff)
#define IFP_SINGLE_WIDE_F1_4_ETHERTYPEf_SET(r,f) (r).ifp_single_wide_f1_4[0]=(((r).ifp_single_wide_f1_4[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))
#define IFP_SINGLE_WIDE_F1_4_SPAREf_GET(r) (((r).ifp_single_wide_f1_4[1]) & 0x1f)
#define IFP_SINGLE_WIDE_F1_4_SPAREf_SET(r,f) (r).ifp_single_wide_f1_4[1]=(((r).ifp_single_wide_f1_4[1] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))

/*******************************************************************************
 * End of 'IFP_SINGLE_WIDE_F1_4'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  IFP_SINGLE_WIDE_F2_0
 * BLOCKS:  
 * DESC:     Position and description of bits in FP FIELDS
 * SIZE:     128
 * FIELDS:
 *     TTL_FN           TTL_FN 
 *     TCP_FN           TCP_FN 
 *     IPFLAG           IPFLAG 
 *     TOS_FN           TOS_FN 
 *     L4_DST           L4_DST 
 *     L4_SRC           L4_SRC 
 *     IP_PROTOCOL_LAST_NH IP_PROTOCOL_LAST_NH 
 *     DIP              DIP
 *     SIP              SIP
 */
#define IFP_SINGLE_WIDE_F2_0_SIZE 16

/*
 * This structure should be used to declare and program IFP_SINGLE_WIDE_F2_0.
 */
typedef union IFP_SINGLE_WIDE_F2_0_s {
	uint32 v[4];
	uint32 ifp_single_wide_f2_0[4];
	uint32 _ifp_single_wide_f2_0;
} IFP_SINGLE_WIDE_F2_0_t;

#define IFP_SINGLE_WIDE_F2_0_CLR(r) sal_memset(&((r)._ifp_single_wide_f2_0), 0, sizeof(IFP_SINGLE_WIDE_F2_0_t))
#define IFP_SINGLE_WIDE_F2_0_SET(r,i,d) (r).ifp_single_wide_f2_0[i] = d
#define IFP_SINGLE_WIDE_F2_0_GET(r,i) (r).ifp_single_wide_f2_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define IFP_SINGLE_WIDE_F2_0_TTL_FNf_GET(r) (((r).ifp_single_wide_f2_0[0]) & 0xff)
#define IFP_SINGLE_WIDE_F2_0_TTL_FNf_SET(r,f) (r).ifp_single_wide_f2_0[0]=(((r).ifp_single_wide_f2_0[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define IFP_SINGLE_WIDE_F2_0_TCP_FNf_GET(r) ((((r).ifp_single_wide_f2_0[0]) >> 8) & 0x3f)
#define IFP_SINGLE_WIDE_F2_0_TCP_FNf_SET(r,f) (r).ifp_single_wide_f2_0[0]=(((r).ifp_single_wide_f2_0[0] & ~((uint32)0x3f << 8)) | ((((uint32)f) & 0x3f) << 8))
#define IFP_SINGLE_WIDE_F2_0_IPFLAGf_GET(r) ((((r).ifp_single_wide_f2_0[0]) >> 14) & 0x3)
#define IFP_SINGLE_WIDE_F2_0_IPFLAGf_SET(r,f) (r).ifp_single_wide_f2_0[0]=(((r).ifp_single_wide_f2_0[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define IFP_SINGLE_WIDE_F2_0_TOS_FNf_GET(r) ((((r).ifp_single_wide_f2_0[0]) >> 16) & 0xff)
#define IFP_SINGLE_WIDE_F2_0_TOS_FNf_SET(r,f) (r).ifp_single_wide_f2_0[0]=(((r).ifp_single_wide_f2_0[0] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define IFP_SINGLE_WIDE_F2_0_L4_DSTf_GET(r) field32_get((r).ifp_single_wide_f2_0,24,39)
#define IFP_SINGLE_WIDE_F2_0_L4_DSTf_SET(r,f) field32_set((r).ifp_single_wide_f2_0,24,39,f)
#define IFP_SINGLE_WIDE_F2_0_L4_SRCf_GET(r) ((((r).ifp_single_wide_f2_0[1]) >> 8) & 0xffff)
#define IFP_SINGLE_WIDE_F2_0_L4_SRCf_SET(r,f) (r).ifp_single_wide_f2_0[1]=(((r).ifp_single_wide_f2_0[1] & ~((uint32)0xffff << 8)) | ((((uint32)f) & 0xffff) << 8))
#define IFP_SINGLE_WIDE_F2_0_IP_PROTOCOL_LAST_NHf_GET(r) ((((r).ifp_single_wide_f2_0[1]) >> 24) & 0xff)
#define IFP_SINGLE_WIDE_F2_0_IP_PROTOCOL_LAST_NHf_SET(r,f) (r).ifp_single_wide_f2_0[1]=(((r).ifp_single_wide_f2_0[1] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define IFP_SINGLE_WIDE_F2_0_DIPf_GET(r) ((r).ifp_single_wide_f2_0[2])
#define IFP_SINGLE_WIDE_F2_0_DIPf_SET(r,f) (r).ifp_single_wide_f2_0[2]=((uint32)f)
#define IFP_SINGLE_WIDE_F2_0_SIPf_GET(r) ((r).ifp_single_wide_f2_0[3])
#define IFP_SINGLE_WIDE_F2_0_SIPf_SET(r,f) (r).ifp_single_wide_f2_0[3]=((uint32)f)

/*******************************************************************************
 * End of 'IFP_SINGLE_WIDE_F2_0'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  IFP_SINGLE_WIDE_F2_5
 * BLOCKS:  
 * DESC:     Position and description of bits in FP FIELDS
 * SIZE:     128
 * FIELDS:
 *     OUTER_VLAN_TAG   OUTER_VLAN_TAG 
 *     ETHERTYPE        ETHERTYPE 
 *     SA               SA 
 *     DA               DA 
 */
#define IFP_SINGLE_WIDE_F2_5_SIZE 16

/*
 * This structure should be used to declare and program IFP_SINGLE_WIDE_F2_5.
 */
typedef union IFP_SINGLE_WIDE_F2_5_s {
	uint32 v[4];
	uint32 ifp_single_wide_f2_5[4];
	uint32 _ifp_single_wide_f2_5;
} IFP_SINGLE_WIDE_F2_5_t;

#define IFP_SINGLE_WIDE_F2_5_CLR(r) sal_memset(&((r)._ifp_single_wide_f2_5), 0, sizeof(IFP_SINGLE_WIDE_F2_5_t))
#define IFP_SINGLE_WIDE_F2_5_SET(r,i,d) (r).ifp_single_wide_f2_5[i] = d
#define IFP_SINGLE_WIDE_F2_5_GET(r,i) (r).ifp_single_wide_f2_5[i]

/*
 * These macros can be used to access individual fields.
 */
#define IFP_SINGLE_WIDE_F2_5_OUTER_VLAN_TAGf_GET(r) (((r).ifp_single_wide_f2_5[0]) & 0xffff)
#define IFP_SINGLE_WIDE_F2_5_OUTER_VLAN_TAGf_SET(r,f) (r).ifp_single_wide_f2_5[0]=(((r).ifp_single_wide_f2_5[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define IFP_SINGLE_WIDE_F2_5_ETHERTYPEf_GET(r) ((((r).ifp_single_wide_f2_5[0]) >> 16) & 0xffff)
#define IFP_SINGLE_WIDE_F2_5_ETHERTYPEf_SET(r,f) (r).ifp_single_wide_f2_5[0]=(((r).ifp_single_wide_f2_5[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))
#define IFP_SINGLE_WIDE_F2_5_SAf_GET(r,a) field_get((r).ifp_single_wide_f2_5,32,79,a)
#define IFP_SINGLE_WIDE_F2_5_SAf_SET(r,a) field_set((r).ifp_single_wide_f2_5,32,79,a)
#define IFP_SINGLE_WIDE_F2_5_DAf_GET(r,a) field_get((r).ifp_single_wide_f2_5,80,127,a)
#define IFP_SINGLE_WIDE_F2_5_DAf_SET(r,a) field_set((r).ifp_single_wide_f2_5,80,127,a)

/*******************************************************************************
 * End of 'IFP_SINGLE_WIDE_F2_5'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  IFP_SINGLE_WIDE_F2_8
 * BLOCKS:  
 * DESC:     Position and description of bits in FP FIELDS
 * SIZE:     128
 * FIELDS:
 *     UDF1             UDF1
 */
#define IFP_SINGLE_WIDE_F2_8_SIZE 16

/*
 * This structure should be used to declare and program IFP_SINGLE_WIDE_F2_8.
 */
typedef union IFP_SINGLE_WIDE_F2_8_s {
	uint32 v[4];
	uint32 ifp_single_wide_f2_8[4];
	uint32 _ifp_single_wide_f2_8;
} IFP_SINGLE_WIDE_F2_8_t;

#define IFP_SINGLE_WIDE_F2_8_CLR(r) sal_memset(&((r)._ifp_single_wide_f2_8), 0, sizeof(IFP_SINGLE_WIDE_F2_8_t))
#define IFP_SINGLE_WIDE_F2_8_SET(r,i,d) (r).ifp_single_wide_f2_8[i] = d
#define IFP_SINGLE_WIDE_F2_8_GET(r,i) (r).ifp_single_wide_f2_8[i]

/*
 * These macros can be used to access individual fields.
 */
#define IFP_SINGLE_WIDE_F2_8_UDF1f_GET(r,a) field_get((r).ifp_single_wide_f2_8,0,127,a)
#define IFP_SINGLE_WIDE_F2_8_UDF1f_SET(r,a) field_set((r).ifp_single_wide_f2_8,0,127,a)

/*******************************************************************************
 * End of 'IFP_SINGLE_WIDE_F2_8'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  IFP_SINGLE_WIDE_F3_11
 * BLOCKS:  
 * DESC:     Position and description of bits in FP FIELDS
 * SIZE:     37
 * FIELDS:
 *     SGLP             SGLP 
 *     SVP              SVP 
 *     SVP_VALID        SVP_VALID 
 *     SPARE            SPARE 
 */
#define IFP_SINGLE_WIDE_F3_11_SIZE 5

/*
 * This structure should be used to declare and program IFP_SINGLE_WIDE_F3_11.
 */
typedef union IFP_SINGLE_WIDE_F3_11_s {
	uint32 v[2];
	uint32 ifp_single_wide_f3_11[2];
	uint32 _ifp_single_wide_f3_11;
} IFP_SINGLE_WIDE_F3_11_t;

#define IFP_SINGLE_WIDE_F3_11_CLR(r) sal_memset(&((r)._ifp_single_wide_f3_11), 0, sizeof(IFP_SINGLE_WIDE_F3_11_t))
#define IFP_SINGLE_WIDE_F3_11_SET(r,i,d) (r).ifp_single_wide_f3_11[i] = d
#define IFP_SINGLE_WIDE_F3_11_GET(r,i) (r).ifp_single_wide_f3_11[i]

/*
 * These macros can be used to access individual fields.
 */
#define IFP_SINGLE_WIDE_F3_11_SGLPf_GET(r) (((r).ifp_single_wide_f3_11[0]) & 0x7fff)
#define IFP_SINGLE_WIDE_F3_11_SGLPf_SET(r,f) (r).ifp_single_wide_f3_11[0]=(((r).ifp_single_wide_f3_11[0] & ~((uint32)0x7fff)) | (((uint32)f) & 0x7fff))
#define IFP_SINGLE_WIDE_F3_11_SVPf_GET(r) ((((r).ifp_single_wide_f3_11[0]) >> 15) & 0x1fff)
#define IFP_SINGLE_WIDE_F3_11_SVPf_SET(r,f) (r).ifp_single_wide_f3_11[0]=(((r).ifp_single_wide_f3_11[0] & ~((uint32)0x1fff << 15)) | ((((uint32)f) & 0x1fff) << 15))
#define IFP_SINGLE_WIDE_F3_11_SVP_VALIDf_GET(r) ((((r).ifp_single_wide_f3_11[0]) >> 28) & 0x1)
#define IFP_SINGLE_WIDE_F3_11_SVP_VALIDf_SET(r,f) (r).ifp_single_wide_f3_11[0]=(((r).ifp_single_wide_f3_11[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define IFP_SINGLE_WIDE_F3_11_SPAREf_GET(r) field32_get((r).ifp_single_wide_f3_11,29,36)
#define IFP_SINGLE_WIDE_F3_11_SPAREf_SET(r,f) field32_set((r).ifp_single_wide_f3_11,29,36,f)

/*******************************************************************************
 * End of 'IFP_SINGLE_WIDE_F3_11'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  IFP_SINGLE_WIDE_F3_3
 * BLOCKS:  
 * DESC:     Position and description of bits in FP FIELDS
 * SIZE:     37
 * FIELDS:
 *     OUTER_VLAN_TAG   OUTER_VLAN_TAG 
 *     PACKET_FORMAT    PACKET_FORMAT 
 *     SWITCHING_TAG_STATUS SWITCHING_TAG_STATUS 
 *     MH_OPCODE        MH_OPCODE 
 *     PKT_RESOLUTION   PKT_RESOLUTION 
 *     IP_INFO          IP_INFO 
 *     SPARE            SPARE 
 */
#define IFP_SINGLE_WIDE_F3_3_SIZE 5

/*
 * This structure should be used to declare and program IFP_SINGLE_WIDE_F3_3.
 */
typedef union IFP_SINGLE_WIDE_F3_3_s {
	uint32 v[2];
	uint32 ifp_single_wide_f3_3[2];
	uint32 _ifp_single_wide_f3_3;
} IFP_SINGLE_WIDE_F3_3_t;

#define IFP_SINGLE_WIDE_F3_3_CLR(r) sal_memset(&((r)._ifp_single_wide_f3_3), 0, sizeof(IFP_SINGLE_WIDE_F3_3_t))
#define IFP_SINGLE_WIDE_F3_3_SET(r,i,d) (r).ifp_single_wide_f3_3[i] = d
#define IFP_SINGLE_WIDE_F3_3_GET(r,i) (r).ifp_single_wide_f3_3[i]

/*
 * These macros can be used to access individual fields.
 */
#define IFP_SINGLE_WIDE_F3_3_OUTER_VLAN_TAGf_GET(r) (((r).ifp_single_wide_f3_3[0]) & 0xffff)
#define IFP_SINGLE_WIDE_F3_3_OUTER_VLAN_TAGf_SET(r,f) (r).ifp_single_wide_f3_3[0]=(((r).ifp_single_wide_f3_3[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define IFP_SINGLE_WIDE_F3_3_PACKET_FORMATf_GET(r) ((((r).ifp_single_wide_f3_3[0]) >> 16) & 0xf)
#define IFP_SINGLE_WIDE_F3_3_PACKET_FORMATf_SET(r,f) (r).ifp_single_wide_f3_3[0]=(((r).ifp_single_wide_f3_3[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define IFP_SINGLE_WIDE_F3_3_SWITCHING_TAG_STATUSf_GET(r) ((((r).ifp_single_wide_f3_3[0]) >> 20) & 0x3)
#define IFP_SINGLE_WIDE_F3_3_SWITCHING_TAG_STATUSf_SET(r,f) (r).ifp_single_wide_f3_3[0]=(((r).ifp_single_wide_f3_3[0] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define IFP_SINGLE_WIDE_F3_3_MH_OPCODEf_GET(r) ((((r).ifp_single_wide_f3_3[0]) >> 22) & 0x7)
#define IFP_SINGLE_WIDE_F3_3_MH_OPCODEf_SET(r,f) (r).ifp_single_wide_f3_3[0]=(((r).ifp_single_wide_f3_3[0] & ~((uint32)0x7 << 22)) | ((((uint32)f) & 0x7) << 22))
#define IFP_SINGLE_WIDE_F3_3_PKT_RESOLUTIONf_GET(r) ((((r).ifp_single_wide_f3_3[0]) >> 25) & 0x1f)
#define IFP_SINGLE_WIDE_F3_3_PKT_RESOLUTIONf_SET(r,f) (r).ifp_single_wide_f3_3[0]=(((r).ifp_single_wide_f3_3[0] & ~((uint32)0x1f << 25)) | ((((uint32)f) & 0x1f) << 25))
#define IFP_SINGLE_WIDE_F3_3_IP_INFOf_GET(r) field32_get((r).ifp_single_wide_f3_3,30,32)
#define IFP_SINGLE_WIDE_F3_3_IP_INFOf_SET(r,f) field32_set((r).ifp_single_wide_f3_3,30,32,f)
#define IFP_SINGLE_WIDE_F3_3_SPAREf_GET(r) ((((r).ifp_single_wide_f3_3[1]) >> 1) & 0xf)
#define IFP_SINGLE_WIDE_F3_3_SPAREf_SET(r,f) (r).ifp_single_wide_f3_3[1]=(((r).ifp_single_wide_f3_3[1] & ~((uint32)0xf << 1)) | ((((uint32)f) & 0xf) << 1))

/*******************************************************************************
 * End of 'IFP_SINGLE_WIDE_F3_3'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  IFP_SINGLE_WIDE_FIXED
 * BLOCKS:  
 * DESC:     Position and description of bits in FP FIELDS
 * SIZE:     19
 * FIELDS:
 *     HIGIG            HIGIG 
 *     FORWARDING_TYPE  FORWARDING_TYPE 
 *     SVP_OR_L3IIF     L3_TYPE 
 *     L3_TYPE          L3_TYPE 
 *     L4_VALID         L4_VALID 
 *     L3_ROUTABLE      L3_ROUTABLE 
 *     TUNNEL_TYPE_LOOPBACK_TYPE TUNNEL_TYPE 
 *     DROP             DROP 
 *     MIRROR_ONLY      Mirror only copy of packet. (Only possible for HG). 
 *     MIML_PRESENT     MIML Present. 
 *     CUSTOM_HEADER_PRESENT CUSTOM_HEADER Present. 
 */
#define IFP_SINGLE_WIDE_FIXED_SIZE 3

/*
 * This structure should be used to declare and program IFP_SINGLE_WIDE_FIXED.
 */
typedef union IFP_SINGLE_WIDE_FIXED_s {
	uint32 v[1];
	uint32 ifp_single_wide_fixed[1];
	uint32 _ifp_single_wide_fixed;
} IFP_SINGLE_WIDE_FIXED_t;

#define IFP_SINGLE_WIDE_FIXED_CLR(r) (r).ifp_single_wide_fixed[0] = 0
#define IFP_SINGLE_WIDE_FIXED_SET(r,d) (r).ifp_single_wide_fixed[0] = d
#define IFP_SINGLE_WIDE_FIXED_GET(r) (r).ifp_single_wide_fixed[0]

/*
 * These macros can be used to access individual fields.
 */
#define IFP_SINGLE_WIDE_FIXED_HIGIGf_GET(r) (((r).ifp_single_wide_fixed[0]) & 0x1)
#define IFP_SINGLE_WIDE_FIXED_HIGIGf_SET(r,f) (r).ifp_single_wide_fixed[0]=(((r).ifp_single_wide_fixed[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define IFP_SINGLE_WIDE_FIXED_FORWARDING_TYPEf_GET(r) ((((r).ifp_single_wide_fixed[0]) >> 1) & 0x7)
#define IFP_SINGLE_WIDE_FIXED_FORWARDING_TYPEf_SET(r,f) (r).ifp_single_wide_fixed[0]=(((r).ifp_single_wide_fixed[0] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define IFP_SINGLE_WIDE_FIXED_SVP_OR_L3IIFf_GET(r) ((((r).ifp_single_wide_fixed[0]) >> 4) & 0x1)
#define IFP_SINGLE_WIDE_FIXED_SVP_OR_L3IIFf_SET(r,f) (r).ifp_single_wide_fixed[0]=(((r).ifp_single_wide_fixed[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define IFP_SINGLE_WIDE_FIXED_L3_TYPEf_GET(r) ((((r).ifp_single_wide_fixed[0]) >> 5) & 0xf)
#define IFP_SINGLE_WIDE_FIXED_L3_TYPEf_SET(r,f) (r).ifp_single_wide_fixed[0]=(((r).ifp_single_wide_fixed[0] & ~((uint32)0xf << 5)) | ((((uint32)f) & 0xf) << 5))
#define IFP_SINGLE_WIDE_FIXED_L4_VALIDf_GET(r) ((((r).ifp_single_wide_fixed[0]) >> 9) & 0x1)
#define IFP_SINGLE_WIDE_FIXED_L4_VALIDf_SET(r,f) (r).ifp_single_wide_fixed[0]=(((r).ifp_single_wide_fixed[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define IFP_SINGLE_WIDE_FIXED_L3_ROUTABLEf_GET(r) ((((r).ifp_single_wide_fixed[0]) >> 10) & 0x1)
#define IFP_SINGLE_WIDE_FIXED_L3_ROUTABLEf_SET(r,f) (r).ifp_single_wide_fixed[0]=(((r).ifp_single_wide_fixed[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define IFP_SINGLE_WIDE_FIXED_TUNNEL_TYPE_LOOPBACK_TYPEf_GET(r) ((((r).ifp_single_wide_fixed[0]) >> 11) & 0xf)
#define IFP_SINGLE_WIDE_FIXED_TUNNEL_TYPE_LOOPBACK_TYPEf_SET(r,f) (r).ifp_single_wide_fixed[0]=(((r).ifp_single_wide_fixed[0] & ~((uint32)0xf << 11)) | ((((uint32)f) & 0xf) << 11))
#define IFP_SINGLE_WIDE_FIXED_DROPf_GET(r) ((((r).ifp_single_wide_fixed[0]) >> 15) & 0x1)
#define IFP_SINGLE_WIDE_FIXED_DROPf_SET(r,f) (r).ifp_single_wide_fixed[0]=(((r).ifp_single_wide_fixed[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define IFP_SINGLE_WIDE_FIXED_MIRROR_ONLYf_GET(r) ((((r).ifp_single_wide_fixed[0]) >> 16) & 0x1)
#define IFP_SINGLE_WIDE_FIXED_MIRROR_ONLYf_SET(r,f) (r).ifp_single_wide_fixed[0]=(((r).ifp_single_wide_fixed[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define IFP_SINGLE_WIDE_FIXED_MIML_PRESENTf_GET(r) ((((r).ifp_single_wide_fixed[0]) >> 17) & 0x1)
#define IFP_SINGLE_WIDE_FIXED_MIML_PRESENTf_SET(r,f) (r).ifp_single_wide_fixed[0]=(((r).ifp_single_wide_fixed[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define IFP_SINGLE_WIDE_FIXED_CUSTOM_HEADER_PRESENTf_GET(r) ((((r).ifp_single_wide_fixed[0]) >> 18) & 0x1)
#define IFP_SINGLE_WIDE_FIXED_CUSTOM_HEADER_PRESENTf_SET(r,f) (r).ifp_single_wide_fixed[0]=(((r).ifp_single_wide_fixed[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))

/*******************************************************************************
 * End of 'IFP_SINGLE_WIDE_FIXED'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  IGMP_MLD_PKT_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     IGMP/MLD Control Register
 * SIZE:     32
 * FIELDS:
 *     IPV6_MC_ROUTER_ADV_PKT_TO_CPU Copy Multicast Router Advertisement/Solicitation/Termination packets (ICMP types 151, 152, 153) to CPU if set to 1.
 *     IPV6_MC_ROUTER_ADV_PKT_FWD_ACTION Forwarding of Multicast Router Advertisement/Solicitation/Termination  packets (ICMP types 151, 152, 153) as below:        00 - Forward based on MAC-DA01 - Drop the packet10 - Flood the packet to the VLAN members11 - Reserved
 *     IPV4_MC_ROUTER_ADV_PKT_TO_CPU Copy Multicast Router Advertisement/Solicitation/Termination packets (ICMP types 151, 152, 153) to CPU if set to 1
 *     IPV4_MC_ROUTER_ADV_PKT_FWD_ACTION Forwarding of Multicast Router Advertisement/Solicitation/Termination  packets (ICMP types 151, 152, 153):        00 - Forward based on MAC-DA01 - Drop the packet10 - Flood the packet to the VLAN members11 - Reserved.
 *     IPV6_RESVD_MC_PKT_TO_CPU Copy IPv6 reserved multicast packets (DIP = ff0X:0:0:0:0:0:0:0) to CPU if set to 1
 *     IPV6_RESVD_MC_PKT_FWD_ACTION Forwarding of IPv6 reserved multicast packets (DIP = ff0X:0:0:0:0:0:0:0) as shown below:       00 - Forward based on MAC-DA       01 - Drop the packet       10 - Flood the packet to the VLAN members       11 - Reserved.
 *     IPV4_RESVD_MC_PKT_TO_CPU Copy IPv4 reserved multicast packets (DIP = 224.0.0.X) to CPU if set to 1.
 *     IPV4_RESVD_MC_PKT_FWD_ACTION Forwarding of IPv4 reserved multicast packets (DIP = 224.0.0.X) as shown below:00 - Forward based on MAC-DA01 - Drop the packet10 - Flood the packet to the VLAN members11 - Reserved.
 *     MLD_QUERY_TO_CPU Copy MLD Queries to the CPU if set to 1.
 *     MLD_QUERY_FWD_ACTION Forwarding of MLD Query messages as shown below:       00 - Forward based on MAC-DA01 - Drop the packet10 - Flood the packet to the VLAN members11 - Reserved
 *     MLD_REP_DONE_TO_CPU Copy MLD Report (v1, v2,)/Done (v1) msgs to the CPU if set to 1.
 *     MLD_REP_DONE_FWD_ACTION Forwarding of MLD Report(v1,v2,)/Done(v1) messages as shown below: 00 - Forward based on MAC-DA01 - Drop the packet10 - Flood the packet to the VLAN members11 - Reserved
 *     IGMP_UNKNOWN_MSG_TO_CPU Copy the unknown IGMP msg to CPU if set to 1.
 *     IGMP_UNKNOWN_MSG_FWD_ACTION Forwarding of unknown IGMP messages (messages that are not recognized as Query/Report/Leave messages) as shown below:       00 - Forward based on MAC-DA       01 - Drop the packet       10 - Flood the packet to the VLAN members       11 - Reserved
 *     IGMP_QUERY_TO_CPU Copy IGMP Query to the CPU if set to 1
 *     IGMP_QUERY_FWD_ACTION Forwarding of IGMP Query messages as shown below:       00 - Forward based on MAC-DA01 - Drop the packet.10 - Flood the packet to the VLAN members11 - Reserved.
 *     IGMP_REP_LEAVE_TO_CPU Copy IGMP Report (v1, v2, v3)/Leave (v2) msgs to the CPU if set to 1.
 *     IGMP_REP_LEAVE_FWD_ACTION Forwarding of IGMP Report(v1,v2,v3)/Leave(v2) messages as shown below:       00 - Forward based on MAC-DA01 - Drop the packet.10 - Flood the packet to the VLAN members11 - Reserved.
 *     PFM_RULE_APPLY   When set to 1, PFM rules are applied to IGMP/MLD/RESERVED_MC packets when flooded to VLAN
 */
#define IGMP_MLD_PKT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IGMP_MLD_PKT_CONTROL.
 */
typedef union IGMP_MLD_PKT_CONTROLr_s {
	uint32 v[1];
	uint32 igmp_mld_pkt_control[1];
	uint32 _igmp_mld_pkt_control;
} IGMP_MLD_PKT_CONTROLr_t;

#define IGMP_MLD_PKT_CONTROLr_CLR(r) (r).igmp_mld_pkt_control[0] = 0
#define IGMP_MLD_PKT_CONTROLr_SET(r,d) (r).igmp_mld_pkt_control[0] = d
#define IGMP_MLD_PKT_CONTROLr_GET(r) (r).igmp_mld_pkt_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_GET(r) (((r).igmp_mld_pkt_control[0]) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 1) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 1)) | ((((uint32)f) & 0x3) << 1))
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 3) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 4) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 6) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 7) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 7)) | ((((uint32)f) & 0x3) << 7))
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 9) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 10) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 12) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 13) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 15) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 16) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 18) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 19) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 21) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 22) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 24) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 25) & 0x3)
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x3 << 25)) | ((((uint32)f) & 0x3) << 25))
#define IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 27) & 0x1)
#define IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))

/*
 * These macros can be used to access IGMP_MLD_PKT_CONTROL.
 */
#define WRITE_IGMP_MLD_PKT_CONTROLr(u,p,r) bcm5354x_reg_set(u,R_IGMP_MLD_PKT_CONTROL(p),(r._igmp_mld_pkt_control))
#define READ_IGMP_MLD_PKT_CONTROLr(u,p,r) bcm5354x_reg_get(u,R_IGMP_MLD_PKT_CONTROL(p),&(r._igmp_mld_pkt_control))

/*******************************************************************************
 * End of 'IGMP_MLD_PKT_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  IHOST_SCU_CONTROL
 * BLOCKS:   IPROC
 * DESC:     SCU Control
 * SIZE:     32
 * FIELDS:
 *     SCU_ENABLE       Enables the SCU.
 *     ADDRESS_FILTER_ENABLE Enables addrss filtering on port 1. Resert value is from FILTEREN port, 1 in Kona.
 *     PARITY_ON        Enables parity - not used in Kona.
 *     SPEC_LINEFILL_EN When set, coherent linefill requests are sent speculatively to the PL310 in parallel with tag lookup.
 *     FORCE_PORT0_EN   When set, all requests from ACP or processors with AxCACHE=DV are forced to M0.
 *     SCU_STANDBY_EN   When set, stops SCU clock when all processors are in WFI, no ACP requests exist, and no remaining SCU activity happens.
 *     IC_STANDBY_EN    When set, stops interrupt controller clock when no interrupts are pending and no register accesses are pending.
 *     RESERVED         Reserved bits write has no effect and read always returns 0
 */
#define IHOST_SCU_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IHOST_SCU_CONTROL.
 */
typedef union IHOST_SCU_CONTROLr_s {
	uint32 v[1];
	uint32 ihost_scu_control[1];
	uint32 _ihost_scu_control;
} IHOST_SCU_CONTROLr_t;

#define IHOST_SCU_CONTROLr_CLR(r) (r).ihost_scu_control[0] = 0
#define IHOST_SCU_CONTROLr_SET(r,d) (r).ihost_scu_control[0] = d
#define IHOST_SCU_CONTROLr_GET(r) (r).ihost_scu_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define IHOST_SCU_CONTROLr_SCU_ENABLEf_GET(r) (((r).ihost_scu_control[0]) & 0x1)
#define IHOST_SCU_CONTROLr_SCU_ENABLEf_SET(r,f) (r).ihost_scu_control[0]=(((r).ihost_scu_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define IHOST_SCU_CONTROLr_ADDRESS_FILTER_ENABLEf_GET(r) ((((r).ihost_scu_control[0]) >> 1) & 0x1)
#define IHOST_SCU_CONTROLr_ADDRESS_FILTER_ENABLEf_SET(r,f) (r).ihost_scu_control[0]=(((r).ihost_scu_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define IHOST_SCU_CONTROLr_PARITY_ONf_GET(r) ((((r).ihost_scu_control[0]) >> 2) & 0x1)
#define IHOST_SCU_CONTROLr_PARITY_ONf_SET(r,f) (r).ihost_scu_control[0]=(((r).ihost_scu_control[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define IHOST_SCU_CONTROLr_SPEC_LINEFILL_ENf_GET(r) ((((r).ihost_scu_control[0]) >> 3) & 0x1)
#define IHOST_SCU_CONTROLr_SPEC_LINEFILL_ENf_SET(r,f) (r).ihost_scu_control[0]=(((r).ihost_scu_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define IHOST_SCU_CONTROLr_FORCE_PORT0_ENf_GET(r) ((((r).ihost_scu_control[0]) >> 4) & 0x1)
#define IHOST_SCU_CONTROLr_FORCE_PORT0_ENf_SET(r,f) (r).ihost_scu_control[0]=(((r).ihost_scu_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define IHOST_SCU_CONTROLr_SCU_STANDBY_ENf_GET(r) ((((r).ihost_scu_control[0]) >> 5) & 0x1)
#define IHOST_SCU_CONTROLr_SCU_STANDBY_ENf_SET(r,f) (r).ihost_scu_control[0]=(((r).ihost_scu_control[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define IHOST_SCU_CONTROLr_IC_STANDBY_ENf_GET(r) ((((r).ihost_scu_control[0]) >> 6) & 0x1)
#define IHOST_SCU_CONTROLr_IC_STANDBY_ENf_SET(r,f) (r).ihost_scu_control[0]=(((r).ihost_scu_control[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define IHOST_SCU_CONTROLr_RESERVEDf_GET(r) ((((r).ihost_scu_control[0]) >> 7) & 0x1ffffff)
#define IHOST_SCU_CONTROLr_RESERVEDf_SET(r,f) (r).ihost_scu_control[0]=(((r).ihost_scu_control[0] & ~((uint32)0x1ffffff << 7)) | ((((uint32)f) & 0x1ffffff) << 7))

/*
 * These macros can be used to access IHOST_SCU_CONTROL.
 */
#define READ_IHOST_SCU_CONTROLr(u,r) bcm5354x_read32(u, R_IHOST_SCU_CONTROL, &(r._ihost_scu_control))
#define WRITE_IHOST_SCU_CONTROLr(u,r) bcm5354x_write32(u, R_IHOST_SCU_CONTROL, (r._ihost_scu_control))

/*******************************************************************************
 * End of 'IHOST_SCU_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  IING_EGRMSKBMAP_64
 * BLOCKS:   IPIPE
 * DESC:     Ingress Block Mask, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Bitmap of ports to be blocked. 0=allow-through, 1=block. Note: If any bit in this register belongs to a member of a trunk group (either GE/HIGIG), then in order to function correctly, all bits of that trunk group should be disabled here as well.
 *     BITMAP_LO        Overlay bitmap for ports 31:0
 *     BLK_BITMAP       Overlay bitmap for ports 31:0
 */
#define IING_EGRMSKBMAP_64r_SIZE 4

/*
 * This structure should be used to declare and program IING_EGRMSKBMAP_64.
 */
typedef union IING_EGRMSKBMAP_64r_s {
	uint32 v[1];
	uint32 iing_egrmskbmap_64[1];
	uint32 _iing_egrmskbmap_64;
} IING_EGRMSKBMAP_64r_t;

#define IING_EGRMSKBMAP_64r_CLR(r) (r).iing_egrmskbmap_64[0] = 0
#define IING_EGRMSKBMAP_64r_SET(r,d) (r).iing_egrmskbmap_64[0] = d
#define IING_EGRMSKBMAP_64r_GET(r) (r).iing_egrmskbmap_64[0]

/*
 * These macros can be used to access individual fields.
 */
#define IING_EGRMSKBMAP_64r_BITMAPf_GET(r) ((r).iing_egrmskbmap_64[0])
#define IING_EGRMSKBMAP_64r_BITMAPf_SET(r,f) (r).iing_egrmskbmap_64[0]=((uint32)f)
#define IING_EGRMSKBMAP_64r_BITMAP_LOf_GET(r) ((r).iing_egrmskbmap_64[0])
#define IING_EGRMSKBMAP_64r_BITMAP_LOf_SET(r,f) (r).iing_egrmskbmap_64[0]=((uint32)f)
#define IING_EGRMSKBMAP_64r_BLK_BITMAPf_GET(r) ((r).iing_egrmskbmap_64[0])
#define IING_EGRMSKBMAP_64r_BLK_BITMAPf_SET(r,f) (r).iing_egrmskbmap_64[0]=((uint32)f)

/*
 * These macros can be used to access IING_EGRMSKBMAP_64.
 */
#define WRITE_IING_EGRMSKBMAP_64r(u,p,r) bcm5354x_reg_set(u,R_IING_EGRMSKBMAP_64(p),(r._iing_egrmskbmap_64))
#define READ_IING_EGRMSKBMAP_64r(u,p,r) bcm5354x_reg_get(u,R_IING_EGRMSKBMAP_64(p),&(r._iing_egrmskbmap_64))

/*******************************************************************************
 * End of 'IING_EGRMSKBMAP_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  IM_MTP_INDEX
 * BLOCKS:   IPIPE
 * DESC:     Ingress Mirror to Port Table
The index to this table is obtained from MIRROR_CONTROL.IM_MTP_INDEX. The fields specify 1 of 4 mirror to ports
 * SIZE:     15
 * FIELDS:
 *     PORT_NUM         Port if T==0
 *     TGID             Trunk ID value if T==1
 *     MODULE_ID        Module ID if T==0. 
 *     T                Trunked port (LAG) indication
 */
#define IM_MTP_INDEXm_MIN 0
#define IM_MTP_INDEXm_MAX 3
#define IM_MTP_INDEXm_CMAX(u) 3
#define IM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program IM_MTP_INDEX.
 */
typedef union IM_MTP_INDEXm_s {
	uint32 v[1];
	uint32 im_mtp_index[1];
	uint32 _im_mtp_index;
} IM_MTP_INDEXm_t;

#define IM_MTP_INDEXm_CLR(r) (r).im_mtp_index[0] = 0
#define IM_MTP_INDEXm_SET(r,d) (r).im_mtp_index[0] = d
#define IM_MTP_INDEXm_GET(r) (r).im_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 */
#define IM_MTP_INDEXm_PORT_NUMf_GET(r) (((r).im_mtp_index[0]) & 0x3f)
#define IM_MTP_INDEXm_PORT_NUMf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define IM_MTP_INDEXm_TGIDf_GET(r) (((r).im_mtp_index[0]) & 0x7)
#define IM_MTP_INDEXm_TGIDf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define IM_MTP_INDEXm_MODULE_IDf_GET(r) ((((r).im_mtp_index[0]) >> 6) & 0xff)
#define IM_MTP_INDEXm_MODULE_IDf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define IM_MTP_INDEXm_Tf_GET(r) ((((r).im_mtp_index[0]) >> 14) & 0x1)
#define IM_MTP_INDEXm_Tf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))

/*
 * These macros can be used to access IM_MTP_INDEX.
 */
#define WRITE_IM_MTP_INDEXm(u,i,r) bcm5354x_mem_set(u, M_IM_MTP_INDEX(i), &(r._im_mtp_index), 1)
#define READ_IM_MTP_INDEXm(u,i,r) bcm5354x_mem_get(u, M_IM_MTP_INDEX(i), &(r._im_mtp_index), 1)

/*******************************************************************************
 * End of 'IM_MTP_INDEXm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  ING_CONFIG_64
 * BLOCKS:   IPIPE
 * DESC:     Switch configuration register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0       Reserved.
 *     TRUNKS128        If set to 1, 128 trunk groups are supported
 *     L2DH_EN          L2 destination hit bit enable       0 = Do not update hit bit on destination match       1 = Update the L2 table hit bit on a destination match
 *     L2DST_HIT_ENABLE If set to 1, L2 table will update its HIT bit on destination lookup
 *     L3SH_EN          If set to 1, controls the update of the HIT bit in the L3 table upon an IP source address match.       0 = Do not update L3 table hit bit.       1 = Update the L3 table hit bit.       Hit bit in the L3 table is always updated upon a destination IPmatch.
 *     L3SRC_HIT_ENABLE If set to 1, L3 table will update its HIT bit on source lookup. Only apply to Unicast packets.
 *     CFI_AS_CNG       If set to 1, for tagged packets, use VLAN's CFI field to map to an internal CNG value (for double tagging)
 *     SNAP_OTHER_DECODE_ENABLE If set to 1, decode SNAP packets with non-zero OUI for protocol-based VLAN
 *     STNMOVE_ON_L2SRC_DISC If set to 1, perform station movement on L2 source discard packets
 *     FB_A0_COMPATIBLE If set to 1, disable source MOD_ID checks for mirror packets on HiGig when in XGS-3 style of mirroring. Used when compatibility with BCM56504 A0 devices is required.
 *     STACK_MODE       Stacking Mode.
 *     CVLAN_CFI_AS_CNG If set to 1, treat CFI bit in customer VLAN tag as CNG
 *     APPLY_EGR_MASK_ON_L2 If set to 1, apply Egress mask for L2 switched packets
 *     APPLY_EGR_MASK_ON_L3 If set to 1, apply Egress mask for L3 switched packets
 *     SVL_ENABLE       If set to 1, enable Shared VLAN Learning
 *     LOOKUP_L2MC_WITH_FID_ID  If set to 1, enable L2MC lookups to occur with MAC_DA + FID in Shared VLAN learning mode. 
 *     MAP_FID_ID_TO_OUTER_TAG If set to 1, copy FID-ID as VLAN-ID in outer VLAN tag for FP classification only
 *     MAP_FID_ID_TO_INNER_TAG If set to 1, copy FID-ID as VLAN-ID in inner VLAN tag for FP classification only
 *     DISABLE_E2E_HOL_CHECK Disable E2E HOL checking
 *     LBID_RTAG        If set to 1, RTAG selects how LBID is computed
 *     APPLY_MTU_CHECK_ON_HIGIG_IPMC If set to 1, L3 MTU check is applied to HiGig IPMC packets.
 *     IGNORE_HG_HDR_LAG_FAILOVER If set to 1, HiGig headers LAG_FAILOVER bit will be ignored and will be treated as reserved bit.
 *     IGNORE_HG_HDR_DONOT_LEARN If set to 1, HiGig headers DONOT_LEARN bit will be ignored and will be treated as reserved bit.
 *     IGNORE_HG_HDR_HDR_EXT_LEN If set to 1, HiGig+ headers HDR_EXT_LEN bits will be ignored and will be treated as reserved bit.
 *     IGNORE_MY_MODID  If set to 1, the MY_MODID from the PORT TABLE will be ignored. The chip will not have a module ID (this is the case when the chip is used as a fabric device).
 *     IGMP_PKTS_UNICAST_IGNORE If set to 1, unicast packets with IGMP payload (i.e. IP PROTOCOL = 2) will not be treated as IGMP packets
 *     MLD_PKTS_UNICAST_IGNORE If set to 1, unicast packets with MLD payload will not be treated as MLD packets
 *     ARP_VALIDATION_EN If set to 1, enables the sender Ethernet address to be sent to the VFP. Use in conjunction with the ARP_RARP_TO_FP bit. 
 *     MLD_CHECKS_ENABLE If set to 1, stricter checks for MLD packets are enabled. The packet is checked for TTL=1 and SIP is LINK_LOCAL. 
 *     IPV4_RESERVED_MC_ADDR_IGMP_ENABLE If set to 1, treat the IGMP packets with a IPv4 reserved multicast destination address as IGMP packets. (not as IPv4 reserved multicast packets)
 *     IPV6_RESERVED_MC_ADDR_MLD_ENABLE If set to 1, treat the MLD packets with a IPv6 reserved multicast destination address as MLD packets (not as IPv6 reserved multicast packets)
 *     IPV4_MC_MACDA_CHECK_ENABLE If set to 1, check MACDA and IPV4 DIP address match for IPv4 multicast packets
 *     IPV6_MC_MACDA_CHECK_ENABLE If set to 1, check MACDA and IPV6 DIP address match for IPv6 multicast packets
 *     ARP_RARP_TO_FP   This field controls the encodings of the ARP/RARP packet type into the VFP and IFP keys. If bit[0] is set, then ARP packets are included. If bit[1] is set, then RARP packets are included. It is also used in conjunction with ARP_VALIDATION_EN to validate these packets in the VFP.
 *     RESERVED_40      Reserved bit
 *     VFP_PRI_ACTION_FB2_MODE FB2 backward compatibility mode for L2/L3 lookup/DSCP priority override
 *     L3IIF_URPF_SELECT When set to 1, the uRPF controls are defined per L3_IIF.  When set to 0, the uRPF controls are per physical port.
 *     IGNORE_PPD0_PRESERVE_QOS If set, then the parser will not interpret the PPD0 bits as preserve QOS bits and instead will treat them as reserved and will be transited.
 *     IGNORE_PPD2_PRESERVE_QOS If set, then the parser will not interpret the PPD2 bits as preserve QOS bits and instead will treat them as reserved and will be transited.
 *     USE_PPD_SOURCE   If set to 1, the PPD overlay contains the system source port for packet processing.  If set to 0, the FRC source will be used as the system source port for packet processing.
 *     TREAT_PKTPRI_AS_DOT1P If set, then the packet priority which is derived from VLAN assignment will be treated as dot1p priority (instead of ING_PRI_CNG_MAP.PRI.)
 *     IPHDR_ERROR_L3_LOOKUP_ENABLE .
 *     ENABLE_MAC_IP_BINDING_FOR_ARP_PKTS Enable the MAC_IP_BINDING support for ARP packets
 *     HIGIG2_ECN_IN_CC_ENABLE Backward compatibility mode. 0: Backward compatible 1: Higig Congestion class valid.
 *     L2_128_OVF_DISABLE Disable new 128 L2_ENTRY_OVERFLOW feature.
 */
#define ING_CONFIG_64r_SIZE 8

/*
 * This structure should be used to declare and program ING_CONFIG_64.
 */
typedef union ING_CONFIG_64r_s {
	uint32 v[2];
	uint32 ing_config_64[2];
	uint32 _ing_config_64;
} ING_CONFIG_64r_t;

#define ING_CONFIG_64r_CLR(r) sal_memset(&((r)._ing_config_64), 0, sizeof(ING_CONFIG_64r_t))
#define ING_CONFIG_64r_SET(r,i,d) (r).ing_config_64[i] = d
#define ING_CONFIG_64r_GET(r,i) (r).ing_config_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define ING_CONFIG_64r_RESERVED_0f_GET(r) (((r).ing_config_64[0]) & 0x1)
#define ING_CONFIG_64r_RESERVED_0f_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define ING_CONFIG_64r_TRUNKS128f_GET(r) ((((r).ing_config_64[0]) >> 1) & 0x1)
#define ING_CONFIG_64r_TRUNKS128f_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define ING_CONFIG_64r_L2DH_ENf_GET(r) ((((r).ing_config_64[0]) >> 2) & 0x1)
#define ING_CONFIG_64r_L2DH_ENf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define ING_CONFIG_64r_L2DST_HIT_ENABLEf_GET(r) ((((r).ing_config_64[0]) >> 2) & 0x1)
#define ING_CONFIG_64r_L2DST_HIT_ENABLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define ING_CONFIG_64r_L3SH_ENf_GET(r) ((((r).ing_config_64[0]) >> 3) & 0x1)
#define ING_CONFIG_64r_L3SH_ENf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define ING_CONFIG_64r_L3SRC_HIT_ENABLEf_GET(r) ((((r).ing_config_64[0]) >> 3) & 0x1)
#define ING_CONFIG_64r_L3SRC_HIT_ENABLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define ING_CONFIG_64r_CFI_AS_CNGf_GET(r) ((((r).ing_config_64[0]) >> 5) & 0x1)
#define ING_CONFIG_64r_CFI_AS_CNGf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define ING_CONFIG_64r_SNAP_OTHER_DECODE_ENABLEf_GET(r) ((((r).ing_config_64[0]) >> 6) & 0x1)
#define ING_CONFIG_64r_SNAP_OTHER_DECODE_ENABLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define ING_CONFIG_64r_STNMOVE_ON_L2SRC_DISCf_GET(r) ((((r).ing_config_64[0]) >> 7) & 0x1)
#define ING_CONFIG_64r_STNMOVE_ON_L2SRC_DISCf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define ING_CONFIG_64r_FB_A0_COMPATIBLEf_GET(r) ((((r).ing_config_64[0]) >> 8) & 0x1)
#define ING_CONFIG_64r_FB_A0_COMPATIBLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define ING_CONFIG_64r_STACK_MODEf_GET(r) ((((r).ing_config_64[0]) >> 9) & 0x3)
#define ING_CONFIG_64r_STACK_MODEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define ING_CONFIG_64r_CVLAN_CFI_AS_CNGf_GET(r) ((((r).ing_config_64[0]) >> 11) & 0x1)
#define ING_CONFIG_64r_CVLAN_CFI_AS_CNGf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define ING_CONFIG_64r_APPLY_EGR_MASK_ON_L2f_GET(r) ((((r).ing_config_64[0]) >> 12) & 0x1)
#define ING_CONFIG_64r_APPLY_EGR_MASK_ON_L2f_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define ING_CONFIG_64r_APPLY_EGR_MASK_ON_L3f_GET(r) ((((r).ing_config_64[0]) >> 13) & 0x1)
#define ING_CONFIG_64r_APPLY_EGR_MASK_ON_L3f_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define ING_CONFIG_64r_SVL_ENABLEf_GET(r) ((((r).ing_config_64[0]) >> 14) & 0x1)
#define ING_CONFIG_64r_SVL_ENABLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define ING_CONFIG_64r_LOOKUP_L2MC_WITH_FID_IDf_GET(r) ((((r).ing_config_64[0]) >> 15) & 0x1)
#define ING_CONFIG_64r_LOOKUP_L2MC_WITH_FID_IDf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define ING_CONFIG_64r_MAP_FID_ID_TO_OUTER_TAGf_GET(r) ((((r).ing_config_64[0]) >> 16) & 0x1)
#define ING_CONFIG_64r_MAP_FID_ID_TO_OUTER_TAGf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define ING_CONFIG_64r_MAP_FID_ID_TO_INNER_TAGf_GET(r) ((((r).ing_config_64[0]) >> 17) & 0x1)
#define ING_CONFIG_64r_MAP_FID_ID_TO_INNER_TAGf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define ING_CONFIG_64r_DISABLE_E2E_HOL_CHECKf_GET(r) ((((r).ing_config_64[0]) >> 18) & 0x1)
#define ING_CONFIG_64r_DISABLE_E2E_HOL_CHECKf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define ING_CONFIG_64r_LBID_RTAGf_GET(r) ((((r).ing_config_64[0]) >> 19) & 0x7)
#define ING_CONFIG_64r_LBID_RTAGf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x7 << 19)) | ((((uint32)f) & 0x7) << 19))
#define ING_CONFIG_64r_APPLY_MTU_CHECK_ON_HIGIG_IPMCf_GET(r) ((((r).ing_config_64[0]) >> 22) & 0x1)
#define ING_CONFIG_64r_APPLY_MTU_CHECK_ON_HIGIG_IPMCf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define ING_CONFIG_64r_IGNORE_HG_HDR_LAG_FAILOVERf_GET(r) ((((r).ing_config_64[0]) >> 23) & 0x1)
#define ING_CONFIG_64r_IGNORE_HG_HDR_LAG_FAILOVERf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define ING_CONFIG_64r_IGNORE_HG_HDR_DONOT_LEARNf_GET(r) ((((r).ing_config_64[0]) >> 24) & 0x1)
#define ING_CONFIG_64r_IGNORE_HG_HDR_DONOT_LEARNf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define ING_CONFIG_64r_IGNORE_HG_HDR_HDR_EXT_LENf_GET(r) ((((r).ing_config_64[0]) >> 25) & 0x1)
#define ING_CONFIG_64r_IGNORE_HG_HDR_HDR_EXT_LENf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define ING_CONFIG_64r_IGNORE_MY_MODIDf_GET(r) ((((r).ing_config_64[0]) >> 26) & 0x1)
#define ING_CONFIG_64r_IGNORE_MY_MODIDf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define ING_CONFIG_64r_IGMP_PKTS_UNICAST_IGNOREf_GET(r) ((((r).ing_config_64[0]) >> 27) & 0x1)
#define ING_CONFIG_64r_IGMP_PKTS_UNICAST_IGNOREf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define ING_CONFIG_64r_MLD_PKTS_UNICAST_IGNOREf_GET(r) ((((r).ing_config_64[0]) >> 28) & 0x1)
#define ING_CONFIG_64r_MLD_PKTS_UNICAST_IGNOREf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define ING_CONFIG_64r_ARP_VALIDATION_ENf_GET(r) ((((r).ing_config_64[0]) >> 29) & 0x1)
#define ING_CONFIG_64r_ARP_VALIDATION_ENf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define ING_CONFIG_64r_MLD_CHECKS_ENABLEf_GET(r) ((((r).ing_config_64[0]) >> 30) & 0x1)
#define ING_CONFIG_64r_MLD_CHECKS_ENABLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define ING_CONFIG_64r_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_GET(r) ((((r).ing_config_64[0]) >> 31) & 0x1)
#define ING_CONFIG_64r_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_SET(r,f) (r).ing_config_64[0]=(((r).ing_config_64[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define ING_CONFIG_64r_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_GET(r) (((r).ing_config_64[1]) & 0x1)
#define ING_CONFIG_64r_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define ING_CONFIG_64r_IPV4_MC_MACDA_CHECK_ENABLEf_GET(r) ((((r).ing_config_64[1]) >> 1) & 0x1)
#define ING_CONFIG_64r_IPV4_MC_MACDA_CHECK_ENABLEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define ING_CONFIG_64r_IPV6_MC_MACDA_CHECK_ENABLEf_GET(r) ((((r).ing_config_64[1]) >> 2) & 0x1)
#define ING_CONFIG_64r_IPV6_MC_MACDA_CHECK_ENABLEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define ING_CONFIG_64r_ARP_RARP_TO_FPf_GET(r) ((((r).ing_config_64[1]) >> 6) & 0x3)
#define ING_CONFIG_64r_ARP_RARP_TO_FPf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define ING_CONFIG_64r_RESERVED_40f_GET(r) ((((r).ing_config_64[1]) >> 8) & 0x1)
#define ING_CONFIG_64r_RESERVED_40f_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define ING_CONFIG_64r_VFP_PRI_ACTION_FB2_MODEf_GET(r) ((((r).ing_config_64[1]) >> 9) & 0x1)
#define ING_CONFIG_64r_VFP_PRI_ACTION_FB2_MODEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define ING_CONFIG_64r_L3IIF_URPF_SELECTf_GET(r) ((((r).ing_config_64[1]) >> 10) & 0x1)
#define ING_CONFIG_64r_L3IIF_URPF_SELECTf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define ING_CONFIG_64r_IGNORE_PPD0_PRESERVE_QOSf_GET(r) ((((r).ing_config_64[1]) >> 11) & 0x1)
#define ING_CONFIG_64r_IGNORE_PPD0_PRESERVE_QOSf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define ING_CONFIG_64r_IGNORE_PPD2_PRESERVE_QOSf_GET(r) ((((r).ing_config_64[1]) >> 12) & 0x1)
#define ING_CONFIG_64r_IGNORE_PPD2_PRESERVE_QOSf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define ING_CONFIG_64r_USE_PPD_SOURCEf_GET(r) ((((r).ing_config_64[1]) >> 13) & 0x1)
#define ING_CONFIG_64r_USE_PPD_SOURCEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define ING_CONFIG_64r_TREAT_PKTPRI_AS_DOT1Pf_GET(r) ((((r).ing_config_64[1]) >> 14) & 0x1)
#define ING_CONFIG_64r_TREAT_PKTPRI_AS_DOT1Pf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define ING_CONFIG_64r_IPHDR_ERROR_L3_LOOKUP_ENABLEf_GET(r) ((((r).ing_config_64[1]) >> 16) & 0x1)
#define ING_CONFIG_64r_IPHDR_ERROR_L3_LOOKUP_ENABLEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define ING_CONFIG_64r_ENABLE_MAC_IP_BINDING_FOR_ARP_PKTSf_GET(r) ((((r).ing_config_64[1]) >> 17) & 0x1)
#define ING_CONFIG_64r_ENABLE_MAC_IP_BINDING_FOR_ARP_PKTSf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define ING_CONFIG_64r_HIGIG2_ECN_IN_CC_ENABLEf_GET(r) ((((r).ing_config_64[1]) >> 18) & 0x1)
#define ING_CONFIG_64r_HIGIG2_ECN_IN_CC_ENABLEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define ING_CONFIG_64r_L2_128_OVF_DISABLEf_GET(r) ((((r).ing_config_64[1]) >> 19) & 0x1)
#define ING_CONFIG_64r_L2_128_OVF_DISABLEf_SET(r,f) (r).ing_config_64[1]=(((r).ing_config_64[1] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))

/*
 * These macros can be used to access ING_CONFIG_64.
 */
#define WRITE_ING_CONFIG_64r(u,r) bcm5354x_reg64_set(u,R_ING_CONFIG_64,&(r._ing_config_64),2)
#define READ_ING_CONFIG_64r(u,r) bcm5354x_reg64_get(u,R_ING_CONFIG_64,&(r._ing_config_64),2)

/*******************************************************************************
 * End of 'ING_CONFIG_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  ING_EGRMSKBMAP_64
 * BLOCKS:   IPIPE
 * DESC:     Ingress Block Mask, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Bitmap of ports to be blocked. 0=allow-through, 1=block. Note: If any bit in this register belongs to a member of a trunk group (either GE/HIGIG), then in order to function correctly, all bits of that trunk group should be disabled here as well.
 *     BITMAP_LO        Overlay bitmap for ports 31:0
 *     BLK_BITMAP       Overlay bitmap for ports 31:0
 */
#define ING_EGRMSKBMAP_64r_SIZE 4

/*
 * This structure should be used to declare and program ING_EGRMSKBMAP_64.
 */
typedef union ING_EGRMSKBMAP_64r_s {
	uint32 v[1];
	uint32 ing_egrmskbmap_64[1];
	uint32 _ing_egrmskbmap_64;
} ING_EGRMSKBMAP_64r_t;

#define ING_EGRMSKBMAP_64r_CLR(r) (r).ing_egrmskbmap_64[0] = 0
#define ING_EGRMSKBMAP_64r_SET(r,d) (r).ing_egrmskbmap_64[0] = d
#define ING_EGRMSKBMAP_64r_GET(r) (r).ing_egrmskbmap_64[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_EGRMSKBMAP_64r_BITMAPf_GET(r) ((r).ing_egrmskbmap_64[0])
#define ING_EGRMSKBMAP_64r_BITMAPf_SET(r,f) (r).ing_egrmskbmap_64[0]=((uint32)f)
#define ING_EGRMSKBMAP_64r_BITMAP_LOf_GET(r) ((r).ing_egrmskbmap_64[0])
#define ING_EGRMSKBMAP_64r_BITMAP_LOf_SET(r,f) (r).ing_egrmskbmap_64[0]=((uint32)f)
#define ING_EGRMSKBMAP_64r_BLK_BITMAPf_GET(r) ((r).ing_egrmskbmap_64[0])
#define ING_EGRMSKBMAP_64r_BLK_BITMAPf_SET(r,f) (r).ing_egrmskbmap_64[0]=((uint32)f)

/*
 * These macros can be used to access ING_EGRMSKBMAP_64.
 */
#define WRITE_ING_EGRMSKBMAP_64r(u,p,r) bcm5354x_reg_set(u,R_ING_EGRMSKBMAP_64(p),(r._ing_egrmskbmap_64))
#define READ_ING_EGRMSKBMAP_64r(u,p,r) bcm5354x_reg_get(u,R_ING_EGRMSKBMAP_64(p),&(r._ing_egrmskbmap_64))

/*******************************************************************************
 * End of 'ING_EGRMSKBMAP_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  ING_HW_RESET_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register 1. ING_HW_RESET_CONTROL_1 and ING_HW_RESET_CONTROL_2 can be used in conjunction to clear memory tables that reside in the ingress pipeline in hardware.
 * SIZE:     32
 * FIELDS:
 *     OFFSET           18-bit starting offset of table for memory
 *     MEMORY_NUMBER    Memory Select
 *     STAGE_NUMBER     IP stage for the memory table
 */
#define ING_HW_RESET_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_1.
 */
typedef union ING_HW_RESET_CONTROL_1r_s {
	uint32 v[1];
	uint32 ing_hw_reset_control_1[1];
	uint32 _ing_hw_reset_control_1;
} ING_HW_RESET_CONTROL_1r_t;

#define ING_HW_RESET_CONTROL_1r_CLR(r) (r).ing_hw_reset_control_1[0] = 0
#define ING_HW_RESET_CONTROL_1r_SET(r,d) (r).ing_hw_reset_control_1[0] = d
#define ING_HW_RESET_CONTROL_1r_GET(r) (r).ing_hw_reset_control_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_HW_RESET_CONTROL_1r_OFFSETf_GET(r) (((r).ing_hw_reset_control_1[0]) & 0x3ffff)
#define ING_HW_RESET_CONTROL_1r_OFFSETf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32)0x3ffff)) | (((uint32)f) & 0x3ffff))
#define ING_HW_RESET_CONTROL_1r_MEMORY_NUMBERf_GET(r) ((((r).ing_hw_reset_control_1[0]) >> 18) & 0xff)
#define ING_HW_RESET_CONTROL_1r_MEMORY_NUMBERf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32)0xff << 18)) | ((((uint32)f) & 0xff) << 18))
#define ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET(r) ((((r).ing_hw_reset_control_1[0]) >> 26) & 0x3f)
#define ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_1.
 */
#define WRITE_ING_HW_RESET_CONTROL_1r(u,r) bcm5354x_reg_set(u,R_ING_HW_RESET_CONTROL_1,(r._ing_hw_reset_control_1))
#define READ_ING_HW_RESET_CONTROL_1r(u,r) bcm5354x_reg_get(u,R_ING_HW_RESET_CONTROL_1,&(r._ing_hw_reset_control_1))

/*******************************************************************************
 * End of 'ING_HW_RESET_CONTROL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  ING_HW_RESET_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register 2
 * SIZE:     32
 * FIELDS:
 *     COUNT            Number of entries of memory to initialize. Note that the number mentioned here should be one more than the entries to be intialized.
 *     RESET_ALL        Indicates all memories in all stages should be initialized (independent of stage or table number)				0 = Clear memory table specified in ING_HW_RESET_CONTROL_1				1 = Clear all memory tables in the ingress pipeline
 *     VALID            Set by software to trigger memory initialization				0 = Normal oparation				1 = Begin  initialization
 *     DONE             Set by hardware to indicate memory table writes have completed on pipeline				0 = Not complete				1 = Completed
 */
#define ING_HW_RESET_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_2.
 */
typedef union ING_HW_RESET_CONTROL_2r_s {
	uint32 v[1];
	uint32 ing_hw_reset_control_2[1];
	uint32 _ing_hw_reset_control_2;
} ING_HW_RESET_CONTROL_2r_t;

#define ING_HW_RESET_CONTROL_2r_CLR(r) (r).ing_hw_reset_control_2[0] = 0
#define ING_HW_RESET_CONTROL_2r_SET(r,d) (r).ing_hw_reset_control_2[0] = d
#define ING_HW_RESET_CONTROL_2r_GET(r) (r).ing_hw_reset_control_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_HW_RESET_CONTROL_2r_COUNTf_GET(r) (((r).ing_hw_reset_control_2[0]) & 0xffff)
#define ING_HW_RESET_CONTROL_2r_COUNTf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 16) & 0x1)
#define ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define ING_HW_RESET_CONTROL_2r_VALIDf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 17) & 0x1)
#define ING_HW_RESET_CONTROL_2r_VALIDf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define ING_HW_RESET_CONTROL_2r_DONEf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 18) & 0x1)
#define ING_HW_RESET_CONTROL_2r_DONEf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_2.
 */
#define WRITE_ING_HW_RESET_CONTROL_2r(u,r) bcm5354x_reg_set(u,R_ING_HW_RESET_CONTROL_2,(r._ing_hw_reset_control_2))
#define READ_ING_HW_RESET_CONTROL_2r(u,r) bcm5354x_reg_get(u,R_ING_HW_RESET_CONTROL_2,&(r._ing_hw_reset_control_2))

/*******************************************************************************
 * End of 'ING_HW_RESET_CONTROL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  ING_MISC_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Additional configuration bits
 * SIZE:     32
 * FIELDS:
 *     APPLY_EGR_MASK_ON_UC_ONLY If set, apply egress mask on unicast packets only.
 *     APPLY_SRCMOD_BLOCK_ON_UC_ONLY If set, apply source modid block on unicast packets only.
 *     DO_NOT_APPLY_SRCMOD_BLOCK_ON_SC If set, do not apply source modid block on system control packets.
 *     DO_NOT_COPY_FROM_CPU_TO_CPU If set, packets originating from the CPU port will not not be copied packet CPU.
 *     LOCAL_SW_DISABLE_HGTRUNK_RES_EN Enables Higig Trunk resolution when chip is in local switch disable mode. GNATS(8815, 8962)
 *     STG_CHECK_ENABLE If set, apply egress port's spanning tree check before enqueuing to the MMU for L2 forwarding.
 *     USE_DEST_PORT    USE_DEST_PORT.
 *     INPUT_PRI_TAGGED 0 - incoming_vlan_tag[15:13]; 1 - int_pri[3:0].
 *     INPUT_PRI_UNTAGGED 0 - learn_and_fwd_vlan_tag[15:13]; 1 - int_pri[3:0].
 */
#define ING_MISC_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program ING_MISC_CONFIG.
 */
typedef union ING_MISC_CONFIGr_s {
	uint32 v[1];
	uint32 ing_misc_config[1];
	uint32 _ing_misc_config;
} ING_MISC_CONFIGr_t;

#define ING_MISC_CONFIGr_CLR(r) (r).ing_misc_config[0] = 0
#define ING_MISC_CONFIGr_SET(r,d) (r).ing_misc_config[0] = d
#define ING_MISC_CONFIGr_GET(r) (r).ing_misc_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_GET(r) (((r).ing_misc_config[0]) & 0x1)
#define ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_GET(r) ((((r).ing_misc_config[0]) >> 1) & 0x1)
#define ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_GET(r) ((((r).ing_misc_config[0]) >> 2) & 0x1)
#define ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define ING_MISC_CONFIGr_DO_NOT_COPY_FROM_CPU_TO_CPUf_GET(r) ((((r).ing_misc_config[0]) >> 3) & 0x1)
#define ING_MISC_CONFIGr_DO_NOT_COPY_FROM_CPU_TO_CPUf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define ING_MISC_CONFIGr_LOCAL_SW_DISABLE_HGTRUNK_RES_ENf_GET(r) ((((r).ing_misc_config[0]) >> 4) & 0x1)
#define ING_MISC_CONFIGr_LOCAL_SW_DISABLE_HGTRUNK_RES_ENf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define ING_MISC_CONFIGr_STG_CHECK_ENABLEf_GET(r) ((((r).ing_misc_config[0]) >> 17) & 0x1)
#define ING_MISC_CONFIGr_STG_CHECK_ENABLEf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define ING_MISC_CONFIGr_USE_DEST_PORTf_GET(r) ((((r).ing_misc_config[0]) >> 19) & 0x1)
#define ING_MISC_CONFIGr_USE_DEST_PORTf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define ING_MISC_CONFIGr_INPUT_PRI_TAGGEDf_GET(r) ((((r).ing_misc_config[0]) >> 20) & 0x1)
#define ING_MISC_CONFIGr_INPUT_PRI_TAGGEDf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define ING_MISC_CONFIGr_INPUT_PRI_UNTAGGEDf_GET(r) ((((r).ing_misc_config[0]) >> 21) & 0x1)
#define ING_MISC_CONFIGr_INPUT_PRI_UNTAGGEDf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))

/*
 * These macros can be used to access ING_MISC_CONFIG.
 */
#define WRITE_ING_MISC_CONFIGr(u,r) bcm5354x_reg_set(u,R_ING_MISC_CONFIG,(r._ing_misc_config))
#define READ_ING_MISC_CONFIGr(u,r) bcm5354x_reg_get(u,R_ING_MISC_CONFIG,&(r._ing_misc_config))

/*******************************************************************************
 * End of 'ING_MISC_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Ingress Physical to Logical Port Number Mapping Table. Indexed by the Physical port number, and provides the corresponding logical port number.
 * SIZE:     6
 * FIELDS:
 *     LOGICAL_PORT_NUMBER Logical Port Number.
 */
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_MIN 0
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_MAX 41
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_CMAX(u) 41
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLE.
 */
typedef union ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_s {
	uint32 v[1];
	uint32 ing_physical_to_logical_port_number_mapping_table[1];
	uint32 _ing_physical_to_logical_port_number_mapping_table;
} ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_t;

#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_CLR(r) (r).ing_physical_to_logical_port_number_mapping_table[0] = 0
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_SET(r,d) (r).ing_physical_to_logical_port_number_mapping_table[0] = d
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_GET(r) (r).ing_physical_to_logical_port_number_mapping_table[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_LOGICAL_PORT_NUMBERf_GET(r) (((r).ing_physical_to_logical_port_number_mapping_table[0]) & 0x3f)
#define ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm_LOGICAL_PORT_NUMBERf_SET(r,f) (r).ing_physical_to_logical_port_number_mapping_table[0]=(((r).ing_physical_to_logical_port_number_mapping_table[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))

/*
 * These macros can be used to access ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLE.
 */
#define WRITE_ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm(u,i,r) bcm5354x_mem_set(u, M_ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLE(i), &(r._ing_physical_to_logical_port_number_mapping_table), 1)
#define READ_ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm(u,i,r) bcm5354x_mem_get(u, M_ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLE(i), &(r._ing_physical_to_logical_port_number_mapping_table), 1)

/*******************************************************************************
 * End of 'ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  ING_PRI_CNG_MAP
 * BLOCKS:   IPIPE
 * DESC:     Per port ingress priority/CFI mapping table. The ING_PRI_CNG_MAP table is used to lookup the (.1p, CFI) bits of incoming VLAN tag to generate (int_pri, CNG). This is done only if the 802.1p bits are trusted on the incoming L2 interface. The index into this table is composed of 10 bits: 6 bits of ingress port, 3 bits for priority, and 1 bit for CFI. The priority and CFI will be taken from the outer tag or inner tag depending on whether USE_INNER_PRI is set.
 * SIZE:     5
 * FIELDS:
 *     CNG              CNG mapped from incoming packet priority and CFG
 *     PRI              Priority mapped from incoming packet priority and CFI
 */
#define ING_PRI_CNG_MAPm_MIN 0
#define ING_PRI_CNG_MAPm_MAX 1070
#define ING_PRI_CNG_MAPm_CMAX(u) 1070
#define ING_PRI_CNG_MAPm_SIZE 1

/*
 * This structure should be used to declare and program ING_PRI_CNG_MAP.
 */
typedef union ING_PRI_CNG_MAPm_s {
	uint32 v[1];
	uint32 ing_pri_cng_map[1];
	uint32 _ing_pri_cng_map;
} ING_PRI_CNG_MAPm_t;

#define ING_PRI_CNG_MAPm_CLR(r) (r).ing_pri_cng_map[0] = 0
#define ING_PRI_CNG_MAPm_SET(r,d) (r).ing_pri_cng_map[0] = d
#define ING_PRI_CNG_MAPm_GET(r) (r).ing_pri_cng_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_PRI_CNG_MAPm_CNGf_GET(r) (((r).ing_pri_cng_map[0]) & 0x3)
#define ING_PRI_CNG_MAPm_CNGf_SET(r,f) (r).ing_pri_cng_map[0]=(((r).ing_pri_cng_map[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define ING_PRI_CNG_MAPm_PRIf_GET(r) ((((r).ing_pri_cng_map[0]) >> 2) & 0x7)
#define ING_PRI_CNG_MAPm_PRIf_SET(r,f) (r).ing_pri_cng_map[0]=(((r).ing_pri_cng_map[0] & ~((uint32)0x7 << 2)) | ((((uint32)f) & 0x7) << 2))

/*
 * These macros can be used to access ING_PRI_CNG_MAP.
 */
#define WRITE_ING_PRI_CNG_MAPm(u,i,r) bcm5354x_mem_set(u, M_ING_PRI_CNG_MAP(i), &(r._ing_pri_cng_map), 1)
#define READ_ING_PRI_CNG_MAPm(u,i,r) bcm5354x_mem_get(u, M_ING_PRI_CNG_MAP(i), &(r._ing_pri_cng_map), 1)

/*******************************************************************************
 * End of 'ING_PRI_CNG_MAPm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  ING_VLAN_TAG_ACTION_PROFILE
 * BLOCKS:   IPIPE
 * DESC:      Actions for the VLAN translation.
The index into this table is supplied from the TAG_ACTION_PROFILE_PTR field in PORT, IPORT, LPORT, VLAN_SUBNET, VLAN_PROTOCOL, VLAN_XLATE, or VLAN_MAC table
 * SIZE:     24
 * FIELDS:
 *     UT_ITAG_ACTION   Specifies the inner VLAN tag action if incoming packet is untagged:0 = do not modify1 = add internal IVID2 = reserved3 = reserved
 *     UT_OTAG_ACTION   Specifies the outer VLAN tag action if incoming packet untagged:0 = do not modify1 = add internal OVID2 = reserved3 = reserved
 *     SIT_PITAG_ACTION Specifies the inner VLAN tag action if incoming packet is single inner-tagged and priority-tagged:0 = do not modify1 = reserved2 = replace incoming IVID with internal IVID3 = delete incoming IVID
 *     SIT_ITAG_ACTION  Specifies the inner VLAN tag action if incoming packet is single inner-tagged and not priority-tagged:0 = do not modify1 = reserved2 = replace incoming IVID with internal IVID3 = delete incoming IVID
 *     SIT_OTAG_ACTION  Specifies the inner VLAN tag action if incoming packet is single inner-tagged and not priority-tagged:0 = do not modify1 = add internal OVID2 = reserved3 = reserved
 *     SOT_ITAG_ACTION  Specifies the inner VLAN tag action if incoming packet is single outer-tagged:0 = do not modify1 = add internal IVID2 = reserved3 = reserved
 *     SOT_POTAG_ACTION Specifies the outer VLAN tag action if incoming packet is single outer-tagged and priority-tagged:0 = do not modify1 = add internal OVID2 = replace incoming OVID with internal OVID3 = delete incoming OVID
 *     SOT_OTAG_ACTION  Specifies the outer VLAN tag action if incoming packet is single outer-tagged:0 = do not modify1 = add internal OVID2 = replace incoming OVID with internal OVID3 = delete incoming OVID
 *     DT_PITAG_ACTION  Specifies the inner VLAN tag action if incoming packet is double tagged and inner tag is a priority tag:0 = do not modify1 = reserved2 = replace incoming IVID with internal IVID3 = delete incoming IVID
 *     DT_ITAG_ACTION   Specifies the inner VLAN tag action if incoming packet is double tagged:0 = do not modify1 = reserved2 = replace incoming IVID with internal IVID3 = delete incoming IVID
 *     DT_POTAG_ACTION  Specifies the outer VLAN tag action if incoming packet is double tagged and priority-tagged:0 = do not modify1 = add internal OVID2 = replace incoming OVID with internal OVID3 = delete incoming OVID
 *     DT_OTAG_ACTION   Specifies the outer VLAN tag action if incoming packet is double tagged:0 = do not modify1 = add internal OVID2 = replace incoming OVID with internal OVID3 = delete incoming OVID
 */
#define ING_VLAN_TAG_ACTION_PROFILEm_MIN 0
#define ING_VLAN_TAG_ACTION_PROFILEm_MAX 31
#define ING_VLAN_TAG_ACTION_PROFILEm_CMAX(u) 31
#define ING_VLAN_TAG_ACTION_PROFILEm_SIZE 3

/*
 * This structure should be used to declare and program ING_VLAN_TAG_ACTION_PROFILE.
 */
typedef union ING_VLAN_TAG_ACTION_PROFILEm_s {
	uint32 v[1];
	uint32 ing_vlan_tag_action_profile[1];
	uint32 _ing_vlan_tag_action_profile;
} ING_VLAN_TAG_ACTION_PROFILEm_t;

#define ING_VLAN_TAG_ACTION_PROFILEm_CLR(r) (r).ing_vlan_tag_action_profile[0] = 0
#define ING_VLAN_TAG_ACTION_PROFILEm_SET(r,d) (r).ing_vlan_tag_action_profile[0] = d
#define ING_VLAN_TAG_ACTION_PROFILEm_GET(r) (r).ing_vlan_tag_action_profile[0]

/*
 * These macros can be used to access individual fields.
 */
#define ING_VLAN_TAG_ACTION_PROFILEm_UT_ITAG_ACTIONf_GET(r) (((r).ing_vlan_tag_action_profile[0]) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_UT_ITAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define ING_VLAN_TAG_ACTION_PROFILEm_UT_OTAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 2) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_UT_OTAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define ING_VLAN_TAG_ACTION_PROFILEm_SIT_PITAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 4) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_SIT_PITAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define ING_VLAN_TAG_ACTION_PROFILEm_SIT_ITAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 6) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_SIT_ITAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define ING_VLAN_TAG_ACTION_PROFILEm_SIT_OTAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 8) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_SIT_OTAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define ING_VLAN_TAG_ACTION_PROFILEm_SOT_ITAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 10) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_SOT_ITAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define ING_VLAN_TAG_ACTION_PROFILEm_SOT_POTAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 12) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_SOT_POTAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define ING_VLAN_TAG_ACTION_PROFILEm_SOT_OTAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 14) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_SOT_OTAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_PITAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 16) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_PITAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_ITAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 18) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_ITAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_POTAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 20) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_POTAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_OTAG_ACTIONf_GET(r) ((((r).ing_vlan_tag_action_profile[0]) >> 22) & 0x3)
#define ING_VLAN_TAG_ACTION_PROFILEm_DT_OTAG_ACTIONf_SET(r,f) (r).ing_vlan_tag_action_profile[0]=(((r).ing_vlan_tag_action_profile[0] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))

/*
 * These macros can be used to access ING_VLAN_TAG_ACTION_PROFILE.
 */
#define WRITE_ING_VLAN_TAG_ACTION_PROFILEm(u,i,r) bcm5354x_mem_set(u, M_ING_VLAN_TAG_ACTION_PROFILE(i), &(r._ing_vlan_tag_action_profile), 1)
#define READ_ING_VLAN_TAG_ACTION_PROFILEm(u,i,r) bcm5354x_mem_get(u, M_ING_VLAN_TAG_ACTION_PROFILE(i), &(r._ing_vlan_tag_action_profile), 1)

/*******************************************************************************
 * End of 'ING_VLAN_TAG_ACTION_PROFILEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  IPROC_WRAP_TOP_STRAP_STATUS_1
 * BLOCKS:   CMIC
 * DESC:     top strap pin status 1 register
 * SIZE:     32
 * FIELDS:
 *     STRAP_STATUS     Bit 0:strap_xtal_freq_sel 0 : XTAL output clock frequence is 25MHz. 1 : XTAL output clock frequence is 50MHz.Bit 2: strap_gphy_sgmii_sel[1] 0 : Front ports select SGMII , OOB port select GPHY  1 : Front ports select GPHY  , OOB port select SGMIIBit 1: strap_gphy_sgmii_sel[0] 0 : Front ports select SGMII  1 : Front ports select GPHYBit 31-3: reserved
 */
#define IPROC_WRAP_TOP_STRAP_STATUS_1r_SIZE 4

/*
 * This structure should be used to declare and program IPROC_WRAP_TOP_STRAP_STATUS_1.
 */
typedef union IPROC_WRAP_TOP_STRAP_STATUS_1r_s {
	uint32 v[1];
	uint32 iproc_wrap_top_strap_status_1[1];
	uint32 _iproc_wrap_top_strap_status_1;
} IPROC_WRAP_TOP_STRAP_STATUS_1r_t;

#define IPROC_WRAP_TOP_STRAP_STATUS_1r_CLR(r) (r).iproc_wrap_top_strap_status_1[0] = 0
#define IPROC_WRAP_TOP_STRAP_STATUS_1r_SET(r,d) (r).iproc_wrap_top_strap_status_1[0] = d
#define IPROC_WRAP_TOP_STRAP_STATUS_1r_GET(r) (r).iproc_wrap_top_strap_status_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define IPROC_WRAP_TOP_STRAP_STATUS_1r_STRAP_STATUSf_GET(r) ((r).iproc_wrap_top_strap_status_1[0])
#define IPROC_WRAP_TOP_STRAP_STATUS_1r_STRAP_STATUSf_SET(r,f) (r).iproc_wrap_top_strap_status_1[0]=((uint32)f)

/*
 * These macros can be used to access IPROC_WRAP_TOP_STRAP_STATUS_1.
 */
#define READ_IPROC_WRAP_TOP_STRAP_STATUS_1r(u,r) bcm5354x_read32(u, IPROC_WRAP_TOP_STRAP_STATUS_1, &(r._iproc_wrap_top_strap_status_1))
#define WRITE_IPROC_WRAP_TOP_STRAP_STATUS_1r(u,r) bcm5354x_write32(u, IPROC_WRAP_TOP_STRAP_STATUS_1, (r._iproc_wrap_top_strap_status_1))

/*******************************************************************************
 * End of 'IPROC_WRAP_TOP_STRAP_STATUS_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  IP_TO_CMICM_CREDIT_TRANSFER
 * BLOCKS:   IPIPE
 * DESC:     Controls the number of credits transferred from IP to CMICM for data transfer purposes.
 * SIZE:     32
 * FIELDS:
 *     NUM_OF_CREDITS   Number of 8 byte credits available for CMIC.
 *     TRANSFER_ENABLE  Enable the transfer of credits from IP to CMIC
 */
#define IP_TO_CMICM_CREDIT_TRANSFERr_SIZE 4

/*
 * This structure should be used to declare and program IP_TO_CMICM_CREDIT_TRANSFER.
 */
typedef union IP_TO_CMICM_CREDIT_TRANSFERr_s {
	uint32 v[1];
	uint32 ip_to_cmicm_credit_transfer[1];
	uint32 _ip_to_cmicm_credit_transfer;
} IP_TO_CMICM_CREDIT_TRANSFERr_t;

#define IP_TO_CMICM_CREDIT_TRANSFERr_CLR(r) (r).ip_to_cmicm_credit_transfer[0] = 0
#define IP_TO_CMICM_CREDIT_TRANSFERr_SET(r,d) (r).ip_to_cmicm_credit_transfer[0] = d
#define IP_TO_CMICM_CREDIT_TRANSFERr_GET(r) (r).ip_to_cmicm_credit_transfer[0]

/*
 * These macros can be used to access individual fields.
 */
#define IP_TO_CMICM_CREDIT_TRANSFERr_NUM_OF_CREDITSf_GET(r) (((r).ip_to_cmicm_credit_transfer[0]) & 0x3f)
#define IP_TO_CMICM_CREDIT_TRANSFERr_NUM_OF_CREDITSf_SET(r,f) (r).ip_to_cmicm_credit_transfer[0]=(((r).ip_to_cmicm_credit_transfer[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define IP_TO_CMICM_CREDIT_TRANSFERr_TRANSFER_ENABLEf_GET(r) ((((r).ip_to_cmicm_credit_transfer[0]) >> 6) & 0x1)
#define IP_TO_CMICM_CREDIT_TRANSFERr_TRANSFER_ENABLEf_SET(r,f) (r).ip_to_cmicm_credit_transfer[0]=(((r).ip_to_cmicm_credit_transfer[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))

/*
 * These macros can be used to access IP_TO_CMICM_CREDIT_TRANSFER.
 */
#define WRITE_IP_TO_CMICM_CREDIT_TRANSFERr(u,r) bcm5354x_reg_set(u,R_IP_TO_CMICM_CREDIT_TRANSFER,(r._ip_to_cmicm_credit_transfer))
#define READ_IP_TO_CMICM_CREDIT_TRANSFERr(u,r) bcm5354x_reg_get(u,R_IP_TO_CMICM_CREDIT_TRANSFER,&(r._ip_to_cmicm_credit_transfer))

/*******************************************************************************
 * End of 'IP_TO_CMICM_CREDIT_TRANSFERr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  IUNKNOWN_MCAST_BLOCK_MASK_64
 * BLOCKS:   IPIPE
 * DESC:     Unknown Multicast Block Mask
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked. 1=Block, 0=Allow
 *     BLK_BITMAP_0     Overlay bitmap for ports 31:0. 1=Block, 0=Allow
 */
#define IUNKNOWN_MCAST_BLOCK_MASK_64r_SIZE 4

/*
 * This structure should be used to declare and program IUNKNOWN_MCAST_BLOCK_MASK_64.
 */
typedef union IUNKNOWN_MCAST_BLOCK_MASK_64r_s {
	uint32 v[1];
	uint32 iunknown_mcast_block_mask_64[1];
	uint32 _iunknown_mcast_block_mask_64;
} IUNKNOWN_MCAST_BLOCK_MASK_64r_t;

#define IUNKNOWN_MCAST_BLOCK_MASK_64r_CLR(r) (r).iunknown_mcast_block_mask_64[0] = 0
#define IUNKNOWN_MCAST_BLOCK_MASK_64r_SET(r,d) (r).iunknown_mcast_block_mask_64[0] = d
#define IUNKNOWN_MCAST_BLOCK_MASK_64r_GET(r) (r).iunknown_mcast_block_mask_64[0]

/*
 * These macros can be used to access individual fields.
 */
#define IUNKNOWN_MCAST_BLOCK_MASK_64r_BLK_BITMAPf_GET(r) ((r).iunknown_mcast_block_mask_64[0])
#define IUNKNOWN_MCAST_BLOCK_MASK_64r_BLK_BITMAPf_SET(r,f) (r).iunknown_mcast_block_mask_64[0]=((uint32)f)
#define IUNKNOWN_MCAST_BLOCK_MASK_64r_BLK_BITMAP_0f_GET(r) ((r).iunknown_mcast_block_mask_64[0])
#define IUNKNOWN_MCAST_BLOCK_MASK_64r_BLK_BITMAP_0f_SET(r,f) (r).iunknown_mcast_block_mask_64[0]=((uint32)f)

/*
 * These macros can be used to access IUNKNOWN_MCAST_BLOCK_MASK_64.
 */
#define WRITE_IUNKNOWN_MCAST_BLOCK_MASK_64r(u,p,r) bcm5354x_reg_set(u,R_IUNKNOWN_MCAST_BLOCK_MASK_64(p),(r._iunknown_mcast_block_mask_64))
#define READ_IUNKNOWN_MCAST_BLOCK_MASK_64r(u,p,r) bcm5354x_reg_get(u,R_IUNKNOWN_MCAST_BLOCK_MASK_64(p),&(r._iunknown_mcast_block_mask_64))

/*******************************************************************************
 * End of 'IUNKNOWN_MCAST_BLOCK_MASK_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  IUNKNOWN_UCAST_BLOCK_MASK_64
 * BLOCKS:   IPIPE
 * DESC:     Unknown Unicast Block Mask
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked. 1=Block, 0=Allow
 *     BLK_BITMAP_0     Overlay bitmap for ports 31:0. 1=Block, 0=Allow
 */
#define IUNKNOWN_UCAST_BLOCK_MASK_64r_SIZE 4

/*
 * This structure should be used to declare and program IUNKNOWN_UCAST_BLOCK_MASK_64.
 */
typedef union IUNKNOWN_UCAST_BLOCK_MASK_64r_s {
	uint32 v[1];
	uint32 iunknown_ucast_block_mask_64[1];
	uint32 _iunknown_ucast_block_mask_64;
} IUNKNOWN_UCAST_BLOCK_MASK_64r_t;

#define IUNKNOWN_UCAST_BLOCK_MASK_64r_CLR(r) (r).iunknown_ucast_block_mask_64[0] = 0
#define IUNKNOWN_UCAST_BLOCK_MASK_64r_SET(r,d) (r).iunknown_ucast_block_mask_64[0] = d
#define IUNKNOWN_UCAST_BLOCK_MASK_64r_GET(r) (r).iunknown_ucast_block_mask_64[0]

/*
 * These macros can be used to access individual fields.
 */
#define IUNKNOWN_UCAST_BLOCK_MASK_64r_BLK_BITMAPf_GET(r) ((r).iunknown_ucast_block_mask_64[0])
#define IUNKNOWN_UCAST_BLOCK_MASK_64r_BLK_BITMAPf_SET(r,f) (r).iunknown_ucast_block_mask_64[0]=((uint32)f)
#define IUNKNOWN_UCAST_BLOCK_MASK_64r_BLK_BITMAP_0f_GET(r) ((r).iunknown_ucast_block_mask_64[0])
#define IUNKNOWN_UCAST_BLOCK_MASK_64r_BLK_BITMAP_0f_SET(r,f) (r).iunknown_ucast_block_mask_64[0]=((uint32)f)

/*
 * These macros can be used to access IUNKNOWN_UCAST_BLOCK_MASK_64.
 */
#define WRITE_IUNKNOWN_UCAST_BLOCK_MASK_64r(u,p,r) bcm5354x_reg_set(u,R_IUNKNOWN_UCAST_BLOCK_MASK_64(p),(r._iunknown_ucast_block_mask_64))
#define READ_IUNKNOWN_UCAST_BLOCK_MASK_64r(u,p,r) bcm5354x_reg_get(u,R_IUNKNOWN_UCAST_BLOCK_MASK_64(p),&(r._iunknown_ucast_block_mask_64))

/*******************************************************************************
 * End of 'IUNKNOWN_UCAST_BLOCK_MASK_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  L2MC
 * BLOCKS:   IPIPE
 * DESC:     L2 Multicast table
The multicast table is 64 entries deep and 32 bits wide. If the destination MAC address is a multicast address, then the result of the destination lookup is a 9-bit index (L2MC_PTR) into this table. The result of the direct index into the L2 multicast table is a bitmap that indicates which ports on the local switch should receive the packet. The MC Port Bitmap is qualified with the VLAN bitmap. The MC Port bitmap is picked up from the L2MC table
 * SIZE:     42
 * FIELDS:
 *     HIGIG_TRUNK_OVERRIDE Higig Trunk Override indicationWhen set, indicates the HiGig port bitmap cannot be modified by HiGig trunking logic
 *     RESERVED_1       Reserved
 *     PORT_BITMAP      Multicast port membership bitmap
 *     PORT_BITMAP_LO   Multicast port membership
 *     VALID            Indicates that the entry is valid
 *     EVEN_PARITY      Even parity bit
 */
#define L2MCm_MIN 0
#define L2MCm_MAX 511
#define L2MCm_CMAX(u) 511
#define L2MCm_SIZE 6

/*
 * This structure should be used to declare and program L2MC.
 */
typedef union L2MCm_s {
	uint32 v[2];
	uint32 l2mc[2];
	uint32 _l2mc;
} L2MCm_t;

#define L2MCm_CLR(r) sal_memset(&((r)._l2mc), 0, sizeof(L2MCm_t))
#define L2MCm_SET(r,i,d) (r).l2mc[i] = d
#define L2MCm_GET(r,i) (r).l2mc[i]

/*
 * These macros can be used to access individual fields.
 */
#define L2MCm_HIGIG_TRUNK_OVERRIDEf_GET(r) (((r).l2mc[0]) & 0x1)
#define L2MCm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2MCm_RESERVED_1f_GET(r) ((((r).l2mc[0]) >> 1) & 0x7f)
#define L2MCm_RESERVED_1f_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32)0x7f << 1)) | ((((uint32)f) & 0x7f) << 1))
#define L2MCm_PORT_BITMAPf_GET(r) field32_get((r).l2mc,8,39)
#define L2MCm_PORT_BITMAPf_SET(r,f) field32_set((r).l2mc,8,39,f)
#define L2MCm_PORT_BITMAP_LOf_GET(r) field32_get((r).l2mc,8,39)
#define L2MCm_PORT_BITMAP_LOf_SET(r,f) field32_set((r).l2mc,8,39,f)
#define L2MCm_VALIDf_GET(r) ((((r).l2mc[1]) >> 8) & 0x1)
#define L2MCm_VALIDf_SET(r,f) (r).l2mc[1]=(((r).l2mc[1] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define L2MCm_EVEN_PARITYf_GET(r) ((((r).l2mc[1]) >> 9) & 0x1)
#define L2MCm_EVEN_PARITYf_SET(r,f) (r).l2mc[1]=(((r).l2mc[1] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))

/*
 * These macros can be used to access L2MC.
 */
#define WRITE_L2MCm(u,i,r) bcm5354x_mem_set(u, M_L2MC(i), &(r._l2mc), 2)
#define READ_L2MCm(u,i,r) bcm5354x_mem_get(u, M_L2MC(i), &(r._l2mc), 2)

/*******************************************************************************
 * End of 'L2MCm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  L2_AGE_TIMER
 * BLOCKS:   IPIPE
 * DESC:     Age Timer Register
 * SIZE:     32
 * FIELDS:
 *     AGE_VAL          Age Limit. Value is the age timer in units of 1 second to age dynamic entries. Default is 300 seconds. When aging is first enabled, it may take up to three times the AGE_VAL for aging to occur because AGE_ENA is asynchronous to the internal timers. Note: IEEE 802.1d specification range is 10 to 1,000,000 seconds.
 *     AGE_ENA          Age Enable
 */
#define L2_AGE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program L2_AGE_TIMER.
 */
typedef union L2_AGE_TIMERr_s {
	uint32 v[1];
	uint32 l2_age_timer[1];
	uint32 _l2_age_timer;
} L2_AGE_TIMERr_t;

#define L2_AGE_TIMERr_CLR(r) (r).l2_age_timer[0] = 0
#define L2_AGE_TIMERr_SET(r,d) (r).l2_age_timer[0] = d
#define L2_AGE_TIMERr_GET(r) (r).l2_age_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define L2_AGE_TIMERr_AGE_VALf_GET(r) (((r).l2_age_timer[0]) & 0xfffff)
#define L2_AGE_TIMERr_AGE_VALf_SET(r,f) (r).l2_age_timer[0]=(((r).l2_age_timer[0] & ~((uint32)0xfffff)) | (((uint32)f) & 0xfffff))
#define L2_AGE_TIMERr_AGE_ENAf_GET(r) ((((r).l2_age_timer[0]) >> 20) & 0x1)
#define L2_AGE_TIMERr_AGE_ENAf_SET(r,f) (r).l2_age_timer[0]=(((r).l2_age_timer[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))

/*
 * These macros can be used to access L2_AGE_TIMER.
 */
#define WRITE_L2_AGE_TIMERr(u,r) bcm5354x_reg_set(u,R_L2_AGE_TIMER,(r._l2_age_timer))
#define READ_L2_AGE_TIMERr(u,r) bcm5354x_reg_get(u,R_L2_AGE_TIMER,&(r._l2_age_timer))

/*******************************************************************************
 * End of 'L2_AGE_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  L2_AUX_HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2_AUX_HASH_CONTROL Register. Enable dual hashing mode for the L2 table. The hashing mode in this register is for the second group of L2 tables. The hashing mode for first group of L2 tables is controlled via the HASH_SELECT register. 
 * SIZE:     32
 * FIELDS:
 *     INSERT_LEAST_FULL_HALF If set to 1, insert entry into the least full half of the hash location.
 *     HASH_SELECT      Select hashing modes for the L2 table second group lookup.
 *     ENABLE           If set, enables the dual hashing feature. This is to improve the first miss utilization.
 */
#define L2_AUX_HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2_AUX_HASH_CONTROL.
 */
typedef union L2_AUX_HASH_CONTROLr_s {
	uint32 v[1];
	uint32 l2_aux_hash_control[1];
	uint32 _l2_aux_hash_control;
} L2_AUX_HASH_CONTROLr_t;

#define L2_AUX_HASH_CONTROLr_CLR(r) (r).l2_aux_hash_control[0] = 0
#define L2_AUX_HASH_CONTROLr_SET(r,d) (r).l2_aux_hash_control[0] = d
#define L2_AUX_HASH_CONTROLr_GET(r) (r).l2_aux_hash_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define L2_AUX_HASH_CONTROLr_INSERT_LEAST_FULL_HALFf_GET(r) (((r).l2_aux_hash_control[0]) & 0x1)
#define L2_AUX_HASH_CONTROLr_INSERT_LEAST_FULL_HALFf_SET(r,f) (r).l2_aux_hash_control[0]=(((r).l2_aux_hash_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_AUX_HASH_CONTROLr_HASH_SELECTf_GET(r) ((((r).l2_aux_hash_control[0]) >> 1) & 0x7)
#define L2_AUX_HASH_CONTROLr_HASH_SELECTf_SET(r,f) (r).l2_aux_hash_control[0]=(((r).l2_aux_hash_control[0] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define L2_AUX_HASH_CONTROLr_ENABLEf_GET(r) ((((r).l2_aux_hash_control[0]) >> 4) & 0x1)
#define L2_AUX_HASH_CONTROLr_ENABLEf_SET(r,f) (r).l2_aux_hash_control[0]=(((r).l2_aux_hash_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))

/*
 * These macros can be used to access L2_AUX_HASH_CONTROL.
 */
#define WRITE_L2_AUX_HASH_CONTROLr(u,r) bcm5354x_reg_set(u,R_L2_AUX_HASH_CONTROL,(r._l2_aux_hash_control))
#define READ_L2_AUX_HASH_CONTROLr(u,r) bcm5354x_reg_get(u,R_L2_AUX_HASH_CONTROL,&(r._l2_aux_hash_control))

/*******************************************************************************
 * End of 'L2_AUX_HASH_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  L2_ENTRY
 * BLOCKS:   IPIPE
 * DESC:     Combined HW-managed L2 entry table. Includes L2_ENTRY, L2_HITDA, and L2_HITSA. This table and the three tables it includes are hashed tables. The fields used for the hash depends on the definition specified in KEY_TYPE. To manipulate and look up entries in the table, please use S-channel Message OPCODES TBL_INS, TBL_DEL and TBL_LKUP.
 * SIZE:     107
 * FIELDS:
 *     KEY_TYPE         KEY: Key type
 *     LEGACY:OVID      KEY TYPE 1 or 2: OVID
 *     LEGACY:VLAN_ID   KEY TYPE 0: VLAN ID
 *     LEGACY:MAC_ADDR  KEY TYPE 0: MAC address
 *     LEGACY:IVID      KEY TYPE 2: IVID
 *     LEGACY:DESTINATION_1 Destination fields for KEY_TYPE = 1 and 2
 *     LEGACY:PORT_NUM_1 Port if T_1==0
 *     LEGACY:TGID_1    Trunk ID value if T_1==1
 *     LEGACY:MODULE_ID_1 Module ID if T_1==0
 *     LEGACY:REMOTE_TRUNK_1 When T_1==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     LEGACY:T_1       Indicates destination is a LAG
 *     LEGACY:ASSOCIATED_DATA Entire associated data for KEY_TYPE = 0
 *     LEGACY:DESTINATION Destination fields for KEY_TYPE = 0, 1 and 2
 *     LEGACY:VPG       Reserved
 *     LEGACY:L2MC_PTR  L2MC pointer if MAC_ADDR[40]==1
 *     LEGACY:PORT_NUM  Port if T==0
 *     LEGACY:TGID      Trunk ID value if T==1
 *     LEGACY:MODULE_ID Module ID if T==0
 *     LEGACY:REMOTE_TRUNK When T==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     LEGACY:DEST_TYPE Indicates destination type.		    For VLAN-based keys:		    00 = {MODID, PORT} or L2MC_index		    01 = {'0', TGID} or L2MC_index		    #10 = GPON DVPG		    11 = GPON Multicast (L3MC_index)		    		    #For VFI-based keys:		    #10 = VPLS DVP		    #11 = VPLS Multicast (L3MC_index)
 *     LEGACY:T         Trunk bit(overlay)Indicates destination is a LAG
 *     LEGACY:L3        Identifies this entry as the result of L3 interface configuration. The MAC address inthis entry is an L3 interface MAC address; any packet addressed to this MAC address needs to be routed
 *     LEGACY:CLASS_ID  L2 Classification ID used for ingress ContentAware engine
 *     LEGACY:MAC_BLOCK_INDEX This field indicates the index into the PORT_MAC Block Index
 *     LEGACY:DUMMY_INDEX Reserved when using CLASS_ID overlay
 *     LEGACY:RPE       Remap Priority Enable bit0 = Do not use the IEEE 802.1p priority from L2_ENTRY.PRI. Recommended setting when the priority is to be obtained from the VLAN tables or the PORT table for untagged packets.1 = Use the IEEE 802.1p priority from the L2_ENTRY.PRI field. This overwrites any priority obtained from the VLAN tables or the default priority from the PORT table. This is applicable for untagged packets and for tagged packets when PORT.MAP_TAG_PACKET_PRIORITYT=1.
 *     LEGACY:MIRROR    Mirror bit
 *     LEGACY:MIRROR0   Mirror container bitmap to enable egress mirroring Egress mirror port bitmaps are defined in EMIRROR_CONTROL table
 *     LEGACY:PRI       Identifies the priority of the packet. Used when L2_ENTRY.RPE=1
 *     LEGACY:CPU       Sends the packet to the CPU when set
 *     LEGACY:DST_DISCARD Destination DiscardThis bit identifies whether the packet should be discarded based on the the destination address. Set to discard
 *     LEGACY:SRC_DISCARD Source DiscardThis bit identifies whether the packet should be discarded based on the the source address. Set to discard
 *     LEGACY:SCP       Source CoS PriorityIf this bit is set in the matched source entry, the source CoS has priority over destination CoS
 *     LEGACY:LIMIT_COUNTED Indicates if entry is counted for MAC limits.  CPU INSERT can set/reset for new entry as needed/  HW LEARNs always set this bit.
 *     LEGACY:REMOTE    Indicates if entry is learned from a local port (0) or a remote port (1).  Note: CPU must set this field correctly for CPU INSERT commands.
 *     LEGACY:STATIC_BIT Indicates entry is software programmed and static
 *     LEGACY:PENDING   Indicates that the entry is pending validation from software
 *     L2:VLAN_ID       KEY TYPE 0: VLAN ID
 *     L2:MAC_ADDR      KEY TYPE 0: MAC address
 *     L2:RESVEVED_63   RESERVED.
 *     L2:ASSOCIATED_DATA Entire associated data for KEY_TYPE = 0
 *     L2:DESTINATION   Destination fields for KEY_TYPE = 0, 1 and 2
 *     L2:L2MC_PTR      L2MC pointer if MAC_ADDR[40]==1
 *     L2:PORT_NUM      Port if T==0
 *     L2:TGID          Trunk ID value if T==1
 *     L2:MODULE_ID     Module ID if T==0
 *     L2:REMOTE_TRUNK  When T==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     L2:DEST_TYPE     Indicates destination type.		    For VLAN-based keys:		    00 = {MODID, PORT} or L2MC_index		    01 = {'0', TGID} or L2MC_index		    #10 = GPON DVPG		    11 = GPON Multicast (L3MC_index)		    		    #For VFI-based keys:		    #10 = VPLS DVP		    #11 = VPLS Multicast (L3MC_index)
 *     L2:T             Trunk bit(overlay)Indicates destination is a LAG
 *     L2:L3            Identifies this entry as the result of L3 interface configuration. The MAC address in this entry is an L3 interface MAC address; any packet addressed to this MAC address needs to be routed
 *     L2:CLASS_ID      L2 Classification ID used for ingress ContentAware engine
 *     L2:MAC_BLOCK_INDEX This field indicates the index into the PORT_MAC_BLOCK table
 *     L2:DUMMY_INDEX   Reserved when using CLASS_ID overlay
 *     L2:RPE           Remap Priority Enable bit 0 = Do not use the IEEE 802.1p priority from L2_ENTRY.PRI. Recommended setting when the priority is to be obtained from the VLAN tables or the PORT table for untagged packets. 1 = Use the IEEE 802.1p priority from the L2_ENTRY.PRI field. This overwrites any priority obtained from the VLAN tables or the default priority from the PORT table. This is applicable for untagged packets and for tagged packets when PORT.MAP_TAG_PACKET_PRIORITYT=1.
 *     L2:MIRROR        Mirror container bitmap to enable egress mirroring Egress mirror port bitmaps are defined in EMIRROR_CONTROL table 
 *     L2:MIRROR0       Mirror bit
 *     L2:PRI           PRI Identifies the priority of the packet. Used when L2_ENTRY.RPE=1
 *     L2:CPU           Sends the packet to CPU when set
 *     L2:DST_DISCARD   Destination DiscardThis bit identifies whether the packet should be discarded based on the the destination address. Set to discard
 *     L2:SRC_DISCARD   Source DiscardThis bit identifies whether the packet should be discarded based on the the source address. Set to discard
 *     L2:SCP           Source CoS PriorityIf this bit is set in the matched source entry, the source CoS has priority over destination CoS 
 *     L2:LIMIT_COUNTED Indicates if entry is counted for MAC limits.  CPU INSERT can set/reset for new entry as needed/  HW LEARNs always set this bit.
 *     L2:REMOTE        Indicates if entry is learned from a local port (0) or a remote port (1).  Note: CPU must set this field correctly for CPU INSERT commands.
 *     L2:STATIC_BIT    Indicates entry is SW programmed and static
 *     L2:PENDING       Indicates that the entry is pending validation from software
 *     VLAN:OVID        KEY TYPE 1 or 2: OVID
 *     VLAN:IVID        KEY TYPE 2: IVID
 *     VLAN:DESTINATION_1 Destination fields for KEY_TYPE = 1 and 2
 *     VLAN:PORT_NUM_1  Port if T_1==0
 *     VLAN:TGID_1      Trunk ID value if T_1==1
 *     VLAN:MODULE_ID_1 Module ID if T_1==0
 *     VLAN:REMOTE_TRUNK_1 When T_1==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     VLAN:T_1         Indicates destination is a LAG
 *     VLAN:DESTINATION Destination fields for KEY_TYPE = 0, 1 and 2
 *     VLAN:PORT_NUM    Port if T==0
 *     VLAN:TGID        Trunk ID value if T==1
 *     VLAN:MODULE_ID   Module ID if T==0
 *     VLAN:REMOTE_TRUNK When T==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     VLAN:DEST_TYPE   Indicates destination type.		    For VLAN-based keys:		    00 = {MODID, PORT} or L2MC_index		    01 = {'0', TGID} or L2MC_index		    #10 = GPON DVPG		    11 = GPON Multicast (L3MC_index)		    		    #For VFI-based keys:		    #10 = VPLS DVP		    #11 = VPLS Multicast (L3MC_index)
 *     VLAN:T           Trunk bit(overlay)Indicates destination is a LAG
 *     VLAN:L3          Identifies this entry as the result of L3 interface configuration. The MAC address in this entry is an L3 interface MAC address; any packet addressed to this MAC address needs to be routed
 *     VLAN:CLASS_ID    L2 Classification ID used for ingress ContentAware egnine
 *     VLAN:MAC_BLOCK_INDEX This field indicates the index into the PORT_MAC_BLOCK table
 *     VLAN:DUMMY_INDEX Reserved when using CLASS_ID overlay
 *     VLAN:RPE         Remap Priority Enable bit0 = Do not use the IEEE 802.1p priority from L2_ENTRY.PRI. Recommended setting when the priority is to be obtained from the VLAN tables or the PORT table for untagged packets.1 = Use the IEEE 802.1p priority from the L2_ENTRY.PRI field. This overwrites any priority obtained from the VLAN tables or the default priority from the PORT table. This is applicable for untagged packets and for tagged packets when PORT.MAP_TAG_PACKET_PRIORITYT=1.
 *     VLAN:MIRROR      MIRROR Mirror container bitmap to enable egress mirroring Egress mirror port bitmaps are defined in EMIRROR_CONTROL table
 *     VLAN:MIRROR0     Mirror bit
 *     VLAN:PRI         Identifies the priority of the packet. Used when L2_ENTRY.RPE=1
 *     VLAN:CPU         Sends the packet to the CPU when set
 *     VLAN:DST_DISCARD DISCARD Destination Discard This bit identifies whether the packet should be discarded based on the the destination address. Set to discard
 *     VLAN:SRC_DISCARD DISCARD Source Discard This bit identifies whether the packet should be discarded based on the the source address. Set to discard
 *     VLAN:SCP         Source CoS PriorityIf this bit is set in the matched source entry, the source CoS has priority over destination CoS
 *     VLAN:LIMIT_COUNTED Indicates if entry is counted for MAC limits.  CPU INSERT can set/reset for new entry as needed/  HW LEARNs always set this bit.
 *     VLAN:REMOTE      Indicates if entry is learned from a local port (0) or a remote port (1).  Note: CPU must set this field correctly for CPU INSERT commands.
 *     VLAN:STATIC_BIT  Indicates entry is software programmed and static
 *     VLAN:PENDING     Indicates that the entry is pending validation from software
 *     VIF:KEY          Key for KEY_TYPE = VIF.
 *     VIF:NAMESPACE    KEY TYPE VIF: Ingress Ports associated Namespace from PORT_TABLE.
 *     VIF:DST_VIF      KEY TYPE VIF: The dst_vif field of the incoming packet's VNTAG.
 *     VIF:P            KEY TYPE VIF: The p field of the incoming packet's VNTAG.
 *     VIF:ASSOCIATED_DATA Entire associated data for KEY_TYPE = VIF
 *     VIF:DESTINATION  Destination fields for KEY_TYPE = 0, 1 and 2
 *     VIF:L2MC_PTR     L2MC pointer if MAC_ADDR[40]==1
 *     VIF:PORT_NUM     Port if T==0 and VPG_TYPE==0
 *     VIF:TGID         Trunk ID value if T==1
 *     VIF:MODULE_ID    Module ID if T==0 and VPG_TYPE==0
 *     VIF:REMOTE_TRUNK When T==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     VIF:DEST_TYPE    Indicates destination type.		    For VIF-based keys:		    00 = {MODID, PORT} or L2MC_index		    01 = {'0', TGID} or L2MC_index
 *     VIF:T            Indicates destination is a LAG
 *     VIF:RESERVED_78  RESERVED.
 *     VIF:CLASS_ID     L2 Classification ID used for ingress FP
 *     VIF:MAC_BLOCK_INDEX MAC Block Index
 *     VIF:DUMMY_INDEX  Dummy base field to line up with CLASS_ID overlay
 *     VIF:RPE          RPE bit
 *     VIF:RESERVED_89  RESERVED.
 *     VIF:PRI          Priority
 *     VIF:CPU          CPU bit
 *     VIF:DST_DISCARD  Dst Discard
 *     VIF:SRC_DISCARD  Src Discard
 *     VIF:SCP          SCP bit
 *     VIF:RESERVED_96  RESERVED.
 *     VIF:REMOTE       Indicates if entry is learned from a local port (0) or a remote port (1).  Note: CPU must set this field correctly for CPU INSERT commands.
 *     VIF:STATIC_BIT   Indicates entry is SW programmed and static
 *     VIF:PENDING      Indicates that the entry is pending validation from software
 *     PE_VID:KEY       Key for KEY_TYPE = VIF.
 *     PE_VID:NAMESPACE KEY TYPE PE_VID: Ingress Ports associated Namespace from PORT_TABLE.
 *     PE_VID:ETAG_VID  KEY TYPE PE_VID: The VID field of the incoming packet's ETAG.
 *     PE_VID:ASSOCIATED_DATA Entire associated data for KEY_TYPE = VIF
 *     PE_VID:DESTINATION Destination fields for KEY_TYPE = 0, 1 and 2
 *     PE_VID:L2MC_PTR  L2MC pointer if MAC_ADDR[40]==1
 *     PE_VID:PORT_NUM  Port if T==0 and VPG_TYPE==0
 *     PE_VID:TGID      Trunk ID value if T==1
 *     PE_VID:MODULE_ID Module ID if T==0 and VPG_TYPE==0
 *     PE_VID:REMOTE_TRUNK When T==1, indicates entry was learned on higig port (pkt originally entered system on a remote module)
 *     PE_VID:DEST_TYPE Indicates destination type.		    For PE_VID-based keys:		    00 = {MODID, PORT} or L2MC_index		    01 = {'0', TGID} or L2MC_index
 *     PE_VID:T         Indicates destination is a LAG
 *     PE_VID:RESERVED_80 RESERVED.
 *     PE_VID:CLASS_ID  L2 Classification ID used for ingress FP
 *     PE_VID:MAC_BLOCK_INDEX MAC Block Index
 *     PE_VID:DUMMY_INDEX Dummy base field to line up with CLASS_ID overlay
 *     PE_VID:RPE       RPE bit
 *     PE_VID:RESERVED_89 RESERVED.
 *     PE_VID:PRI       Priority
 *     PE_VID:CPU       CPU bit
 *     PE_VID:DST_DISCARD Dst Discard
 *     PE_VID:SRC_DISCARD Src Discard
 *     PE_VID:SCP       SCP bit
 *     PE_VID:RESERVED_98 RESERVED.
 *     PE_VID:REMOTE    Indicates if entry is learned from a local port (0) or a remote port (1).  Note: CPU must set this field correctly for CPU INSERT commands.
 *     PE_VID:STATIC_BIT Indicates entry is SW programmed and static
 *     PE_VID:PENDING   Indicates that the entry is pending validation from software
 *     VALID            Indicates that the entry is valid
 *     EVEN_PARITY      Even parity bit (i.e. excludes HIT bits)
 *     HITDA            Dst hit update bitThis bit is set if there is a match with the destination address. It is used in aging mechanism. If the AGE TIME duration is expired and this bit is not set, then this entry is purged out by the aging process, provided that the STATIC_BIT is not set.
 *     HITSA            Src hit update bitThis bit is set if there is a match with the source address. It is used in hardware aging mechanism. If the AGE TIME duration is expired and this bit is not set, then this entry is purged out by the aging process, provided that the STATIC_BIT is not set.
 *     LOCAL_SA         Src local update bitLOCAL_SA starts out as the inverse of REMOTE, but LOCAL_SA is a dynamic value that is updated on a per packet basis.
 */
#define L2_ENTRYm_MIN 0
#define L2_ENTRYm_MAX 16383
#define L2_ENTRYm_CMAX(u) 16383
#define L2_ENTRYm_SIZE 14

/*
 * This structure should be used to declare and program L2_ENTRY.
 */
typedef union L2_ENTRYm_s {
	uint32 v[4];
	uint32 l2_entry[4];
	uint32 _l2_entry;
} L2_ENTRYm_t;

#define L2_ENTRYm_CLR(r) sal_memset(&((r)._l2_entry), 0, sizeof(L2_ENTRYm_t))
#define L2_ENTRYm_SET(r,i,d) (r).l2_entry[i] = d
#define L2_ENTRYm_GET(r,i) (r).l2_entry[i]

/*
 * These macros can be used to access individual fields.
 */
#define L2_ENTRYm_KEY_TYPEf_GET(r) (((r).l2_entry[0]) & 0x7)
#define L2_ENTRYm_KEY_TYPEf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define L2_ENTRYm_LEGACY_OVIDf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_LEGACY_OVIDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_LEGACY_VLAN_IDf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_LEGACY_VLAN_IDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_LEGACY_MAC_ADDRf_GET(r,a) field_get((r).l2_entry,15,62,a)
#define L2_ENTRYm_LEGACY_MAC_ADDRf_SET(r,a) field_set((r).l2_entry,15,62,a)
#define L2_ENTRYm_LEGACY_IVIDf_GET(r) ((((r).l2_entry[0]) >> 15) & 0xfff)
#define L2_ENTRYm_LEGACY_IVIDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 15)) | ((((uint32)f) & 0xfff) << 15))
#define L2_ENTRYm_LEGACY_DESTINATION_1f_GET(r) ((((r).l2_entry[1]) >> 16) & 0x3fff)
#define L2_ENTRYm_LEGACY_DESTINATION_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x3fff << 16)) | ((((uint32)f) & 0x3fff) << 16))
#define L2_ENTRYm_LEGACY_PORT_NUM_1f_GET(r) ((((r).l2_entry[1]) >> 16) & 0x3f)
#define L2_ENTRYm_LEGACY_PORT_NUM_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x3f << 16)) | ((((uint32)f) & 0x3f) << 16))
#define L2_ENTRYm_LEGACY_TGID_1f_GET(r) ((((r).l2_entry[1]) >> 16) & 0x7)
#define L2_ENTRYm_LEGACY_TGID_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x7 << 16)) | ((((uint32)f) & 0x7) << 16))
#define L2_ENTRYm_LEGACY_MODULE_ID_1f_GET(r) ((((r).l2_entry[1]) >> 22) & 0xff)
#define L2_ENTRYm_LEGACY_MODULE_ID_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0xff << 22)) | ((((uint32)f) & 0xff) << 22))
#define L2_ENTRYm_LEGACY_REMOTE_TRUNK_1f_GET(r) ((((r).l2_entry[1]) >> 29) & 0x1)
#define L2_ENTRYm_LEGACY_REMOTE_TRUNK_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define L2_ENTRYm_LEGACY_T_1f_GET(r) ((((r).l2_entry[1]) >> 30) & 0x1)
#define L2_ENTRYm_LEGACY_T_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_LEGACY_ASSOCIATED_DATAf_GET(r,a) field_get((r).l2_entry,64,101,a)
#define L2_ENTRYm_LEGACY_ASSOCIATED_DATAf_SET(r,a) field_set((r).l2_entry,64,101,a)
#define L2_ENTRYm_LEGACY_DESTINATIONf_GET(r) (((r).l2_entry[2]) & 0x3fff)
#define L2_ENTRYm_LEGACY_DESTINATIONf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define L2_ENTRYm_LEGACY_VPGf_GET(r) (((r).l2_entry[2]) & 0x3fff)
#define L2_ENTRYm_LEGACY_VPGf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define L2_ENTRYm_LEGACY_L2MC_PTRf_GET(r) (((r).l2_entry[2]) & 0x1ff)
#define L2_ENTRYm_LEGACY_L2MC_PTRf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define L2_ENTRYm_LEGACY_PORT_NUMf_GET(r) (((r).l2_entry[2]) & 0x3f)
#define L2_ENTRYm_LEGACY_PORT_NUMf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define L2_ENTRYm_LEGACY_TGIDf_GET(r) (((r).l2_entry[2]) & 0x7)
#define L2_ENTRYm_LEGACY_TGIDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define L2_ENTRYm_LEGACY_MODULE_IDf_GET(r) ((((r).l2_entry[2]) >> 6) & 0xff)
#define L2_ENTRYm_LEGACY_MODULE_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define L2_ENTRYm_LEGACY_REMOTE_TRUNKf_GET(r) ((((r).l2_entry[2]) >> 13) & 0x1)
#define L2_ENTRYm_LEGACY_REMOTE_TRUNKf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define L2_ENTRYm_LEGACY_DEST_TYPEf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x3)
#define L2_ENTRYm_LEGACY_DEST_TYPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define L2_ENTRYm_LEGACY_Tf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x1)
#define L2_ENTRYm_LEGACY_Tf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_LEGACY_L3f_GET(r) ((((r).l2_entry[2]) >> 16) & 0x1)
#define L2_ENTRYm_LEGACY_L3f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define L2_ENTRYm_LEGACY_CLASS_IDf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x3f)
#define L2_ENTRYm_LEGACY_CLASS_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define L2_ENTRYm_LEGACY_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x1f)
#define L2_ENTRYm_LEGACY_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define L2_ENTRYm_LEGACY_DUMMY_INDEXf_GET(r) ((((r).l2_entry[2]) >> 22) & 0x1)
#define L2_ENTRYm_LEGACY_DUMMY_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define L2_ENTRYm_LEGACY_RPEf_GET(r) ((((r).l2_entry[2]) >> 24) & 0x1)
#define L2_ENTRYm_LEGACY_RPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define L2_ENTRYm_LEGACY_MIRRORf_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_LEGACY_MIRRORf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_LEGACY_MIRROR0f_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_LEGACY_MIRROR0f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_LEGACY_PRIf_GET(r) ((((r).l2_entry[2]) >> 27) & 0x7)
#define L2_ENTRYm_LEGACY_PRIf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define L2_ENTRYm_LEGACY_CPUf_GET(r) ((((r).l2_entry[2]) >> 30) & 0x1)
#define L2_ENTRYm_LEGACY_CPUf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_LEGACY_DST_DISCARDf_GET(r) ((((r).l2_entry[2]) >> 31) & 0x1)
#define L2_ENTRYm_LEGACY_DST_DISCARDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define L2_ENTRYm_LEGACY_SRC_DISCARDf_GET(r) (((r).l2_entry[3]) & 0x1)
#define L2_ENTRYm_LEGACY_SRC_DISCARDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_ENTRYm_LEGACY_SCPf_GET(r) ((((r).l2_entry[3]) >> 1) & 0x1)
#define L2_ENTRYm_LEGACY_SCPf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define L2_ENTRYm_LEGACY_LIMIT_COUNTEDf_GET(r) ((((r).l2_entry[3]) >> 2) & 0x1)
#define L2_ENTRYm_LEGACY_LIMIT_COUNTEDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_ENTRYm_LEGACY_REMOTEf_GET(r) ((((r).l2_entry[3]) >> 3) & 0x1)
#define L2_ENTRYm_LEGACY_REMOTEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_ENTRYm_LEGACY_STATIC_BITf_GET(r) ((((r).l2_entry[3]) >> 4) & 0x1)
#define L2_ENTRYm_LEGACY_STATIC_BITf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_ENTRYm_LEGACY_PENDINGf_GET(r) ((((r).l2_entry[3]) >> 5) & 0x1)
#define L2_ENTRYm_LEGACY_PENDINGf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define L2_ENTRYm_L2_VLAN_IDf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_L2_VLAN_IDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_L2_MAC_ADDRf_GET(r,a) field_get((r).l2_entry,15,62,a)
#define L2_ENTRYm_L2_MAC_ADDRf_SET(r,a) field_set((r).l2_entry,15,62,a)
#define L2_ENTRYm_L2_RESVEVED_63f_GET(r) ((((r).l2_entry[1]) >> 31) & 0x1)
#define L2_ENTRYm_L2_RESVEVED_63f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define L2_ENTRYm_L2_ASSOCIATED_DATAf_GET(r,a) field_get((r).l2_entry,64,101,a)
#define L2_ENTRYm_L2_ASSOCIATED_DATAf_SET(r,a) field_set((r).l2_entry,64,101,a)
#define L2_ENTRYm_L2_DESTINATIONf_GET(r) (((r).l2_entry[2]) & 0x3fff)
#define L2_ENTRYm_L2_DESTINATIONf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define L2_ENTRYm_L2_L2MC_PTRf_GET(r) (((r).l2_entry[2]) & 0x1ff)
#define L2_ENTRYm_L2_L2MC_PTRf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define L2_ENTRYm_L2_PORT_NUMf_GET(r) (((r).l2_entry[2]) & 0x3f)
#define L2_ENTRYm_L2_PORT_NUMf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define L2_ENTRYm_L2_TGIDf_GET(r) (((r).l2_entry[2]) & 0x7)
#define L2_ENTRYm_L2_TGIDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define L2_ENTRYm_L2_MODULE_IDf_GET(r) ((((r).l2_entry[2]) >> 6) & 0xff)
#define L2_ENTRYm_L2_MODULE_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define L2_ENTRYm_L2_REMOTE_TRUNKf_GET(r) ((((r).l2_entry[2]) >> 13) & 0x1)
#define L2_ENTRYm_L2_REMOTE_TRUNKf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define L2_ENTRYm_L2_DEST_TYPEf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x3)
#define L2_ENTRYm_L2_DEST_TYPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define L2_ENTRYm_L2_Tf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x1)
#define L2_ENTRYm_L2_Tf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_L2_L3f_GET(r) ((((r).l2_entry[2]) >> 16) & 0x1)
#define L2_ENTRYm_L2_L3f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define L2_ENTRYm_L2_CLASS_IDf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x3f)
#define L2_ENTRYm_L2_CLASS_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define L2_ENTRYm_L2_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x1f)
#define L2_ENTRYm_L2_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define L2_ENTRYm_L2_DUMMY_INDEXf_GET(r) ((((r).l2_entry[2]) >> 22) & 0x1)
#define L2_ENTRYm_L2_DUMMY_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define L2_ENTRYm_L2_RPEf_GET(r) ((((r).l2_entry[2]) >> 24) & 0x1)
#define L2_ENTRYm_L2_RPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define L2_ENTRYm_L2_MIRRORf_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_L2_MIRRORf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_L2_MIRROR0f_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_L2_MIRROR0f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_L2_PRIf_GET(r) ((((r).l2_entry[2]) >> 27) & 0x7)
#define L2_ENTRYm_L2_PRIf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define L2_ENTRYm_L2_CPUf_GET(r) ((((r).l2_entry[2]) >> 30) & 0x1)
#define L2_ENTRYm_L2_CPUf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_L2_DST_DISCARDf_GET(r) ((((r).l2_entry[2]) >> 31) & 0x1)
#define L2_ENTRYm_L2_DST_DISCARDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define L2_ENTRYm_L2_SRC_DISCARDf_GET(r) (((r).l2_entry[3]) & 0x1)
#define L2_ENTRYm_L2_SRC_DISCARDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_ENTRYm_L2_SCPf_GET(r) ((((r).l2_entry[3]) >> 1) & 0x1)
#define L2_ENTRYm_L2_SCPf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define L2_ENTRYm_L2_LIMIT_COUNTEDf_GET(r) ((((r).l2_entry[3]) >> 2) & 0x1)
#define L2_ENTRYm_L2_LIMIT_COUNTEDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_ENTRYm_L2_REMOTEf_GET(r) ((((r).l2_entry[3]) >> 3) & 0x1)
#define L2_ENTRYm_L2_REMOTEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_ENTRYm_L2_STATIC_BITf_GET(r) ((((r).l2_entry[3]) >> 4) & 0x1)
#define L2_ENTRYm_L2_STATIC_BITf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_ENTRYm_L2_PENDINGf_GET(r) ((((r).l2_entry[3]) >> 5) & 0x1)
#define L2_ENTRYm_L2_PENDINGf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define L2_ENTRYm_VLAN_OVIDf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_VLAN_OVIDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_VLAN_IVIDf_GET(r) ((((r).l2_entry[0]) >> 15) & 0xfff)
#define L2_ENTRYm_VLAN_IVIDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 15)) | ((((uint32)f) & 0xfff) << 15))
#define L2_ENTRYm_VLAN_DESTINATION_1f_GET(r) ((((r).l2_entry[1]) >> 16) & 0x3fff)
#define L2_ENTRYm_VLAN_DESTINATION_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x3fff << 16)) | ((((uint32)f) & 0x3fff) << 16))
#define L2_ENTRYm_VLAN_PORT_NUM_1f_GET(r) ((((r).l2_entry[1]) >> 16) & 0x3f)
#define L2_ENTRYm_VLAN_PORT_NUM_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x3f << 16)) | ((((uint32)f) & 0x3f) << 16))
#define L2_ENTRYm_VLAN_TGID_1f_GET(r) ((((r).l2_entry[1]) >> 16) & 0x7)
#define L2_ENTRYm_VLAN_TGID_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x7 << 16)) | ((((uint32)f) & 0x7) << 16))
#define L2_ENTRYm_VLAN_MODULE_ID_1f_GET(r) ((((r).l2_entry[1]) >> 22) & 0xff)
#define L2_ENTRYm_VLAN_MODULE_ID_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0xff << 22)) | ((((uint32)f) & 0xff) << 22))
#define L2_ENTRYm_VLAN_REMOTE_TRUNK_1f_GET(r) ((((r).l2_entry[1]) >> 29) & 0x1)
#define L2_ENTRYm_VLAN_REMOTE_TRUNK_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define L2_ENTRYm_VLAN_T_1f_GET(r) ((((r).l2_entry[1]) >> 30) & 0x1)
#define L2_ENTRYm_VLAN_T_1f_SET(r,f) (r).l2_entry[1]=(((r).l2_entry[1] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_VLAN_DESTINATIONf_GET(r) (((r).l2_entry[2]) & 0x3fff)
#define L2_ENTRYm_VLAN_DESTINATIONf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define L2_ENTRYm_VLAN_PORT_NUMf_GET(r) (((r).l2_entry[2]) & 0x3f)
#define L2_ENTRYm_VLAN_PORT_NUMf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define L2_ENTRYm_VLAN_TGIDf_GET(r) (((r).l2_entry[2]) & 0x7)
#define L2_ENTRYm_VLAN_TGIDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define L2_ENTRYm_VLAN_MODULE_IDf_GET(r) ((((r).l2_entry[2]) >> 6) & 0xff)
#define L2_ENTRYm_VLAN_MODULE_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define L2_ENTRYm_VLAN_REMOTE_TRUNKf_GET(r) ((((r).l2_entry[2]) >> 13) & 0x1)
#define L2_ENTRYm_VLAN_REMOTE_TRUNKf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define L2_ENTRYm_VLAN_DEST_TYPEf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x3)
#define L2_ENTRYm_VLAN_DEST_TYPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define L2_ENTRYm_VLAN_Tf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x1)
#define L2_ENTRYm_VLAN_Tf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_VLAN_L3f_GET(r) ((((r).l2_entry[2]) >> 16) & 0x1)
#define L2_ENTRYm_VLAN_L3f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define L2_ENTRYm_VLAN_CLASS_IDf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x3f)
#define L2_ENTRYm_VLAN_CLASS_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define L2_ENTRYm_VLAN_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x1f)
#define L2_ENTRYm_VLAN_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define L2_ENTRYm_VLAN_DUMMY_INDEXf_GET(r) ((((r).l2_entry[2]) >> 22) & 0x1)
#define L2_ENTRYm_VLAN_DUMMY_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define L2_ENTRYm_VLAN_RPEf_GET(r) ((((r).l2_entry[2]) >> 24) & 0x1)
#define L2_ENTRYm_VLAN_RPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define L2_ENTRYm_VLAN_MIRRORf_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_VLAN_MIRRORf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_VLAN_MIRROR0f_GET(r) ((((r).l2_entry[2]) >> 25) & 0x1)
#define L2_ENTRYm_VLAN_MIRROR0f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define L2_ENTRYm_VLAN_PRIf_GET(r) ((((r).l2_entry[2]) >> 27) & 0x7)
#define L2_ENTRYm_VLAN_PRIf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define L2_ENTRYm_VLAN_CPUf_GET(r) ((((r).l2_entry[2]) >> 30) & 0x1)
#define L2_ENTRYm_VLAN_CPUf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_VLAN_DST_DISCARDf_GET(r) ((((r).l2_entry[2]) >> 31) & 0x1)
#define L2_ENTRYm_VLAN_DST_DISCARDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define L2_ENTRYm_VLAN_SRC_DISCARDf_GET(r) (((r).l2_entry[3]) & 0x1)
#define L2_ENTRYm_VLAN_SRC_DISCARDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_ENTRYm_VLAN_SCPf_GET(r) ((((r).l2_entry[3]) >> 1) & 0x1)
#define L2_ENTRYm_VLAN_SCPf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define L2_ENTRYm_VLAN_LIMIT_COUNTEDf_GET(r) ((((r).l2_entry[3]) >> 2) & 0x1)
#define L2_ENTRYm_VLAN_LIMIT_COUNTEDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_ENTRYm_VLAN_REMOTEf_GET(r) ((((r).l2_entry[3]) >> 3) & 0x1)
#define L2_ENTRYm_VLAN_REMOTEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_ENTRYm_VLAN_STATIC_BITf_GET(r) ((((r).l2_entry[3]) >> 4) & 0x1)
#define L2_ENTRYm_VLAN_STATIC_BITf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_ENTRYm_VLAN_PENDINGf_GET(r) ((((r).l2_entry[3]) >> 5) & 0x1)
#define L2_ENTRYm_VLAN_PENDINGf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define L2_ENTRYm_VIF_KEYf_GET(r,a) field_get((r).l2_entry,0,62,a)
#define L2_ENTRYm_VIF_KEYf_SET(r,a) field_set((r).l2_entry,0,62,a)
#define L2_ENTRYm_VIF_NAMESPACEf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_VIF_NAMESPACEf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_VIF_DST_VIFf_GET(r) ((((r).l2_entry[0]) >> 15) & 0x3fff)
#define L2_ENTRYm_VIF_DST_VIFf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0x3fff << 15)) | ((((uint32)f) & 0x3fff) << 15))
#define L2_ENTRYm_VIF_Pf_GET(r) ((((r).l2_entry[0]) >> 29) & 0x1)
#define L2_ENTRYm_VIF_Pf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define L2_ENTRYm_VIF_ASSOCIATED_DATAf_GET(r,a) field_get((r).l2_entry,64,101,a)
#define L2_ENTRYm_VIF_ASSOCIATED_DATAf_SET(r,a) field_set((r).l2_entry,64,101,a)
#define L2_ENTRYm_VIF_DESTINATIONf_GET(r) (((r).l2_entry[2]) & 0x3fff)
#define L2_ENTRYm_VIF_DESTINATIONf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define L2_ENTRYm_VIF_L2MC_PTRf_GET(r) (((r).l2_entry[2]) & 0x1ff)
#define L2_ENTRYm_VIF_L2MC_PTRf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define L2_ENTRYm_VIF_PORT_NUMf_GET(r) (((r).l2_entry[2]) & 0x3f)
#define L2_ENTRYm_VIF_PORT_NUMf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define L2_ENTRYm_VIF_TGIDf_GET(r) (((r).l2_entry[2]) & 0x7)
#define L2_ENTRYm_VIF_TGIDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define L2_ENTRYm_VIF_MODULE_IDf_GET(r) ((((r).l2_entry[2]) >> 6) & 0xff)
#define L2_ENTRYm_VIF_MODULE_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define L2_ENTRYm_VIF_REMOTE_TRUNKf_GET(r) ((((r).l2_entry[2]) >> 13) & 0x1)
#define L2_ENTRYm_VIF_REMOTE_TRUNKf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define L2_ENTRYm_VIF_DEST_TYPEf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x3)
#define L2_ENTRYm_VIF_DEST_TYPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define L2_ENTRYm_VIF_Tf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x1)
#define L2_ENTRYm_VIF_Tf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_VIF_RESERVED_78f_GET(r) ((((r).l2_entry[2]) >> 16) & 0x1)
#define L2_ENTRYm_VIF_RESERVED_78f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define L2_ENTRYm_VIF_CLASS_IDf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x3f)
#define L2_ENTRYm_VIF_CLASS_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define L2_ENTRYm_VIF_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x1f)
#define L2_ENTRYm_VIF_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define L2_ENTRYm_VIF_DUMMY_INDEXf_GET(r) ((((r).l2_entry[2]) >> 22) & 0x1)
#define L2_ENTRYm_VIF_DUMMY_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define L2_ENTRYm_VIF_RPEf_GET(r) ((((r).l2_entry[2]) >> 24) & 0x1)
#define L2_ENTRYm_VIF_RPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define L2_ENTRYm_VIF_RESERVED_89f_GET(r) ((((r).l2_entry[2]) >> 25) & 0x3)
#define L2_ENTRYm_VIF_RESERVED_89f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3 << 25)) | ((((uint32)f) & 0x3) << 25))
#define L2_ENTRYm_VIF_PRIf_GET(r) ((((r).l2_entry[2]) >> 27) & 0x7)
#define L2_ENTRYm_VIF_PRIf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define L2_ENTRYm_VIF_CPUf_GET(r) ((((r).l2_entry[2]) >> 30) & 0x1)
#define L2_ENTRYm_VIF_CPUf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_VIF_DST_DISCARDf_GET(r) ((((r).l2_entry[2]) >> 31) & 0x1)
#define L2_ENTRYm_VIF_DST_DISCARDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define L2_ENTRYm_VIF_SRC_DISCARDf_GET(r) (((r).l2_entry[3]) & 0x1)
#define L2_ENTRYm_VIF_SRC_DISCARDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_ENTRYm_VIF_SCPf_GET(r) ((((r).l2_entry[3]) >> 1) & 0x1)
#define L2_ENTRYm_VIF_SCPf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define L2_ENTRYm_VIF_RESERVED_96f_GET(r) ((((r).l2_entry[3]) >> 2) & 0x1)
#define L2_ENTRYm_VIF_RESERVED_96f_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_ENTRYm_VIF_REMOTEf_GET(r) ((((r).l2_entry[3]) >> 3) & 0x1)
#define L2_ENTRYm_VIF_REMOTEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_ENTRYm_VIF_STATIC_BITf_GET(r) ((((r).l2_entry[3]) >> 4) & 0x1)
#define L2_ENTRYm_VIF_STATIC_BITf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_ENTRYm_VIF_PENDINGf_GET(r) ((((r).l2_entry[3]) >> 5) & 0x1)
#define L2_ENTRYm_VIF_PENDINGf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define L2_ENTRYm_PE_VID_KEYf_GET(r,a) field_get((r).l2_entry,0,62,a)
#define L2_ENTRYm_PE_VID_KEYf_SET(r,a) field_set((r).l2_entry,0,62,a)
#define L2_ENTRYm_PE_VID_NAMESPACEf_GET(r) ((((r).l2_entry[0]) >> 3) & 0xfff)
#define L2_ENTRYm_PE_VID_NAMESPACEf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0xfff << 3)) | ((((uint32)f) & 0xfff) << 3))
#define L2_ENTRYm_PE_VID_ETAG_VIDf_GET(r) ((((r).l2_entry[0]) >> 15) & 0x3fff)
#define L2_ENTRYm_PE_VID_ETAG_VIDf_SET(r,f) (r).l2_entry[0]=(((r).l2_entry[0] & ~((uint32)0x3fff << 15)) | ((((uint32)f) & 0x3fff) << 15))
#define L2_ENTRYm_PE_VID_ASSOCIATED_DATAf_GET(r,a) field_get((r).l2_entry,64,101,a)
#define L2_ENTRYm_PE_VID_ASSOCIATED_DATAf_SET(r,a) field_set((r).l2_entry,64,101,a)
#define L2_ENTRYm_PE_VID_DESTINATIONf_GET(r) (((r).l2_entry[2]) & 0x3fff)
#define L2_ENTRYm_PE_VID_DESTINATIONf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define L2_ENTRYm_PE_VID_L2MC_PTRf_GET(r) (((r).l2_entry[2]) & 0x1ff)
#define L2_ENTRYm_PE_VID_L2MC_PTRf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1ff)) | (((uint32)f) & 0x1ff))
#define L2_ENTRYm_PE_VID_PORT_NUMf_GET(r) (((r).l2_entry[2]) & 0x3f)
#define L2_ENTRYm_PE_VID_PORT_NUMf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define L2_ENTRYm_PE_VID_TGIDf_GET(r) (((r).l2_entry[2]) & 0x7)
#define L2_ENTRYm_PE_VID_TGIDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define L2_ENTRYm_PE_VID_MODULE_IDf_GET(r) ((((r).l2_entry[2]) >> 6) & 0xff)
#define L2_ENTRYm_PE_VID_MODULE_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define L2_ENTRYm_PE_VID_REMOTE_TRUNKf_GET(r) ((((r).l2_entry[2]) >> 13) & 0x1)
#define L2_ENTRYm_PE_VID_REMOTE_TRUNKf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define L2_ENTRYm_PE_VID_DEST_TYPEf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x3)
#define L2_ENTRYm_PE_VID_DEST_TYPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define L2_ENTRYm_PE_VID_Tf_GET(r) ((((r).l2_entry[2]) >> 14) & 0x1)
#define L2_ENTRYm_PE_VID_Tf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_ENTRYm_PE_VID_RESERVED_80f_GET(r) ((((r).l2_entry[2]) >> 16) & 0x1)
#define L2_ENTRYm_PE_VID_RESERVED_80f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define L2_ENTRYm_PE_VID_CLASS_IDf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x3f)
#define L2_ENTRYm_PE_VID_CLASS_IDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define L2_ENTRYm_PE_VID_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry[2]) >> 17) & 0x1f)
#define L2_ENTRYm_PE_VID_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define L2_ENTRYm_PE_VID_DUMMY_INDEXf_GET(r) ((((r).l2_entry[2]) >> 22) & 0x1)
#define L2_ENTRYm_PE_VID_DUMMY_INDEXf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define L2_ENTRYm_PE_VID_RPEf_GET(r) ((((r).l2_entry[2]) >> 24) & 0x1)
#define L2_ENTRYm_PE_VID_RPEf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define L2_ENTRYm_PE_VID_RESERVED_89f_GET(r) ((((r).l2_entry[2]) >> 25) & 0x3)
#define L2_ENTRYm_PE_VID_RESERVED_89f_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x3 << 25)) | ((((uint32)f) & 0x3) << 25))
#define L2_ENTRYm_PE_VID_PRIf_GET(r) ((((r).l2_entry[2]) >> 27) & 0x7)
#define L2_ENTRYm_PE_VID_PRIf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x7 << 27)) | ((((uint32)f) & 0x7) << 27))
#define L2_ENTRYm_PE_VID_CPUf_GET(r) ((((r).l2_entry[2]) >> 30) & 0x1)
#define L2_ENTRYm_PE_VID_CPUf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define L2_ENTRYm_PE_VID_DST_DISCARDf_GET(r) ((((r).l2_entry[2]) >> 31) & 0x1)
#define L2_ENTRYm_PE_VID_DST_DISCARDf_SET(r,f) (r).l2_entry[2]=(((r).l2_entry[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define L2_ENTRYm_PE_VID_SRC_DISCARDf_GET(r) (((r).l2_entry[3]) & 0x1)
#define L2_ENTRYm_PE_VID_SRC_DISCARDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_ENTRYm_PE_VID_SCPf_GET(r) ((((r).l2_entry[3]) >> 1) & 0x1)
#define L2_ENTRYm_PE_VID_SCPf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define L2_ENTRYm_PE_VID_RESERVED_98f_GET(r) ((((r).l2_entry[3]) >> 2) & 0x1)
#define L2_ENTRYm_PE_VID_RESERVED_98f_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_ENTRYm_PE_VID_REMOTEf_GET(r) ((((r).l2_entry[3]) >> 3) & 0x1)
#define L2_ENTRYm_PE_VID_REMOTEf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_ENTRYm_PE_VID_STATIC_BITf_GET(r) ((((r).l2_entry[3]) >> 4) & 0x1)
#define L2_ENTRYm_PE_VID_STATIC_BITf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_ENTRYm_PE_VID_PENDINGf_GET(r) ((((r).l2_entry[3]) >> 5) & 0x1)
#define L2_ENTRYm_PE_VID_PENDINGf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define L2_ENTRYm_VALIDf_GET(r) ((((r).l2_entry[3]) >> 6) & 0x1)
#define L2_ENTRYm_VALIDf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define L2_ENTRYm_EVEN_PARITYf_GET(r) ((((r).l2_entry[3]) >> 7) & 0x1)
#define L2_ENTRYm_EVEN_PARITYf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define L2_ENTRYm_HITDAf_GET(r) ((((r).l2_entry[3]) >> 8) & 0x1)
#define L2_ENTRYm_HITDAf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define L2_ENTRYm_HITSAf_GET(r) ((((r).l2_entry[3]) >> 9) & 0x1)
#define L2_ENTRYm_HITSAf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define L2_ENTRYm_LOCAL_SAf_GET(r) ((((r).l2_entry[3]) >> 10) & 0x1)
#define L2_ENTRYm_LOCAL_SAf_SET(r,f) (r).l2_entry[3]=(((r).l2_entry[3] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))

/*
 * These macros can be used to access L2_ENTRY.
 */
#define WRITE_L2_ENTRYm(u,i,r) bcm5354x_mem_set(u, M_L2_ENTRY(i), &(r._l2_entry), 4)
#define READ_L2_ENTRYm(u,i,r) bcm5354x_mem_get(u, M_L2_ENTRY(i), &(r._l2_entry), 4)

/*******************************************************************************
 * End of 'L2_ENTRYm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  L2_USER_ENTRY
 * BLOCKS:   IPIPE
 * DESC:     Combined L2_ENTRY TCAM/Data RAM for guaranteed L2 entries and BPDUs. FeatureSpecific-Ethernet
 * SIZE:     173
 * FIELDS:
 *     VALID            Indicates that the entry is valid
 *     KEY              The entire Key.
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     KEY_TYPE         Key Type - VLAN-based(0)
 *     RESERVED         RESERVED.
 *     MASK             Mask for the entire Key.
 *     MAC_ADDR_MASK    MASK of MAC_ADDR
 *     VLAN_ID_MASK     MASK of VLAN_ID
 *     VFI_MASK         MASK of VFI
 *     RESERVED_VFI_MASK MASK of RESERVED_VFI
 *     KEY_TYPE_MASK    MASK of KEY_TYPE
 *     RESERVED_MASK    MASK of RESERVED
 *     PRI              Priority
 *     CPU              CPU bit
 *     L3               Indicates an L3 entry
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     MIRROR0          Mirror bit
 *     DST_DISCARD      Dst Discard
 *     PORT_NUM         Port if T==0
 *     TGID             TGID value if T==1
 *     MODULE_ID        Module ID if T==0
 *     T                Trunk (LAG) indication
 *     BPDU             Indicates entry is a BPDU
 *     DO_NOT_LEARN_MACSA If set to 1, destination hits in the L2_USER_ENTRY will not learn their MACSA
 *     CLASS_ID         L2 Destination Class ID for IFP keys.
 *     L2_PROTOCOL_PKT  When configured as a per-VFI L2_USER_ENTRY TCAM entry, this bit indicates the packet that matched L2 protocol packet
 *     EVEN_PARITY      Even parity for the  L2_USER_ENTRY_DATA RAM.
 */
#define L2_USER_ENTRYm_MIN 0
#define L2_USER_ENTRYm_MAX 127
#define L2_USER_ENTRYm_CMAX(u) 127
#define L2_USER_ENTRYm_SIZE 22

/*
 * This structure should be used to declare and program L2_USER_ENTRY.
 */
typedef union L2_USER_ENTRYm_s {
	uint32 v[6];
	uint32 l2_user_entry[6];
	uint32 _l2_user_entry;
} L2_USER_ENTRYm_t;

#define L2_USER_ENTRYm_CLR(r) sal_memset(&((r)._l2_user_entry), 0, sizeof(L2_USER_ENTRYm_t))
#define L2_USER_ENTRYm_SET(r,i,d) (r).l2_user_entry[i] = d
#define L2_USER_ENTRYm_GET(r,i) (r).l2_user_entry[i]

/*
 * These macros can be used to access individual fields.
 */
#define L2_USER_ENTRYm_VALIDf_GET(r) (((r).l2_user_entry[0]) & 0x1)
#define L2_USER_ENTRYm_VALIDf_SET(r,f) (r).l2_user_entry[0]=(((r).l2_user_entry[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L2_USER_ENTRYm_KEYf_GET(r,a) field_get((r).l2_user_entry,1,69,a)
#define L2_USER_ENTRYm_KEYf_SET(r,a) field_set((r).l2_user_entry,1,69,a)
#define L2_USER_ENTRYm_MAC_ADDRf_GET(r,a) field_get((r).l2_user_entry,1,48,a)
#define L2_USER_ENTRYm_MAC_ADDRf_SET(r,a) field_set((r).l2_user_entry,1,48,a)
#define L2_USER_ENTRYm_VLAN_IDf_GET(r) ((((r).l2_user_entry[1]) >> 17) & 0xfff)
#define L2_USER_ENTRYm_VLAN_IDf_SET(r,f) (r).l2_user_entry[1]=(((r).l2_user_entry[1] & ~((uint32)0xfff << 17)) | ((((uint32)f) & 0xfff) << 17))
#define L2_USER_ENTRYm_KEY_TYPEf_GET(r) ((((r).l2_user_entry[1]) >> 29) & 0x1)
#define L2_USER_ENTRYm_KEY_TYPEf_SET(r,f) (r).l2_user_entry[1]=(((r).l2_user_entry[1] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define L2_USER_ENTRYm_RESERVEDf_GET(r) field32_get((r).l2_user_entry,62,69)
#define L2_USER_ENTRYm_RESERVEDf_SET(r,f) field32_set((r).l2_user_entry,62,69,f)
#define L2_USER_ENTRYm_MASKf_GET(r,a) field_get((r).l2_user_entry,70,138,a)
#define L2_USER_ENTRYm_MASKf_SET(r,a) field_set((r).l2_user_entry,70,138,a)
#define L2_USER_ENTRYm_MAC_ADDR_MASKf_GET(r,a) field_get((r).l2_user_entry,70,117,a)
#define L2_USER_ENTRYm_MAC_ADDR_MASKf_SET(r,a) field_set((r).l2_user_entry,70,117,a)
#define L2_USER_ENTRYm_VLAN_ID_MASKf_GET(r) field32_get((r).l2_user_entry,118,129)
#define L2_USER_ENTRYm_VLAN_ID_MASKf_SET(r,f) field32_set((r).l2_user_entry,118,129,f)
#define L2_USER_ENTRYm_VFI_MASKf_GET(r) field32_get((r).l2_user_entry,118,128)
#define L2_USER_ENTRYm_VFI_MASKf_SET(r,f) field32_set((r).l2_user_entry,118,128,f)
#define L2_USER_ENTRYm_RESERVED_VFI_MASKf_GET(r) ((((r).l2_user_entry[4]) >> 1) & 0x1)
#define L2_USER_ENTRYm_RESERVED_VFI_MASKf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define L2_USER_ENTRYm_KEY_TYPE_MASKf_GET(r) ((((r).l2_user_entry[4]) >> 2) & 0x1)
#define L2_USER_ENTRYm_KEY_TYPE_MASKf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_USER_ENTRYm_RESERVED_MASKf_GET(r) ((((r).l2_user_entry[4]) >> 3) & 0xff)
#define L2_USER_ENTRYm_RESERVED_MASKf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0xff << 3)) | ((((uint32)f) & 0xff) << 3))
#define L2_USER_ENTRYm_PRIf_GET(r) ((((r).l2_user_entry[4]) >> 11) & 0x7)
#define L2_USER_ENTRYm_PRIf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x7 << 11)) | ((((uint32)f) & 0x7) << 11))
#define L2_USER_ENTRYm_CPUf_GET(r) ((((r).l2_user_entry[4]) >> 14) & 0x1)
#define L2_USER_ENTRYm_CPUf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define L2_USER_ENTRYm_L3f_GET(r) ((((r).l2_user_entry[4]) >> 15) & 0x1)
#define L2_USER_ENTRYm_L3f_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define L2_USER_ENTRYm_RPEf_GET(r) ((((r).l2_user_entry[4]) >> 16) & 0x1)
#define L2_USER_ENTRYm_RPEf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define L2_USER_ENTRYm_MIRRORf_GET(r) ((((r).l2_user_entry[4]) >> 17) & 0x1)
#define L2_USER_ENTRYm_MIRRORf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define L2_USER_ENTRYm_MIRROR0f_GET(r) ((((r).l2_user_entry[4]) >> 17) & 0x1)
#define L2_USER_ENTRYm_MIRROR0f_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define L2_USER_ENTRYm_DST_DISCARDf_GET(r) ((((r).l2_user_entry[4]) >> 19) & 0x1)
#define L2_USER_ENTRYm_DST_DISCARDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define L2_USER_ENTRYm_PORT_NUMf_GET(r) ((((r).l2_user_entry[4]) >> 20) & 0x3f)
#define L2_USER_ENTRYm_PORT_NUMf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define L2_USER_ENTRYm_TGIDf_GET(r) ((((r).l2_user_entry[4]) >> 20) & 0x7)
#define L2_USER_ENTRYm_TGIDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32)0x7 << 20)) | ((((uint32)f) & 0x7) << 20))
#define L2_USER_ENTRYm_MODULE_IDf_GET(r) field32_get((r).l2_user_entry,154,161)
#define L2_USER_ENTRYm_MODULE_IDf_SET(r,f) field32_set((r).l2_user_entry,154,161,f)
#define L2_USER_ENTRYm_Tf_GET(r) ((((r).l2_user_entry[5]) >> 2) & 0x1)
#define L2_USER_ENTRYm_Tf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define L2_USER_ENTRYm_BPDUf_GET(r) ((((r).l2_user_entry[5]) >> 3) & 0x1)
#define L2_USER_ENTRYm_BPDUf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define L2_USER_ENTRYm_DO_NOT_LEARN_MACSAf_GET(r) ((((r).l2_user_entry[5]) >> 4) & 0x1)
#define L2_USER_ENTRYm_DO_NOT_LEARN_MACSAf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define L2_USER_ENTRYm_CLASS_IDf_GET(r) ((((r).l2_user_entry[5]) >> 5) & 0x3f)
#define L2_USER_ENTRYm_CLASS_IDf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x3f << 5)) | ((((uint32)f) & 0x3f) << 5))
#define L2_USER_ENTRYm_L2_PROTOCOL_PKTf_GET(r) ((((r).l2_user_entry[5]) >> 11) & 0x1)
#define L2_USER_ENTRYm_L2_PROTOCOL_PKTf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define L2_USER_ENTRYm_EVEN_PARITYf_GET(r) ((((r).l2_user_entry[5]) >> 12) & 0x1)
#define L2_USER_ENTRYm_EVEN_PARITYf_SET(r,f) (r).l2_user_entry[5]=(((r).l2_user_entry[5] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))

/*
 * These macros can be used to access L2_USER_ENTRY.
 */
#define WRITE_L2_USER_ENTRYm(u,i,r) bcm5354x_tcam_mem_set(u, M_L2_USER_ENTRY(i), &(r._l2_user_entry), 6, 1, 70, 69)
#define READ_L2_USER_ENTRYm(u,i,r) bcm5354x_tcam_mem_get(u, M_L2_USER_ENTRY(i), &(r._l2_user_entry), 6, 1, 70, 69)

/*******************************************************************************
 * End of 'L2_USER_ENTRYm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  L2_USER_ENTRY_CAM_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_CONTROL 
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *     BLKSEL           BLKSEL bits
 */
#define L2_USER_ENTRY_CAM_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_DBGCTRL.
 */
typedef union L2_USER_ENTRY_CAM_DBGCTRLr_s {
	uint32 v[1];
	uint32 l2_user_entry_cam_dbgctrl[1];
	uint32 _l2_user_entry_cam_dbgctrl;
} L2_USER_ENTRY_CAM_DBGCTRLr_t;

#define L2_USER_ENTRY_CAM_DBGCTRLr_CLR(r) (r).l2_user_entry_cam_dbgctrl[0] = 0
#define L2_USER_ENTRY_CAM_DBGCTRLr_SET(r,d) (r).l2_user_entry_cam_dbgctrl[0] = d
#define L2_USER_ENTRY_CAM_DBGCTRLr_GET(r) (r).l2_user_entry_cam_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define L2_USER_ENTRY_CAM_DBGCTRLr_TMf_GET(r) (((r).l2_user_entry_cam_dbgctrl[0]) & 0xfffff)
#define L2_USER_ENTRY_CAM_DBGCTRLr_TMf_SET(r,f) (r).l2_user_entry_cam_dbgctrl[0]=(((r).l2_user_entry_cam_dbgctrl[0] & ~((uint32)0xfffff)) | (((uint32)f) & 0xfffff))
#define L2_USER_ENTRY_CAM_DBGCTRLr_BLKSELf_GET(r) ((((r).l2_user_entry_cam_dbgctrl[0]) >> 20) & 0xf)
#define L2_USER_ENTRY_CAM_DBGCTRLr_BLKSELf_SET(r,f) (r).l2_user_entry_cam_dbgctrl[0]=(((r).l2_user_entry_cam_dbgctrl[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_DBGCTRL.
 */
#define WRITE_L2_USER_ENTRY_CAM_DBGCTRLr(u,r) bcm5354x_reg_set(u,R_L2_USER_ENTRY_CAM_DBGCTRL,(r._l2_user_entry_cam_dbgctrl))
#define READ_L2_USER_ENTRY_CAM_DBGCTRLr(u,r) bcm5354x_reg_get(u,R_L2_USER_ENTRY_CAM_DBGCTRL,&(r._l2_user_entry_cam_dbgctrl))

/*******************************************************************************
 * End of 'L2_USER_ENTRY_CAM_DBGCTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  L3_AUX_HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L3_AUX_HASH_CONTROL. Enable dual hashing mode for L3 table. The hashing mode in this register is for the second group of L3 tables. Hashing mode for first group of L3 tables is controlled via the HASH_SELECT register.
 * SIZE:     32
 * FIELDS:
 *     INSERT_LEAST_FULL_HALF If set to 1, insert entry into the least full half of the hash location.
 *     HASH_SELECT      Selects one of the standard hashing modes.
 *     ENABLE           Set to enable dual hashing feature. This is to improve the first miss utilization.
 */
#define L3_AUX_HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L3_AUX_HASH_CONTROL.
 */
typedef union L3_AUX_HASH_CONTROLr_s {
	uint32 v[1];
	uint32 l3_aux_hash_control[1];
	uint32 _l3_aux_hash_control;
} L3_AUX_HASH_CONTROLr_t;

#define L3_AUX_HASH_CONTROLr_CLR(r) (r).l3_aux_hash_control[0] = 0
#define L3_AUX_HASH_CONTROLr_SET(r,d) (r).l3_aux_hash_control[0] = d
#define L3_AUX_HASH_CONTROLr_GET(r) (r).l3_aux_hash_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define L3_AUX_HASH_CONTROLr_INSERT_LEAST_FULL_HALFf_GET(r) (((r).l3_aux_hash_control[0]) & 0x1)
#define L3_AUX_HASH_CONTROLr_INSERT_LEAST_FULL_HALFf_SET(r,f) (r).l3_aux_hash_control[0]=(((r).l3_aux_hash_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define L3_AUX_HASH_CONTROLr_HASH_SELECTf_GET(r) ((((r).l3_aux_hash_control[0]) >> 1) & 0x7)
#define L3_AUX_HASH_CONTROLr_HASH_SELECTf_SET(r,f) (r).l3_aux_hash_control[0]=(((r).l3_aux_hash_control[0] & ~((uint32)0x7 << 1)) | ((((uint32)f) & 0x7) << 1))
#define L3_AUX_HASH_CONTROLr_ENABLEf_GET(r) ((((r).l3_aux_hash_control[0]) >> 4) & 0x1)
#define L3_AUX_HASH_CONTROLr_ENABLEf_SET(r,f) (r).l3_aux_hash_control[0]=(((r).l3_aux_hash_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))

/*
 * These macros can be used to access L3_AUX_HASH_CONTROL.
 */
#define WRITE_L3_AUX_HASH_CONTROLr(u,r) bcm5354x_reg_set(u,R_L3_AUX_HASH_CONTROL,(r._l3_aux_hash_control))
#define READ_L3_AUX_HASH_CONTROLr(u,r) bcm5354x_reg_get(u,R_L3_AUX_HASH_CONTROL,&(r._l3_aux_hash_control))

/*******************************************************************************
 * End of 'L3_AUX_HASH_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  LOG_TO_PHY_PORT_MAPPING
 * BLOCKS:   MMU
 * DESC:     Logical port number to physical port number mapping registers
 * SIZE:     32
 * FIELDS:
 *     PHY_PORT         Registers indexed by logical port number, contents are physical port number.
 */
#define LOG_TO_PHY_PORT_MAPPINGr_SIZE 4

/*
 * This structure should be used to declare and program LOG_TO_PHY_PORT_MAPPING.
 */
typedef union LOG_TO_PHY_PORT_MAPPINGr_s {
	uint32 v[1];
	uint32 log_to_phy_port_mapping[1];
	uint32 _log_to_phy_port_mapping;
} LOG_TO_PHY_PORT_MAPPINGr_t;

#define LOG_TO_PHY_PORT_MAPPINGr_CLR(r) (r).log_to_phy_port_mapping[0] = 0
#define LOG_TO_PHY_PORT_MAPPINGr_SET(r,d) (r).log_to_phy_port_mapping[0] = d
#define LOG_TO_PHY_PORT_MAPPINGr_GET(r) (r).log_to_phy_port_mapping[0]

/*
 * These macros can be used to access individual fields.
 */
#define LOG_TO_PHY_PORT_MAPPINGr_PHY_PORTf_GET(r) (((r).log_to_phy_port_mapping[0]) & 0x3f)
#define LOG_TO_PHY_PORT_MAPPINGr_PHY_PORTf_SET(r,f) (r).log_to_phy_port_mapping[0]=(((r).log_to_phy_port_mapping[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))

/*
 * These macros can be used to access LOG_TO_PHY_PORT_MAPPING.
 */
#define WRITE_LOG_TO_PHY_PORT_MAPPINGr(u,p,r) bcm5354x_reg_set(u,R_LOG_TO_PHY_PORT_MAPPING(p),(r._log_to_phy_port_mapping))
#define READ_LOG_TO_PHY_PORT_MAPPINGr(u,p,r) bcm5354x_reg_get(u,R_LOG_TO_PHY_PORT_MAPPING(p),&(r._log_to_phy_port_mapping))

/*******************************************************************************
 * End of 'LOG_TO_PHY_PORT_MAPPINGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  LWMCOSCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLSETLIMIT     This field indicates the threshold at which packet drops will begin in terms of buffer utilization in the units of cells, setting the HOL blocking state for this queue/port.In Dynamic Memory mode:This LWMCOSCELLSETLIMIT.CELLSETLIMIT register allocates the guaranteed cells for one port's COSx queue. After cell count over this limit, it will start using dynamic cells in port dynamic space.When the following conditions are met, it will set this queue's HOL status and stop admitting any new coming cell. ( ( DYNCELLCOUNT(port) >=DYNCELLLIMIT.DYNCELLLIMIT(port) ) OR ( TOTALDYNCELLUSED >=TOTALDYNCELLLIMIT.SETLIMIT ) ) AND ( COSLCCOUNT(port, cos) >=LWMCOSCELLSETLIMIT.CELLSETLIMIT(port, cos) )When not in Dynamic Memory Mode, This is COSx queue HOL Cell high limit.When the following condition is met, it will set this queue's HOL status and stop admitting any new coming cell. ( COSLCCOUNT(port, cos) >=LWMCOSCELLSETLIMIT.CELLSETLIMIT(port, cos) ) 
 *     CELLRESETLIMIT   This field indicates the level at which buffer utilization in terms of cells must drop below before traffic is allowed to resume from HOL blocking state.When in Dynamic Memory mode:To reset a cos queue's HOL status, it needs to meet following conditions ( ( DYNCELLCOUNT(port) <DYNCELLLIMIT.RESETLIMIT(port) ) AND ( TOTALDYNCELLUSED <TOTALDYNCELLRESETLIMIT.RESETLIMIT ) ) OR ( COSLCCOUNT(port, cos) <LWMCOSCELLSETLIMIT.RESETLIMIT(port, cos) )When not in Dynamic Memory Mode:To reset a cos queue's HOL status, it needs to meet following condition ( COSLCCOUNT(port, cos) <LWMCOSCELLSETLIMIT.RESETLIMIT(port, cos) ) 
 */
#define LWMCOSCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program LWMCOSCELLSETLIMIT.
 */
typedef union LWMCOSCELLSETLIMITr_s {
	uint32 v[1];
	uint32 lwmcoscellsetlimit[1];
	uint32 _lwmcoscellsetlimit;
} LWMCOSCELLSETLIMITr_t;

#define LWMCOSCELLSETLIMITr_CLR(r) (r).lwmcoscellsetlimit[0] = 0
#define LWMCOSCELLSETLIMITr_SET(r,d) (r).lwmcoscellsetlimit[0] = d
#define LWMCOSCELLSETLIMITr_GET(r) (r).lwmcoscellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define LWMCOSCELLSETLIMITr_CELLSETLIMITf_GET(r) (((r).lwmcoscellsetlimit[0]) & 0xfff)
#define LWMCOSCELLSETLIMITr_CELLSETLIMITf_SET(r,f) (r).lwmcoscellsetlimit[0]=(((r).lwmcoscellsetlimit[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define LWMCOSCELLSETLIMITr_CELLRESETLIMITf_GET(r) ((((r).lwmcoscellsetlimit[0]) >> 12) & 0xfff)
#define LWMCOSCELLSETLIMITr_CELLRESETLIMITf_SET(r,f) (r).lwmcoscellsetlimit[0]=(((r).lwmcoscellsetlimit[0] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))

/*
 * These macros can be used to access LWMCOSCELLSETLIMIT.
 */
#define WRITE_LWMCOSCELLSETLIMITr(u,p, cos,r) bcm5354x_reg_set(u, R_LWMCOSCELLSETLIMIT(cos,p), (r._lwmcoscellsetlimit))
#define READ_LWMCOSCELLSETLIMITr(u,p, cos,r) bcm5354x_reg_get(u,R_LWMCOSCELLSETLIMIT(cos,p),&(r._lwmcoscellsetlimit))

/*******************************************************************************
 * End of 'LWMCOSCELLSETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MAC_0
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     MAC Address 32-Bit Word 0. Core MAC address bit 47 to 16.
 * SIZE:     32
 * FIELDS:
 *     MAC_ADDR0        Register Bit 0 refers to Bit 16 of the MAC address, Bit 1 refers to bit 17 of the MAC address etc.
 */
#define MAC_0r_SIZE 4

/* MAC_0r is element of MAC */

/*
 * This structure should be used to declare and program MAC_0.
 */
typedef union MAC_0r_s {
	uint32 v[1];
	uint32 mac_0[1];
	uint32 _mac_0;
} MAC_0r_t;

#define MAC_0r_CLR(r) (r).mac_0[0] = 0
#define MAC_0r_SET(r,d) (r).mac_0[0] = d
#define MAC_0r_GET(r) (r).mac_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_0r_MAC_ADDR0f_GET(r) ((r).mac_0[0])
#define MAC_0r_MAC_ADDR0f_SET(r,f) (r).mac_0[0]=((uint32)f)

/*
 * These macros can be used to access MAC_0.
 */
#define WRITE_MAC_0r(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_0(bcm5354x_gport_lport_to_index_in_block[p]), (r._mac_0))
#define READ_MAC_0r(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_0(bcm5354x_gport_lport_to_index_in_block[p]), &(r._mac_0))

/*******************************************************************************
 * End of 'MAC_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MAC_1
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     MAC Address 32-Bit Word 1. Core MAC address bit 15 to 0.
 * SIZE:     32
 * FIELDS:
 *     MAC_ADDR1        Register Bit 0 refers to Bit 0 of the MAC address, Register Bit 1 refers to Bit 1 of the MAC address etc.Bits 16 to 31 are reserved.
 */
#define MAC_1r_SIZE 4

/* MAC_1r is element of MAC */

/*
 * This structure should be used to declare and program MAC_1.
 */
typedef union MAC_1r_s {
	uint32 v[1];
	uint32 mac_1[1];
	uint32 _mac_1;
} MAC_1r_t;

#define MAC_1r_CLR(r) (r).mac_1[0] = 0
#define MAC_1r_SET(r,d) (r).mac_1[0] = d
#define MAC_1r_GET(r) (r).mac_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_1r_MAC_ADDR1f_GET(r) (((r).mac_1[0]) & 0xffff)
#define MAC_1r_MAC_ADDR1f_SET(r,f) (r).mac_1[0]=(((r).mac_1[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access MAC_1.
 */
#define WRITE_MAC_1r(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_1(bcm5354x_gport_lport_to_index_in_block[p]), (r._mac_1))
#define READ_MAC_1r(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_1(bcm5354x_gport_lport_to_index_in_block[p]), &(r._mac_1))

/*******************************************************************************
 * End of 'MAC_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MAC_PFC_CTRL
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     PPP control register
 * SIZE:     32
 * FIELDS:
 *     PFC_TX_ENBL      Enables the PPP-Tx functionality.
 *     PFC_RX_ENBL      Enables the PPP-Rx functionality.
 *     FORCE_PFC_XON    Instructs MAC to send Xon message to all classes of service.
 *     RX_PASS_PFC_FRM  When set, MAC pass PFC frame to the system. Otherwise, PFC frame is discarded.
 *     PFC_STATS_EN     When clear, none of PFC related counters should increment. 			       Otherwise, PFC counters is in full function.                                Note: it is programming requirement to set this bit when PFC function is enable.
 */
#define MAC_PFC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MAC_PFC_CTRL.
 */
typedef union MAC_PFC_CTRLr_s {
	uint32 v[1];
	uint32 mac_pfc_ctrl[1];
	uint32 _mac_pfc_ctrl;
} MAC_PFC_CTRLr_t;

#define MAC_PFC_CTRLr_CLR(r) (r).mac_pfc_ctrl[0] = 0
#define MAC_PFC_CTRLr_SET(r,d) (r).mac_pfc_ctrl[0] = d
#define MAC_PFC_CTRLr_GET(r) (r).mac_pfc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_PFC_CTRLr_PFC_TX_ENBLf_GET(r) (((r).mac_pfc_ctrl[0]) & 0x1)
#define MAC_PFC_CTRLr_PFC_TX_ENBLf_SET(r,f) (r).mac_pfc_ctrl[0]=(((r).mac_pfc_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define MAC_PFC_CTRLr_PFC_RX_ENBLf_GET(r) ((((r).mac_pfc_ctrl[0]) >> 1) & 0x1)
#define MAC_PFC_CTRLr_PFC_RX_ENBLf_SET(r,f) (r).mac_pfc_ctrl[0]=(((r).mac_pfc_ctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define MAC_PFC_CTRLr_FORCE_PFC_XONf_GET(r) ((((r).mac_pfc_ctrl[0]) >> 2) & 0x1)
#define MAC_PFC_CTRLr_FORCE_PFC_XONf_SET(r,f) (r).mac_pfc_ctrl[0]=(((r).mac_pfc_ctrl[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define MAC_PFC_CTRLr_RX_PASS_PFC_FRMf_GET(r) ((((r).mac_pfc_ctrl[0]) >> 4) & 0x1)
#define MAC_PFC_CTRLr_RX_PASS_PFC_FRMf_SET(r,f) (r).mac_pfc_ctrl[0]=(((r).mac_pfc_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define MAC_PFC_CTRLr_PFC_STATS_ENf_GET(r) ((((r).mac_pfc_ctrl[0]) >> 5) & 0x1)
#define MAC_PFC_CTRLr_PFC_STATS_ENf_SET(r,f) (r).mac_pfc_ctrl[0]=(((r).mac_pfc_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))

/*
 * These macros can be used to access MAC_PFC_CTRL.
 */
#define WRITE_MAC_PFC_CTRLr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_PFC_CTRL(bcm5354x_gport_lport_to_index_in_block[p]), (r._mac_pfc_ctrl))
#define READ_MAC_PFC_CTRLr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_PFC_CTRL(bcm5354x_gport_lport_to_index_in_block[p]), &(r._mac_pfc_ctrl))

/*******************************************************************************
 * End of 'MAC_PFC_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MAC_PFC_DA_0
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     lower 32 bits of programmable DA for PPP (GNAT 13897)
 * SIZE:     32
 * FIELDS:
 *     PFC_MACDA_0      Lower 32 bits of programmable DA for PPP. Since PPP is not standardized yet, the DA must be programmable to make sure that when it gets standardized, we can be standards compliant. 
 */
#define MAC_PFC_DA_0r_SIZE 4

/* MAC_PFC_DA_0r is element of MAC_PFC_DA */

/*
 * This structure should be used to declare and program MAC_PFC_DA_0.
 */
typedef union MAC_PFC_DA_0r_s {
	uint32 v[1];
	uint32 mac_pfc_da_0[1];
	uint32 _mac_pfc_da_0;
} MAC_PFC_DA_0r_t;

#define MAC_PFC_DA_0r_CLR(r) (r).mac_pfc_da_0[0] = 0
#define MAC_PFC_DA_0r_SET(r,d) (r).mac_pfc_da_0[0] = d
#define MAC_PFC_DA_0r_GET(r) (r).mac_pfc_da_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_PFC_DA_0r_PFC_MACDA_0f_GET(r) ((r).mac_pfc_da_0[0])
#define MAC_PFC_DA_0r_PFC_MACDA_0f_SET(r,f) (r).mac_pfc_da_0[0]=((uint32)f)

/*
 * These macros can be used to access MAC_PFC_DA_0.
 */
#define WRITE_MAC_PFC_DA_0r(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_PFC_DA_0(bcm5354x_gport_lport_to_index_in_block[p]), (r._mac_pfc_da_0))
#define READ_MAC_PFC_DA_0r(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_PFC_DA_0(bcm5354x_gport_lport_to_index_in_block[p]), &(r._mac_pfc_da_0))

/*******************************************************************************
 * End of 'MAC_PFC_DA_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MAC_PFC_DA_1
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     upper 16 bits of programmable DA for PPP (GNAT 13897)
 * SIZE:     32
 * FIELDS:
 *     PFC_MACDA_1      Upper 16 bits of programmable DA for PPP. Since PPP is not standardized yet, the DA must be programmable to make sure that when it gets standardized, we can be standards compliant. 
 */
#define MAC_PFC_DA_1r_SIZE 4

/* MAC_PFC_DA_1r is element of MAC_PFC_DA */

/*
 * This structure should be used to declare and program MAC_PFC_DA_1.
 */
typedef union MAC_PFC_DA_1r_s {
	uint32 v[1];
	uint32 mac_pfc_da_1[1];
	uint32 _mac_pfc_da_1;
} MAC_PFC_DA_1r_t;

#define MAC_PFC_DA_1r_CLR(r) (r).mac_pfc_da_1[0] = 0
#define MAC_PFC_DA_1r_SET(r,d) (r).mac_pfc_da_1[0] = d
#define MAC_PFC_DA_1r_GET(r) (r).mac_pfc_da_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_PFC_DA_1r_PFC_MACDA_1f_GET(r) (((r).mac_pfc_da_1[0]) & 0xffff)
#define MAC_PFC_DA_1r_PFC_MACDA_1f_SET(r,f) (r).mac_pfc_da_1[0]=(((r).mac_pfc_da_1[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access MAC_PFC_DA_1.
 */
#define WRITE_MAC_PFC_DA_1r(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_PFC_DA_1(bcm5354x_gport_lport_to_index_in_block[p]), (r._mac_pfc_da_1))
#define READ_MAC_PFC_DA_1r(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_PFC_DA_1(bcm5354x_gport_lport_to_index_in_block[p]), &(r._mac_pfc_da_1))

/*******************************************************************************
 * End of 'MAC_PFC_DA_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MAC_PFC_OPCODE
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Programmable opcode (GNAT 13440)
 * SIZE:     32
 * FIELDS:
 *     PFC_OPCODE       These 16 bits are for opcode. Since PFC is not standardized yet, the opcode must be programmable to make sure that when it gets standardized, we can be standards compliant. 
 */
#define MAC_PFC_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program MAC_PFC_OPCODE.
 */
typedef union MAC_PFC_OPCODEr_s {
	uint32 v[1];
	uint32 mac_pfc_opcode[1];
	uint32 _mac_pfc_opcode;
} MAC_PFC_OPCODEr_t;

#define MAC_PFC_OPCODEr_CLR(r) (r).mac_pfc_opcode[0] = 0
#define MAC_PFC_OPCODEr_SET(r,d) (r).mac_pfc_opcode[0] = d
#define MAC_PFC_OPCODEr_GET(r) (r).mac_pfc_opcode[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_PFC_OPCODEr_PFC_OPCODEf_GET(r) (((r).mac_pfc_opcode[0]) & 0xffff)
#define MAC_PFC_OPCODEr_PFC_OPCODEf_SET(r,f) (r).mac_pfc_opcode[0]=(((r).mac_pfc_opcode[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access MAC_PFC_OPCODE.
 */
#define WRITE_MAC_PFC_OPCODEr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_PFC_OPCODE(bcm5354x_gport_lport_to_index_in_block[p]), (r._mac_pfc_opcode))
#define READ_MAC_PFC_OPCODEr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_PFC_OPCODE(bcm5354x_gport_lport_to_index_in_block[p]), &(r._mac_pfc_opcode))

/*******************************************************************************
 * End of 'MAC_PFC_OPCODEr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MAC_PFC_REFRESH_CTRL
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     PPP refresh control register
 * SIZE:     32
 * FIELDS:
 *     PFC_REFRESH_EN   Enables the PPP refresh functionality on the Tx side. When enabled, the MAC sends Xoff message on refresh counter becoming 0
 *     PFC_REFRESH_TIMER PPP refresh counter value.
 */
#define MAC_PFC_REFRESH_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MAC_PFC_REFRESH_CTRL.
 */
typedef union MAC_PFC_REFRESH_CTRLr_s {
	uint32 v[1];
	uint32 mac_pfc_refresh_ctrl[1];
	uint32 _mac_pfc_refresh_ctrl;
} MAC_PFC_REFRESH_CTRLr_t;

#define MAC_PFC_REFRESH_CTRLr_CLR(r) (r).mac_pfc_refresh_ctrl[0] = 0
#define MAC_PFC_REFRESH_CTRLr_SET(r,d) (r).mac_pfc_refresh_ctrl[0] = d
#define MAC_PFC_REFRESH_CTRLr_GET(r) (r).mac_pfc_refresh_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_PFC_REFRESH_CTRLr_PFC_REFRESH_ENf_GET(r) (((r).mac_pfc_refresh_ctrl[0]) & 0x1)
#define MAC_PFC_REFRESH_CTRLr_PFC_REFRESH_ENf_SET(r,f) (r).mac_pfc_refresh_ctrl[0]=(((r).mac_pfc_refresh_ctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define MAC_PFC_REFRESH_CTRLr_PFC_REFRESH_TIMERf_GET(r) ((((r).mac_pfc_refresh_ctrl[0]) >> 16) & 0xffff)
#define MAC_PFC_REFRESH_CTRLr_PFC_REFRESH_TIMERf_SET(r,f) (r).mac_pfc_refresh_ctrl[0]=(((r).mac_pfc_refresh_ctrl[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access MAC_PFC_REFRESH_CTRL.
 */
#define WRITE_MAC_PFC_REFRESH_CTRLr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_PFC_REFRESH_CTRL(bcm5354x_gport_lport_to_index_in_block[p]), (r._mac_pfc_refresh_ctrl))
#define READ_MAC_PFC_REFRESH_CTRLr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_PFC_REFRESH_CTRL(bcm5354x_gport_lport_to_index_in_block[p]), &(r._mac_pfc_refresh_ctrl))

/*******************************************************************************
 * End of 'MAC_PFC_REFRESH_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MAC_PFC_TYPE
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Programmable ethertype (GNAT 13440)
 * SIZE:     32
 * FIELDS:
 *     PFC_ETH_TYPE     These 16 bits are for programmable ethertype in PFC. Since PFC is not standardized yet, the ethertype must be programmable to make sure that when it gets standardized, we can be standards compliant. 
 */
#define MAC_PFC_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program MAC_PFC_TYPE.
 */
typedef union MAC_PFC_TYPEr_s {
	uint32 v[1];
	uint32 mac_pfc_type[1];
	uint32 _mac_pfc_type;
} MAC_PFC_TYPEr_t;

#define MAC_PFC_TYPEr_CLR(r) (r).mac_pfc_type[0] = 0
#define MAC_PFC_TYPEr_SET(r,d) (r).mac_pfc_type[0] = d
#define MAC_PFC_TYPEr_GET(r) (r).mac_pfc_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAC_PFC_TYPEr_PFC_ETH_TYPEf_GET(r) (((r).mac_pfc_type[0]) & 0xffff)
#define MAC_PFC_TYPEr_PFC_ETH_TYPEf_SET(r,f) (r).mac_pfc_type[0]=(((r).mac_pfc_type[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access MAC_PFC_TYPE.
 */
#define WRITE_MAC_PFC_TYPEr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_PFC_TYPE(bcm5354x_gport_lport_to_index_in_block[p]), (r._mac_pfc_type))
#define READ_MAC_PFC_TYPEr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_MAC_PFC_TYPE(bcm5354x_gport_lport_to_index_in_block[p]), &(r._mac_pfc_type))

/*******************************************************************************
 * End of 'MAC_PFC_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MAXBUCKETCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Min Bucket function is disabled when Bucket Size is 0.Threshold determines the size of Minimum Bucket. This Threshold setting is not related to actual bandwidth rate number.When SHAPING_Q_GRAN corresponding Q setting is 0:  The Bucket Size is range from 4k Bytes to 16M Bytes with 4k Bytes increment. The Bucket size is determined by the formula,  Bucket Size = MIN_THD_SEL * 4KBytesWhen SHAPING_Q_GRAN corresponding Q setting is 1:  The Bucket Size is range from 8k Bytes to 32M Bytes with 8k Bytes increment. The Bucket size is determined by the formula,  Bucket Size = MIN_THD_SEL * 8KBytesWhen EAV is enabled for a port, this register is used to program the upper 12 bits of the 18-bit EAV Bucket threshold. The lower 6-bits are programmed in EAVBUCKETCONFIG_EXT register.The Bucket Size is determined by the formula:Bucket Size = {MAX_THD_SEL,EAVBUCKETCONFIG_EXT.EAV_THD_SEL_6LSB} * 2^10  * bucket unitWhen SHAPING_Q_GRAN corresponding Q setting is 0:  bucket unit = 0.5 bit  The Bucket Size is range from 64B Bytes to 16M Bytes with 64 Bytes increment.When SHAPING_Q_GRAN corresponding Q setting is 1:  bucket unit = 1 bit  The Bucket Size is range from 128B Bytes to 32M Bytes with 128 Bytes increment.EAV Bucket function is disableD when Bucket Size is 0.
 *     MAX_REFRESH      Refresh count for minimum rate bucket. When SHAPING_Q_GRAN corresponding Q setting is 0:  Every unit of REFRESH represents 64,000 bps, (bits per second).  Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),                set MIN_REFRESH = 7812,  Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),                set MIN_REFRESH = 15624.When SHAPING_Q_GRAN corresponding Q setting is 1:  Every unit of REFRESH represents 256,000 bps, (bits per second).When EAV is enabled for a port, this register is used to program the rate of the EAV Shaper at the same granularity as a MAX Bucket.
 *     EAV_MODE         Enable EAV Shaper0: MAX shaping1: EAV shaping
 */
#define MAXBUCKETCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MAXBUCKETCONFIG.
 */
typedef union MAXBUCKETCONFIGr_s {
	uint32 v[1];
	uint32 maxbucketconfig[1];
	uint32 _maxbucketconfig;
} MAXBUCKETCONFIGr_t;

#define MAXBUCKETCONFIGr_CLR(r) (r).maxbucketconfig[0] = 0
#define MAXBUCKETCONFIGr_SET(r,d) (r).maxbucketconfig[0] = d
#define MAXBUCKETCONFIGr_GET(r) (r).maxbucketconfig[0]

/*
 * These macros can be used to access individual fields.
 */
#define MAXBUCKETCONFIGr_MAX_THD_SELf_GET(r) (((r).maxbucketconfig[0]) & 0xfff)
#define MAXBUCKETCONFIGr_MAX_THD_SELf_SET(r,f) (r).maxbucketconfig[0]=(((r).maxbucketconfig[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define MAXBUCKETCONFIGr_MAX_REFRESHf_GET(r) ((((r).maxbucketconfig[0]) >> 12) & 0x3ffff)
#define MAXBUCKETCONFIGr_MAX_REFRESHf_SET(r,f) (r).maxbucketconfig[0]=(((r).maxbucketconfig[0] & ~((uint32)0x3ffff << 12)) | ((((uint32)f) & 0x3ffff) << 12))
#define MAXBUCKETCONFIGr_EAV_MODEf_GET(r) ((((r).maxbucketconfig[0]) >> 30) & 0x1)
#define MAXBUCKETCONFIGr_EAV_MODEf_SET(r,f) (r).maxbucketconfig[0]=(((r).maxbucketconfig[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))

/*
 * These macros can be used to access MAXBUCKETCONFIG.
 */
#define WRITE_MAXBUCKETCONFIGr(u,p, cos,r) bcm5354x_reg_set(u, R_MAXBUCKETCONFIG(cos,p), (r._maxbucketconfig))
#define READ_MAXBUCKETCONFIGr(u,p, cos,r) bcm5354x_reg_get(u,R_MAXBUCKETCONFIG(cos,p),&(r._maxbucketconfig))

/*******************************************************************************
 * End of 'MAXBUCKETCONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MII_EEE_DELAY_ENTRY_TIMER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     MII_EEE LPI timer
 * SIZE:     32
 * FIELDS:
 *     MII_EEE_LPI_TIMER This is the duration for which condition to move to LPI state must be satisfied, at the end of which MAC transitions to LPI State. The decrement unit is 1 micro-second.This register is meant for 10/100 Mbps speed.
 */
#define MII_EEE_DELAY_ENTRY_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program MII_EEE_DELAY_ENTRY_TIMER.
 */
typedef union MII_EEE_DELAY_ENTRY_TIMERr_s {
	uint32 v[1];
	uint32 mii_eee_delay_entry_timer[1];
	uint32 _mii_eee_delay_entry_timer;
} MII_EEE_DELAY_ENTRY_TIMERr_t;

#define MII_EEE_DELAY_ENTRY_TIMERr_CLR(r) (r).mii_eee_delay_entry_timer[0] = 0
#define MII_EEE_DELAY_ENTRY_TIMERr_SET(r,d) (r).mii_eee_delay_entry_timer[0] = d
#define MII_EEE_DELAY_ENTRY_TIMERr_GET(r) (r).mii_eee_delay_entry_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define MII_EEE_DELAY_ENTRY_TIMERr_MII_EEE_LPI_TIMERf_GET(r) ((r).mii_eee_delay_entry_timer[0])
#define MII_EEE_DELAY_ENTRY_TIMERr_MII_EEE_LPI_TIMERf_SET(r,f) (r).mii_eee_delay_entry_timer[0]=((uint32)f)

/*
 * These macros can be used to access MII_EEE_DELAY_ENTRY_TIMER.
 */
#define WRITE_MII_EEE_DELAY_ENTRY_TIMERr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_MII_EEE_DELAY_ENTRY_TIMER(bcm5354x_gport_lport_to_index_in_block[p]), (r._mii_eee_delay_entry_timer))
#define READ_MII_EEE_DELAY_ENTRY_TIMERr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_MII_EEE_DELAY_ENTRY_TIMER(bcm5354x_gport_lport_to_index_in_block[p]), &(r._mii_eee_delay_entry_timer))

/*******************************************************************************
 * End of 'MII_EEE_DELAY_ENTRY_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MII_EEE_WAKE_TIMER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     MII_EEE Wake timer
 * SIZE:     32
 * FIELDS:
 *     MII_EEE_WAKE_TIMER This is the duration for which MAC must wait to go back to ACTIVE state from LPI state when it receives packet for transmission. The decrement unit is 1 micro-second.This register is meant for 10/100 Mbps speed.
 */
#define MII_EEE_WAKE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program MII_EEE_WAKE_TIMER.
 */
typedef union MII_EEE_WAKE_TIMERr_s {
	uint32 v[1];
	uint32 mii_eee_wake_timer[1];
	uint32 _mii_eee_wake_timer;
} MII_EEE_WAKE_TIMERr_t;

#define MII_EEE_WAKE_TIMERr_CLR(r) (r).mii_eee_wake_timer[0] = 0
#define MII_EEE_WAKE_TIMERr_SET(r,d) (r).mii_eee_wake_timer[0] = d
#define MII_EEE_WAKE_TIMERr_GET(r) (r).mii_eee_wake_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define MII_EEE_WAKE_TIMERr_MII_EEE_WAKE_TIMERf_GET(r) (((r).mii_eee_wake_timer[0]) & 0xffff)
#define MII_EEE_WAKE_TIMERr_MII_EEE_WAKE_TIMERf_SET(r,f) (r).mii_eee_wake_timer[0]=(((r).mii_eee_wake_timer[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access MII_EEE_WAKE_TIMER.
 */
#define WRITE_MII_EEE_WAKE_TIMERr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_MII_EEE_WAKE_TIMER(bcm5354x_gport_lport_to_index_in_block[p]), (r._mii_eee_wake_timer))
#define READ_MII_EEE_WAKE_TIMERr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_MII_EEE_WAKE_TIMER(bcm5354x_gport_lport_to_index_in_block[p]), &(r._mii_eee_wake_timer))

/*******************************************************************************
 * End of 'MII_EEE_WAKE_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MIRROR_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Mirror control register 
 * SIZE:     32
 * FIELDS:
 *     M_ENABLE         Enable mirroring
 *     IM_MTP_INDEX     Ingress MTP index
 *     IM_MTP_INDEX0    Ingress MTP index
 *     EM_MTP_INDEX     Egress MTP index
 *     EM_MTP_INDEX0    Egress MTP index
 *     NON_UC_EM_MTP_INDEX Non-unicast egress MTP index
 *     NON_UC_EM_MTP_INDEX0 Non-unicast egress MTP index
 *     SRC_MODID_BLOCK_MIRROR_ONLY_PKT Apply the source MODID block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig packets with MH.M=1, MH.MO=1, MH.MD=0 ports
 *     SRC_MODID_BLOCK_MIRROR_COPY Apply the source MODID block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig packets with MH.M=1, MH.MO=0, MH.MD=0 ports
 */
#define MIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MIRROR_CONTROL.
 */
typedef union MIRROR_CONTROLr_s {
	uint32 v[1];
	uint32 mirror_control[1];
	uint32 _mirror_control;
} MIRROR_CONTROLr_t;

#define MIRROR_CONTROLr_CLR(r) (r).mirror_control[0] = 0
#define MIRROR_CONTROLr_SET(r,d) (r).mirror_control[0] = d
#define MIRROR_CONTROLr_GET(r) (r).mirror_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define MIRROR_CONTROLr_M_ENABLEf_GET(r) (((r).mirror_control[0]) & 0x1)
#define MIRROR_CONTROLr_M_ENABLEf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define MIRROR_CONTROLr_IM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 1) & 0x3)
#define MIRROR_CONTROLr_IM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x3 << 1)) | ((((uint32)f) & 0x3) << 1))
#define MIRROR_CONTROLr_IM_MTP_INDEX0f_GET(r) ((((r).mirror_control[0]) >> 1) & 0x3)
#define MIRROR_CONTROLr_IM_MTP_INDEX0f_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x3 << 1)) | ((((uint32)f) & 0x3) << 1))
#define MIRROR_CONTROLr_EM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 3) & 0x3)
#define MIRROR_CONTROLr_EM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x3 << 3)) | ((((uint32)f) & 0x3) << 3))
#define MIRROR_CONTROLr_EM_MTP_INDEX0f_GET(r) ((((r).mirror_control[0]) >> 3) & 0x3)
#define MIRROR_CONTROLr_EM_MTP_INDEX0f_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x3 << 3)) | ((((uint32)f) & 0x3) << 3))
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 5) & 0x3)
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x3 << 5)) | ((((uint32)f) & 0x3) << 5))
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEX0f_GET(r) ((((r).mirror_control[0]) >> 5) & 0x3)
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEX0f_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x3 << 5)) | ((((uint32)f) & 0x3) << 5))
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET(r) ((((r).mirror_control[0]) >> 13) & 0x1)
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET(r) ((((r).mirror_control[0]) >> 14) & 0x1)
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))

/*
 * These macros can be used to access MIRROR_CONTROL.
 */
#define WRITE_MIRROR_CONTROLr(u,p,r) bcm5354x_reg_set(u,R_MIRROR_CONTROL(p),(r._mirror_control))
#define READ_MIRROR_CONTROLr(u,p,r) bcm5354x_reg_get(u,R_MIRROR_CONTROL(p),&(r._mirror_control))

/*******************************************************************************
 * End of 'MIRROR_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MISCCONFIG
 * BLOCKS:   MMU
 * DESC:     Controls various functions in the MMU
 * SIZE:     32
 * FIELDS:
 *     DYNAMIC_MEMORY_EN Dynamic Memory Mode EnableHOL cell limit behavior (dynamic sharing of CBP):1: Dynamic Memory mode is enabled,0: Dynamic Memory mode is disabled.
 *     CLRDROPCTR       Clear All Drop Packet CountersWhen set to 1, MMU will clear all port counters of the followings:DROPPEDPKTCOUNT, CNGDROPCOUNT0, CNGDROPCOUNT1.Reading this bit will always return 0.
 *     SKIDMARKER       SkidMarker for each HOL Packet Counter, reserved value for the packets already in the transition to be accepted by MMU XQ. The values of SkidMarker are:0: 4 packets,1: 5 packets, 2: 6 packets,3: 7 packets.
 *     SLAM_MEM         Write 1 into this register will interrupt CFAP & CCP power-on initialization.After write 1 into this register, users will be able to slam cfap and ccp memories with desired value. When memory slamming is done, users need to wirte 1 into CFAPCONFIG.CFAPINIT register to complete CFAP & CCP initialzation.This regsiter should not be programmed while the tarffic is on. It may generate unexpected result.
 *     METERING_CLK_EN  METERING_CLK_EN will enable metering 7.8125us refresh tick to flow into egress port metering, min/max bucket and ingress back pressure metering function.0: Disable refresh tick,1: Enable refresh tick.
 *     PARITY_CHECK_EN  PARITY_CHECK_EN enable MMU hardware to 1. generate parity/ECC for memory write data2. check the parity protection memory read out data, report parity error3. check the ECC protection memory read out data,report ECC error and repair 1 bit error.4. "0": Disable memory parity/ECC "1": Enable  memory parity/ECC
 *     HOL_CELL_SOP_DROP_EN Only do HOL cell drop on sop cell to help TCP performance. This bit is also used to drop packets                               on SOP cell for BKP discard. 0X0 = DISABLE - Disable hol cell drop on sop cell 0x1 = ENABLE - Enable hol cell drop on sop cell 
 *     DYN_XQ_EN        Dynamic sharing of descriptor queue (XQ) among COSn for a port 0x0 = DISABLE - Disable dyn_xq_en 0x1 = ENABLE - Enable dyn_xq_en 
 *     IPMC_IND_MODE    IPMC_IND_MODE will enable egress port's ppp send out one extra l2 packet with L3IPMC packets when a packet is tagged as both l2 and l3 switching 0: disable sending extra l2 packet,1: enable sending extra l2 packet.
 *     CNG_DROP_EN      Set this bit will enable CNG colored packet drop function 0x0 = DISABLE - Disable CNG packet drop function 0x1 = ENABLE - Enable CNG packet drop function
 *     MULTIPLE_ACCOUNTING_FIX_EN Set to enable the fix for the accounting logic of the global dynamic space, for a multicast cell 0x0 = DISABLE - Disable MC accounting fix 0x1 = ENABLE - Enable MC accounting fix
 *     RESERVED         Reserved
 *     RESERVED_1       Reserved
 *     MEM_CORRUPT_CTL  This is purely for debug purpose.MMU memory feature wrapper has 2 corrupt control bits . Software/DV/DVT can inject memory error by setting these 2 bits.For parity only wrapper:bit 14: set 1 to inject parity error when write, hardware will write error parity/ECC into memory.bit 15: set 1 to inject parity error when read.For ECC wrapper:2'b01: inject 2bit ECC error when write 2'b10: inject 1bit ECC error when read2'b11: inject 2bit ECC error or read
 *     ECC_ONE_BIT_ERROR_INT_EN This is purely for debug purpose.set 1: to enable 1-bit ECC error trigger the interrupt and record the error pointer 
 */
#define MISCCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MISCCONFIG.
 */
typedef union MISCCONFIGr_s {
	uint32 v[1];
	uint32 miscconfig[1];
	uint32 _miscconfig;
} MISCCONFIGr_t;

#define MISCCONFIGr_CLR(r) (r).miscconfig[0] = 0
#define MISCCONFIGr_SET(r,d) (r).miscconfig[0] = d
#define MISCCONFIGr_GET(r) (r).miscconfig[0]

/*
 * These macros can be used to access individual fields.
 */
#define MISCCONFIGr_DYNAMIC_MEMORY_ENf_GET(r) (((r).miscconfig[0]) & 0x1)
#define MISCCONFIGr_DYNAMIC_MEMORY_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define MISCCONFIGr_CLRDROPCTRf_GET(r) ((((r).miscconfig[0]) >> 1) & 0x1)
#define MISCCONFIGr_CLRDROPCTRf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define MISCCONFIGr_SKIDMARKERf_GET(r) ((((r).miscconfig[0]) >> 2) & 0x3)
#define MISCCONFIGr_SKIDMARKERf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define MISCCONFIGr_SLAM_MEMf_GET(r) ((((r).miscconfig[0]) >> 4) & 0x1)
#define MISCCONFIGr_SLAM_MEMf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define MISCCONFIGr_METERING_CLK_ENf_GET(r) ((((r).miscconfig[0]) >> 5) & 0x1)
#define MISCCONFIGr_METERING_CLK_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define MISCCONFIGr_PARITY_CHECK_ENf_GET(r) ((((r).miscconfig[0]) >> 6) & 0x1)
#define MISCCONFIGr_PARITY_CHECK_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_GET(r) ((((r).miscconfig[0]) >> 7) & 0x1)
#define MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define MISCCONFIGr_DYN_XQ_ENf_GET(r) ((((r).miscconfig[0]) >> 8) & 0x1)
#define MISCCONFIGr_DYN_XQ_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define MISCCONFIGr_IPMC_IND_MODEf_GET(r) ((((r).miscconfig[0]) >> 9) & 0x1)
#define MISCCONFIGr_IPMC_IND_MODEf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define MISCCONFIGr_CNG_DROP_ENf_GET(r) ((((r).miscconfig[0]) >> 10) & 0x1)
#define MISCCONFIGr_CNG_DROP_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define MISCCONFIGr_MULTIPLE_ACCOUNTING_FIX_ENf_GET(r) ((((r).miscconfig[0]) >> 11) & 0x1)
#define MISCCONFIGr_MULTIPLE_ACCOUNTING_FIX_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define MISCCONFIGr_RESERVEDf_GET(r) ((((r).miscconfig[0]) >> 12) & 0x1)
#define MISCCONFIGr_RESERVEDf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define MISCCONFIGr_RESERVED_1f_GET(r) ((((r).miscconfig[0]) >> 13) & 0x1)
#define MISCCONFIGr_RESERVED_1f_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define MISCCONFIGr_MEM_CORRUPT_CTLf_GET(r) ((((r).miscconfig[0]) >> 14) & 0x3)
#define MISCCONFIGr_MEM_CORRUPT_CTLf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define MISCCONFIGr_ECC_ONE_BIT_ERROR_INT_ENf_GET(r) ((((r).miscconfig[0]) >> 16) & 0x1)
#define MISCCONFIGr_ECC_ONE_BIT_ERROR_INT_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))

/*
 * These macros can be used to access MISCCONFIG.
 */
#define WRITE_MISCCONFIGr(u,r) bcm5354x_reg_set(u,R_MISCCONFIG,(r._miscconfig))
#define READ_MISCCONFIGr(u,r) bcm5354x_reg_get(u,R_MISCCONFIG,&(r._miscconfig))

/*******************************************************************************
 * End of 'MISCCONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MMUFLUSHCONTROL
 * BLOCKS:   MMU
 * DESC:     Port MMU XQ Flush
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Each control bit when asserted, puts the corresponding port in the flush state. When a particular port is in flush state, the packets from the XQ of the port are purged after dequeue. It is expected that once a port is in flush state, there will be no more packets queued so that the queues become empty for that port. Once the port is empty, flush control bit can be deasserted. 
 */
#define MMUFLUSHCONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MMUFLUSHCONTROL.
 */
typedef union MMUFLUSHCONTROLr_s {
	uint32 v[1];
	uint32 mmuflushcontrol[1];
	uint32 _mmuflushcontrol;
} MMUFLUSHCONTROLr_t;

#define MMUFLUSHCONTROLr_CLR(r) (r).mmuflushcontrol[0] = 0
#define MMUFLUSHCONTROLr_SET(r,d) (r).mmuflushcontrol[0] = d
#define MMUFLUSHCONTROLr_GET(r) (r).mmuflushcontrol[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUFLUSHCONTROLr_FLUSHf_GET(r) ((r).mmuflushcontrol[0])
#define MMUFLUSHCONTROLr_FLUSHf_SET(r,f) (r).mmuflushcontrol[0]=((uint32)f)

/*
 * These macros can be used to access MMUFLUSHCONTROL.
 */
#define WRITE_MMUFLUSHCONTROLr(u,r) bcm5354x_reg_set(u,R_MMUFLUSHCONTROL,(r._mmuflushcontrol))
#define READ_MMUFLUSHCONTROLr(u,r) bcm5354x_reg_get(u,R_MMUFLUSHCONTROL,&(r._mmuflushcontrol))

/*******************************************************************************
 * End of 'MMUFLUSHCONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MMUPORTENABLE
 * BLOCKS:   MMU
 * DESC:     Port to memory buffer enable configuration 
 * SIZE:     32
 * FIELDS:
 *     MMUPORTENABLE    This bitmap specifies which egress ports are allowed to buffer packets. 
 */
#define MMUPORTENABLEr_SIZE 4

/*
 * This structure should be used to declare and program MMUPORTENABLE.
 */
typedef union MMUPORTENABLEr_s {
	uint32 v[1];
	uint32 mmuportenable[1];
	uint32 _mmuportenable;
} MMUPORTENABLEr_t;

#define MMUPORTENABLEr_CLR(r) (r).mmuportenable[0] = 0
#define MMUPORTENABLEr_SET(r,d) (r).mmuportenable[0] = d
#define MMUPORTENABLEr_GET(r) (r).mmuportenable[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUPORTENABLEr_MMUPORTENABLEf_GET(r) ((r).mmuportenable[0])
#define MMUPORTENABLEr_MMUPORTENABLEf_SET(r,f) (r).mmuportenable[0]=((uint32)f)

/*
 * These macros can be used to access MMUPORTENABLE.
 */
#define WRITE_MMUPORTENABLEr(u,r) bcm5354x_reg_set(u,R_MMUPORTENABLE,(r._mmuportenable))
#define READ_MMUPORTENABLEr(u,r) bcm5354x_reg_get(u,R_MMUPORTENABLE,&(r._mmuportenable))

/*******************************************************************************
 * End of 'MMUPORTENABLEr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MMUPORTTXENABLE
 * BLOCKS:   MMU
 * DESC:     Memory buffer to port enable configuration. This is so software can turn off any port's transmission on a packet boundary, without truncating or fragmenting any packets. 

 * SIZE:     32
 * FIELDS:
 *     MMUPORTTXENABLE  This bitmap specifies which ports the memory buffer can transmit packets to. 
 */
#define MMUPORTTXENABLEr_SIZE 4

/*
 * This structure should be used to declare and program MMUPORTTXENABLE.
 */
typedef union MMUPORTTXENABLEr_s {
	uint32 v[1];
	uint32 mmuporttxenable[1];
	uint32 _mmuporttxenable;
} MMUPORTTXENABLEr_t;

#define MMUPORTTXENABLEr_CLR(r) (r).mmuporttxenable[0] = 0
#define MMUPORTTXENABLEr_SET(r,d) (r).mmuporttxenable[0] = d
#define MMUPORTTXENABLEr_GET(r) (r).mmuporttxenable[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMUPORTTXENABLEr_MMUPORTTXENABLEf_GET(r) ((r).mmuporttxenable[0])
#define MMUPORTTXENABLEr_MMUPORTTXENABLEf_SET(r,f) (r).mmuporttxenable[0]=((uint32)f)

/*
 * These macros can be used to access MMUPORTTXENABLE.
 */
#define WRITE_MMUPORTTXENABLEr(u,r) bcm5354x_reg_set(u,R_MMUPORTTXENABLE,(r._mmuporttxenable))
#define READ_MMUPORTTXENABLEr(u,r) bcm5354x_reg_get(u,R_MMUPORTTXENABLE,&(r._mmuporttxenable))

/*******************************************************************************
 * End of 'MMUPORTTXENABLEr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  MMU_ARB_TDM_TABLE
 * BLOCKS:   MMU
 * DESC:     MMU to EPIPE Arbiter TDM Table
Must be programmed with the values specified in SDK per index as part of initialization before traffic is enabled.
 * SIZE:     7
 * FIELDS:
 *     PORT_NUM         Indicates destination port ID.Value as programmed in SDK.
 *     WRAP_EN          MMU to EPIPE TDM Table Read Wrap around Enable.Value as programmed in SDK.
 */
#define MMU_ARB_TDM_TABLEm_MIN 0
#define MMU_ARB_TDM_TABLEm_MAX 127
#define MMU_ARB_TDM_TABLEm_CMAX(u) 127
#define MMU_ARB_TDM_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program MMU_ARB_TDM_TABLE.
 */
typedef union MMU_ARB_TDM_TABLEm_s {
	uint32 v[1];
	uint32 mmu_arb_tdm_table[1];
	uint32 _mmu_arb_tdm_table;
} MMU_ARB_TDM_TABLEm_t;

#define MMU_ARB_TDM_TABLEm_CLR(r) (r).mmu_arb_tdm_table[0] = 0
#define MMU_ARB_TDM_TABLEm_SET(r,d) (r).mmu_arb_tdm_table[0] = d
#define MMU_ARB_TDM_TABLEm_GET(r) (r).mmu_arb_tdm_table[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_ARB_TDM_TABLEm_PORT_NUMf_GET(r) (((r).mmu_arb_tdm_table[0]) & 0x3f)
#define MMU_ARB_TDM_TABLEm_PORT_NUMf_SET(r,f) (r).mmu_arb_tdm_table[0]=(((r).mmu_arb_tdm_table[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define MMU_ARB_TDM_TABLEm_WRAP_ENf_GET(r) ((((r).mmu_arb_tdm_table[0]) >> 6) & 0x1)
#define MMU_ARB_TDM_TABLEm_WRAP_ENf_SET(r,f) (r).mmu_arb_tdm_table[0]=(((r).mmu_arb_tdm_table[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))

/*
 * These macros can be used to access MMU_ARB_TDM_TABLE.
 */
#define WRITE_MMU_ARB_TDM_TABLEm(u,i,r) bcm5354x_mem_set(u, M_MMU_ARB_TDM_TABLE(i), &(r._mmu_arb_tdm_table), 1)
#define READ_MMU_ARB_TDM_TABLEm(u,i,r) bcm5354x_mem_get(u, M_MMU_ARB_TDM_TABLE(i), &(r._mmu_arb_tdm_table), 1)

/*******************************************************************************
 * End of 'MMU_ARB_TDM_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MMU_FC_RX_EN
 * BLOCKS:   MMU
 * DESC:     MMU PFC/SAFC RX enable register
 * SIZE:     32
 * FIELDS:
 *     MMU_FC_RX_ENABLE RX enable bitmap. Each bit represents a Tx COS in that port that can be backpressured by PFC/LLFC messages received from the link partner. Bit 7: COS7....Bit 0: COS01: Enable backpressure for the Tx COS0: Ignore backpressure for the Tx COS 
 */
#define MMU_FC_RX_ENr_SIZE 4

/*
 * This structure should be used to declare and program MMU_FC_RX_EN.
 */
typedef union MMU_FC_RX_ENr_s {
	uint32 v[1];
	uint32 mmu_fc_rx_en[1];
	uint32 _mmu_fc_rx_en;
} MMU_FC_RX_ENr_t;

#define MMU_FC_RX_ENr_CLR(r) (r).mmu_fc_rx_en[0] = 0
#define MMU_FC_RX_ENr_SET(r,d) (r).mmu_fc_rx_en[0] = d
#define MMU_FC_RX_ENr_GET(r) (r).mmu_fc_rx_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_FC_RX_ENr_MMU_FC_RX_ENABLEf_GET(r) (((r).mmu_fc_rx_en[0]) & 0xff)
#define MMU_FC_RX_ENr_MMU_FC_RX_ENABLEf_SET(r,f) (r).mmu_fc_rx_en[0]=(((r).mmu_fc_rx_en[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))

/*
 * These macros can be used to access MMU_FC_RX_EN.
 */
#define WRITE_MMU_FC_RX_ENr(u,p,r) bcm5354x_reg_set(u,R_MMU_FC_RX_EN(p),(r._mmu_fc_rx_en))
#define READ_MMU_FC_RX_ENr(u,p,r) bcm5354x_reg_get(u,R_MMU_FC_RX_EN(p),&(r._mmu_fc_rx_en))

/*******************************************************************************
 * End of 'MMU_FC_RX_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  MMU_FC_TX_EN
 * BLOCKS:   MMU
 * DESC:     MMU PFC/SAFC RX enable register
 * SIZE:     32
 * FIELDS:
 *     MMU_FC_TX_ENABLE Each bit corresponding to a "priority enable vector" bit."0": MMU will reset the corresponding "priority enable vector" bit no matter its original XOFF status set by any of MMU flow control schemes"1": MMU will honor its original XOFF status set by any of MMU flow control schemesFor PFC, [7:0] is used.For SAFC, [15:0] is used.
 */
#define MMU_FC_TX_ENr_SIZE 4

/*
 * This structure should be used to declare and program MMU_FC_TX_EN.
 */
typedef union MMU_FC_TX_ENr_s {
	uint32 v[1];
	uint32 mmu_fc_tx_en[1];
	uint32 _mmu_fc_tx_en;
} MMU_FC_TX_ENr_t;

#define MMU_FC_TX_ENr_CLR(r) (r).mmu_fc_tx_en[0] = 0
#define MMU_FC_TX_ENr_SET(r,d) (r).mmu_fc_tx_en[0] = d
#define MMU_FC_TX_ENr_GET(r) (r).mmu_fc_tx_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_FC_TX_ENr_MMU_FC_TX_ENABLEf_GET(r) (((r).mmu_fc_tx_en[0]) & 0xffff)
#define MMU_FC_TX_ENr_MMU_FC_TX_ENABLEf_SET(r,f) (r).mmu_fc_tx_en[0]=(((r).mmu_fc_tx_en[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access MMU_FC_TX_EN.
 */
#define WRITE_MMU_FC_TX_ENr(u,p,r) bcm5354x_reg_set(u,R_MMU_FC_TX_EN(p),(r._mmu_fc_tx_en))
#define READ_MMU_FC_TX_ENr(u,p,r) bcm5354x_reg_get(u,R_MMU_FC_TX_EN(p),&(r._mmu_fc_tx_en))

/*******************************************************************************
 * End of 'MMU_FC_TX_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  MMU_IPMC_GROUP_TBL
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table - implemented in FLOP
 * SIZE:     11
 * FIELDS:
 *     PORT2_1STPTR     9 bit first pointer to LSB VLAN Bitmap for Port 2
 *     ECCP             ECC and Parity  of the IPMC group table.
 *     ECC              ECC of the IPMC group table.
 *     PARITY           Parity  of the IPMC group table.
 */
#define MMU_IPMC_GROUP_TBLm_MIN 0
#define MMU_IPMC_GROUP_TBLm_MAX 63
#define MMU_IPMC_GROUP_TBLm_CMAX(u) 63
#define MMU_IPMC_GROUP_TBLm_SIZE 2

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL.
 */
typedef union MMU_IPMC_GROUP_TBLm_s {
	uint32 v[1];
	uint32 mmu_ipmc_group_tbl[1];
	uint32 _mmu_ipmc_group_tbl;
} MMU_IPMC_GROUP_TBLm_t;

#define MMU_IPMC_GROUP_TBLm_CLR(r) (r).mmu_ipmc_group_tbl[0] = 0
#define MMU_IPMC_GROUP_TBLm_SET(r,d) (r).mmu_ipmc_group_tbl[0] = d
#define MMU_IPMC_GROUP_TBLm_GET(r) (r).mmu_ipmc_group_tbl[0]

/*
 * These macros can be used to access individual fields.
 */
#define MMU_IPMC_GROUP_TBLm_PORT2_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl[0]) & 0x3f)
#define MMU_IPMC_GROUP_TBLm_PORT2_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl[0]=(((r).mmu_ipmc_group_tbl[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define MMU_IPMC_GROUP_TBLm_ECCPf_GET(r) ((((r).mmu_ipmc_group_tbl[0]) >> 6) & 0x1f)
#define MMU_IPMC_GROUP_TBLm_ECCPf_SET(r,f) (r).mmu_ipmc_group_tbl[0]=(((r).mmu_ipmc_group_tbl[0] & ~((uint32)0x1f << 6)) | ((((uint32)f) & 0x1f) << 6))
#define MMU_IPMC_GROUP_TBLm_ECCf_GET(r) ((((r).mmu_ipmc_group_tbl[0]) >> 6) & 0xf)
#define MMU_IPMC_GROUP_TBLm_ECCf_SET(r,f) (r).mmu_ipmc_group_tbl[0]=(((r).mmu_ipmc_group_tbl[0] & ~((uint32)0xf << 6)) | ((((uint32)f) & 0xf) << 6))
#define MMU_IPMC_GROUP_TBLm_PARITYf_GET(r) ((((r).mmu_ipmc_group_tbl[0]) >> 10) & 0x1)
#define MMU_IPMC_GROUP_TBLm_PARITYf_SET(r,f) (r).mmu_ipmc_group_tbl[0]=(((r).mmu_ipmc_group_tbl[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL.
 */
#define WRITE_MMU_IPMC_GROUP_TBLm(u,aidx,idx, r) bcm5354x_mem_set(u, M_MMU_IPMC_GROUP_TBL(aidx,idx), &(r._mmu_ipmc_group_tbl), 1)
#define READ_MMU_IPMC_GROUP_TBLm(u,aidx,idx, r) bcm5354x_mem_get(u, M_MMU_IPMC_GROUP_TBL(aidx,idx), &(r._mmu_ipmc_group_tbl), 1)

/*******************************************************************************
 * End of 'MMU_IPMC_GROUP_TBLm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  NONUCAST_TRUNK_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Multicast and Broadcast Trunk Block Mask Table
 * SIZE:     33
 * FIELDS:
 *     BLOCK_MASK       Multicast/broadcast trunk block mask
 *     BLOCK_MASK_LO    Multicast/broadcast trunk block mask
 *     EVEN_PARITY      Even parity.
 */
#define NONUCAST_TRUNK_BLOCK_MASKm_MIN 0
#define NONUCAST_TRUNK_BLOCK_MASKm_MAX 63
#define NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u) 63
#define NONUCAST_TRUNK_BLOCK_MASKm_SIZE 5

/*
 * This structure should be used to declare and program NONUCAST_TRUNK_BLOCK_MASK.
 */
typedef union NONUCAST_TRUNK_BLOCK_MASKm_s {
	uint32 v[2];
	uint32 nonucast_trunk_block_mask[2];
	uint32 _nonucast_trunk_block_mask;
} NONUCAST_TRUNK_BLOCK_MASKm_t;

#define NONUCAST_TRUNK_BLOCK_MASKm_CLR(r) sal_memset(&((r)._nonucast_trunk_block_mask), 0, sizeof(NONUCAST_TRUNK_BLOCK_MASKm_t))
#define NONUCAST_TRUNK_BLOCK_MASKm_SET(r,i,d) (r).nonucast_trunk_block_mask[i] = d
#define NONUCAST_TRUNK_BLOCK_MASKm_GET(r,i) (r).nonucast_trunk_block_mask[i]

/*
 * These macros can be used to access individual fields.
 */
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET(r) ((r).nonucast_trunk_block_mask[0])
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET(r,f) (r).nonucast_trunk_block_mask[0]=((uint32)f)
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_GET(r) ((r).nonucast_trunk_block_mask[0])
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_SET(r,f) (r).nonucast_trunk_block_mask[0]=((uint32)f)
#define NONUCAST_TRUNK_BLOCK_MASKm_EVEN_PARITYf_GET(r) (((r).nonucast_trunk_block_mask[1]) & 0x1)
#define NONUCAST_TRUNK_BLOCK_MASKm_EVEN_PARITYf_SET(r,f) (r).nonucast_trunk_block_mask[1]=(((r).nonucast_trunk_block_mask[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access NONUCAST_TRUNK_BLOCK_MASK.
 */
#define WRITE_NONUCAST_TRUNK_BLOCK_MASKm(u,i,r) bcm5354x_mem_set(u, M_NONUCAST_TRUNK_BLOCK_MASK(i), &(r._nonucast_trunk_block_mask), 2)
#define READ_NONUCAST_TRUNK_BLOCK_MASKm(u,i,r) bcm5354x_mem_get(u, M_NONUCAST_TRUNK_BLOCK_MASK(i), &(r._nonucast_trunk_block_mask), 2)

/*******************************************************************************
 * End of 'NONUCAST_TRUNK_BLOCK_MASKm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  PFC_XOFF_TIMER
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     XOFF Timer value for PFC Tx packet
 * SIZE:     32
 * FIELDS:
 *     PFC_XOFF_TIMER   Time value sent in the Timer Field for classes in XOFF state (Unit is 512 bit-times).
 */
#define PFC_XOFF_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program PFC_XOFF_TIMER.
 */
typedef union PFC_XOFF_TIMERr_s {
	uint32 v[1];
	uint32 pfc_xoff_timer[1];
	uint32 _pfc_xoff_timer;
} PFC_XOFF_TIMERr_t;

#define PFC_XOFF_TIMERr_CLR(r) (r).pfc_xoff_timer[0] = 0
#define PFC_XOFF_TIMERr_SET(r,d) (r).pfc_xoff_timer[0] = d
#define PFC_XOFF_TIMERr_GET(r) (r).pfc_xoff_timer[0]

/*
 * These macros can be used to access individual fields.
 */
#define PFC_XOFF_TIMERr_PFC_XOFF_TIMERf_GET(r) (((r).pfc_xoff_timer[0]) & 0xffff)
#define PFC_XOFF_TIMERr_PFC_XOFF_TIMERf_SET(r,f) (r).pfc_xoff_timer[0]=(((r).pfc_xoff_timer[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access PFC_XOFF_TIMER.
 */
#define WRITE_PFC_XOFF_TIMERr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_PFC_XOFF_TIMER(bcm5354x_gport_lport_to_index_in_block[p]), (r._pfc_xoff_timer))
#define READ_PFC_XOFF_TIMERr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_PFC_XOFF_TIMER(bcm5354x_gport_lport_to_index_in_block[p]), &(r._pfc_xoff_timer))

/*******************************************************************************
 * End of 'PFC_XOFF_TIMERr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  PG2TC
 * BLOCKS:   MMU
 * DESC:     PG to PRIORITY/TC mapping register
 * SIZE:     32
 * FIELDS:
 *     PG_BMP           The registers are used when the port is configured either as a PFC enabled or a SAFC enabled port. The 16-bit vector PGn_BMP (n=0..7) indicates which bits in the Enable vector in the PFC/SAFC frame transmitted by Greyhound will be set when Priority Group (PG) n needs to be backpressured. Each bit in a PGn_BMP register corresponds to a bit in the Enable vector in the PFC/SAFC frame. For a PFC enabled port, only the lower 8 bits of each of the 8 registers map directly to the PFC Enable Vector and the upper 8 bits are ignored. Instead, on a SAFC enabled port the 16 bits of each of the 8 registers map directly to the 16-bit SAFC Enable Vector.These mapping registers for a PFC/SAFC enabled port in Greyhound are used only when Greyhound transmits a PFC/SAFC frame on that port.For example, if bit 5 in the 16-bit vector PG3_BMP is set for a PFC/SAFC enabled port and PG3 needs to be backpressured on that port, then bit 5 in the Enable vector in the transmitted PFC/SAFC frame will be set by the PFC/SAFC transmit function in Greyhound. 
 */
#define PG2TCr_SIZE 4

/*
 * This structure should be used to declare and program PG2TC.
 */
typedef union PG2TCr_s {
	uint32 v[1];
	uint32 pg2tc[1];
	uint32 _pg2tc;
} PG2TCr_t;

#define PG2TCr_CLR(r) (r).pg2tc[0] = 0
#define PG2TCr_SET(r,d) (r).pg2tc[0] = d
#define PG2TCr_GET(r) (r).pg2tc[0]

/*
 * These macros can be used to access individual fields.
 */
#define PG2TCr_PG_BMPf_GET(r) (((r).pg2tc[0]) & 0xffff)
#define PG2TCr_PG_BMPf_SET(r,f) (r).pg2tc[0]=(((r).pg2tc[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access PG2TC.
 */
#define WRITE_PG2TCr(u,p, i,r) bcm5354x_reg_set(u, R_PG2TC(i,p), (r._pg2tc))
#define READ_PG2TCr(u,p, i,r) bcm5354x_reg_get(u,R_PG2TC(i,p),&(r._pg2tc))

/*******************************************************************************
 * End of 'PG2TCr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  PGCELLLIMIT
 * BLOCKS:   MMU
 * DESC:     PG cell set/reset limit
 * SIZE:     32
 * FIELDS:
 *     CELLSETLIMIT     When a PG of an ingress port is not in a backpressure state, the PG's cell counter must rise above this threshold before the backpressure state for the ingress PG is set.(criterion:PGCELLCNT >= CELLSETLIMIT)
 *     CELLRESETLIMIT   When a Priority Group is in the backpressure state, its cell counter must cross this reset limit threshold for the backpressure state of the PG to be reset.(criterion:PGCELLCNT < CELLRESETLIMIT)The CELLRESETLIMIT can be set to the same value or a value lower than the CELLSETLIMIT
 */
#define PGCELLLIMITr_SIZE 4

/*
 * This structure should be used to declare and program PGCELLLIMIT.
 */
typedef union PGCELLLIMITr_s {
	uint32 v[1];
	uint32 pgcelllimit[1];
	uint32 _pgcelllimit;
} PGCELLLIMITr_t;

#define PGCELLLIMITr_CLR(r) (r).pgcelllimit[0] = 0
#define PGCELLLIMITr_SET(r,d) (r).pgcelllimit[0] = d
#define PGCELLLIMITr_GET(r) (r).pgcelllimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGCELLLIMITr_CELLSETLIMITf_GET(r) (((r).pgcelllimit[0]) & 0xfff)
#define PGCELLLIMITr_CELLSETLIMITf_SET(r,f) (r).pgcelllimit[0]=(((r).pgcelllimit[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define PGCELLLIMITr_CELLRESETLIMITf_GET(r) ((((r).pgcelllimit[0]) >> 12) & 0xfff)
#define PGCELLLIMITr_CELLRESETLIMITf_SET(r,f) (r).pgcelllimit[0]=(((r).pgcelllimit[0] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))

/*
 * These macros can be used to access PGCELLLIMIT.
 */
#define WRITE_PGCELLLIMITr(u,p, i,r) bcm5354x_reg_set(u, R_PGCELLLIMIT(i,p), (r._pgcelllimit))
#define READ_PGCELLLIMITr(u,p, i,r) bcm5354x_reg_get(u,R_PGCELLLIMIT(i,p),&(r._pgcelllimit))

/*******************************************************************************
 * End of 'PGCELLLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  PGDISCARDSETLIMIT
 * BLOCKS:   MMU
 * DESC:     PG discard limit
 * SIZE:     32
 * FIELDS:
 *     DISCARDSETLIMIT  If the cell counter of a priority group of an ingress port rises above this threshold, new coming packets are dropped immediately.(criterion:PGCELLCNT >= DISCARDSETLIMIT)
 */
#define PGDISCARDSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program PGDISCARDSETLIMIT.
 */
typedef union PGDISCARDSETLIMITr_s {
	uint32 v[1];
	uint32 pgdiscardsetlimit[1];
	uint32 _pgdiscardsetlimit;
} PGDISCARDSETLIMITr_t;

#define PGDISCARDSETLIMITr_CLR(r) (r).pgdiscardsetlimit[0] = 0
#define PGDISCARDSETLIMITr_SET(r,d) (r).pgdiscardsetlimit[0] = d
#define PGDISCARDSETLIMITr_GET(r) (r).pgdiscardsetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGDISCARDSETLIMITr_DISCARDSETLIMITf_GET(r) (((r).pgdiscardsetlimit[0]) & 0xfff)
#define PGDISCARDSETLIMITr_DISCARDSETLIMITf_SET(r,f) (r).pgdiscardsetlimit[0]=(((r).pgdiscardsetlimit[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))

/*
 * These macros can be used to access PGDISCARDSETLIMIT.
 */
#define WRITE_PGDISCARDSETLIMITr(u,p, i,r) bcm5354x_reg_set(u, R_PGDISCARDSETLIMIT(i,p), (r._pgdiscardsetlimit))
#define READ_PGDISCARDSETLIMITr(u,p, i,r) bcm5354x_reg_get(u,R_PGDISCARDSETLIMIT(i,p),&(r._pgdiscardsetlimit))

/*******************************************************************************
 * End of 'PGDISCARDSETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  PGW_CTRL_0
 * BLOCKS:   TOP
 * DESC:     PGW Control Register 0
 * SIZE:     32
 * FIELDS:
 *     SW_QTC_DISABLE   When the bit is set, QTC would be shut off.Bit 0: control QTC_0.Bit 1: control QTC_1.
 *     SW_PM4X10_DISABLE When the bit is set, PM_4X10 would be shut off.Bit 0: control PM_4X10_0.Bit 1: control PM_4X10_1.
 *     RSVD             Reserved
 */
#define PGW_CTRL_0r_SIZE 4

/*
 * This structure should be used to declare and program PGW_CTRL_0.
 */
typedef union PGW_CTRL_0r_s {
	uint32 v[1];
	uint32 pgw_ctrl_0[1];
	uint32 _pgw_ctrl_0;
} PGW_CTRL_0r_t;

#define PGW_CTRL_0r_CLR(r) (r).pgw_ctrl_0[0] = 0
#define PGW_CTRL_0r_SET(r,d) (r).pgw_ctrl_0[0] = d
#define PGW_CTRL_0r_GET(r) (r).pgw_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGW_CTRL_0r_SW_QTC_DISABLEf_GET(r) (((r).pgw_ctrl_0[0]) & 0x3)
#define PGW_CTRL_0r_SW_QTC_DISABLEf_SET(r,f) (r).pgw_ctrl_0[0]=(((r).pgw_ctrl_0[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define PGW_CTRL_0r_SW_PM4X10_DISABLEf_GET(r) ((((r).pgw_ctrl_0[0]) >> 2) & 0x3)
#define PGW_CTRL_0r_SW_PM4X10_DISABLEf_SET(r,f) (r).pgw_ctrl_0[0]=(((r).pgw_ctrl_0[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define PGW_CTRL_0r_RSVDf_GET(r) ((((r).pgw_ctrl_0[0]) >> 4) & 0xfffffff)
#define PGW_CTRL_0r_RSVDf_SET(r,f) (r).pgw_ctrl_0[0]=(((r).pgw_ctrl_0[0] & ~((uint32)0xfffffff << 4)) | ((((uint32)f) & 0xfffffff) << 4))

/*
 * These macros can be used to access PGW_CTRL_0.
 */
#define WRITE_PGW_CTRL_0r(u,r) bcm5354x_reg_set(u,R_PGW_CTRL_0,(r._pgw_ctrl_0))
#define READ_PGW_CTRL_0r(u,r) bcm5354x_reg_get(u,R_PGW_CTRL_0,&(r._pgw_ctrl_0))

/*******************************************************************************
 * End of 'PGW_CTRL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  PGW_GE0_MODE_REG
 * BLOCKS:   PGW_GE0 PGW_GE1 PGW_GE2
 * DESC:     GE0 PORT Mode Register
 * SIZE:     32
 * FIELDS:
 *     GP0_TDM_MODE     GPort GP0 bus TDM Mode.  Applies to one of PGW_GE0..7 depending on sbus block id.
 */
#define PGW_GE0_MODE_REGr_SIZE 4

/* PGW_GE0_MODE_REGr is element of PGW_GE_MODE_REG */

/*
 * This structure should be used to declare and program PGW_GE0_MODE_REG.
 */
typedef union PGW_GE0_MODE_REGr_s {
	uint32 v[1];
	uint32 pgw_ge0_mode_reg[1];
	uint32 _pgw_ge0_mode_reg;
} PGW_GE0_MODE_REGr_t;

#define PGW_GE0_MODE_REGr_CLR(r) (r).pgw_ge0_mode_reg[0] = 0
#define PGW_GE0_MODE_REGr_SET(r,d) (r).pgw_ge0_mode_reg[0] = d
#define PGW_GE0_MODE_REGr_GET(r) (r).pgw_ge0_mode_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGW_GE0_MODE_REGr_GP0_TDM_MODEf_GET(r) (((r).pgw_ge0_mode_reg[0]) & 0xf)
#define PGW_GE0_MODE_REGr_GP0_TDM_MODEf_SET(r,f) (r).pgw_ge0_mode_reg[0]=(((r).pgw_ge0_mode_reg[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))

/*
 * These macros can be used to access PGW_GE0_MODE_REG.
 */
#define WRITE_PGW_GE0_MODE_REGr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pgw_ge_lport_to_blockid[p], R_PGW_GE0_MODE_REG, (r._pgw_ge0_mode_reg))
#define READ_PGW_GE0_MODE_REGr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pgw_ge_lport_to_blockid[p], R_PGW_GE0_MODE_REG, &(r._pgw_ge0_mode_reg))

/*******************************************************************************
 * End of 'PGW_GE0_MODE_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  PGW_GE1_MODE_REG
 * BLOCKS:   PGW_GE0 PGW_GE1 PGW_GE2
 * DESC:     GE1 PORT Mode Register
 * SIZE:     32
 * FIELDS:
 *     GP0_TDM_MODE     GPort GP0 bus TDM Mode.  Applies to one of PGW_GE0..7 depending on sbus block id.
 */
#define PGW_GE1_MODE_REGr_SIZE 4

/* PGW_GE1_MODE_REGr is element of PGW_GE_MODE_REG */

/*
 * This structure should be used to declare and program PGW_GE1_MODE_REG.
 */
typedef union PGW_GE1_MODE_REGr_s {
	uint32 v[1];
	uint32 pgw_ge1_mode_reg[1];
	uint32 _pgw_ge1_mode_reg;
} PGW_GE1_MODE_REGr_t;

#define PGW_GE1_MODE_REGr_CLR(r) (r).pgw_ge1_mode_reg[0] = 0
#define PGW_GE1_MODE_REGr_SET(r,d) (r).pgw_ge1_mode_reg[0] = d
#define PGW_GE1_MODE_REGr_GET(r) (r).pgw_ge1_mode_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGW_GE1_MODE_REGr_GP0_TDM_MODEf_GET(r) (((r).pgw_ge1_mode_reg[0]) & 0xf)
#define PGW_GE1_MODE_REGr_GP0_TDM_MODEf_SET(r,f) (r).pgw_ge1_mode_reg[0]=(((r).pgw_ge1_mode_reg[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))

/*
 * These macros can be used to access PGW_GE1_MODE_REG.
 */
#define WRITE_PGW_GE1_MODE_REGr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pgw_ge_lport_to_blockid[p], R_PGW_GE1_MODE_REG, (r._pgw_ge1_mode_reg))
#define READ_PGW_GE1_MODE_REGr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pgw_ge_lport_to_blockid[p], R_PGW_GE1_MODE_REG, &(r._pgw_ge1_mode_reg))

/*******************************************************************************
 * End of 'PGW_GE1_MODE_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  PGW_GE_RXFIFO_SOFT_RESET
 * BLOCKS:   PGW_GE0 PGW_GE1 PGW_GE2
 * DESC:     PGW_GE RXFIFO Soft Reset per subport block.  Active high signal. 
 * SIZE:     32
 * FIELDS:
 *     PORT0            Reset Sub-Port 0.  QSGMII Mode/Ethernet Mod
 *     PORT1            Reset Sub-Port 1.  QSGMII Mode/Ethernet Mod
 *     PORT2            Reset Sub-Port 2.  QSGMII Mode/Ethernet Mod
 *     PORT3            Reset Sub-Port 3.  QSGMII Mode/Ethernet Mode
 *     PORT4            Reset Sub-Port 4.  QSGMII Mode only
 *     PORT5            Reset Sub-Port 5.  QSGMII Mode only
 *     PORT6            Reset Sub-Port 6.  QSGMII Mode only
 *     PORT7            Reset Sub-Port 7.  QSGMII Mode only
 *     PORT8            Reset Sub-Port 8.  QSGMII Mode only
 *     PORT9            Reset Sub-Port 9.  QSGMII Mode only
 *     PORT10           Reset Sub-Port 10.  QSGMII Mode only
 *     PORT11           Reset Sub-Port 11.  QSGMII Mode only
 *     PORT12           Reset Sub-Port 12.  QSGMII Mode only
 *     PORT13           Reset Sub-Port 13.  QSGMII Mode only
 *     PORT14           Reset Sub-Port 14.  QSGMII Mode only
 *     PORT15           Reset Sub-Port 15.  QSGMII Mode only
 */
#define PGW_GE_RXFIFO_SOFT_RESETr_SIZE 4

/*
 * This structure should be used to declare and program PGW_GE_RXFIFO_SOFT_RESET.
 */
typedef union PGW_GE_RXFIFO_SOFT_RESETr_s {
	uint32 v[1];
	uint32 pgw_ge_rxfifo_soft_reset[1];
	uint32 _pgw_ge_rxfifo_soft_reset;
} PGW_GE_RXFIFO_SOFT_RESETr_t;

#define PGW_GE_RXFIFO_SOFT_RESETr_CLR(r) (r).pgw_ge_rxfifo_soft_reset[0] = 0
#define PGW_GE_RXFIFO_SOFT_RESETr_SET(r,d) (r).pgw_ge_rxfifo_soft_reset[0] = d
#define PGW_GE_RXFIFO_SOFT_RESETr_GET(r) (r).pgw_ge_rxfifo_soft_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT0f_GET(r) (((r).pgw_ge_rxfifo_soft_reset[0]) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT0f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT1f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 1) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT1f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT2f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 2) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT2f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT3f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 3) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT3f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT4f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 4) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT4f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT5f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 5) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT5f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT6f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 6) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT6f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT7f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 7) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT7f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT8f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 8) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT8f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT9f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 9) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT9f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT10f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 10) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT10f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT11f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 11) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT11f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT12f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 12) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT12f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT13f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 13) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT13f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT14f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 14) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT14f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT15f_GET(r) ((((r).pgw_ge_rxfifo_soft_reset[0]) >> 15) & 0x1)
#define PGW_GE_RXFIFO_SOFT_RESETr_PORT15f_SET(r,f) (r).pgw_ge_rxfifo_soft_reset[0]=(((r).pgw_ge_rxfifo_soft_reset[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))

/*
 * These macros can be used to access PGW_GE_RXFIFO_SOFT_RESET.
 */
#define WRITE_PGW_GE_RXFIFO_SOFT_RESETr(u,p,r) bcm5354x_reg_set(u, bcm5354x_pgw_ge_lport_to_blockid[p], R_PGW_GE_RXFIFO_SOFT_RESET, (r._pgw_ge_rxfifo_soft_reset))
#define READ_PGW_GE_RXFIFO_SOFT_RESETr(u,p,r) bcm5354x_reg_get(u, bcm5354x_pgw_ge_lport_to_blockid[p], R_PGW_GE_RXFIFO_SOFT_RESET, &(r._pgw_ge_rxfifo_soft_reset))

/*******************************************************************************
 * End of 'PGW_GE_RXFIFO_SOFT_RESETr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  PG_CTRL0
 * BLOCKS:   MMU
 * DESC:     Priority group control register
 * SIZE:     32
 * FIELDS:
 *     PRI0_GRP         The register maps input priority 0 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI1_GRP         The register maps input priority 1 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI2_GRP         The register maps input priority 2 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI3_GRP         The register maps input priority 3 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI4_GRP         The register maps input priority 4 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI5_GRP         The register maps input priority 5 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI6_GRP         The register maps input priority 6 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI7_GRP         The register maps input priority 7 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PPFC_PG_EN       Each bit is for a Priority group.Bit 0: Priority Group 0....Bit 7: Priority Group 71: Enables the MMU to trigger corresponding Tx MACs to generate PFC frames for all priorities mapped to this PG0: MMU will not trigger corresponding Tx MACs to generate PFC/SAFC frames for any priority/TC mapped to this PG even if the cell utilization for this PG has exceeded the cell limit threshold
 */
#define PG_CTRL0r_SIZE 4

/*
 * This structure should be used to declare and program PG_CTRL0.
 */
typedef union PG_CTRL0r_s {
	uint32 v[1];
	uint32 pg_ctrl0[1];
	uint32 _pg_ctrl0;
} PG_CTRL0r_t;

#define PG_CTRL0r_CLR(r) (r).pg_ctrl0[0] = 0
#define PG_CTRL0r_SET(r,d) (r).pg_ctrl0[0] = d
#define PG_CTRL0r_GET(r) (r).pg_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define PG_CTRL0r_PRI0_GRPf_GET(r) (((r).pg_ctrl0[0]) & 0x7)
#define PG_CTRL0r_PRI0_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define PG_CTRL0r_PRI1_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 3) & 0x7)
#define PG_CTRL0r_PRI1_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define PG_CTRL0r_PRI2_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 6) & 0x7)
#define PG_CTRL0r_PRI2_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define PG_CTRL0r_PRI3_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 9) & 0x7)
#define PG_CTRL0r_PRI3_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define PG_CTRL0r_PRI4_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 12) & 0x7)
#define PG_CTRL0r_PRI4_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define PG_CTRL0r_PRI5_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 15) & 0x7)
#define PG_CTRL0r_PRI5_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define PG_CTRL0r_PRI6_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 18) & 0x7)
#define PG_CTRL0r_PRI6_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define PG_CTRL0r_PRI7_GRPf_GET(r) ((((r).pg_ctrl0[0]) >> 21) & 0x7)
#define PG_CTRL0r_PRI7_GRPf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0x7 << 21)) | ((((uint32)f) & 0x7) << 21))
#define PG_CTRL0r_PPFC_PG_ENf_GET(r) ((((r).pg_ctrl0[0]) >> 24) & 0xff)
#define PG_CTRL0r_PPFC_PG_ENf_SET(r,f) (r).pg_ctrl0[0]=(((r).pg_ctrl0[0] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))

/*
 * These macros can be used to access PG_CTRL0.
 */
#define WRITE_PG_CTRL0r(u,p,r) bcm5354x_reg_set(u,R_PG_CTRL0(p),(r._pg_ctrl0))
#define READ_PG_CTRL0r(u,p,r) bcm5354x_reg_get(u,R_PG_CTRL0(p),&(r._pg_ctrl0))

/*******************************************************************************
 * End of 'PG_CTRL0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  PG_CTRL1
 * BLOCKS:   MMU
 * DESC:     Priority group control register
 * SIZE:     32
 * FIELDS:
 *     PRI8_GRP         The register maps input priority 8 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI9_GRP         The register maps input priority 9 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI10_GRP        The register maps input priority 10 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI11_GRP        The register maps input priority 11 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI12_GRP        The register maps input priority 12 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI13_GRP        The register maps input priority 13 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI14_GRP        The register maps input priority 14 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 *     PRI15_GRP        The register maps input priority 15 to one of the Priority groups 0..7 to generate PFC or SAFC frames
 */
#define PG_CTRL1r_SIZE 4

/*
 * This structure should be used to declare and program PG_CTRL1.
 */
typedef union PG_CTRL1r_s {
	uint32 v[1];
	uint32 pg_ctrl1[1];
	uint32 _pg_ctrl1;
} PG_CTRL1r_t;

#define PG_CTRL1r_CLR(r) (r).pg_ctrl1[0] = 0
#define PG_CTRL1r_SET(r,d) (r).pg_ctrl1[0] = d
#define PG_CTRL1r_GET(r) (r).pg_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define PG_CTRL1r_PRI8_GRPf_GET(r) (((r).pg_ctrl1[0]) & 0x7)
#define PG_CTRL1r_PRI8_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define PG_CTRL1r_PRI9_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 3) & 0x7)
#define PG_CTRL1r_PRI9_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 3)) | ((((uint32)f) & 0x7) << 3))
#define PG_CTRL1r_PRI10_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 6) & 0x7)
#define PG_CTRL1r_PRI10_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 6)) | ((((uint32)f) & 0x7) << 6))
#define PG_CTRL1r_PRI11_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 9) & 0x7)
#define PG_CTRL1r_PRI11_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 9)) | ((((uint32)f) & 0x7) << 9))
#define PG_CTRL1r_PRI12_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 12) & 0x7)
#define PG_CTRL1r_PRI12_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define PG_CTRL1r_PRI13_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 15) & 0x7)
#define PG_CTRL1r_PRI13_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define PG_CTRL1r_PRI14_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 18) & 0x7)
#define PG_CTRL1r_PRI14_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 18)) | ((((uint32)f) & 0x7) << 18))
#define PG_CTRL1r_PRI15_GRPf_GET(r) ((((r).pg_ctrl1[0]) >> 21) & 0x7)
#define PG_CTRL1r_PRI15_GRPf_SET(r,f) (r).pg_ctrl1[0]=(((r).pg_ctrl1[0] & ~((uint32)0x7 << 21)) | ((((uint32)f) & 0x7) << 21))

/*
 * These macros can be used to access PG_CTRL1.
 */
#define WRITE_PG_CTRL1r(u,p,r) bcm5354x_reg_set(u,R_PG_CTRL1(p),(r._pg_ctrl1))
#define READ_PG_CTRL1r(u,p,r) bcm5354x_reg_get(u,R_PG_CTRL1(p),&(r._pg_ctrl1))

/*******************************************************************************
 * End of 'PG_CTRL1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  PORT
 * BLOCKS:   IPIPE
 * DESC:     Port Configuration Table.
This table is used to control basic switching logic on a per port basis. The port number corresponds to the index.
Note: MY_MODID for HiGig ports must be defined in IPORT_TABLE.MY_MODID.
 * SIZE:     384
 * FIELDS:
 *     DATA_0           Physical memory data field #0
 *     FILTER_ENABLE    Enable Filtering
 *     VT_MISS_DROP     VLAN translation miss drop
 *     VT_ENABLE        VLAN translation enable
 *     TRUST_DSCP_V4    Ingress port is trusted port, trust incoming IPv4 DSCP
 *     TRUST_DSCP_V6    Ingress port is trusted port, trust incoming IPv6 DSCP
 *     EN_IFILTER       Enable ingress filtering
 *     MIRROR           Mirror enable (same as MIRROR0) 
 *     MIRROR0          Mirror 0 enable
 *     PORT_PRI         Port default priority, when using default PORT VLAN_ID
 *     IPMC_DO_VLAN     If set, include the VLAN ID as part of the IPMC search key in the L3_ENTRY table when doing the {S,V,G} lookups, else the VID will be zero for those lookups.
 *     V6IPMC_ENABLE    IPv6 IPMC enable
 *     V4IPMC_ENABLE    IPv4 IPMC enable
 *     V6IPMC_L2_ENABLE Enables L2-only forwarding of IPMCv6 packets on this port based on (SGV,*GV) lookups.
 *     V4IPMC_L2_ENABLE Enables L2-only forwarding of IPMCv4 packets on this port based on (SGV,*GV) lookups.
 *     V6L3_ENABLE      IPv6 L3 enable
 *     V4L3_ENABLE      IPv4 L3 enable
 *     DROP_BPDU        when set, ingress drops BPDUs
 *     PORT_DIS_TAG     Drop all tagged packets
 *     PORT_DIS_UNTAG   Drop all untagged packets
 *     PASS_CONTROL_FRAMES Pass pause frames through without dropping
 *     SUBNET_BASED_VID_ENABLE Enable subnet-based VLANs
 *     MAC_BASED_VID_ENABLE Enable MAC-based VLANs
 *     OVID             Internal outer VLAN ID
 *     PORT_VID         Port VLAN
 *     PORT_TYPE        Port can be Ethernet, HiGig port, MIM loopback port or Embeded HiGig port
 *     DUAL_MODID_ENABLE Enable dual modid mode where this chip looks like two MODIDs to rest of system. Incoming higig packets using (MY_MODID+1)/Port_ID are mapped to MY_MODID/(Port_ID+32) for internal processing. Note that when set, MY_MODID must be even (ends in 0). When not set, all ports belong to single MY_MODID.
 *     MAP_TAG_PKT_PRIORITY Map the incoming packet priority
 *     MY_MODID         Stacking module ID for this module. Valid values are from 0 - 256.
 *     PORT_BRIDGE      Allows L2 bridging to the incoming port
 *     IGNORE_IPMC_L2_BITMAP Set this bit to disable L2 switching of IPMC pkts on this port.
 *     IGNORE_IPMC_L3_BITMAP Set this bit to disable L3 routing of IPMC pkts on this port.
 *     HIGIG_TRUNK      Set this bit if the port is a member if a higig trunkIf set, then HIGIG_PACKET must also be set.
 *     HIGIG_TRUNK_ID   If HIGIG_TRUNK=1, then this is the trunk ID
 *     RESERVED_53      Reserved
 *     VLAN_PRECEDENCE  Determine the priorities for selecting VLAN (MAC-based, subnet-based VLANs). If set, subnet-based VLAN assignment has higher priority than MAC-based vlan assignment.
 *     RESERVED_0       Reserved.
 *     HIGIG2           If HIGIG_PACKET=1, then this bit indicates if the port is in HiGig2 mode (if HIGIG2=1) or in HiGig mode (if HIGIG2=0)
 *     ALLOW_SRC_MOD    When set, packets whose source modid is equal to my_modid are not dropped
 *     TRUST_OUTER_DOT1P If this bit is set, outer 802.1p bits will be used to derive (int_pri,CNG) in the ING_PRI_CNG_MAP table 
 *     REMOVE_HG_HDR_SRC_PORT If set to 1, do not forward the pkt to the non-trunk (i.e., not LAG) source port in module header when the MH.SRC_MODID is same as ING_CONFIG.MY_MODID. NOTE: If module header's source port is a trunk (LAG) port, the pkts are not forwarded to its LAG members irrespective of this control bit
 *     FP_PORT_SELECT_TYPE Controls whether PORT_FIELD_SEL_INDEX1 or PORT_FIELD_SEL_INDEX0 is selected as the input into the FP_PORT_FIELD_SELECT table
 *     VFP_ENABLE       VFP ENABLE.
 *     VFP_PORT_GROUP_ID VFP PORT GROUP ID.
 *     URPF_MODE        RESERVED.
 *     URPF_DEFAULTROUTECHECK RESERVED.
 *     CFI_AS_CNG       Indicates for ING_OUTER_TPID[3] to ING_OUTER_TPID[0] if the CFI bit in the packet indicates CNG
 *     USE_INNER_PRI    If set, use the packet's inner priority.
 *     ECCP_0           Memory_0 ECC + Parity bits.
 *     ECC_0            Memory_0 ECC bits for 1-bit error correction.
 *     PARITY_0         Memory_0 Parity bit for 2-bit error detection.
 *     DATA_1           Physical memory data field #1
 *     OUTER_TPID_ENABLE Indicates if ING_OUTER_TPID[3] to ING_OUTER_TPID[0] are allowed outer TPID values.
 *     OUTER_TPID_VERIFY If set, indicates to verify the packet's outer TPID matches the VLAN tables TPID value
 *     USE_INCOMING_DOT1P If set, preserve incoming 802.1p priority in the packet
 *     PVLAN_ENABLE     If set, enable private VLAN on this port
 *     TAG_ACTION_PROFILE_PTR Ingress VLAN tag action profile pointer, used as the index into the tING_VLAN_TAG_ACTION_PROFILE table.
 *     RESERVED_108     Reserved.
 *     IVID             Internal inner VLAN ID
 *     TRUST_INCOMING_VID If set, trust incoming outer and inner VLAN tags.  NOTE: If VT_ENABLE is set, the incoming outer and inner VLAN tags are trusted regardless of the setting of this bit.
 *     VT_KEY_TYPE      Indicates the key type for the first lookup to the ingress VLAN translation table -- see encodings in VLAN_XLATE
 *     VT_KEY_TYPE_USE_GLP If set then the GLP (T,MODID,PORT) is included as part of the VLAN_XLATE Key, else the GLP is set to all one's to be port-independant.
 *     VT_KEY_TYPE_2    Indicates the key type for the first lookup to the ingress VLAN translation table -- see encodings in VLAN_XLATE
 *     VT_KEY_TYPE_2_USE_GLP If set then the GLP (T,MODID,PORT) is included as part of the VLAN_XLATE Key for the second key lookup, else the GLP is set to all one's to be port-independant.
 *     CML_FLAGS_NEW    CPU managed learning control for new entries		    What to do when a L2 miss occurs:		    bit[0] = Drop the packet		    bit[1] = Copy to CPU		    bit[2] = Set the Pending bit on HW Learn		    bit[3] = Do HW Learn
 *     CML_FLAGS_MOVE   CPU managed learning control for station moves		    What to do when a L2 station move is detected:		    bit[0] = Drop the packet		    bit[1] = Copy to CPU		    bit[2] = Set the Pending bit on HW Station Move		    bit[3] = Do HW Station Move
 *     PRI_MAPPING      3-bits for each of 8 Pkt Priority values		    [2:0]   = lookup_pri for pkt_pri=0		    [5:3]   = lookup_pri for pkt_pri=1		    [8:6]   = lookup_pri for pkt_pri=2		    [11:9]  = lookup_pri for pkt_pri=3		    [14:12] = lookup_pri for pkt_pri=4		    [17:15] = lookup_pri for pkt_pri=5		    [20:18] = lookup_pri for pkt_pri=6		    [23:21] = lookup_pri for pkt_pri=7
 *     CFI_0_MAPPING    Mapped value When CFI==0 for VXLT keys
 *     CFI_1_MAPPING    Mapped value When CFI==0 for VXLT keys
 *     PORT_OPERATION   Default Port Operation		                             0 = normal operation		                             1 = Reserved		                             2 = Reserved		                             3 = Reserved                                 4 = normal operation but use per-port VLAN
 *     MAC_IP_BIND_LOOKUP_MISS_DROP enable drop due to HPAE: source IP binding with SA_MAC and Src Port checking failure.
 *     REMOTE_CPU_EN    Enables remote cpu packet parsing
 *     DISABLE_STATIC_MOVE_DROP When set, this bit allows packets to be forwarded even if the MACSA has moved and is marked as static in the L2 table
 *     USE_IVID_AS_OVID When set, use the inner VID as the learning and forwarding VID. Note that VXLT and VFP hits will override this setting.
 *     MH_INGRESS_TAGGED_SEL Controls how to interpret the INGRESS_TAGGED bit in the module header
 *     CLASS_BASED_SM_ENABLE Enable class based station movement checks
 *     RESERVED_1       Reserved.
 *     ECCP_1           Memory_1 ECC + Parity bits.
 *     ECC_1            Memory_1 ECC bits for 1-bit error correction.
 *     PARITY_1         Memory_1 Parity bit for 2-bit error detection.
 *     DATA_2           Physical memory data field #2
 *     RESERVED_2       Reserved.
 *     TRUST_DOT1P_PTR  Profile pointer into the ING_PRI_CNG_MAP table. Valid values are 0 to 62.
 *     IEEE_802_1AS_ENABLE If this bit is set, then any IEEE 802.1AS packet that matches in the IEEE 802.1AS Control Register is trapped to the CPU
 *     USE_PORT_TABLE_GROUP_ID 0== Use port_group_id from SOURCE_TRUNK_MAP table for VFP key.  1== Use port_group_id from LPORT table for VFP key
 *     VLAN_PROTOCOL_DATA_INDEX Index to the 16 entry block into VLAN_PROTOCOL_DATA table.
 *     OAM_ENABLE       Per Port OAM enable for parsing
 *     PROTOCOL_PKT_INDEX Protocol pkt index.
 *     MDL_BITMAP       MDL Bitmap used by a DOWN MEP.
 *     CTRL_PROFILE_INDEX_1588 Index to ING_1588_INGRESS_CTRL table for per 1588 message type actions
 *     INNER_TPID_ENABLE If set to 1, enable the inner TPID
 *     NIV_UPLINK_PORT  If set, this ingress port is an uplink port. This field is used for checking the validity and format of incoming VNTAG/ETAG's.
 *     NIV_VIF_ID       This port's NIV/PE - Virtual Interface (VIF) identifier. If this ports is a downlink Access-IV/PE, this configuration field shall be used to set src_vif of the ingress port-based VNTAG/ETAG added in the packet.
 *     NIV_NAMESPACE    The NIV/PE-namespace associated with this ingress port. If this port is a downlink port, this field typically takes a compressed GLP value of it's associated NIV/PE uplink port. If this port is an uplink port, it takes a compressed value of it's own GLP. This field is used for forwarding lookups in the VIF table when this ingress port is an uplink port. This field is used for RPF lookups when this ingress port is a downlink port.
 *     PROHIBITED_DOT1P The 802.1p priorities prohibited from ingressing on this port. If set to 1, corresponding dot1p priorities are not allowed to ingress if packet is VLAN tagged or Priority tagged.
 *     NIV_RPF_CHECK_ENABLE If set, all VNTAG/ETAG'ed packets ingressing at this port are checked for Reverse Path Forwarding (RPF). Drop the packet if this check fails.
 *     NIV_VIF_LOOKUP_ENABLE If set, L2_ENTRY table lookup is an NIV/PE based lookup using the VIF key type. This is set for IV/PE uplink ports.
 *     USE_MIML_PCP_FOR_PRI Use MIML_PCP and MIML_CFI to derive INT_PRI and CNG.
 *     MIML_ENABLE      Enable MIML feature.
 *     USE_CUSTOM_HEADER_FOR_PRI Use CUSTOME_HEADER to derive INT_PRI and CNG.
 *     CUSTOM_HEADER_ENABLE Enable CUSTOME_HEADER feature.
 *     MIML_DOT1P_MAPPING_PTR Used to pick a mapping profile when USE_MIML_PCP_FOR_PRI is set.
 *     ECCP_2           Memory_2 ECC + Parity bits.
 *     ECC_2            Memory_2 ECC bits for 1-bit error correction.
 *     PARITY_2         Memory_2 Parity bit for 2-bit error detection.
 *     DATA_3           Physical memory data field #3
 *     TX_DEST_PORT     Destination Global Logical Port (DGLP) associated with this ingress port. When TX_DEST_PORT_ENABLE is set, all ingress traffic shall be sent to the DGLP configured. {Trunk, Modid(7,0), Port(5,0)}
 *     RESERVED_303     Reserved.
 *     TX_DEST_PORT_ENABLE If set, all the ingress packets are sent to the TX_DEST_PORT configured for this ingress port. This mode is to support the packet forwarding requirement of an upstream IV/PE.
 *     VNTAG_ACTIONS_IF_NOT_PRESENT VNATG/ETAG actions if not present.
 *     VNTAG_ACTIONS_IF_PRESENT VNTAG/ETAG actions if present.
 *     DISCARD_IF_VNTAG_PRESENT Drop the ingress packet if it contains a VNTAG/ETAG. Ingress packets that contain VNTAG are typically dropped by Access-IV's in the upstream direction.
 *     DISCARD_IF_VNTAG_NOT_PRESENT Drop the ingress packet if it does not contain a VNTAG/ETAG. Ingress packets that don't contain VNTAG/ETAG are dropped by Transit-IV's in the upstream direction and all IV's in the downstream direction.
 *     ETAG_PCP_DE_MAPPING_PTR Profile used to derive ETAG's {PCP,DE} from incoming outer/inner VLAN tag's {pri,cfi} by indexing the ING_ETAG_PCP_MAPPING table.
 *     PHB_FROM_ETAG    int_pri and cng are derived from ETAG.PCP and ETAG.DE based on PORT__TRUST_DOT1P_PTR.
 *     ETAG_DOT1P_MAPPING_PTR ETAG dot1p mapping ptr
 *     ETAG_DE          When an Ingress Port based ETAG is added DE field is populated from this value.
 *     ETAG_PCP         When an Ingress Port based ETAG is added PCP field is populated from this value.
 *     RESERVED_322     Reserved.
 *     ETAG_PCP_DE_SOURCE Specifies the Source of PCP and DE fields when an Ingress Port based ETAG is added to the packet.
 *     IPMCV4_UNICAST_MACDA_ENABLE Enable Routing IPMCV4 packet with unicast MACDA.
 *     IPMCV6_UNICAST_MACDA_ENABLE Enable Routing IPMCV6 packet with unicast MACDA.
 *     RESERVED_4       Reserved.
 *     ECCP_3           Memory_3 ECC + Parity bits.
 *     ECC_3            Memory_3 ECC bits for 1-bit error correction.
 *     PARITY_3         Memory_3 Parity bit for 2-bit error detection.
 */
#define PORTm_MIN 0
#define PORTm_MAX 31
#define PORTm_CMAX(u) 31
#define PORTm_SIZE 48

/*
 * This structure should be used to declare and program PORT.
 */
typedef union PORTm_s {
	uint32 v[12];
	uint32 port[12];
	uint32 _port;
} PORTm_t;

#define PORTm_CLR(r) sal_memset(&((r)._port), 0, sizeof(PORTm_t))
#define PORTm_SET(r,i,d) (r).port[i] = d
#define PORTm_GET(r,i) (r).port[i]

/*
 * These macros can be used to access individual fields.
 */
#define PORTm_DATA_0f_GET(r,a) field_get((r).port,0,87,a)
#define PORTm_DATA_0f_SET(r,a) field_set((r).port,0,87,a)
#define PORTm_FILTER_ENABLEf_GET(r) (((r).port[0]) & 0x1)
#define PORTm_FILTER_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define PORTm_VT_MISS_DROPf_GET(r) ((((r).port[0]) >> 1) & 0x1)
#define PORTm_VT_MISS_DROPf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define PORTm_VT_ENABLEf_GET(r) ((((r).port[0]) >> 2) & 0x1)
#define PORTm_VT_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define PORTm_TRUST_DSCP_V4f_GET(r) ((((r).port[0]) >> 3) & 0x1)
#define PORTm_TRUST_DSCP_V4f_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define PORTm_TRUST_DSCP_V6f_GET(r) ((((r).port[0]) >> 4) & 0x1)
#define PORTm_TRUST_DSCP_V6f_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define PORTm_EN_IFILTERf_GET(r) ((((r).port[0]) >> 5) & 0x1)
#define PORTm_EN_IFILTERf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PORTm_MIRRORf_GET(r) ((((r).port[0]) >> 6) & 0x1)
#define PORTm_MIRRORf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PORTm_MIRROR0f_GET(r) ((((r).port[0]) >> 6) & 0x1)
#define PORTm_MIRROR0f_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PORTm_PORT_PRIf_GET(r) ((((r).port[0]) >> 8) & 0x7)
#define PORTm_PORT_PRIf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x7 << 8)) | ((((uint32)f) & 0x7) << 8))
#define PORTm_IPMC_DO_VLANf_GET(r) ((((r).port[0]) >> 11) & 0x1)
#define PORTm_IPMC_DO_VLANf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define PORTm_V6IPMC_ENABLEf_GET(r) ((((r).port[0]) >> 12) & 0x1)
#define PORTm_V6IPMC_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define PORTm_V4IPMC_ENABLEf_GET(r) ((((r).port[0]) >> 13) & 0x1)
#define PORTm_V4IPMC_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define PORTm_V6IPMC_L2_ENABLEf_GET(r) ((((r).port[0]) >> 14) & 0x1)
#define PORTm_V6IPMC_L2_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define PORTm_V4IPMC_L2_ENABLEf_GET(r) ((((r).port[0]) >> 15) & 0x1)
#define PORTm_V4IPMC_L2_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define PORTm_V6L3_ENABLEf_GET(r) ((((r).port[0]) >> 16) & 0x1)
#define PORTm_V6L3_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define PORTm_V4L3_ENABLEf_GET(r) ((((r).port[0]) >> 17) & 0x1)
#define PORTm_V4L3_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define PORTm_DROP_BPDUf_GET(r) ((((r).port[0]) >> 18) & 0x1)
#define PORTm_DROP_BPDUf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define PORTm_PORT_DIS_TAGf_GET(r) ((((r).port[0]) >> 19) & 0x1)
#define PORTm_PORT_DIS_TAGf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define PORTm_PORT_DIS_UNTAGf_GET(r) ((((r).port[0]) >> 20) & 0x1)
#define PORTm_PORT_DIS_UNTAGf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define PORTm_PASS_CONTROL_FRAMESf_GET(r) ((((r).port[0]) >> 21) & 0x1)
#define PORTm_PASS_CONTROL_FRAMESf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define PORTm_SUBNET_BASED_VID_ENABLEf_GET(r) ((((r).port[0]) >> 22) & 0x1)
#define PORTm_SUBNET_BASED_VID_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define PORTm_MAC_BASED_VID_ENABLEf_GET(r) ((((r).port[0]) >> 23) & 0x1)
#define PORTm_MAC_BASED_VID_ENABLEf_SET(r,f) (r).port[0]=(((r).port[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define PORTm_OVIDf_GET(r) field32_get((r).port,24,35)
#define PORTm_OVIDf_SET(r,f) field32_set((r).port,24,35,f)
#define PORTm_PORT_VIDf_GET(r) field32_get((r).port,24,35)
#define PORTm_PORT_VIDf_SET(r,f) field32_set((r).port,24,35,f)
#define PORTm_PORT_TYPEf_GET(r) ((((r).port[1]) >> 4) & 0x3)
#define PORTm_PORT_TYPEf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define PORTm_DUAL_MODID_ENABLEf_GET(r) ((((r).port[1]) >> 6) & 0x1)
#define PORTm_DUAL_MODID_ENABLEf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PORTm_MAP_TAG_PKT_PRIORITYf_GET(r) ((((r).port[1]) >> 7) & 0x1)
#define PORTm_MAP_TAG_PKT_PRIORITYf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define PORTm_MY_MODIDf_GET(r) ((((r).port[1]) >> 8) & 0xff)
#define PORTm_MY_MODIDf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define PORTm_PORT_BRIDGEf_GET(r) ((((r).port[1]) >> 16) & 0x1)
#define PORTm_PORT_BRIDGEf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define PORTm_IGNORE_IPMC_L2_BITMAPf_GET(r) ((((r).port[1]) >> 17) & 0x1)
#define PORTm_IGNORE_IPMC_L2_BITMAPf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define PORTm_IGNORE_IPMC_L3_BITMAPf_GET(r) ((((r).port[1]) >> 18) & 0x1)
#define PORTm_IGNORE_IPMC_L3_BITMAPf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define PORTm_HIGIG_TRUNKf_GET(r) ((((r).port[1]) >> 19) & 0x1)
#define PORTm_HIGIG_TRUNKf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define PORTm_HIGIG_TRUNK_IDf_GET(r) ((((r).port[1]) >> 20) & 0x1)
#define PORTm_HIGIG_TRUNK_IDf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define PORTm_RESERVED_53f_GET(r) ((((r).port[1]) >> 21) & 0x7)
#define PORTm_RESERVED_53f_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x7 << 21)) | ((((uint32)f) & 0x7) << 21))
#define PORTm_VLAN_PRECEDENCEf_GET(r) ((((r).port[1]) >> 24) & 0x1)
#define PORTm_VLAN_PRECEDENCEf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define PORTm_RESERVED_0f_GET(r) ((((r).port[1]) >> 25) & 0x1)
#define PORTm_RESERVED_0f_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define PORTm_HIGIG2f_GET(r) ((((r).port[1]) >> 26) & 0x1)
#define PORTm_HIGIG2f_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define PORTm_ALLOW_SRC_MODf_GET(r) ((((r).port[1]) >> 27) & 0x1)
#define PORTm_ALLOW_SRC_MODf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define PORTm_TRUST_OUTER_DOT1Pf_GET(r) ((((r).port[1]) >> 28) & 0x1)
#define PORTm_TRUST_OUTER_DOT1Pf_SET(r,f) (r).port[1]=(((r).port[1] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define PORTm_REMOVE_HG_HDR_SRC_PORTf_GET(r) ((((r).port[2]) >> 5) & 0x1)
#define PORTm_REMOVE_HG_HDR_SRC_PORTf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PORTm_FP_PORT_SELECT_TYPEf_GET(r) ((((r).port[2]) >> 6) & 0x1)
#define PORTm_FP_PORT_SELECT_TYPEf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PORTm_VFP_ENABLEf_GET(r) ((((r).port[2]) >> 7) & 0x1)
#define PORTm_VFP_ENABLEf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define PORTm_VFP_PORT_GROUP_IDf_GET(r) ((((r).port[2]) >> 8) & 0xff)
#define PORTm_VFP_PORT_GROUP_IDf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define PORTm_URPF_MODEf_GET(r) ((((r).port[2]) >> 16) & 0x3)
#define PORTm_URPF_MODEf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define PORTm_URPF_DEFAULTROUTECHECKf_GET(r) ((((r).port[2]) >> 18) & 0x1)
#define PORTm_URPF_DEFAULTROUTECHECKf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define PORTm_CFI_AS_CNGf_GET(r) ((((r).port[2]) >> 19) & 0xf)
#define PORTm_CFI_AS_CNGf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0xf << 19)) | ((((uint32)f) & 0xf) << 19))
#define PORTm_USE_INNER_PRIf_GET(r) ((((r).port[2]) >> 23) & 0x1)
#define PORTm_USE_INNER_PRIf_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define PORTm_ECCP_0f_GET(r) ((((r).port[2]) >> 24) & 0xff)
#define PORTm_ECCP_0f_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define PORTm_ECC_0f_GET(r) ((((r).port[2]) >> 24) & 0x7f)
#define PORTm_ECC_0f_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x7f << 24)) | ((((uint32)f) & 0x7f) << 24))
#define PORTm_PARITY_0f_GET(r) ((((r).port[2]) >> 31) & 0x1)
#define PORTm_PARITY_0f_SET(r,f) (r).port[2]=(((r).port[2] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define PORTm_DATA_1f_GET(r,a) field_get((r).port,96,183,a)
#define PORTm_DATA_1f_SET(r,a) field_set((r).port,96,183,a)
#define PORTm_OUTER_TPID_ENABLEf_GET(r) (((r).port[3]) & 0xf)
#define PORTm_OUTER_TPID_ENABLEf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define PORTm_OUTER_TPID_VERIFYf_GET(r) ((((r).port[3]) >> 4) & 0x1)
#define PORTm_OUTER_TPID_VERIFYf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define PORTm_USE_INCOMING_DOT1Pf_GET(r) ((((r).port[3]) >> 5) & 0x1)
#define PORTm_USE_INCOMING_DOT1Pf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PORTm_PVLAN_ENABLEf_GET(r) ((((r).port[3]) >> 6) & 0x1)
#define PORTm_PVLAN_ENABLEf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PORTm_TAG_ACTION_PROFILE_PTRf_GET(r) ((((r).port[3]) >> 7) & 0x1f)
#define PORTm_TAG_ACTION_PROFILE_PTRf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x1f << 7)) | ((((uint32)f) & 0x1f) << 7))
#define PORTm_RESERVED_108f_GET(r) ((((r).port[3]) >> 12) & 0x1)
#define PORTm_RESERVED_108f_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define PORTm_IVIDf_GET(r) ((((r).port[3]) >> 13) & 0xfff)
#define PORTm_IVIDf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0xfff << 13)) | ((((uint32)f) & 0xfff) << 13))
#define PORTm_TRUST_INCOMING_VIDf_GET(r) ((((r).port[3]) >> 25) & 0x1)
#define PORTm_TRUST_INCOMING_VIDf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define PORTm_VT_KEY_TYPEf_GET(r) ((((r).port[3]) >> 26) & 0xf)
#define PORTm_VT_KEY_TYPEf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0xf << 26)) | ((((uint32)f) & 0xf) << 26))
#define PORTm_VT_KEY_TYPE_USE_GLPf_GET(r) ((((r).port[3]) >> 30) & 0x1)
#define PORTm_VT_KEY_TYPE_USE_GLPf_SET(r,f) (r).port[3]=(((r).port[3] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define PORTm_VT_KEY_TYPE_2f_GET(r) field32_get((r).port,127,130)
#define PORTm_VT_KEY_TYPE_2f_SET(r,f) field32_set((r).port,127,130,f)
#define PORTm_VT_KEY_TYPE_2_USE_GLPf_GET(r) ((((r).port[4]) >> 3) & 0x1)
#define PORTm_VT_KEY_TYPE_2_USE_GLPf_SET(r,f) (r).port[4]=(((r).port[4] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define PORTm_CML_FLAGS_NEWf_GET(r) ((((r).port[4]) >> 4) & 0xf)
#define PORTm_CML_FLAGS_NEWf_SET(r,f) (r).port[4]=(((r).port[4] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define PORTm_CML_FLAGS_MOVEf_GET(r) ((((r).port[4]) >> 8) & 0xf)
#define PORTm_CML_FLAGS_MOVEf_SET(r,f) (r).port[4]=(((r).port[4] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define PORTm_PRI_MAPPINGf_GET(r) field32_get((r).port,140,163)
#define PORTm_PRI_MAPPINGf_SET(r,f) field32_set((r).port,140,163,f)
#define PORTm_CFI_0_MAPPINGf_GET(r) ((((r).port[5]) >> 4) & 0x1)
#define PORTm_CFI_0_MAPPINGf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define PORTm_CFI_1_MAPPINGf_GET(r) ((((r).port[5]) >> 5) & 0x1)
#define PORTm_CFI_1_MAPPINGf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PORTm_PORT_OPERATIONf_GET(r) ((((r).port[5]) >> 7) & 0x7)
#define PORTm_PORT_OPERATIONf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x7 << 7)) | ((((uint32)f) & 0x7) << 7))
#define PORTm_MAC_IP_BIND_LOOKUP_MISS_DROPf_GET(r) ((((r).port[5]) >> 10) & 0x1)
#define PORTm_MAC_IP_BIND_LOOKUP_MISS_DROPf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define PORTm_REMOTE_CPU_ENf_GET(r) ((((r).port[5]) >> 11) & 0x1)
#define PORTm_REMOTE_CPU_ENf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define PORTm_DISABLE_STATIC_MOVE_DROPf_GET(r) ((((r).port[5]) >> 12) & 0x1)
#define PORTm_DISABLE_STATIC_MOVE_DROPf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define PORTm_USE_IVID_AS_OVIDf_GET(r) ((((r).port[5]) >> 13) & 0x1)
#define PORTm_USE_IVID_AS_OVIDf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define PORTm_MH_INGRESS_TAGGED_SELf_GET(r) ((((r).port[5]) >> 20) & 0x1)
#define PORTm_MH_INGRESS_TAGGED_SELf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define PORTm_CLASS_BASED_SM_ENABLEf_GET(r) ((((r).port[5]) >> 21) & 0x1)
#define PORTm_CLASS_BASED_SM_ENABLEf_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define PORTm_RESERVED_1f_GET(r) ((((r).port[5]) >> 22) & 0x3)
#define PORTm_RESERVED_1f_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define PORTm_ECCP_1f_GET(r) ((((r).port[5]) >> 24) & 0xff)
#define PORTm_ECCP_1f_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define PORTm_ECC_1f_GET(r) ((((r).port[5]) >> 24) & 0x7f)
#define PORTm_ECC_1f_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x7f << 24)) | ((((uint32)f) & 0x7f) << 24))
#define PORTm_PARITY_1f_GET(r) ((((r).port[5]) >> 31) & 0x1)
#define PORTm_PARITY_1f_SET(r,f) (r).port[5]=(((r).port[5] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define PORTm_DATA_2f_GET(r,a) field_get((r).port,192,279,a)
#define PORTm_DATA_2f_SET(r,a) field_set((r).port,192,279,a)
#define PORTm_RESERVED_2f_GET(r) (((r).port[6]) & 0x3)
#define PORTm_RESERVED_2f_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define PORTm_TRUST_DOT1P_PTRf_GET(r) ((((r).port[6]) >> 2) & 0x3f)
#define PORTm_TRUST_DOT1P_PTRf_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x3f << 2)) | ((((uint32)f) & 0x3f) << 2))
#define PORTm_IEEE_802_1AS_ENABLEf_GET(r) ((((r).port[6]) >> 8) & 0x1)
#define PORTm_IEEE_802_1AS_ENABLEf_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define PORTm_USE_PORT_TABLE_GROUP_IDf_GET(r) ((((r).port[6]) >> 9) & 0x1)
#define PORTm_USE_PORT_TABLE_GROUP_IDf_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define PORTm_VLAN_PROTOCOL_DATA_INDEXf_GET(r) ((((r).port[6]) >> 17) & 0x1f)
#define PORTm_VLAN_PROTOCOL_DATA_INDEXf_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x1f << 17)) | ((((uint32)f) & 0x1f) << 17))
#define PORTm_OAM_ENABLEf_GET(r) ((((r).port[6]) >> 22) & 0x1)
#define PORTm_OAM_ENABLEf_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define PORTm_PROTOCOL_PKT_INDEXf_GET(r) ((((r).port[6]) >> 23) & 0x1f)
#define PORTm_PROTOCOL_PKT_INDEXf_SET(r,f) (r).port[6]=(((r).port[6] & ~((uint32)0x1f << 23)) | ((((uint32)f) & 0x1f) << 23))
#define PORTm_MDL_BITMAPf_GET(r) field32_get((r).port,220,227)
#define PORTm_MDL_BITMAPf_SET(r,f) field32_set((r).port,220,227,f)
#define PORTm_CTRL_PROFILE_INDEX_1588f_GET(r) ((((r).port[7]) >> 4) & 0x3f)
#define PORTm_CTRL_PROFILE_INDEX_1588f_SET(r,f) (r).port[7]=(((r).port[7] & ~((uint32)0x3f << 4)) | ((((uint32)f) & 0x3f) << 4))
#define PORTm_INNER_TPID_ENABLEf_GET(r) ((((r).port[7]) >> 10) & 0x1)
#define PORTm_INNER_TPID_ENABLEf_SET(r,f) (r).port[7]=(((r).port[7] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define PORTm_NIV_UPLINK_PORTf_GET(r) ((((r).port[7]) >> 11) & 0x1)
#define PORTm_NIV_UPLINK_PORTf_SET(r,f) (r).port[7]=(((r).port[7] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define PORTm_NIV_VIF_IDf_GET(r) ((((r).port[7]) >> 12) & 0xfff)
#define PORTm_NIV_VIF_IDf_SET(r,f) (r).port[7]=(((r).port[7] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))
#define PORTm_NIV_NAMESPACEf_GET(r) field32_get((r).port,248,259)
#define PORTm_NIV_NAMESPACEf_SET(r,f) field32_set((r).port,248,259,f)
#define PORTm_PROHIBITED_DOT1Pf_GET(r) ((((r).port[8]) >> 4) & 0xff)
#define PORTm_PROHIBITED_DOT1Pf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0xff << 4)) | ((((uint32)f) & 0xff) << 4))
#define PORTm_NIV_RPF_CHECK_ENABLEf_GET(r) ((((r).port[8]) >> 12) & 0x1)
#define PORTm_NIV_RPF_CHECK_ENABLEf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define PORTm_NIV_VIF_LOOKUP_ENABLEf_GET(r) ((((r).port[8]) >> 13) & 0x1)
#define PORTm_NIV_VIF_LOOKUP_ENABLEf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define PORTm_USE_MIML_PCP_FOR_PRIf_GET(r) ((((r).port[8]) >> 14) & 0x1)
#define PORTm_USE_MIML_PCP_FOR_PRIf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define PORTm_MIML_ENABLEf_GET(r) ((((r).port[8]) >> 15) & 0x1)
#define PORTm_MIML_ENABLEf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define PORTm_USE_CUSTOM_HEADER_FOR_PRIf_GET(r) ((((r).port[8]) >> 16) & 0x1)
#define PORTm_USE_CUSTOM_HEADER_FOR_PRIf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define PORTm_CUSTOM_HEADER_ENABLEf_GET(r) ((((r).port[8]) >> 17) & 0x1)
#define PORTm_CUSTOM_HEADER_ENABLEf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define PORTm_MIML_DOT1P_MAPPING_PTRf_GET(r) ((((r).port[8]) >> 18) & 0x3f)
#define PORTm_MIML_DOT1P_MAPPING_PTRf_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))
#define PORTm_ECCP_2f_GET(r) ((((r).port[8]) >> 24) & 0xff)
#define PORTm_ECCP_2f_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define PORTm_ECC_2f_GET(r) ((((r).port[8]) >> 24) & 0x7f)
#define PORTm_ECC_2f_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x7f << 24)) | ((((uint32)f) & 0x7f) << 24))
#define PORTm_PARITY_2f_GET(r) ((((r).port[8]) >> 31) & 0x1)
#define PORTm_PARITY_2f_SET(r,f) (r).port[8]=(((r).port[8] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define PORTm_DATA_3f_GET(r,a) field_get((r).port,288,375,a)
#define PORTm_DATA_3f_SET(r,a) field_set((r).port,288,375,a)
#define PORTm_TX_DEST_PORTf_GET(r) (((r).port[9]) & 0x7fff)
#define PORTm_TX_DEST_PORTf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x7fff)) | (((uint32)f) & 0x7fff))
#define PORTm_RESERVED_303f_GET(r) ((((r).port[9]) >> 15) & 0x1)
#define PORTm_RESERVED_303f_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define PORTm_TX_DEST_PORT_ENABLEf_GET(r) ((((r).port[9]) >> 16) & 0x1)
#define PORTm_TX_DEST_PORT_ENABLEf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define PORTm_VNTAG_ACTIONS_IF_NOT_PRESENTf_GET(r) ((((r).port[9]) >> 17) & 0x3)
#define PORTm_VNTAG_ACTIONS_IF_NOT_PRESENTf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x3 << 17)) | ((((uint32)f) & 0x3) << 17))
#define PORTm_VNTAG_ACTIONS_IF_PRESENTf_GET(r) ((((r).port[9]) >> 19) & 0x3)
#define PORTm_VNTAG_ACTIONS_IF_PRESENTf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define PORTm_DISCARD_IF_VNTAG_PRESENTf_GET(r) ((((r).port[9]) >> 21) & 0x1)
#define PORTm_DISCARD_IF_VNTAG_PRESENTf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define PORTm_DISCARD_IF_VNTAG_NOT_PRESENTf_GET(r) ((((r).port[9]) >> 22) & 0x1)
#define PORTm_DISCARD_IF_VNTAG_NOT_PRESENTf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define PORTm_ETAG_PCP_DE_MAPPING_PTRf_GET(r) ((((r).port[9]) >> 23) & 0x3f)
#define PORTm_ETAG_PCP_DE_MAPPING_PTRf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x3f << 23)) | ((((uint32)f) & 0x3f) << 23))
#define PORTm_PHB_FROM_ETAGf_GET(r) ((((r).port[9]) >> 29) & 0x1)
#define PORTm_PHB_FROM_ETAGf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define PORTm_ETAG_DOT1P_MAPPING_PTRf_GET(r) field32_get((r).port,318,321)
#define PORTm_ETAG_DOT1P_MAPPING_PTRf_SET(r,f) field32_set((r).port,318,321,f)
#define PORTm_ETAG_DEf_GET(r) ((((r).port[9]) >> 30) & 0x1)
#define PORTm_ETAG_DEf_SET(r,f) (r).port[9]=(((r).port[9] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define PORTm_ETAG_PCPf_GET(r) field32_get((r).port,319,321)
#define PORTm_ETAG_PCPf_SET(r,f) field32_set((r).port,319,321,f)
#define PORTm_RESERVED_322f_GET(r) ((((r).port[10]) >> 2) & 0x1)
#define PORTm_RESERVED_322f_SET(r,f) (r).port[10]=(((r).port[10] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define PORTm_ETAG_PCP_DE_SOURCEf_GET(r) ((((r).port[10]) >> 3) & 0x3)
#define PORTm_ETAG_PCP_DE_SOURCEf_SET(r,f) (r).port[10]=(((r).port[10] & ~((uint32)0x3 << 3)) | ((((uint32)f) & 0x3) << 3))
#define PORTm_IPMCV4_UNICAST_MACDA_ENABLEf_GET(r) ((((r).port[10]) >> 5) & 0x1)
#define PORTm_IPMCV4_UNICAST_MACDA_ENABLEf_SET(r,f) (r).port[10]=(((r).port[10] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PORTm_IPMCV6_UNICAST_MACDA_ENABLEf_GET(r) ((((r).port[10]) >> 6) & 0x1)
#define PORTm_IPMCV6_UNICAST_MACDA_ENABLEf_SET(r,f) (r).port[10]=(((r).port[10] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PORTm_RESERVED_4f_GET(r,a) field_get((r).port,327,375,a)
#define PORTm_RESERVED_4f_SET(r,a) field_set((r).port,327,375,a)
#define PORTm_ECCP_3f_GET(r) ((((r).port[11]) >> 24) & 0xff)
#define PORTm_ECCP_3f_SET(r,f) (r).port[11]=(((r).port[11] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define PORTm_ECC_3f_GET(r) ((((r).port[11]) >> 24) & 0x7f)
#define PORTm_ECC_3f_SET(r,f) (r).port[11]=(((r).port[11] & ~((uint32)0x7f << 24)) | ((((uint32)f) & 0x7f) << 24))
#define PORTm_PARITY_3f_GET(r) ((((r).port[11]) >> 31) & 0x1)
#define PORTm_PARITY_3f_SET(r,f) (r).port[11]=(((r).port[11] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access PORT.
 */
#define WRITE_PORTm(u,i,r) bcm5354x_mem_set(u, M_PORT(i), &(r._port), 12)
#define READ_PORTm(u,i,r) bcm5354x_mem_get(u, M_PORT(i), &(r._port), 12)

/*******************************************************************************
 * End of 'PORTm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  PROTOCOL_PKT_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Protocol Packet Control Register
 * SIZE:     32
 * FIELDS:
 *     DHCP_PKT_TO_CPU  Send DHCP Packets to the CPU
 *     DHCP_PKT_DROP    Drop DHCP Packets
 *     ND_PKT_TO_CPU    Send ND Packets to the CPU
 *     ND_PKT_DROP      Drop ND Packets
 *     ARP_REQUEST_TO_CPU Send ARP Request Packets to the CPU
 *     ARP_REQUEST_DROP Drop ARP Request Packets
 *     ARP_REPLY_TO_CPU Send ARP Reply Packets to the CPU
 *     ARP_REPLY_DROP   Drop ARP Reply Packets
 *     RESERVED_1       RESERVED_1
 *     RESERVED_2       RESERVED_2
 *     RESERVED_3       RESERVED_3
 *     RESERVED_4       RESERVED_4
 */
#define PROTOCOL_PKT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PROTOCOL_PKT_CONTROL.
 */
typedef union PROTOCOL_PKT_CONTROLr_s {
	uint32 v[1];
	uint32 protocol_pkt_control[1];
	uint32 _protocol_pkt_control;
} PROTOCOL_PKT_CONTROLr_t;

#define PROTOCOL_PKT_CONTROLr_CLR(r) (r).protocol_pkt_control[0] = 0
#define PROTOCOL_PKT_CONTROLr_SET(r,d) (r).protocol_pkt_control[0] = d
#define PROTOCOL_PKT_CONTROLr_GET(r) (r).protocol_pkt_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET(r) (((r).protocol_pkt_control[0]) & 0x1)
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 1) & 0x1)
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 2) & 0x1)
#define PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 3) & 0x1)
#define PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 4) & 0x1)
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 5) & 0x1)
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 6) & 0x1)
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 7) & 0x1)
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define PROTOCOL_PKT_CONTROLr_RESERVED_1f_GET(r) ((((r).protocol_pkt_control[0]) >> 8) & 0x1)
#define PROTOCOL_PKT_CONTROLr_RESERVED_1f_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define PROTOCOL_PKT_CONTROLr_RESERVED_2f_GET(r) ((((r).protocol_pkt_control[0]) >> 9) & 0x3)
#define PROTOCOL_PKT_CONTROLr_RESERVED_2f_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define PROTOCOL_PKT_CONTROLr_RESERVED_3f_GET(r) ((((r).protocol_pkt_control[0]) >> 11) & 0x1)
#define PROTOCOL_PKT_CONTROLr_RESERVED_3f_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define PROTOCOL_PKT_CONTROLr_RESERVED_4f_GET(r) ((((r).protocol_pkt_control[0]) >> 12) & 0x3)
#define PROTOCOL_PKT_CONTROLr_RESERVED_4f_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))

/*
 * These macros can be used to access PROTOCOL_PKT_CONTROL.
 */
#define WRITE_PROTOCOL_PKT_CONTROLr(u,p,r) bcm5354x_reg_set(u,R_PROTOCOL_PKT_CONTROL(p),(r._protocol_pkt_control))
#define READ_PROTOCOL_PKT_CONTROLr(u,p,r) bcm5354x_reg_get(u,R_PROTOCOL_PKT_CONTROL(p),&(r._protocol_pkt_control))

/*******************************************************************************
 * End of 'PROTOCOL_PKT_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  RESCAL_STATUS_0
 * BLOCKS:   TOP
 * DESC:     Resistor Calibration Status 0 register
 * SIZE:     32
 * FIELDS:
 *     RESCAL_DONE      RESCAL_DONE asserted after rescal is done
 *     RESCAL_VALID     asserted when rescal is done and a valid pon value is found
 *     RESCAL_CTRL_DFS  default values for i_rescal_ctrl[12:0]
 *     RESCAL_STATE     rescal digital state3'd0: INIT3'd1: WAIT_PWRUP3'd2: COMP_ACC3'd3: WAIT_PON_INC
 *     RESCAL_PREV_COMP_CNT accumulated comparison for previous pon value
 *     RESCAL_CURR_COMP_CNT accumulated comparison for current pon value
 *     RESCAL_PON       pon value; stable after rescal is done or o_done is assertedOutput On-chip Sheet Resistance0000 -24% ~ -21%0001 -21% ~ -18%0010 -18% ~ -15%0011 -15% ~ -12%0100 -12% ~ -9%0101 -9% ~ -6%0110 -6% ~ -3%0111 -3% ~ +0%1000 +0% ~ +3%1001 +3% ~ +6%1010 +6% ~ +9%1011 +9% ~ +12%1100 +12% ~ +15%1101 +15% ~ +18%1110 +18% ~ +21%1111 +21% ~ +24%
 */
#define RESCAL_STATUS_0r_SIZE 4

/*
 * This structure should be used to declare and program RESCAL_STATUS_0.
 */
typedef union RESCAL_STATUS_0r_s {
	uint32 v[1];
	uint32 rescal_status_0[1];
	uint32 _rescal_status_0;
} RESCAL_STATUS_0r_t;

#define RESCAL_STATUS_0r_CLR(r) (r).rescal_status_0[0] = 0
#define RESCAL_STATUS_0r_SET(r,d) (r).rescal_status_0[0] = d
#define RESCAL_STATUS_0r_GET(r) (r).rescal_status_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define RESCAL_STATUS_0r_RESCAL_DONEf_GET(r) (((r).rescal_status_0[0]) & 0x1)
#define RESCAL_STATUS_0r_RESCAL_DONEf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define RESCAL_STATUS_0r_RESCAL_VALIDf_GET(r) ((((r).rescal_status_0[0]) >> 1) & 0x1)
#define RESCAL_STATUS_0r_RESCAL_VALIDf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define RESCAL_STATUS_0r_RESCAL_CTRL_DFSf_GET(r) ((((r).rescal_status_0[0]) >> 2) & 0x1fff)
#define RESCAL_STATUS_0r_RESCAL_CTRL_DFSf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0x1fff << 2)) | ((((uint32)f) & 0x1fff) << 2))
#define RESCAL_STATUS_0r_RESCAL_STATEf_GET(r) ((((r).rescal_status_0[0]) >> 15) & 0x7)
#define RESCAL_STATUS_0r_RESCAL_STATEf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0x7 << 15)) | ((((uint32)f) & 0x7) << 15))
#define RESCAL_STATUS_0r_RESCAL_PREV_COMP_CNTf_GET(r) ((((r).rescal_status_0[0]) >> 18) & 0xf)
#define RESCAL_STATUS_0r_RESCAL_PREV_COMP_CNTf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0xf << 18)) | ((((uint32)f) & 0xf) << 18))
#define RESCAL_STATUS_0r_RESCAL_CURR_COMP_CNTf_GET(r) ((((r).rescal_status_0[0]) >> 22) & 0x3f)
#define RESCAL_STATUS_0r_RESCAL_CURR_COMP_CNTf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0x3f << 22)) | ((((uint32)f) & 0x3f) << 22))
#define RESCAL_STATUS_0r_RESCAL_PONf_GET(r) ((((r).rescal_status_0[0]) >> 28) & 0xf)
#define RESCAL_STATUS_0r_RESCAL_PONf_SET(r,f) (r).rescal_status_0[0]=(((r).rescal_status_0[0] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))

/*
 * These macros can be used to access RESCAL_STATUS_0.
 */
#define WRITE_RESCAL_STATUS_0r(u,r) bcm5354x_reg_set(u,R_RESCAL_STATUS_0,(r._rescal_status_0))
#define READ_RESCAL_STATUS_0r(u,r) bcm5354x_reg_get(u,R_RESCAL_STATUS_0,&(r._rescal_status_0))

/*******************************************************************************
 * End of 'RESCAL_STATUS_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  RX_DCB
 * BLOCKS:  
 * DESC:     Packet DMA RX descriptor.
 * SIZE:     512
 * FIELDS:
 *     BYTES_TRANSFERRED Actual number of bytes transferred
 *     END_BIT          Packet End bit
 *     START_BIT        Packet Start bit
 *     CELL_ERROR       Cell Error bit
 *     PKTDATA_READ_ECC_ERROR 2 bit ECC error while reading packet data from RX data Buffers.
 *     STATUS_READ_ECC_ERROR 2 bit ECC error while reading Status from RX Status Buffers. 
 *     DONE             Done bit
 *     EP_TO_CPU_HDR_TIMESTAMP_UPPER Carries the MSB 32bits of the DM-TIMESTAMP for an OAM-DM packet  
 *     EP_TO_CPU_HDR_INCOMING_TAG_STATUS Indicates the incoming tag status, PBE field: 0 = untagged, 1 = single inner-tag, 2 = single outer-tag, 3 = double tagged.
 *     EP_TO_CPU_HDR_ING_OTAG_ACTION Indicates ingress outer VLAN tag action, PBE field: 0 = do not modify, 1 = add O-VID, 2 = replace O-VID, <3 = reserved>
 *     EP_TO_CPU_HDR_ING_ITAG_ACTION Indicates ingress inner VLAN tag action, PBE field: 0 = do not modify, 1 = add I-VID, 2 = replace I-VID, 3 = remove I-VID
 *     EP_TO_CPU_HDR_SD_TAG_PRESENT Indicates there is an SD tag in the packet
 *     EP_TO_CPU_HDR_SWITCH flag to indicate this is a switched packet as opposed to a mirrored packet, PBE field
 *     EP_TO_CPU_HDR_PKT_HIGIG_LOOKUP 
 *     EP_TO_CPU_HDR_SRC_HIGIG_TYPE If set  then source port is Higig2, else Higig+. Valid only if SRC_HG is set, PBE field
 *     EP_TO_CPU_HDR_SRC_HIGIG Source is Higig, PBE field
 *     EP_TO_CPU_HDR_IP_ROUTED Indicates packet was routed - UC OR MC
 *     EP_TO_CPU_HDR_L3ONLY L3 IP Multicast Packet Flag, PBE field
 *     EP_TO_CPU_HDR_VNTAG_ACTION New field for VNTAG/ETAGs:                         00: Do not Modify                        01: Add/Replace incoming VNTAG with Ingress Port Based VNTAG                        10: Add/Replace incoming ETAG with Ingress Port Based ETAG.                        11: Delete Packets VNTAG/ETAG
 *     EP_TO_CPU_HDR_SPECIAL_PACKET_INDICATOR OAM or BFD PACKET INDICATOR.Is called SPECIAL_PACKET_INDICATOR in TR3
 *     EP_TO_CPU_HDR_DO_NOT_CHANGE_TTL This should be the final control in the EP indicating to not change the TTL, from any source.
 *     EP_TO_CPU_HDR_BPDU BPDU Packet, PBE field
 *     EP_TO_CPU_HDR_TIMESTAMP_TYPE "0"=> Invalid."3" => 802.1AS timestamp in the TIMESTAMP field. "1" => TIMESTAMP field carries the LM packet-count for an OAM LMM packet. "2" => {TIMESTAMP_UPPER,TIMESTAMP} fields carry the 64-bit DM Time-stamp for an OAM DMM packet.
 *     EP_TO_CPU_HDR_COS Port queue number for regular ethernet ports.
 *     EP_TO_CPU_HDR_IM_MTP_INDEX IM Mirror-to-Port Index, PBE field
 *     EP_TO_CPU_HDR_ECN New ECN value provided by the IFP.
 *     EP_TO_CPU_HDR_CHANGE_ECN Change the ECN as indicated by the IFP.
 *     EP_TO_CPU_HDR_TIMESTAMP If TIMESTAMP_TYPE=3, then this field carries the 32-bit 802.1AS timestamp. If TIMESTAMP_TPYE=1, then this field carried the 32-bit LM packet-count for an OAM-LMM packet.
 *     EP_TO_CPU_HDR_VFI 2 bits of reserved, 12 bits of VFI
 *     EP_TO_CPU_HDR_DSCP New DSCP value computed by the chip (EP) for the packet
 *     EP_TO_CPU_HDR_CHANGE_DSCP Set to 1 if the DSCP value has been changed by the EP
 *     EP_TO_CPU_HDR_IMIRROR Ingress Mirroring, PBE field
 *     EP_TO_CPU_HDR_EMIRROR Egress Mirroring, PBE field
 *     EP_TO_CPU_HDR_OUTER_CFI CFI which was constructed in EP based on CNG mapping, after the hcpm stage of EP.
 *     EP_TO_CPU_HDR_OUTER_PRI Outer Priority after the hcpm stage of the EP.
 *     EP_TO_CPU_HDR_HG_COS Reserved.Port queue number for ports in higig stacking mode.Doesnt exist for Hurricane
 *     EP_TO_CPU_HDR_INNER_VID THE FINAL VERSION
 *     EP_TO_CPU_HDR_INNER_CFI THE FINAL VERSION
 *     EP_TO_CPU_HDR_REPLICATION Indicates the packet is generated as a result of packet replication
 *     EP_TO_CPU_HDR_INNER_PRI THE FINAL VERSION
 *     EP_TO_CPU_HDR_REPLICATION_OR_NHOP_INDEX 9 bits of REPLICATION_OR_NHOP_INDEX
 *     EP_TO_CPU_HDR_RESERVED_140 Reserved.
 *     EP_TO_CPU_HDR_VLAN_COS Reserved.Port queue number for ports in VLAN shaping mode.Doesnt exist for Hurricane
 *     EP_TO_CPU_HDR_SHAPING_COS_SEL Indicates which COS value should be used for MMU bandwidth shaping - specifies the queue number that was used on this port for this packet.  0=COS, 1=CPU_COS, 2=HG_COS, 3=VLAN_COS.HG_COS,VLAN_COS donot exist for Hurricane.
 *     EP_TO_CPU_HDR_VFI_VALID Validates VFI field
 *     EP_TO_CPU_HDR_EM_MTP_INDEX EM Mirror-to-Port Index, PBE field
 *     EP_TO_CPU_HDR_SPECIAL_PACKET_TYPE NEW OAM PACKET INDICATOR
 *     EP_TO_CPU_HDR_SRC_PORT_NUM Source Port Number, PBE field
 *     EP_TO_CPU_HDR_PKT_LENGTH Packet length after all modification
 *     EP_TO_CPU_HDR_MATCHED_RULE Matched Rule, PBE field.For EP-COPY-TO-CPU pkt, this will be EFP_MATCHED_RULE.
 *     EP_TO_CPU_HDR_HGI Valid only for packets which came in on Higig+ source port. Higig+ module header field, PBE field
 *     EP_TO_CPU_HDR_CPU_COS Queue number used in MMU for cpu port, PBE field.For EP-COPY-TO-CPU pkt, this value will come from EP-REDIR-BUS.
 *     EP_TO_CPU_HDR_REGEN_CRC If set, then packet has been modified by the EP and CRC needs to be regenerated
 *     EP_TO_CPU_HDR_RESERVED_327 Reserved.
 *     EP_TO_CPU_HDR_CPU_OPCODE_TYPE Always set to 0 for HR2
 *     EP_TO_CPU_HDR_OUTER_VID VID value after the hcpm stage of EP.
 *     BYTE_COUNT       Byte count for the transfer
 *     CHAIN            Chain bit
 *     SCATTER          Scatter bit
 *     RELOAD           Reload bit
 *     INTERRUPT        SW controlled Interrupt generation.This control is required for Continuous DMA support. bit[0]: 1 - HW asserts descriptor done interrupt after descriptor completion. 0 - Interrupt disabled.  bit[1]: 1 - HW asserts IRQ_STAT0.CH3_DESC_CONTROLLED_INTR after descriptor completion. 0 - interrupt disabled. 1  Output mode (output time values)
 *     MEM_ADDR         Physical memory address for the transfer
 */
#define RX_DCB_SIZE 64

/*
 * This structure should be used to declare and program RX_DCB.
 */
typedef union RX_DCB_s {
	uint32 v[16];
	uint32 rx_dcb[16];
	uint32 _rx_dcb;
} RX_DCB_t;

#define RX_DCB_CLR(r) sal_memset(&((r)._rx_dcb), 0, sizeof(RX_DCB_t))
#define RX_DCB_SET(r,i,d) (r).rx_dcb[i] = d
#define RX_DCB_GET(r,i) (r).rx_dcb[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).rx_dcb[15]) & 0xffff)
#define RX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).rx_dcb[15]=(((r).rx_dcb[15] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define RX_DCB_END_BITf_GET(r) ((((r).rx_dcb[15]) >> 16) & 0x1)
#define RX_DCB_END_BITf_SET(r,f) (r).rx_dcb[15]=(((r).rx_dcb[15] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define RX_DCB_START_BITf_GET(r) ((((r).rx_dcb[15]) >> 17) & 0x1)
#define RX_DCB_START_BITf_SET(r,f) (r).rx_dcb[15]=(((r).rx_dcb[15] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define RX_DCB_CELL_ERRORf_GET(r) ((((r).rx_dcb[15]) >> 18) & 0x1)
#define RX_DCB_CELL_ERRORf_SET(r,f) (r).rx_dcb[15]=(((r).rx_dcb[15] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define RX_DCB_PKTDATA_READ_ECC_ERRORf_GET(r) ((((r).rx_dcb[15]) >> 19) & 0x1)
#define RX_DCB_PKTDATA_READ_ECC_ERRORf_SET(r,f) (r).rx_dcb[15]=(((r).rx_dcb[15] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define RX_DCB_STATUS_READ_ECC_ERRORf_GET(r) ((((r).rx_dcb[15]) >> 20) & 0x1)
#define RX_DCB_STATUS_READ_ECC_ERRORf_SET(r,f) (r).rx_dcb[15]=(((r).rx_dcb[15] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define RX_DCB_DONEf_GET(r) ((((r).rx_dcb[15]) >> 31) & 0x1)
#define RX_DCB_DONEf_SET(r,f) (r).rx_dcb[15]=(((r).rx_dcb[15] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define RX_DCB_EP_TO_CPU_HDR_TIMESTAMP_UPPERf_GET(r) ((r).rx_dcb[14])
#define RX_DCB_EP_TO_CPU_HDR_TIMESTAMP_UPPERf_SET(r,f) (r).rx_dcb[14]=((uint32)f)
#define RX_DCB_EP_TO_CPU_HDR_INCOMING_TAG_STATUSf_GET(r) (((r).rx_dcb[13]) & 0x3)
#define RX_DCB_EP_TO_CPU_HDR_INCOMING_TAG_STATUSf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define RX_DCB_EP_TO_CPU_HDR_ING_OTAG_ACTIONf_GET(r) ((((r).rx_dcb[13]) >> 2) & 0x3)
#define RX_DCB_EP_TO_CPU_HDR_ING_OTAG_ACTIONf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define RX_DCB_EP_TO_CPU_HDR_ING_ITAG_ACTIONf_GET(r) ((((r).rx_dcb[13]) >> 4) & 0x3)
#define RX_DCB_EP_TO_CPU_HDR_ING_ITAG_ACTIONf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define RX_DCB_EP_TO_CPU_HDR_SD_TAG_PRESENTf_GET(r) ((((r).rx_dcb[13]) >> 6) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_SD_TAG_PRESENTf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define RX_DCB_EP_TO_CPU_HDR_SWITCHf_GET(r) ((((r).rx_dcb[13]) >> 7) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_SWITCHf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define RX_DCB_EP_TO_CPU_HDR_PKT_HIGIG_LOOKUPf_GET(r) ((((r).rx_dcb[13]) >> 8) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_PKT_HIGIG_LOOKUPf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define RX_DCB_EP_TO_CPU_HDR_SRC_HIGIG_TYPEf_GET(r) ((((r).rx_dcb[13]) >> 9) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_SRC_HIGIG_TYPEf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define RX_DCB_EP_TO_CPU_HDR_SRC_HIGIGf_GET(r) ((((r).rx_dcb[13]) >> 10) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_SRC_HIGIGf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define RX_DCB_EP_TO_CPU_HDR_IP_ROUTEDf_GET(r) ((((r).rx_dcb[13]) >> 11) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_IP_ROUTEDf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define RX_DCB_EP_TO_CPU_HDR_L3ONLYf_GET(r) ((((r).rx_dcb[13]) >> 12) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_L3ONLYf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define RX_DCB_EP_TO_CPU_HDR_VNTAG_ACTIONf_GET(r) ((((r).rx_dcb[13]) >> 13) & 0x3)
#define RX_DCB_EP_TO_CPU_HDR_VNTAG_ACTIONf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define RX_DCB_EP_TO_CPU_HDR_SPECIAL_PACKET_INDICATORf_GET(r) ((((r).rx_dcb[13]) >> 15) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_SPECIAL_PACKET_INDICATORf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define RX_DCB_EP_TO_CPU_HDR_DO_NOT_CHANGE_TTLf_GET(r) ((((r).rx_dcb[13]) >> 16) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_DO_NOT_CHANGE_TTLf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define RX_DCB_EP_TO_CPU_HDR_BPDUf_GET(r) ((((r).rx_dcb[13]) >> 17) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_BPDUf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define RX_DCB_EP_TO_CPU_HDR_TIMESTAMP_TYPEf_GET(r) ((((r).rx_dcb[13]) >> 18) & 0x3)
#define RX_DCB_EP_TO_CPU_HDR_TIMESTAMP_TYPEf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define RX_DCB_EP_TO_CPU_HDR_COSf_GET(r) ((((r).rx_dcb[13]) >> 20) & 0xf)
#define RX_DCB_EP_TO_CPU_HDR_COSf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define RX_DCB_EP_TO_CPU_HDR_IM_MTP_INDEXf_GET(r) ((((r).rx_dcb[13]) >> 24) & 0x1f)
#define RX_DCB_EP_TO_CPU_HDR_IM_MTP_INDEXf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x1f << 24)) | ((((uint32)f) & 0x1f) << 24))
#define RX_DCB_EP_TO_CPU_HDR_ECNf_GET(r) ((((r).rx_dcb[13]) >> 29) & 0x3)
#define RX_DCB_EP_TO_CPU_HDR_ECNf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x3 << 29)) | ((((uint32)f) & 0x3) << 29))
#define RX_DCB_EP_TO_CPU_HDR_CHANGE_ECNf_GET(r) ((((r).rx_dcb[13]) >> 31) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_CHANGE_ECNf_SET(r,f) (r).rx_dcb[13]=(((r).rx_dcb[13] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define RX_DCB_EP_TO_CPU_HDR_TIMESTAMPf_GET(r) ((r).rx_dcb[12])
#define RX_DCB_EP_TO_CPU_HDR_TIMESTAMPf_SET(r,f) (r).rx_dcb[12]=((uint32)f)
#define RX_DCB_EP_TO_CPU_HDR_VFIf_GET(r) (((r).rx_dcb[12]) & 0x3fff)
#define RX_DCB_EP_TO_CPU_HDR_VFIf_SET(r,f) (r).rx_dcb[12]=(((r).rx_dcb[12] & ~((uint32)0x3fff)) | (((uint32)f) & 0x3fff))
#define RX_DCB_EP_TO_CPU_HDR_DSCPf_GET(r) (((r).rx_dcb[11]) & 0x3f)
#define RX_DCB_EP_TO_CPU_HDR_DSCPf_SET(r,f) (r).rx_dcb[11]=(((r).rx_dcb[11] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define RX_DCB_EP_TO_CPU_HDR_CHANGE_DSCPf_GET(r) ((((r).rx_dcb[11]) >> 6) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_CHANGE_DSCPf_SET(r,f) (r).rx_dcb[11]=(((r).rx_dcb[11] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define RX_DCB_EP_TO_CPU_HDR_IMIRRORf_GET(r) ((((r).rx_dcb[11]) >> 7) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_IMIRRORf_SET(r,f) (r).rx_dcb[11]=(((r).rx_dcb[11] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define RX_DCB_EP_TO_CPU_HDR_EMIRRORf_GET(r) ((((r).rx_dcb[11]) >> 8) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_EMIRRORf_SET(r,f) (r).rx_dcb[11]=(((r).rx_dcb[11] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define RX_DCB_EP_TO_CPU_HDR_OUTER_CFIf_GET(r) ((((r).rx_dcb[11]) >> 9) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_OUTER_CFIf_SET(r,f) (r).rx_dcb[11]=(((r).rx_dcb[11] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define RX_DCB_EP_TO_CPU_HDR_OUTER_PRIf_GET(r) ((((r).rx_dcb[11]) >> 10) & 0x7)
#define RX_DCB_EP_TO_CPU_HDR_OUTER_PRIf_SET(r,f) (r).rx_dcb[11]=(((r).rx_dcb[11] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define RX_DCB_EP_TO_CPU_HDR_HG_COSf_GET(r) ((((r).rx_dcb[11]) >> 13) & 0x1f)
#define RX_DCB_EP_TO_CPU_HDR_HG_COSf_SET(r,f) (r).rx_dcb[11]=(((r).rx_dcb[11] & ~((uint32)0x1f << 13)) | ((((uint32)f) & 0x1f) << 13))
#define RX_DCB_EP_TO_CPU_HDR_INNER_VIDf_GET(r) ((((r).rx_dcb[11]) >> 18) & 0xfff)
#define RX_DCB_EP_TO_CPU_HDR_INNER_VIDf_SET(r,f) (r).rx_dcb[11]=(((r).rx_dcb[11] & ~((uint32)0xfff << 18)) | ((((uint32)f) & 0xfff) << 18))
#define RX_DCB_EP_TO_CPU_HDR_INNER_CFIf_GET(r) ((((r).rx_dcb[11]) >> 30) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_INNER_CFIf_SET(r,f) (r).rx_dcb[11]=(((r).rx_dcb[11] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define RX_DCB_EP_TO_CPU_HDR_REPLICATIONf_GET(r) ((((r).rx_dcb[11]) >> 31) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_REPLICATIONf_SET(r,f) (r).rx_dcb[11]=(((r).rx_dcb[11] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define RX_DCB_EP_TO_CPU_HDR_INNER_PRIf_GET(r) (((r).rx_dcb[10]) & 0x7)
#define RX_DCB_EP_TO_CPU_HDR_INNER_PRIf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define RX_DCB_EP_TO_CPU_HDR_REPLICATION_OR_NHOP_INDEXf_GET(r) ((((r).rx_dcb[10]) >> 3) & 0x1ff)
#define RX_DCB_EP_TO_CPU_HDR_REPLICATION_OR_NHOP_INDEXf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32)0x1ff << 3)) | ((((uint32)f) & 0x1ff) << 3))
#define RX_DCB_EP_TO_CPU_HDR_RESERVED_140f_GET(r) ((((r).rx_dcb[10]) >> 12) & 0xf)
#define RX_DCB_EP_TO_CPU_HDR_RESERVED_140f_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define RX_DCB_EP_TO_CPU_HDR_VLAN_COSf_GET(r) ((((r).rx_dcb[10]) >> 16) & 0x1f)
#define RX_DCB_EP_TO_CPU_HDR_VLAN_COSf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32)0x1f << 16)) | ((((uint32)f) & 0x1f) << 16))
#define RX_DCB_EP_TO_CPU_HDR_SHAPING_COS_SELf_GET(r) ((((r).rx_dcb[10]) >> 21) & 0x3)
#define RX_DCB_EP_TO_CPU_HDR_SHAPING_COS_SELf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define RX_DCB_EP_TO_CPU_HDR_VFI_VALIDf_GET(r) ((((r).rx_dcb[10]) >> 23) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_VFI_VALIDf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define RX_DCB_EP_TO_CPU_HDR_EM_MTP_INDEXf_GET(r) ((((r).rx_dcb[10]) >> 24) & 0x1f)
#define RX_DCB_EP_TO_CPU_HDR_EM_MTP_INDEXf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32)0x1f << 24)) | ((((uint32)f) & 0x1f) << 24))
#define RX_DCB_EP_TO_CPU_HDR_SPECIAL_PACKET_TYPEf_GET(r) ((((r).rx_dcb[10]) >> 29) & 0x7)
#define RX_DCB_EP_TO_CPU_HDR_SPECIAL_PACKET_TYPEf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))
#define RX_DCB_EP_TO_CPU_HDR_SRC_PORT_NUMf_GET(r) (((r).rx_dcb[5]) & 0xff)
#define RX_DCB_EP_TO_CPU_HDR_SRC_PORT_NUMf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define RX_DCB_EP_TO_CPU_HDR_PKT_LENGTHf_GET(r) ((((r).rx_dcb[5]) >> 8) & 0x3fff)
#define RX_DCB_EP_TO_CPU_HDR_PKT_LENGTHf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32)0x3fff << 8)) | ((((uint32)f) & 0x3fff) << 8))
#define RX_DCB_EP_TO_CPU_HDR_MATCHED_RULEf_GET(r) ((((r).rx_dcb[5]) >> 22) & 0xff)
#define RX_DCB_EP_TO_CPU_HDR_MATCHED_RULEf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32)0xff << 22)) | ((((uint32)f) & 0xff) << 22))
#define RX_DCB_EP_TO_CPU_HDR_HGIf_GET(r) ((((r).rx_dcb[5]) >> 30) & 0x3)
#define RX_DCB_EP_TO_CPU_HDR_HGIf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define RX_DCB_EP_TO_CPU_HDR_CPU_COSf_GET(r) (((r).rx_dcb[4]) & 0x3f)
#define RX_DCB_EP_TO_CPU_HDR_CPU_COSf_SET(r,f) (r).rx_dcb[4]=(((r).rx_dcb[4] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define RX_DCB_EP_TO_CPU_HDR_REGEN_CRCf_GET(r) ((((r).rx_dcb[4]) >> 6) & 0x1)
#define RX_DCB_EP_TO_CPU_HDR_REGEN_CRCf_SET(r,f) (r).rx_dcb[4]=(((r).rx_dcb[4] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define RX_DCB_EP_TO_CPU_HDR_RESERVED_327f_GET(r) ((((r).rx_dcb[4]) >> 7) & 0x1ff)
#define RX_DCB_EP_TO_CPU_HDR_RESERVED_327f_SET(r,f) (r).rx_dcb[4]=(((r).rx_dcb[4] & ~((uint32)0x1ff << 7)) | ((((uint32)f) & 0x1ff) << 7))
#define RX_DCB_EP_TO_CPU_HDR_CPU_OPCODE_TYPEf_GET(r) ((((r).rx_dcb[4]) >> 16) & 0xf)
#define RX_DCB_EP_TO_CPU_HDR_CPU_OPCODE_TYPEf_SET(r,f) (r).rx_dcb[4]=(((r).rx_dcb[4] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define RX_DCB_EP_TO_CPU_HDR_OUTER_VIDf_GET(r) ((((r).rx_dcb[4]) >> 20) & 0xfff)
#define RX_DCB_EP_TO_CPU_HDR_OUTER_VIDf_SET(r,f) (r).rx_dcb[4]=(((r).rx_dcb[4] & ~((uint32)0xfff << 20)) | ((((uint32)f) & 0xfff) << 20))
#define RX_DCB_BYTE_COUNTf_GET(r) (((r).rx_dcb[1]) & 0xffff)
#define RX_DCB_BYTE_COUNTf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define RX_DCB_CHAINf_GET(r) ((((r).rx_dcb[1]) >> 16) & 0x1)
#define RX_DCB_CHAINf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define RX_DCB_SCATTERf_GET(r) ((((r).rx_dcb[1]) >> 17) & 0x1)
#define RX_DCB_SCATTERf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define RX_DCB_RELOADf_GET(r) ((((r).rx_dcb[1]) >> 18) & 0x1)
#define RX_DCB_RELOADf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define RX_DCB_INTERRUPTf_GET(r) ((((r).rx_dcb[1]) >> 23) & 0x3)
#define RX_DCB_INTERRUPTf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32)0x3 << 23)) | ((((uint32)f) & 0x3) << 23))
#define RX_DCB_MEM_ADDRf_GET(r) ((r).rx_dcb[0])
#define RX_DCB_MEM_ADDRf_SET(r,f) (r).rx_dcb[0]=((uint32)f)

/*******************************************************************************
 * End of 'RX_DCB'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  SCHAN
 * BLOCKS:  
 * DESC:     Phase 0 of S-bus message
 * SIZE:     32
 * FIELDS:
 *     NACK             NACK (Negative ACK) bit. Set when a legal S-bus commandcannot be serviced due to hardware resource limitations.Valid only for S-bus ACKs, not for S-bus commands.
 *     BANK             Disable for half-buckets on table ops
 *     DMA              0=PIO by CPU, 1=DMA by CMIC. This bit is set by CMIC DMA engine for DMA-generated SBus accesses. Note: CPU PIO commands must leave this bit zero when issusing SBUS commands.
 *     ECODE            Error code (cause for ERR bit getting set).Valid only for S-bus ACKs, not for S-bus commands.
 *     ERR              Error bit. Set due to an illegal/invalid access.Valid only for S-bus ACKs, not for S-bus commands.
 *     DATA_LEN         Data length, in bytes. Valid only for S-bus commands, not for S-bus ACKs.
 *     ACC              Command access type.
 *     DEST_BLOCK       Destination Port
 *     OP_CODE          Opcode
 */
#define SCHAN_SIZE 4

/*
 * This structure should be used to declare and program SCHAN.
 */
typedef union SCHAN_s {
	uint32 v[1];
	uint32 schan[1];
	uint32 _schan;
} SCHAN_t;

#define SCHAN_CLR(r) (r).schan[0] = 0
#define SCHAN_SET(r,d) (r).schan[0] = d
#define SCHAN_GET(r) (r).schan[0]

/*
 * These macros can be used to access individual fields.
 */
#define SCHAN_NACKf_GET(r) (((r).schan[0]) & 0x1)
#define SCHAN_NACKf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define SCHAN_BANKf_GET(r) ((((r).schan[0]) >> 1) & 0x3)
#define SCHAN_BANKf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x3 << 1)) | ((((uint32)f) & 0x3) << 1))
#define SCHAN_DMAf_GET(r) ((((r).schan[0]) >> 3) & 0x1)
#define SCHAN_DMAf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define SCHAN_ECODEf_GET(r) ((((r).schan[0]) >> 4) & 0x3)
#define SCHAN_ECODEf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define SCHAN_ERRf_GET(r) ((((r).schan[0]) >> 6) & 0x1)
#define SCHAN_ERRf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define SCHAN_DATA_LENf_GET(r) ((((r).schan[0]) >> 7) & 0x7f)
#define SCHAN_DATA_LENf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define SCHAN_ACCf_GET(r) ((((r).schan[0]) >> 14) & 0x1f)
#define SCHAN_ACCf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x1f << 14)) | ((((uint32)f) & 0x1f) << 14))
#define SCHAN_DEST_BLOCKf_GET(r) ((((r).schan[0]) >> 19) & 0x7f)
#define SCHAN_DEST_BLOCKf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x7f << 19)) | ((((uint32)f) & 0x7f) << 19))
#define SCHAN_OP_CODEf_GET(r) ((((r).schan[0]) >> 26) & 0x3f)
#define SCHAN_OP_CODEf_SET(r,f) (r).schan[0]=(((r).schan[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*******************************************************************************
 * End of 'SCHAN'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  SHARED_POOL_CTRL
 * BLOCKS:   MMU
 * DESC:     Priority group mapping register
 * SIZE:     32
 * FIELDS:
 *     SHARED_POOL_XOFF_EN Each bit is for a Priority group.Bit 0: PG0.....	Bit 7: PG7Enable accounting of shared pool cell availability to trigger PFC for this PG. 0: usage of global buffers by the PG is not tracked by the MMU1: usage of global buffers by the PG is tracked by the MMU and if it exceeds the cell limit, all priorities mapped to the PG are backpressured
 *     SHARED_POOL_DISCARD_EN Each bit is for a Priority group.Bit 0: Priority Group 0....Bit 7: Priority Group 7If the PPFC_SHARED_POOL_XOFF_EN bit is set for a PG, and the TOTALDYNCELLSETLIMIT is exceeded, entire packets in this Priority Group will be tail dropped or discarded even if part of the packet has already been stored. TOTALDYNCELLSETLIMIT is an optional limit on the global cell count.  Otherwise, packets in this Priority Group will be stored even though the shared pool cell limit is exceeded.
 *     DYNAMIC_COS_DROP_EN Each bit is for a COS.Bit 0: cos 0....Bit 7: cos 7In Dynamic memory mode, if global shared pool counter >=  TOTALDYNCELLSETLIMIT and HOL counter of cos-n >= cos-n's LWMCOSCELLSETLIMIT, then this packet could be discarded by MMU. This register will control this dynamic mode cos-n drop behavior."1": drop the packet if the above condition is meet"0": don't drop the packet if the above condition is meetDefault value is 0xFF for HC2 backward compatible.
 */
#define SHARED_POOL_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program SHARED_POOL_CTRL.
 */
typedef union SHARED_POOL_CTRLr_s {
	uint32 v[1];
	uint32 shared_pool_ctrl[1];
	uint32 _shared_pool_ctrl;
} SHARED_POOL_CTRLr_t;

#define SHARED_POOL_CTRLr_CLR(r) (r).shared_pool_ctrl[0] = 0
#define SHARED_POOL_CTRLr_SET(r,d) (r).shared_pool_ctrl[0] = d
#define SHARED_POOL_CTRLr_GET(r) (r).shared_pool_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define SHARED_POOL_CTRLr_SHARED_POOL_XOFF_ENf_GET(r) (((r).shared_pool_ctrl[0]) & 0xff)
#define SHARED_POOL_CTRLr_SHARED_POOL_XOFF_ENf_SET(r,f) (r).shared_pool_ctrl[0]=(((r).shared_pool_ctrl[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define SHARED_POOL_CTRLr_SHARED_POOL_DISCARD_ENf_GET(r) ((((r).shared_pool_ctrl[0]) >> 8) & 0xff)
#define SHARED_POOL_CTRLr_SHARED_POOL_DISCARD_ENf_SET(r,f) (r).shared_pool_ctrl[0]=(((r).shared_pool_ctrl[0] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define SHARED_POOL_CTRLr_DYNAMIC_COS_DROP_ENf_GET(r) ((((r).shared_pool_ctrl[0]) >> 16) & 0xff)
#define SHARED_POOL_CTRLr_DYNAMIC_COS_DROP_ENf_SET(r,f) (r).shared_pool_ctrl[0]=(((r).shared_pool_ctrl[0] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))

/*
 * These macros can be used to access SHARED_POOL_CTRL.
 */
#define WRITE_SHARED_POOL_CTRLr(u,p,r) bcm5354x_reg_set(u,R_SHARED_POOL_CTRL(p),(r._shared_pool_ctrl))
#define READ_SHARED_POOL_CTRLr(u,p,r) bcm5354x_reg_get(u,R_SHARED_POOL_CTRL(p),&(r._shared_pool_ctrl))

/*******************************************************************************
 * End of 'SHARED_POOL_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  SOBMH
 * BLOCKS:  
 * DESC:     Bit Definitions of the Internal Stream of Bytes Module Header - HW defines a 16-byte field, fields required from software are in the first 12-bytes - hardware modified fields are in the last 4 bytes (but not necessarily - IPCF_PTR is a hw field added to the first 12-byte section) 
 * SIZE:     448
 * FIELDS:
 *     CELL_LENGTH      CELL_LENGTH (set by hardware - in Iarb).
 *     EOP              EOP indicator (set by hardware - in Iarb).
 *     SOP              SOP indicator (set by hardware - in Iarb).
 *     PKT_LENGTH       PKT_LENGTH (set by hardware - in Iarb).
 *     IPCF_PTR         Pointer to cell buffer of this SOBMH cell. (Set by hardware)
 *     RESERVED_IPCF_PTR Pointer to cell buffer of this SOBMH cell. (Set by hardware)
 *     SRC_MODID        Source module ID, must be programmed to MY_MODID.
 *     QUEUE_NUM        Queue number to be used for unicast queuing and CPU queue (CPU_COS).
 *     NLF_PORT_NUMBER  Logical Egress port number provided by the EP
 *     UNICAST          Indicates that PBI.UNICAST should be set to queue as unicast packet.
 *     SPAP             For PBI.SPAP - Service Pool Priority (color)
 *     SPID             For PBI.SPID - Service Pool ID
 *     SPID_OVERRIDE    For PBI.SPID_Override
 *     COS              Class of service for MMU queueing for this packet - sets COS values, PBI.UC_COS, PBI.MC_COS1, and PBI.MC_COS2.
 *     INT_PRI          Internal Priority used for CPU_COS_MAP TCAM lookups for EP COPY TO CPU (header type 0) to generate CPU_COS
 *     INPUT_PRI        Traffic priority to be applied to MMU via PBI.INPUT_PRIORITY.
 *     LOCAL_DEST_PORT  Indicates the local port to send a SOBMH packet out.
 *     SET_L2BM         Indicates that PBI.L2_BITMAP should be set (to queue as L2MC packet).
 *     IEEE1588_TIMESTAMP_HDR_OFFSET HDR_OFFSET
 *     SET_L3BM         Indicates that PBI.L3_BITMAP should be set (to queue as IPMC packet).
 *     TX_TS            Indicates for TS packet transmitted from CPU into IP that the outgoing packet needs to have its transmit timestamp captured by the port.
 *     IEEE1588_INGRESS_TIMESTAMP_SIGN ITS_SIGN
 *     IEEE1588_REGEN_UDP_CHECKSUM Regenerate UDP Checksum
 *     IEEE1588_ONE_STEP_ENABLE ONE STEP TIME STAMPING ENABLE
 *     RESERVED_4       Reserved
 *     OAM_REPLACEMENT_TYPE 00:NOP 01:DM 10:NTP 11:LM
 *     CELL_ERROR       CELL_ERROR or PURGE
 *     RESERVED_1       RESERVED
 *     OAM_REPLACEMENT_OFFSET From CPU indicatinf insertion point in packet for LM count or DM Timestamp. Has 14 Byte offset with 2 byte increments
 *     QUEUE_NUM_UPPER  Holds upper 2 bit of the QUEUE_NUM field.
 *     EP_CPU_REASON_CODE EP Copy to CPU Reasons
 *     LM_COUNTER_INDEX From CPU indicating LM Counter Index
 *     RESERVED_3       Reserved
 *     RESERVED_5       Reserved
 *     HEADER_TYPE      64 Header Types Supported
 *     START            Start of frame indicator. 
 */
#define SOBMH_SIZE 56

/*
 * This structure should be used to declare and program SOBMH.
 */
typedef union SOBMH_s {
	uint32 v[14];
	uint32 sobmh[14];
	uint32 _sobmh;
} SOBMH_t;

#define SOBMH_CLR(r) sal_memset(&((r)._sobmh), 0, sizeof(SOBMH_t))
#define SOBMH_SET(r,i,d) (r).sobmh[i] = d
#define SOBMH_GET(r,i) (r).sobmh[i]

/*
 * These macros can be used to access individual fields.
 */
#define SOBMH_CELL_LENGTHf_GET(r) (((r).sobmh[10]) & 0xff)
#define SOBMH_CELL_LENGTHf_SET(r,f) (r).sobmh[10]=(((r).sobmh[10] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define SOBMH_EOPf_GET(r) ((((r).sobmh[10]) >> 8) & 0x1)
#define SOBMH_EOPf_SET(r,f) (r).sobmh[10]=(((r).sobmh[10] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define SOBMH_SOPf_GET(r) ((((r).sobmh[10]) >> 9) & 0x1)
#define SOBMH_SOPf_SET(r,f) (r).sobmh[10]=(((r).sobmh[10] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define SOBMH_PKT_LENGTHf_GET(r) ((((r).sobmh[10]) >> 10) & 0x3fff)
#define SOBMH_PKT_LENGTHf_SET(r,f) (r).sobmh[10]=(((r).sobmh[10] & ~((uint32)0x3fff << 10)) | ((((uint32)f) & 0x3fff) << 10))
#define SOBMH_IPCF_PTRf_GET(r) ((((r).sobmh[10]) >> 24) & 0xff)
#define SOBMH_IPCF_PTRf_SET(r,f) (r).sobmh[10]=(((r).sobmh[10] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define SOBMH_RESERVED_IPCF_PTRf_GET(r) ((((r).sobmh[10]) >> 24) & 0xff)
#define SOBMH_RESERVED_IPCF_PTRf_SET(r,f) (r).sobmh[10]=(((r).sobmh[10] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define SOBMH_SRC_MODIDf_GET(r) (((r).sobmh[11]) & 0xff)
#define SOBMH_SRC_MODIDf_SET(r,f) (r).sobmh[11]=(((r).sobmh[11] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define SOBMH_QUEUE_NUMf_GET(r) ((((r).sobmh[11]) >> 8) & 0x3ff)
#define SOBMH_QUEUE_NUMf_SET(r,f) (r).sobmh[11]=(((r).sobmh[11] & ~((uint32)0x3ff << 8)) | ((((uint32)f) & 0x3ff) << 8))
#define SOBMH_NLF_PORT_NUMBERf_GET(r) ((((r).sobmh[11]) >> 18) & 0x3f)
#define SOBMH_NLF_PORT_NUMBERf_SET(r,f) (r).sobmh[11]=(((r).sobmh[11] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))
#define SOBMH_UNICASTf_GET(r) ((((r).sobmh[11]) >> 18) & 0x1)
#define SOBMH_UNICASTf_SET(r,f) (r).sobmh[11]=(((r).sobmh[11] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define SOBMH_SPAPf_GET(r) ((((r).sobmh[11]) >> 19) & 0x3)
#define SOBMH_SPAPf_SET(r,f) (r).sobmh[11]=(((r).sobmh[11] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define SOBMH_SPIDf_GET(r) ((((r).sobmh[11]) >> 21) & 0x3)
#define SOBMH_SPIDf_SET(r,f) (r).sobmh[11]=(((r).sobmh[11] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define SOBMH_SPID_OVERRIDEf_GET(r) ((((r).sobmh[11]) >> 23) & 0x1)
#define SOBMH_SPID_OVERRIDEf_SET(r,f) (r).sobmh[11]=(((r).sobmh[11] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define SOBMH_COSf_GET(r) ((((r).sobmh[11]) >> 24) & 0xf)
#define SOBMH_COSf_SET(r,f) (r).sobmh[11]=(((r).sobmh[11] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define SOBMH_INT_PRIf_GET(r) ((((r).sobmh[11]) >> 24) & 0xf)
#define SOBMH_INT_PRIf_SET(r,f) (r).sobmh[11]=(((r).sobmh[11] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define SOBMH_INPUT_PRIf_GET(r) ((((r).sobmh[11]) >> 28) & 0xf)
#define SOBMH_INPUT_PRIf_SET(r,f) (r).sobmh[11]=(((r).sobmh[11] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define SOBMH_LOCAL_DEST_PORTf_GET(r) (((r).sobmh[12]) & 0x7f)
#define SOBMH_LOCAL_DEST_PORTf_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define SOBMH_SET_L2BMf_GET(r) ((((r).sobmh[12]) >> 7) & 0x1)
#define SOBMH_SET_L2BMf_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define SOBMH_IEEE1588_TIMESTAMP_HDR_OFFSETf_GET(r) ((((r).sobmh[12]) >> 8) & 0xff)
#define SOBMH_IEEE1588_TIMESTAMP_HDR_OFFSETf_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define SOBMH_SET_L3BMf_GET(r) ((((r).sobmh[12]) >> 16) & 0x1)
#define SOBMH_SET_L3BMf_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define SOBMH_TX_TSf_GET(r) ((((r).sobmh[12]) >> 17) & 0x1)
#define SOBMH_TX_TSf_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define SOBMH_IEEE1588_INGRESS_TIMESTAMP_SIGNf_GET(r) ((((r).sobmh[12]) >> 18) & 0x1)
#define SOBMH_IEEE1588_INGRESS_TIMESTAMP_SIGNf_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define SOBMH_IEEE1588_REGEN_UDP_CHECKSUMf_GET(r) ((((r).sobmh[12]) >> 19) & 0x1)
#define SOBMH_IEEE1588_REGEN_UDP_CHECKSUMf_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define SOBMH_IEEE1588_ONE_STEP_ENABLEf_GET(r) ((((r).sobmh[12]) >> 20) & 0x1)
#define SOBMH_IEEE1588_ONE_STEP_ENABLEf_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define SOBMH_RESERVED_4f_GET(r) ((((r).sobmh[12]) >> 21) & 0x7ff)
#define SOBMH_RESERVED_4f_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x7ff << 21)) | ((((uint32)f) & 0x7ff) << 21))
#define SOBMH_OAM_REPLACEMENT_TYPEf_GET(r) ((((r).sobmh[12]) >> 21) & 0x3)
#define SOBMH_OAM_REPLACEMENT_TYPEf_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define SOBMH_CELL_ERRORf_GET(r) ((((r).sobmh[12]) >> 23) & 0x1)
#define SOBMH_CELL_ERRORf_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define SOBMH_RESERVED_1f_GET(r) ((((r).sobmh[12]) >> 23) & 0x1)
#define SOBMH_RESERVED_1f_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define SOBMH_OAM_REPLACEMENT_OFFSETf_GET(r) ((((r).sobmh[12]) >> 24) & 0x3f)
#define SOBMH_OAM_REPLACEMENT_OFFSETf_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))
#define SOBMH_QUEUE_NUM_UPPERf_GET(r) ((((r).sobmh[12]) >> 30) & 0x3)
#define SOBMH_QUEUE_NUM_UPPERf_SET(r,f) (r).sobmh[12]=(((r).sobmh[12] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define SOBMH_EP_CPU_REASON_CODEf_GET(r) (((r).sobmh[13]) & 0xfffff)
#define SOBMH_EP_CPU_REASON_CODEf_SET(r,f) (r).sobmh[13]=(((r).sobmh[13] & ~((uint32)0xfffff)) | (((uint32)f) & 0xfffff))
#define SOBMH_LM_COUNTER_INDEXf_GET(r) (((r).sobmh[13]) & 0xffff)
#define SOBMH_LM_COUNTER_INDEXf_SET(r,f) (r).sobmh[13]=(((r).sobmh[13] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define SOBMH_RESERVED_3f_GET(r) ((((r).sobmh[13]) >> 16) & 0xff)
#define SOBMH_RESERVED_3f_SET(r,f) (r).sobmh[13]=(((r).sobmh[13] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define SOBMH_RESERVED_5f_GET(r) ((((r).sobmh[13]) >> 20) & 0xf)
#define SOBMH_RESERVED_5f_SET(r,f) (r).sobmh[13]=(((r).sobmh[13] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define SOBMH_HEADER_TYPEf_GET(r) ((((r).sobmh[13]) >> 24) & 0x3f)
#define SOBMH_HEADER_TYPEf_SET(r,f) (r).sobmh[13]=(((r).sobmh[13] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))
#define SOBMH_STARTf_GET(r) ((((r).sobmh[13]) >> 30) & 0x3)
#define SOBMH_STARTf_SET(r,f) (r).sobmh[13]=(((r).sobmh[13] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))

/*******************************************************************************
 * End of 'SOBMH'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  SOURCE_TRUNK_MAP
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Map Table. 
This table is used to support trunking across different MODIDs.
This table is indexed by the concatenation of \{MY_MODID[7:0], INGRESS_PORT[5:0]\} 
 * SIZE:     65
 * FIELDS:
 *     PORT_TYPE        Indicates source port type
 *     TGID             Source port TGID
 *     LPORT_PROFILE_IDX Index to LPORT PROFILE Table.
 *     CLASS_ID         Source port Class ID
 *     VLAN_RANGE_IDX   Source port vlan range table index
 *     RESERVED_28      Reserved
 *     OVID             Per-system port default VLAN
 *     L3_IIF           Per-port default L3 Interface.
 *     VFP_PORT_GROUP_ID VFP port group ID (used in the VFP for grouping ports)
 *     MA_BASE_POINTER   This pointer forms a part of the index to the MA_INDEX Table.
 *     PACKET_MODIFICATION_DISABLE Used to prevent packet modifications in the upstream direction except for MIML encap.
 *     DISABLE_VLAN_CHECKS If set, then spanning tree and VLAN memberships checks are not performed.
 *     EVEN_PARITY      Even parity for the SOURCE_TRUNK_MAP table
 */
#define SOURCE_TRUNK_MAPm_MIN 0
#define SOURCE_TRUNK_MAPm_MAX 511
#define SOURCE_TRUNK_MAPm_CMAX(u) 511
#define SOURCE_TRUNK_MAPm_SIZE 9

/*
 * This structure should be used to declare and program SOURCE_TRUNK_MAP.
 */
typedef union SOURCE_TRUNK_MAPm_s {
	uint32 v[3];
	uint32 source_trunk_map[3];
	uint32 _source_trunk_map;
} SOURCE_TRUNK_MAPm_t;

#define SOURCE_TRUNK_MAPm_CLR(r) sal_memset(&((r)._source_trunk_map), 0, sizeof(SOURCE_TRUNK_MAPm_t))
#define SOURCE_TRUNK_MAPm_SET(r,i,d) (r).source_trunk_map[i] = d
#define SOURCE_TRUNK_MAPm_GET(r,i) (r).source_trunk_map[i]

/*
 * These macros can be used to access individual fields.
 */
#define SOURCE_TRUNK_MAPm_PORT_TYPEf_GET(r) (((r).source_trunk_map[0]) & 0x3)
#define SOURCE_TRUNK_MAPm_PORT_TYPEf_SET(r,f) (r).source_trunk_map[0]=(((r).source_trunk_map[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define SOURCE_TRUNK_MAPm_TGIDf_GET(r) ((((r).source_trunk_map[0]) >> 2) & 0x7f)
#define SOURCE_TRUNK_MAPm_TGIDf_SET(r,f) (r).source_trunk_map[0]=(((r).source_trunk_map[0] & ~((uint32)0x7f << 2)) | ((((uint32)f) & 0x7f) << 2))
#define SOURCE_TRUNK_MAPm_LPORT_PROFILE_IDXf_GET(r) ((((r).source_trunk_map[0]) >> 9) & 0x3f)
#define SOURCE_TRUNK_MAPm_LPORT_PROFILE_IDXf_SET(r,f) (r).source_trunk_map[0]=(((r).source_trunk_map[0] & ~((uint32)0x3f << 9)) | ((((uint32)f) & 0x3f) << 9))
#define SOURCE_TRUNK_MAPm_CLASS_IDf_GET(r) ((((r).source_trunk_map[0]) >> 15) & 0xff)
#define SOURCE_TRUNK_MAPm_CLASS_IDf_SET(r,f) (r).source_trunk_map[0]=(((r).source_trunk_map[0] & ~((uint32)0xff << 15)) | ((((uint32)f) & 0xff) << 15))
#define SOURCE_TRUNK_MAPm_VLAN_RANGE_IDXf_GET(r) ((((r).source_trunk_map[0]) >> 23) & 0x1f)
#define SOURCE_TRUNK_MAPm_VLAN_RANGE_IDXf_SET(r,f) (r).source_trunk_map[0]=(((r).source_trunk_map[0] & ~((uint32)0x1f << 23)) | ((((uint32)f) & 0x1f) << 23))
#define SOURCE_TRUNK_MAPm_RESERVED_28f_GET(r) ((((r).source_trunk_map[0]) >> 28) & 0x3)
#define SOURCE_TRUNK_MAPm_RESERVED_28f_SET(r,f) (r).source_trunk_map[0]=(((r).source_trunk_map[0] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define SOURCE_TRUNK_MAPm_OVIDf_GET(r) field32_get((r).source_trunk_map,30,42)
#define SOURCE_TRUNK_MAPm_OVIDf_SET(r,f) field32_set((r).source_trunk_map,30,42,f)
#define SOURCE_TRUNK_MAPm_L3_IIFf_GET(r) field32_get((r).source_trunk_map,30,34)
#define SOURCE_TRUNK_MAPm_L3_IIFf_SET(r,f) field32_set((r).source_trunk_map,30,34,f)
#define SOURCE_TRUNK_MAPm_VFP_PORT_GROUP_IDf_GET(r) ((((r).source_trunk_map[1]) >> 11) & 0xff)
#define SOURCE_TRUNK_MAPm_VFP_PORT_GROUP_IDf_SET(r,f) (r).source_trunk_map[1]=(((r).source_trunk_map[1] & ~((uint32)0xff << 11)) | ((((uint32)f) & 0xff) << 11))
#define SOURCE_TRUNK_MAPm_MA_BASE_POINTERf_GET(r) ((((r).source_trunk_map[1]) >> 19) & 0x7ff)
#define SOURCE_TRUNK_MAPm_MA_BASE_POINTERf_SET(r,f) (r).source_trunk_map[1]=(((r).source_trunk_map[1] & ~((uint32)0x7ff << 19)) | ((((uint32)f) & 0x7ff) << 19))
#define SOURCE_TRUNK_MAPm_PACKET_MODIFICATION_DISABLEf_GET(r) ((((r).source_trunk_map[1]) >> 30) & 0x1)
#define SOURCE_TRUNK_MAPm_PACKET_MODIFICATION_DISABLEf_SET(r,f) (r).source_trunk_map[1]=(((r).source_trunk_map[1] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define SOURCE_TRUNK_MAPm_DISABLE_VLAN_CHECKSf_GET(r) ((((r).source_trunk_map[1]) >> 31) & 0x1)
#define SOURCE_TRUNK_MAPm_DISABLE_VLAN_CHECKSf_SET(r,f) (r).source_trunk_map[1]=(((r).source_trunk_map[1] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define SOURCE_TRUNK_MAPm_EVEN_PARITYf_GET(r) (((r).source_trunk_map[2]) & 0x1)
#define SOURCE_TRUNK_MAPm_EVEN_PARITYf_SET(r,f) (r).source_trunk_map[2]=(((r).source_trunk_map[2] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access SOURCE_TRUNK_MAP.
 */
#define WRITE_SOURCE_TRUNK_MAPm(u,i,r) bcm5354x_mem_set(u, M_SOURCE_TRUNK_MAP(i), &(r._source_trunk_map), 3)
#define READ_SOURCE_TRUNK_MAPm(u,i,r) bcm5354x_mem_get(u, M_SOURCE_TRUNK_MAP(i), &(r._source_trunk_map), 3)

/*******************************************************************************
 * End of 'SOURCE_TRUNK_MAPm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  STORM_CONTROL_METER_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Per-port configuration and enables for storm control meters
 * SIZE:     32
 * FIELDS:
 *     PACKET_QUANTUM   Number of tokens consumed by each packet when storm control meters are in packet mode (METER_BYTE_MODE=0).
 *     BYTE_MODE        0=Packet-based metering, 1=Byte-based metering.
 *     BCAST_ENABLE     Turn on storm control metering for broadcast packets
 *     KNOWN_L2MC_ENABLE Turn on storm control metering for known L2MC packets
 *     UNKNOWN_L2MC_ENABLE Turn on storm control metering for unknown L2MC packets
 *     KNOWN_IPMC_ENABLE Turn on storm control metering for known IPMC packets
 *     UNKNOWN_IPMC_ENABLE Turn on storm control metering for unknown IPMC packets
 *     DLFBC_ENABLE     Turn on storm control metering for DLF/BC packets
 */
#define STORM_CONTROL_METER_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program STORM_CONTROL_METER_CONFIG.
 */
typedef union STORM_CONTROL_METER_CONFIGr_s {
	uint32 v[1];
	uint32 storm_control_meter_config[1];
	uint32 _storm_control_meter_config;
} STORM_CONTROL_METER_CONFIGr_t;

#define STORM_CONTROL_METER_CONFIGr_CLR(r) (r).storm_control_meter_config[0] = 0
#define STORM_CONTROL_METER_CONFIGr_SET(r,d) (r).storm_control_meter_config[0] = d
#define STORM_CONTROL_METER_CONFIGr_GET(r) (r).storm_control_meter_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define STORM_CONTROL_METER_CONFIGr_PACKET_QUANTUMf_GET(r) (((r).storm_control_meter_config[0]) & 0xfff)
#define STORM_CONTROL_METER_CONFIGr_PACKET_QUANTUMf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define STORM_CONTROL_METER_CONFIGr_BYTE_MODEf_GET(r) ((((r).storm_control_meter_config[0]) >> 12) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_BYTE_MODEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define STORM_CONTROL_METER_CONFIGr_BCAST_ENABLEf_GET(r) ((((r).storm_control_meter_config[0]) >> 13) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_BCAST_ENABLEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define STORM_CONTROL_METER_CONFIGr_KNOWN_L2MC_ENABLEf_GET(r) ((((r).storm_control_meter_config[0]) >> 14) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_KNOWN_L2MC_ENABLEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define STORM_CONTROL_METER_CONFIGr_UNKNOWN_L2MC_ENABLEf_GET(r) ((((r).storm_control_meter_config[0]) >> 15) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_UNKNOWN_L2MC_ENABLEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define STORM_CONTROL_METER_CONFIGr_KNOWN_IPMC_ENABLEf_GET(r) ((((r).storm_control_meter_config[0]) >> 16) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_KNOWN_IPMC_ENABLEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define STORM_CONTROL_METER_CONFIGr_UNKNOWN_IPMC_ENABLEf_GET(r) ((((r).storm_control_meter_config[0]) >> 17) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_UNKNOWN_IPMC_ENABLEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define STORM_CONTROL_METER_CONFIGr_DLFBC_ENABLEf_GET(r) ((((r).storm_control_meter_config[0]) >> 18) & 0x1)
#define STORM_CONTROL_METER_CONFIGr_DLFBC_ENABLEf_SET(r,f) (r).storm_control_meter_config[0]=(((r).storm_control_meter_config[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))

/*
 * These macros can be used to access STORM_CONTROL_METER_CONFIG.
 */
#define WRITE_STORM_CONTROL_METER_CONFIGr(u,p,r) bcm5354x_reg_set(u,R_STORM_CONTROL_METER_CONFIG(p),(r._storm_control_meter_config))
#define READ_STORM_CONTROL_METER_CONFIGr(u,p,r) bcm5354x_reg_get(u,R_STORM_CONTROL_METER_CONFIG(p),&(r._storm_control_meter_config))

/*******************************************************************************
 * End of 'STORM_CONTROL_METER_CONFIGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  SW2_FP_DST_ACTION_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Enable functions when IFP generates a REDIRECT, REPLACE_PBM or OR_PBM action 
 * SIZE:     32
 * FIELDS:
 *     SRC_REMOVAL_EN   Enables L2 Source Knockout
 *     HG_SRC_REMOVAL_EN Enables HiGiG L2 Source Knockout
 *     LAG_RES_EN       Enables Trunk Resolution
 *     HGTRUNK_RES_EN   Enables HiGiG Trunk Resolution
 *     VLAN_CHECK_EN    Enables Ingress VLAN Membership checks
 *     PORT_BLOCK_EN    Enables application of various port block masks
 *     VLAN_BLOCK_EN    Enables application of vlan block masks
 *     SRC_REMOVAL_EN_FOR_REDIRECT_TO_NHI Enables removal of system ingress port from port-bitmap for packets that have been Redirected to a Next-hop index by the IFP.
 */
#define SW2_FP_DST_ACTION_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SW2_FP_DST_ACTION_CONTROL.
 */
typedef union SW2_FP_DST_ACTION_CONTROLr_s {
	uint32 v[1];
	uint32 sw2_fp_dst_action_control[1];
	uint32 _sw2_fp_dst_action_control;
} SW2_FP_DST_ACTION_CONTROLr_t;

#define SW2_FP_DST_ACTION_CONTROLr_CLR(r) (r).sw2_fp_dst_action_control[0] = 0
#define SW2_FP_DST_ACTION_CONTROLr_SET(r,d) (r).sw2_fp_dst_action_control[0] = d
#define SW2_FP_DST_ACTION_CONTROLr_GET(r) (r).sw2_fp_dst_action_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define SW2_FP_DST_ACTION_CONTROLr_SRC_REMOVAL_ENf_GET(r) (((r).sw2_fp_dst_action_control[0]) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_SRC_REMOVAL_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define SW2_FP_DST_ACTION_CONTROLr_HG_SRC_REMOVAL_ENf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 1) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_HG_SRC_REMOVAL_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define SW2_FP_DST_ACTION_CONTROLr_LAG_RES_ENf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 2) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_LAG_RES_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define SW2_FP_DST_ACTION_CONTROLr_HGTRUNK_RES_ENf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 3) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_HGTRUNK_RES_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define SW2_FP_DST_ACTION_CONTROLr_VLAN_CHECK_ENf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 4) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_VLAN_CHECK_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define SW2_FP_DST_ACTION_CONTROLr_PORT_BLOCK_ENf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 5) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_PORT_BLOCK_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define SW2_FP_DST_ACTION_CONTROLr_VLAN_BLOCK_ENf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 6) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_VLAN_BLOCK_ENf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define SW2_FP_DST_ACTION_CONTROLr_SRC_REMOVAL_EN_FOR_REDIRECT_TO_NHIf_GET(r) ((((r).sw2_fp_dst_action_control[0]) >> 7) & 0x1)
#define SW2_FP_DST_ACTION_CONTROLr_SRC_REMOVAL_EN_FOR_REDIRECT_TO_NHIf_SET(r,f) (r).sw2_fp_dst_action_control[0]=(((r).sw2_fp_dst_action_control[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access SW2_FP_DST_ACTION_CONTROL.
 */
#define WRITE_SW2_FP_DST_ACTION_CONTROLr(u,r) bcm5354x_reg_set(u,R_SW2_FP_DST_ACTION_CONTROL,(r._sw2_fp_dst_action_control))
#define READ_SW2_FP_DST_ACTION_CONTROLr(u,r) bcm5354x_reg_get(u,R_SW2_FP_DST_ACTION_CONTROL,&(r._sw2_fp_dst_action_control))

/*******************************************************************************
 * End of 'SW2_FP_DST_ACTION_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  SW2_RAM_CONTROL_4_64
 * BLOCKS:   IPIPE
 * DESC:     Debug Register to drive the TM inputs of internal rams
 * SIZE:     64
 * FIELDS:
 *     CPU_COS_MAP_TCAM_TM 
 *     IP_STATS_MEM_TM  
 *     STATS_MEM_0_TM   
 *     STATS_MEM_1_TM   
 */
#define SW2_RAM_CONTROL_4_64r_SIZE 8

/*
 * This structure should be used to declare and program SW2_RAM_CONTROL_4_64.
 */
typedef union SW2_RAM_CONTROL_4_64r_s {
	uint32 v[2];
	uint32 sw2_ram_control_4_64[2];
	uint32 _sw2_ram_control_4_64;
} SW2_RAM_CONTROL_4_64r_t;

#define SW2_RAM_CONTROL_4_64r_CLR(r) sal_memset(&((r)._sw2_ram_control_4_64), 0, sizeof(SW2_RAM_CONTROL_4_64r_t))
#define SW2_RAM_CONTROL_4_64r_SET(r,i,d) (r).sw2_ram_control_4_64[i] = d
#define SW2_RAM_CONTROL_4_64r_GET(r,i) (r).sw2_ram_control_4_64[i]

/*
 * These macros can be used to access individual fields.
 */
#define SW2_RAM_CONTROL_4_64r_CPU_COS_MAP_TCAM_TMf_GET(r) (((r).sw2_ram_control_4_64[0]) & 0xfffff)
#define SW2_RAM_CONTROL_4_64r_CPU_COS_MAP_TCAM_TMf_SET(r,f) (r).sw2_ram_control_4_64[0]=(((r).sw2_ram_control_4_64[0] & ~((uint32)0xfffff)) | (((uint32)f) & 0xfffff))
#define SW2_RAM_CONTROL_4_64r_IP_STATS_MEM_TMf_GET(r) ((((r).sw2_ram_control_4_64[0]) >> 20) & 0xfff)
#define SW2_RAM_CONTROL_4_64r_IP_STATS_MEM_TMf_SET(r,f) (r).sw2_ram_control_4_64[0]=(((r).sw2_ram_control_4_64[0] & ~((uint32)0xfff << 20)) | ((((uint32)f) & 0xfff) << 20))
#define SW2_RAM_CONTROL_4_64r_STATS_MEM_0_TMf_GET(r) (((r).sw2_ram_control_4_64[1]) & 0xfff)
#define SW2_RAM_CONTROL_4_64r_STATS_MEM_0_TMf_SET(r,f) (r).sw2_ram_control_4_64[1]=(((r).sw2_ram_control_4_64[1] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define SW2_RAM_CONTROL_4_64r_STATS_MEM_1_TMf_GET(r) ((((r).sw2_ram_control_4_64[1]) >> 12) & 0xfff)
#define SW2_RAM_CONTROL_4_64r_STATS_MEM_1_TMf_SET(r,f) (r).sw2_ram_control_4_64[1]=(((r).sw2_ram_control_4_64[1] & ~((uint32)0xfff << 12)) | ((((uint32)f) & 0xfff) << 12))

/*
 * These macros can be used to access SW2_RAM_CONTROL_4_64.
 */
#define WRITE_SW2_RAM_CONTROL_4_64r(u,r) bcm5354x_reg64_set(u,R_SW2_RAM_CONTROL_4_64,&(r._sw2_ram_control_4_64),2)
#define READ_SW2_RAM_CONTROL_4_64r(u,r) bcm5354x_reg64_get(u,R_SW2_RAM_CONTROL_4_64,&(r._sw2_ram_control_4_64),2)

/*******************************************************************************
 * End of 'SW2_RAM_CONTROL_4_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  SYSTEM_CONFIG_TABLE
 * BLOCKS:   IPIPE
 * DESC:     System Port Table.
This table holds fields to further parse HiGig packets.
This table is indexed via \{SRC_MODID[7:0], SRC_PORT[5:0]\}
 * SIZE:     8
 * FIELDS:
 *     OUTER_TPID_ENABLE Indicates if ING_OUTER_TPID[3] to ING_OUTER_TPID[0] are allowed outer TPID values.
 *     INNER_TPID_ENABLE .
 *     MIML_ENABLE      Enable MIML feature.
 *     CUSTOM_HEADER_ENABLE Enable CUSTOME_HEADER feature.
 *     EVEN_PARITY      PARITY BIT to make the entry parity even.
 */
#define SYSTEM_CONFIG_TABLEm_MIN 0
#define SYSTEM_CONFIG_TABLEm_MAX 511
#define SYSTEM_CONFIG_TABLEm_CMAX(u) 511
#define SYSTEM_CONFIG_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program SYSTEM_CONFIG_TABLE.
 */
typedef union SYSTEM_CONFIG_TABLEm_s {
	uint32 v[1];
	uint32 system_config_table[1];
	uint32 _system_config_table;
} SYSTEM_CONFIG_TABLEm_t;

#define SYSTEM_CONFIG_TABLEm_CLR(r) (r).system_config_table[0] = 0
#define SYSTEM_CONFIG_TABLEm_SET(r,d) (r).system_config_table[0] = d
#define SYSTEM_CONFIG_TABLEm_GET(r) (r).system_config_table[0]

/*
 * These macros can be used to access individual fields.
 */
#define SYSTEM_CONFIG_TABLEm_OUTER_TPID_ENABLEf_GET(r) (((r).system_config_table[0]) & 0xf)
#define SYSTEM_CONFIG_TABLEm_OUTER_TPID_ENABLEf_SET(r,f) (r).system_config_table[0]=(((r).system_config_table[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define SYSTEM_CONFIG_TABLEm_INNER_TPID_ENABLEf_GET(r) ((((r).system_config_table[0]) >> 4) & 0x1)
#define SYSTEM_CONFIG_TABLEm_INNER_TPID_ENABLEf_SET(r,f) (r).system_config_table[0]=(((r).system_config_table[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define SYSTEM_CONFIG_TABLEm_MIML_ENABLEf_GET(r) ((((r).system_config_table[0]) >> 5) & 0x1)
#define SYSTEM_CONFIG_TABLEm_MIML_ENABLEf_SET(r,f) (r).system_config_table[0]=(((r).system_config_table[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define SYSTEM_CONFIG_TABLEm_CUSTOM_HEADER_ENABLEf_GET(r) ((((r).system_config_table[0]) >> 6) & 0x1)
#define SYSTEM_CONFIG_TABLEm_CUSTOM_HEADER_ENABLEf_SET(r,f) (r).system_config_table[0]=(((r).system_config_table[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define SYSTEM_CONFIG_TABLEm_EVEN_PARITYf_GET(r) ((((r).system_config_table[0]) >> 7) & 0x1)
#define SYSTEM_CONFIG_TABLEm_EVEN_PARITYf_SET(r,f) (r).system_config_table[0]=(((r).system_config_table[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access SYSTEM_CONFIG_TABLE.
 */
#define WRITE_SYSTEM_CONFIG_TABLEm(u,i,r) bcm5354x_mem_set(u, M_SYSTEM_CONFIG_TABLE(i), &(r._system_config_table), 1)
#define READ_SYSTEM_CONFIG_TABLEm(u,i,r) bcm5354x_mem_get(u, M_SYSTEM_CONFIG_TABLE(i), &(r._system_config_table), 1)

/*******************************************************************************
 * End of 'SYSTEM_CONFIG_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_CLOCKING_ENFORCE_PSG
 * BLOCKS:   TOP
 * DESC:     TOP CLOCKING_ENFORCE_PSG Register
 * SIZE:     32
 * FIELDS:
 *     L3MC_PSG         L3MC clocking enforce PSG
 *     ICFG_PSG         ICFG clocking enforce PSG
 *     IDISC_PSG        IDISC clocking enforce PSG
 *     IFP_PSG          IFP clocking enforce PSG
 *     IVLAN_PSG        IVLAN clocking enforce PSG
 *     IPARS_PSG        IPARS clocking enforce PSG
 *     IRSEL1_PSG       IRSEL1 clocking enforce PSG
 *     IRSEL2_PSG       IRSEL2 clocking enforce PSG
 *     ISW1_PSG         ISW1 clocking enforce PSG
 *     ECFG_PSG         ECFG clocking enforce PSG
 *     IVXLT_PSG        IVXLT clocking enforce PSG
 *     EPARS_PSG        EPARS clocking enforce PSG
 *     EFP_PSG          EFP clocking enforce PSG
 *     EFPMOD_PSG       EFPMOD clocking enforce PSG
 *     EFPPARS_PSG      EFPPARS clocking enforce PSG
 *     EHCPM_PSG        EHCPM clocking enforce PSG
 *     EINITBUF_PSG     EINITBUF clocking enforce PSG
 *     EVXLT_PSG        EVXLT clocking enforce PSG
 *     EL3_PSG          EL3 clocking enforce PSG
 *     EPMOD_PSG        EPMOD clocking enforce PSG
 *     ESW_PSG          ESW clocking enforce PSG
 *     EVLAN_PSG        EVLAN clocking enforce PSG
 *     L2LU_CLK_ENFORCE L2LU clocking enforce PSG
 *     L2MC_CLK_ENFORCE L2MC clocking enforce PSG
 *     RSVD_24          Reserved
 *     CLK_ENFORCE      clocking enforce
 *     RSVD_26          Reserved
 */
#define TOP_CLOCKING_ENFORCE_PSGr_SIZE 4

/*
 * This structure should be used to declare and program TOP_CLOCKING_ENFORCE_PSG.
 */
typedef union TOP_CLOCKING_ENFORCE_PSGr_s {
	uint32 v[1];
	uint32 top_clocking_enforce_psg[1];
	uint32 _top_clocking_enforce_psg;
} TOP_CLOCKING_ENFORCE_PSGr_t;

#define TOP_CLOCKING_ENFORCE_PSGr_CLR(r) (r).top_clocking_enforce_psg[0] = 0
#define TOP_CLOCKING_ENFORCE_PSGr_SET(r,d) (r).top_clocking_enforce_psg[0] = d
#define TOP_CLOCKING_ENFORCE_PSGr_GET(r) (r).top_clocking_enforce_psg[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_CLOCKING_ENFORCE_PSGr_L3MC_PSGf_GET(r) (((r).top_clocking_enforce_psg[0]) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_L3MC_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_CLOCKING_ENFORCE_PSGr_ICFG_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 1) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_ICFG_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TOP_CLOCKING_ENFORCE_PSGr_IDISC_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 2) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IDISC_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define TOP_CLOCKING_ENFORCE_PSGr_IFP_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 3) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IFP_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define TOP_CLOCKING_ENFORCE_PSGr_IVLAN_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 4) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IVLAN_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define TOP_CLOCKING_ENFORCE_PSGr_IPARS_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 5) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IPARS_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define TOP_CLOCKING_ENFORCE_PSGr_IRSEL1_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 6) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IRSEL1_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define TOP_CLOCKING_ENFORCE_PSGr_IRSEL2_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 7) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IRSEL2_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define TOP_CLOCKING_ENFORCE_PSGr_ISW1_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 8) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_ISW1_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define TOP_CLOCKING_ENFORCE_PSGr_ECFG_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 9) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_ECFG_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_CLOCKING_ENFORCE_PSGr_IVXLT_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 10) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_IVXLT_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define TOP_CLOCKING_ENFORCE_PSGr_EPARS_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 11) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EPARS_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define TOP_CLOCKING_ENFORCE_PSGr_EFP_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 12) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EFP_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define TOP_CLOCKING_ENFORCE_PSGr_EFPMOD_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 13) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EFPMOD_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define TOP_CLOCKING_ENFORCE_PSGr_EFPPARS_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 14) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EFPPARS_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define TOP_CLOCKING_ENFORCE_PSGr_EHCPM_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 15) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EHCPM_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define TOP_CLOCKING_ENFORCE_PSGr_EINITBUF_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 16) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EINITBUF_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define TOP_CLOCKING_ENFORCE_PSGr_EVXLT_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 17) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EVXLT_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define TOP_CLOCKING_ENFORCE_PSGr_EL3_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 18) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EL3_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define TOP_CLOCKING_ENFORCE_PSGr_EPMOD_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 19) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EPMOD_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define TOP_CLOCKING_ENFORCE_PSGr_ESW_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 20) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_ESW_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define TOP_CLOCKING_ENFORCE_PSGr_EVLAN_PSGf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 21) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_EVLAN_PSGf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define TOP_CLOCKING_ENFORCE_PSGr_L2LU_CLK_ENFORCEf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 22) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_L2LU_CLK_ENFORCEf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define TOP_CLOCKING_ENFORCE_PSGr_L2MC_CLK_ENFORCEf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 23) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_L2MC_CLK_ENFORCEf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define TOP_CLOCKING_ENFORCE_PSGr_RSVD_24f_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 24) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_RSVD_24f_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define TOP_CLOCKING_ENFORCE_PSGr_CLK_ENFORCEf_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 25) & 0x1)
#define TOP_CLOCKING_ENFORCE_PSGr_CLK_ENFORCEf_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define TOP_CLOCKING_ENFORCE_PSGr_RSVD_26f_GET(r) ((((r).top_clocking_enforce_psg[0]) >> 26) & 0x3f)
#define TOP_CLOCKING_ENFORCE_PSGr_RSVD_26f_SET(r,f) (r).top_clocking_enforce_psg[0]=(((r).top_clocking_enforce_psg[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access TOP_CLOCKING_ENFORCE_PSG.
 */
#define WRITE_TOP_CLOCKING_ENFORCE_PSGr(u,r) bcm5354x_reg_set(u,R_TOP_CLOCKING_ENFORCE_PSG,(r._top_clocking_enforce_psg))
#define READ_TOP_CLOCKING_ENFORCE_PSGr(u,r) bcm5354x_reg_get(u,R_TOP_CLOCKING_ENFORCE_PSG,&(r._top_clocking_enforce_psg))

/*******************************************************************************
 * End of 'TOP_CLOCKING_ENFORCE_PSGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_CORE_PLL_CTRL4
 * BLOCKS:   TOP
 * DESC:     TOP_CORE_PLL_CTRL4(MSTR_PLL_CTRL2)
 * SIZE:     32
 * FIELDS:
 *     MSTR_PDIV                        input reference clock pre-divider control, default is 1 (decimal)                    0001 = divide by 1                    0010 = divide by 2                    ....                    1111 = divide by 15                    0000 = divide by 16                Note: When strap_xtal_freq_sel is set to 1'b1 for 50MHz XTAL reference clock output, the effective pdiv would be automatically multiplied by 2 from this register for pll.
 *     MSTR_CH0_MDIV                    Post-divider ratio of channel-0, default is 10 (decimal)                    00000000= 256                    00000001= 1                    00000010= 2                    00000011= 3                    :                    :                    11111101= 253                    11111110= 254                    11111111= 255
 *     MSTR_CH0_MDEL                    Programmable delay for post-divider channel-0 (1/2VCO period steps)                    000= NO delay                    001= one VCO period delay                    others = useless
 *     MSTR_CH1_MDIV                    Post-divider ratio of channel-0, default is 24 (decimal)                    00000000= 256                    00000001= 1                    00000010= 2                    00000011= 3                    :                    :                    11111101= 253                    11111110= 254                    11111111= 255
 *     MSTR_CH1_MDEL                    Programmable delay for post-divider channel-1 (1/2VCO period steps)                    000= NO delay                    001= one VCO period delay                    others = useless
 *     RSVD             Reserved
 */
#define TOP_CORE_PLL_CTRL4r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CORE_PLL_CTRL4.
 */
typedef union TOP_CORE_PLL_CTRL4r_s {
	uint32 v[1];
	uint32 top_core_pll_ctrl4[1];
	uint32 _top_core_pll_ctrl4;
} TOP_CORE_PLL_CTRL4r_t;

#define TOP_CORE_PLL_CTRL4r_CLR(r) (r).top_core_pll_ctrl4[0] = 0
#define TOP_CORE_PLL_CTRL4r_SET(r,d) (r).top_core_pll_ctrl4[0] = d
#define TOP_CORE_PLL_CTRL4r_GET(r) (r).top_core_pll_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_CORE_PLL_CTRL4r_MSTR_PDIVf_GET(r) (((r).top_core_pll_ctrl4[0]) & 0xf)
#define TOP_CORE_PLL_CTRL4r_MSTR_PDIVf_SET(r,f) (r).top_core_pll_ctrl4[0]=(((r).top_core_pll_ctrl4[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define TOP_CORE_PLL_CTRL4r_MSTR_CH0_MDIVf_GET(r) ((((r).top_core_pll_ctrl4[0]) >> 4) & 0xff)
#define TOP_CORE_PLL_CTRL4r_MSTR_CH0_MDIVf_SET(r,f) (r).top_core_pll_ctrl4[0]=(((r).top_core_pll_ctrl4[0] & ~((uint32)0xff << 4)) | ((((uint32)f) & 0xff) << 4))
#define TOP_CORE_PLL_CTRL4r_MSTR_CH0_MDELf_GET(r) ((((r).top_core_pll_ctrl4[0]) >> 12) & 0x7)
#define TOP_CORE_PLL_CTRL4r_MSTR_CH0_MDELf_SET(r,f) (r).top_core_pll_ctrl4[0]=(((r).top_core_pll_ctrl4[0] & ~((uint32)0x7 << 12)) | ((((uint32)f) & 0x7) << 12))
#define TOP_CORE_PLL_CTRL4r_MSTR_CH1_MDIVf_GET(r) ((((r).top_core_pll_ctrl4[0]) >> 15) & 0xff)
#define TOP_CORE_PLL_CTRL4r_MSTR_CH1_MDIVf_SET(r,f) (r).top_core_pll_ctrl4[0]=(((r).top_core_pll_ctrl4[0] & ~((uint32)0xff << 15)) | ((((uint32)f) & 0xff) << 15))
#define TOP_CORE_PLL_CTRL4r_MSTR_CH1_MDELf_GET(r) ((((r).top_core_pll_ctrl4[0]) >> 23) & 0x7)
#define TOP_CORE_PLL_CTRL4r_MSTR_CH1_MDELf_SET(r,f) (r).top_core_pll_ctrl4[0]=(((r).top_core_pll_ctrl4[0] & ~((uint32)0x7 << 23)) | ((((uint32)f) & 0x7) << 23))
#define TOP_CORE_PLL_CTRL4r_RSVDf_GET(r) ((((r).top_core_pll_ctrl4[0]) >> 26) & 0x3f)
#define TOP_CORE_PLL_CTRL4r_RSVDf_SET(r,f) (r).top_core_pll_ctrl4[0]=(((r).top_core_pll_ctrl4[0] & ~((uint32)0x3f << 26)) | ((((uint32)f) & 0x3f) << 26))

/*
 * These macros can be used to access TOP_CORE_PLL_CTRL4.
 */
#define WRITE_TOP_CORE_PLL_CTRL4r(u,r) bcm5354x_reg_set(u,R_TOP_CORE_PLL_CTRL4,(r._top_core_pll_ctrl4))
#define READ_TOP_CORE_PLL_CTRL4r(u,r) bcm5354x_reg_get(u,R_TOP_CORE_PLL_CTRL4,&(r._top_core_pll_ctrl4))

/*******************************************************************************
 * End of 'TOP_CORE_PLL_CTRL4r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_MISC_CONTROL_1
 * BLOCKS:   TOP
 * DESC:     TOP Misc Control Register 1
 * SIZE:     32
 * FIELDS:
 *     XG_PLL0_PWRDWN   LCPLL0 power down
 *     BS_PLL0_PWRDWN   BSPLL0 power down
 *     GXPORT_EEE_POWERDOWN_EN Enable gxport EEE Powerdown.
 *     OSC_TEST_ENABLE  set this bit to enable OSC test
 *     CMIC_TO_CORE_PLL_LOAD set this bit to enable SW overwrite to CORE PLL value
 *     CMIC_TO_TS_PLL_LOAD set this bit to enable SW overwrite to TS PLL value
 *     CMIC_TO_XG_PLL0_SW_OVWR set this bit to enable SW overwrite to LCPLL0 settings
 *     CMIC_TO_BS_PLL0_SW_OVWR set this bit to enable SW overwrite to BSPLL0 settings
 *     XTAL_DRV_CUR     50ohm driver current control
 *     XTAL_PD_DRV      50 ohm Driver Power Down
 *     IO_IND_CTRL      Control ind of io pad BHV28HPMF22_D33_THP. For ATE IO characterization only
 *     IO_HYS_EN_CTRL   Control hys_en of io pad BHV28HPMF22_D33_THP. For ATE IO characterization only
 *     IO_SEL0_CTRL     Control sel0 of io pad BHV28HPMF22_D33_THP. For ATE IO characterization only
 *     IO_SEL1_CTRL     Control sel1 of io pad BHV28HPMF22_D33_THP. For ATE IO characterization only
 *     IO_SEL2_CTRL     Control sel2 of io pad BHV28HPMF22_D33_THP. For ATE IO characterization only
 *     IO_SRC_CTRL      Control src of io pad BHV28HPMF22_D33_THP. For ATE IO characterization only
 */
#define TOP_MISC_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program TOP_MISC_CONTROL_1.
 */
typedef union TOP_MISC_CONTROL_1r_s {
	uint32 v[1];
	uint32 top_misc_control_1[1];
	uint32 _top_misc_control_1;
} TOP_MISC_CONTROL_1r_t;

#define TOP_MISC_CONTROL_1r_CLR(r) (r).top_misc_control_1[0] = 0
#define TOP_MISC_CONTROL_1r_SET(r,d) (r).top_misc_control_1[0] = d
#define TOP_MISC_CONTROL_1r_GET(r) (r).top_misc_control_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_MISC_CONTROL_1r_XG_PLL0_PWRDWNf_GET(r) (((r).top_misc_control_1[0]) & 0x1)
#define TOP_MISC_CONTROL_1r_XG_PLL0_PWRDWNf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_MISC_CONTROL_1r_BS_PLL0_PWRDWNf_GET(r) ((((r).top_misc_control_1[0]) >> 2) & 0x1)
#define TOP_MISC_CONTROL_1r_BS_PLL0_PWRDWNf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define TOP_MISC_CONTROL_1r_GXPORT_EEE_POWERDOWN_ENf_GET(r) ((((r).top_misc_control_1[0]) >> 4) & 0x3)
#define TOP_MISC_CONTROL_1r_GXPORT_EEE_POWERDOWN_ENf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define TOP_MISC_CONTROL_1r_OSC_TEST_ENABLEf_GET(r) ((((r).top_misc_control_1[0]) >> 10) & 0x1)
#define TOP_MISC_CONTROL_1r_OSC_TEST_ENABLEf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define TOP_MISC_CONTROL_1r_CMIC_TO_CORE_PLL_LOADf_GET(r) ((((r).top_misc_control_1[0]) >> 11) & 0x1)
#define TOP_MISC_CONTROL_1r_CMIC_TO_CORE_PLL_LOADf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define TOP_MISC_CONTROL_1r_CMIC_TO_TS_PLL_LOADf_GET(r) ((((r).top_misc_control_1[0]) >> 12) & 0x1)
#define TOP_MISC_CONTROL_1r_CMIC_TO_TS_PLL_LOADf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define TOP_MISC_CONTROL_1r_CMIC_TO_XG_PLL0_SW_OVWRf_GET(r) ((((r).top_misc_control_1[0]) >> 13) & 0x1)
#define TOP_MISC_CONTROL_1r_CMIC_TO_XG_PLL0_SW_OVWRf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define TOP_MISC_CONTROL_1r_CMIC_TO_BS_PLL0_SW_OVWRf_GET(r) ((((r).top_misc_control_1[0]) >> 15) & 0x1)
#define TOP_MISC_CONTROL_1r_CMIC_TO_BS_PLL0_SW_OVWRf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define TOP_MISC_CONTROL_1r_XTAL_DRV_CURf_GET(r) ((((r).top_misc_control_1[0]) >> 23) & 0x3)
#define TOP_MISC_CONTROL_1r_XTAL_DRV_CURf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x3 << 23)) | ((((uint32)f) & 0x3) << 23))
#define TOP_MISC_CONTROL_1r_XTAL_PD_DRVf_GET(r) ((((r).top_misc_control_1[0]) >> 25) & 0x1)
#define TOP_MISC_CONTROL_1r_XTAL_PD_DRVf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 25)) | ((((uint32)f) & 0x1) << 25))
#define TOP_MISC_CONTROL_1r_IO_IND_CTRLf_GET(r) ((((r).top_misc_control_1[0]) >> 26) & 0x1)
#define TOP_MISC_CONTROL_1r_IO_IND_CTRLf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 26)) | ((((uint32)f) & 0x1) << 26))
#define TOP_MISC_CONTROL_1r_IO_HYS_EN_CTRLf_GET(r) ((((r).top_misc_control_1[0]) >> 27) & 0x1)
#define TOP_MISC_CONTROL_1r_IO_HYS_EN_CTRLf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define TOP_MISC_CONTROL_1r_IO_SEL0_CTRLf_GET(r) ((((r).top_misc_control_1[0]) >> 28) & 0x1)
#define TOP_MISC_CONTROL_1r_IO_SEL0_CTRLf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define TOP_MISC_CONTROL_1r_IO_SEL1_CTRLf_GET(r) ((((r).top_misc_control_1[0]) >> 29) & 0x1)
#define TOP_MISC_CONTROL_1r_IO_SEL1_CTRLf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define TOP_MISC_CONTROL_1r_IO_SEL2_CTRLf_GET(r) ((((r).top_misc_control_1[0]) >> 30) & 0x1)
#define TOP_MISC_CONTROL_1r_IO_SEL2_CTRLf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define TOP_MISC_CONTROL_1r_IO_SRC_CTRLf_GET(r) ((((r).top_misc_control_1[0]) >> 31) & 0x1)
#define TOP_MISC_CONTROL_1r_IO_SRC_CTRLf_SET(r,f) (r).top_misc_control_1[0]=(((r).top_misc_control_1[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))

/*
 * These macros can be used to access TOP_MISC_CONTROL_1.
 */
#define WRITE_TOP_MISC_CONTROL_1r(u,r) bcm5354x_reg_set(u,R_TOP_MISC_CONTROL_1,(r._top_misc_control_1))
#define READ_TOP_MISC_CONTROL_1r(u,r) bcm5354x_reg_get(u,R_TOP_MISC_CONTROL_1,&(r._top_misc_control_1))

/*******************************************************************************
 * End of 'TOP_MISC_CONTROL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_MISC_CONTROL_3
 * BLOCKS:   TOP
 * DESC:     TOP Miscellaneous Control Register 3
 * SIZE:     32
 * FIELDS:
 *     XG0_LCPLL_HO_BYP_ENABLE XG0 LCPLL holdoverlogic bypass enable
 *     XG1_LCPLL_HO_BYP_ENABLE XG1 LCPLL holdoverlogic bypass enable
 *     BROAD_SYNC0_LCPLL_HO_BYP_ENABLE Broad Sync -0 LCPLL holdoverlogic bypass enable
 *     BROAD_SYNC1_LCPLL_HO_BYP_ENABLE Broad Sync -1 LCPLL holdoverlogic bypass enable
 *     LCPLL_RSTFSM_STATE Holds the LCPLL reset finite state machine (FSM) current state
 *     SW_TAP_DIS       1: Disable SW TAP master drives LVTAP. FOR TEST ONLY
 *     GPORT_MIRROR     mirror gport physical port number when set to 1, [0] for gport0, [1] for gport1
 *     GPIO_FOR_UPI_EN  Enable GPIO8~4 for UPI access.
 *     RVD              Reserved
 */
#define TOP_MISC_CONTROL_3r_SIZE 4

/*
 * This structure should be used to declare and program TOP_MISC_CONTROL_3.
 */
typedef union TOP_MISC_CONTROL_3r_s {
	uint32 v[1];
	uint32 top_misc_control_3[1];
	uint32 _top_misc_control_3;
} TOP_MISC_CONTROL_3r_t;

#define TOP_MISC_CONTROL_3r_CLR(r) (r).top_misc_control_3[0] = 0
#define TOP_MISC_CONTROL_3r_SET(r,d) (r).top_misc_control_3[0] = d
#define TOP_MISC_CONTROL_3r_GET(r) (r).top_misc_control_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_MISC_CONTROL_3r_XG0_LCPLL_HO_BYP_ENABLEf_GET(r) (((r).top_misc_control_3[0]) & 0x1)
#define TOP_MISC_CONTROL_3r_XG0_LCPLL_HO_BYP_ENABLEf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_MISC_CONTROL_3r_XG1_LCPLL_HO_BYP_ENABLEf_GET(r) ((((r).top_misc_control_3[0]) >> 1) & 0x1)
#define TOP_MISC_CONTROL_3r_XG1_LCPLL_HO_BYP_ENABLEf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TOP_MISC_CONTROL_3r_BROAD_SYNC0_LCPLL_HO_BYP_ENABLEf_GET(r) ((((r).top_misc_control_3[0]) >> 2) & 0x1)
#define TOP_MISC_CONTROL_3r_BROAD_SYNC0_LCPLL_HO_BYP_ENABLEf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define TOP_MISC_CONTROL_3r_BROAD_SYNC1_LCPLL_HO_BYP_ENABLEf_GET(r) ((((r).top_misc_control_3[0]) >> 3) & 0x1)
#define TOP_MISC_CONTROL_3r_BROAD_SYNC1_LCPLL_HO_BYP_ENABLEf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define TOP_MISC_CONTROL_3r_LCPLL_RSTFSM_STATEf_GET(r) ((((r).top_misc_control_3[0]) >> 4) & 0x7)
#define TOP_MISC_CONTROL_3r_LCPLL_RSTFSM_STATEf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x7 << 4)) | ((((uint32)f) & 0x7) << 4))
#define TOP_MISC_CONTROL_3r_SW_TAP_DISf_GET(r) ((((r).top_misc_control_3[0]) >> 7) & 0x1)
#define TOP_MISC_CONTROL_3r_SW_TAP_DISf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define TOP_MISC_CONTROL_3r_GPORT_MIRRORf_GET(r) ((((r).top_misc_control_3[0]) >> 8) & 0x3)
#define TOP_MISC_CONTROL_3r_GPORT_MIRRORf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define TOP_MISC_CONTROL_3r_GPIO_FOR_UPI_ENf_GET(r) ((((r).top_misc_control_3[0]) >> 29) & 0x1)
#define TOP_MISC_CONTROL_3r_GPIO_FOR_UPI_ENf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x1 << 29)) | ((((uint32)f) & 0x1) << 29))
#define TOP_MISC_CONTROL_3r_RVDf_GET(r) ((((r).top_misc_control_3[0]) >> 30) & 0x3)
#define TOP_MISC_CONTROL_3r_RVDf_SET(r,f) (r).top_misc_control_3[0]=(((r).top_misc_control_3[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))

/*
 * These macros can be used to access TOP_MISC_CONTROL_3.
 */
#define WRITE_TOP_MISC_CONTROL_3r(u,r) bcm5354x_reg_set(u,R_TOP_MISC_CONTROL_3,(r._top_misc_control_3))
#define READ_TOP_MISC_CONTROL_3r(u,r) bcm5354x_reg_get(u,R_TOP_MISC_CONTROL_3,&(r._top_misc_control_3))

/*******************************************************************************
 * End of 'TOP_MISC_CONTROL_3r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_MISC_STATUS
 * BLOCKS:   TOP
 * DESC:     TOP Misc Status  Register
 * SIZE:     32
 * FIELDS:
 *     RSVD_1           Reserved 
 *     QGPHY_PLL_LOCK   Reserved 
 *     RSVD_0           Reserved
 *     TEST_STATUS_SEL  send the 16bits test status result to IO pad
 *     TEST_STATUS      [31:28] pullup enable for CMICD GPIO, [27:24] pull down enable fo CMICD GPIO; [23:16] reserved
 */
#define TOP_MISC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TOP_MISC_STATUS.
 */
typedef union TOP_MISC_STATUSr_s {
	uint32 v[1];
	uint32 top_misc_status[1];
	uint32 _top_misc_status;
} TOP_MISC_STATUSr_t;

#define TOP_MISC_STATUSr_CLR(r) (r).top_misc_status[0] = 0
#define TOP_MISC_STATUSr_SET(r,d) (r).top_misc_status[0] = d
#define TOP_MISC_STATUSr_GET(r) (r).top_misc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_MISC_STATUSr_RSVD_1f_GET(r) (((r).top_misc_status[0]) & 0x1)
#define TOP_MISC_STATUSr_RSVD_1f_SET(r,f) (r).top_misc_status[0]=(((r).top_misc_status[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_MISC_STATUSr_QGPHY_PLL_LOCKf_GET(r) ((((r).top_misc_status[0]) >> 1) & 0x3f)
#define TOP_MISC_STATUSr_QGPHY_PLL_LOCKf_SET(r,f) (r).top_misc_status[0]=(((r).top_misc_status[0] & ~((uint32)0x3f << 1)) | ((((uint32)f) & 0x3f) << 1))
#define TOP_MISC_STATUSr_RSVD_0f_GET(r) ((((r).top_misc_status[0]) >> 7) & 0xff)
#define TOP_MISC_STATUSr_RSVD_0f_SET(r,f) (r).top_misc_status[0]=(((r).top_misc_status[0] & ~((uint32)0xff << 7)) | ((((uint32)f) & 0xff) << 7))
#define TOP_MISC_STATUSr_TEST_STATUS_SELf_GET(r) ((((r).top_misc_status[0]) >> 15) & 0x1)
#define TOP_MISC_STATUSr_TEST_STATUS_SELf_SET(r,f) (r).top_misc_status[0]=(((r).top_misc_status[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define TOP_MISC_STATUSr_TEST_STATUSf_GET(r) ((((r).top_misc_status[0]) >> 16) & 0xffff)
#define TOP_MISC_STATUSr_TEST_STATUSf_SET(r,f) (r).top_misc_status[0]=(((r).top_misc_status[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access TOP_MISC_STATUS.
 */
#define WRITE_TOP_MISC_STATUSr(u,r) bcm5354x_reg_set(u,R_TOP_MISC_STATUS,(r._top_misc_status))
#define READ_TOP_MISC_STATUSr(u,r) bcm5354x_reg_get(u,R_TOP_MISC_STATUS,&(r._top_misc_status))

/*******************************************************************************
 * End of 'TOP_MISC_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_PVTMON_CTRL_0
 * BLOCKS:   TOP
 * DESC:     PVT Monitor Control Register 0
 * SIZE:     32
 * FIELDS:
 *     BG_ADJ           Bandgap Voltage (Vbg) adjustment.111:Vbg=1.226V110:Vbg=1.220V101:Vbg=1.215V100:Vbg=1.211V000:Vbg=1.205V001:Vbg=1.200V010:Vbg=1.195V011:Vbg=1.191Voutput voltage step size Vbg_u = Vbg/241 =5mV (nom)
 *     VTEST_SEL        Select one of the 16 internal test voltages (Vtest) for a quick ADC test.0000: Vtest = i_VDDC * 1/200001: Vtest = i_VDDC * 2/20...1111: Vtest = i_VDDC * 16/20
 *     RMON_SEL         Resistor monitor select111: external resistor110: reserved101: internal resistor (width=1u, Horizontal)100: internal resistor (width=1u, Vertical)011: internal resistor (width=0.5u, Horizontal)010: internal resistor (width=0.5u, Vertical)001: internal resistor (width=0.25u, Horizontal)000: internal resistor (width=0.25u, Vertical)
 *     FUNC_MODE        Function mode control000: VTMON only001: VTMON and DAC010: Burn-in CLKGEN011: DAC drives both pads (AVS control)100: ADC measures external input on pad_ADC101: ADC measures DAC output110: RMON111: expert mode (controlled by i_ctrl<17:13>)
 *     ADC_IN_SEL       effective only when i_ctrl<12:10>=3'b111ADC input select00: VTMON output01: external input on pad_ADC10: DAC output11: RMON output
 *     DAC_EN           effective only when i_ctrl<12:10>=3'b111Enable DAC when high
 *     CON_PAD          effective only when i_ctrl<12:10>=3'b111connect pad_DAC and pad_ADC when high
 *     BURNIN_EN        effective only when i_ctrl<12:10>=3'b111Enable Burn-in CLKGEN when high
 *     RSVD             Reserved
 *     VDDCMON_REFADJ_MAX1 Adjustment of VDDCMON voltage threshold: Vmax1.    Vbg_u is the Bandgap voltage step size (nom.=5mV, see i_ctrl<2:0>)Vmax11 : 227*Vbg_u (1.135V)0 : 220*Vbg_u (1.100V)
 *     VDDCMON_REFADJ_MIN0 Adjustment of VDDCMON voltage thresholds: Vwarn0 and Vmin0. Vbg is the Bandgap voltage (see i_ctrl<2:0>)Vwarn0 (Default) Vmin0 (Default)1111: 186*Vbg/240 (0.930V) 178*Vbg/240 (0.890V)1110: 184*Vbg/240 (0.920V) 176*Vbg/240 (0.880V)1101: 182*Vbg/240 (0.910V) 174*Vbg/240 (0.870V)1100: 180*Vbg/240 (0.900V) 172*Vbg/240 (0.860V)1011: 178*Vbg/240 (0.890V) 170*Vbg/240 (0.850V)1010: 176*Vbg/240 (0.880V) 168*Vbg/240 (0.840V)1001: 174*Vbg/240 (0.870V) 166*Vbg/240 (0.830V)1000: 172*Vbg/240 (0.860V) 164*Vbg/240 (0.820V)0000: 170*Vbg/240 (0.850V) 162*Vbg/240 (0.810V)0001: 168*Vbg/240 (0.840V) 160*Vbg/240 (0.800V)0010: 166*Vbg/240 (0.830V) 158*Vbg/240 (0.790V)0011: 164*Vbg/240 (0.820V) 156*Vbg/240 (0.780V)0100: 162*Vbg/240 (0.810V) 154*Vbg/240 (0.770V)0101: 160*Vbg/240 (0.800V) 152*Vbg/240 (0.760V)0110: 158*Vbg/240 (0.790V) 150*Vbg/240 (0.750V)0111: 156*Vbg/240 (0.780V) 148*Vbg/240 (0.740V)
 *     VDDCMON_REFADJ_MIN1 Adjustment of VDDCMON voltage thresholds: Vwarn1 and Vmin1. Vbg is the Bandgap voltage (see i_ctrl<2:0>)Vwarn1 (Default) Vmin1 (Default)111: 176*Vbg/240 (0.880V) 168*Vbg/240 (0.840V)110: 174*Vbg/240 (0.870V) 166*Vbg/240 (0.830V)101: 172*Vbg/240 (0.860V) 164*Vbg/240 (0.820V)100: 171*Vbg/240 (0.855V) 163*Vbg/240 (0.815V)000: 170*Vbg/240 (0.850V) 162*Vbg/240 (0.810V)001: 169*Vbg/240 (0.845V) 161*Vbg/240 (0.805V)010: 168*Vbg/240 (0.840V) 160*Vbg/240 (0.800V)011: 166*Vbg/240 (0.830V) 158*Vbg/240 (0.790V)
 *     DAC_RESET        Force DAC output voltage to min, high active
 *     DAC_SET          Force DAC output voltage to max, high active
 *     VDDCMON_REFADJ_MAX Adjustment of VDDCMON voltage threshold: Vmax0.Vbg is the Bandgap voltage (see i_ctrl<2:0>)Vmax1 (Default) = 220*Vbg/240 (1.10V)Vmax0 (Default)111: 194*Vbg/240 (0.970V)110: 192*Vbg/240 (0.960V)101: 190*Vbg/240 (0.950V)100: 189*Vbg/240 (0.945V)000: 188*Vbg/240 (0.940V)001: 187*Vbg/240 (0.935V)010: 186*Vbg/240 (0.930V)011: 184*Vbg/240 (0.920V)
 */
#define TOP_PVTMON_CTRL_0r_SIZE 4

/*
 * This structure should be used to declare and program TOP_PVTMON_CTRL_0.
 */
typedef union TOP_PVTMON_CTRL_0r_s {
	uint32 v[1];
	uint32 top_pvtmon_ctrl_0[1];
	uint32 _top_pvtmon_ctrl_0;
} TOP_PVTMON_CTRL_0r_t;

#define TOP_PVTMON_CTRL_0r_CLR(r) (r).top_pvtmon_ctrl_0[0] = 0
#define TOP_PVTMON_CTRL_0r_SET(r,d) (r).top_pvtmon_ctrl_0[0] = d
#define TOP_PVTMON_CTRL_0r_GET(r) (r).top_pvtmon_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_PVTMON_CTRL_0r_BG_ADJf_GET(r) (((r).top_pvtmon_ctrl_0[0]) & 0x7)
#define TOP_PVTMON_CTRL_0r_BG_ADJf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x7)) | (((uint32)f) & 0x7))
#define TOP_PVTMON_CTRL_0r_VTEST_SELf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 3) & 0xf)
#define TOP_PVTMON_CTRL_0r_VTEST_SELf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0xf << 3)) | ((((uint32)f) & 0xf) << 3))
#define TOP_PVTMON_CTRL_0r_RMON_SELf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 7) & 0x7)
#define TOP_PVTMON_CTRL_0r_RMON_SELf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x7 << 7)) | ((((uint32)f) & 0x7) << 7))
#define TOP_PVTMON_CTRL_0r_FUNC_MODEf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 10) & 0x7)
#define TOP_PVTMON_CTRL_0r_FUNC_MODEf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x7 << 10)) | ((((uint32)f) & 0x7) << 10))
#define TOP_PVTMON_CTRL_0r_ADC_IN_SELf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 13) & 0x3)
#define TOP_PVTMON_CTRL_0r_ADC_IN_SELf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x3 << 13)) | ((((uint32)f) & 0x3) << 13))
#define TOP_PVTMON_CTRL_0r_DAC_ENf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 15) & 0x1)
#define TOP_PVTMON_CTRL_0r_DAC_ENf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define TOP_PVTMON_CTRL_0r_CON_PADf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 16) & 0x1)
#define TOP_PVTMON_CTRL_0r_CON_PADf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define TOP_PVTMON_CTRL_0r_BURNIN_ENf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 17) & 0x1)
#define TOP_PVTMON_CTRL_0r_BURNIN_ENf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define TOP_PVTMON_CTRL_0r_RSVDf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 18) & 0x1)
#define TOP_PVTMON_CTRL_0r_RSVDf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MAX1f_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 19) & 0x1)
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MAX1f_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MIN0f_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 20) & 0xf)
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MIN0f_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MIN1f_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 24) & 0x7)
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MIN1f_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x7 << 24)) | ((((uint32)f) & 0x7) << 24))
#define TOP_PVTMON_CTRL_0r_DAC_RESETf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 27) & 0x1)
#define TOP_PVTMON_CTRL_0r_DAC_RESETf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 27)) | ((((uint32)f) & 0x1) << 27))
#define TOP_PVTMON_CTRL_0r_DAC_SETf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 28) & 0x1)
#define TOP_PVTMON_CTRL_0r_DAC_SETf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x1 << 28)) | ((((uint32)f) & 0x1) << 28))
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MAXf_GET(r) ((((r).top_pvtmon_ctrl_0[0]) >> 29) & 0x7)
#define TOP_PVTMON_CTRL_0r_VDDCMON_REFADJ_MAXf_SET(r,f) (r).top_pvtmon_ctrl_0[0]=(((r).top_pvtmon_ctrl_0[0] & ~((uint32)0x7 << 29)) | ((((uint32)f) & 0x7) << 29))

/*
 * These macros can be used to access TOP_PVTMON_CTRL_0.
 */
#define WRITE_TOP_PVTMON_CTRL_0r(u,r) bcm5354x_reg_set(u,R_TOP_PVTMON_CTRL_0,(r._top_pvtmon_ctrl_0))
#define READ_TOP_PVTMON_CTRL_0r(u,r) bcm5354x_reg_get(u,R_TOP_PVTMON_CTRL_0,&(r._top_pvtmon_ctrl_0))

/*******************************************************************************
 * End of 'TOP_PVTMON_CTRL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_QGPHY_CTRL_0
 * BLOCKS:   TOP
 * DESC:     QGPHY control register 0
 * SIZE:     32
 * FIELDS:
 *     EXT_PWRDOWN      When set to 1, each bit enable 1 port into low power mode.
 *     CK25_DISABLE     Control signal to disable clock 25 to digital/output of ck25_o. This can be used in the lowpwr mode and MDIO access is not required to save power. If MDIO access is needed in lowpwrmode then this bit should be set to 0
 *     RSVD             Reserved
 */
#define TOP_QGPHY_CTRL_0r_SIZE 4

/*
 * This structure should be used to declare and program TOP_QGPHY_CTRL_0.
 */
typedef union TOP_QGPHY_CTRL_0r_s {
	uint32 v[1];
	uint32 top_qgphy_ctrl_0[1];
	uint32 _top_qgphy_ctrl_0;
} TOP_QGPHY_CTRL_0r_t;

#define TOP_QGPHY_CTRL_0r_CLR(r) (r).top_qgphy_ctrl_0[0] = 0
#define TOP_QGPHY_CTRL_0r_SET(r,d) (r).top_qgphy_ctrl_0[0] = d
#define TOP_QGPHY_CTRL_0r_GET(r) (r).top_qgphy_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_QGPHY_CTRL_0r_EXT_PWRDOWNf_GET(r) (((r).top_qgphy_ctrl_0[0]) & 0xffffff)
#define TOP_QGPHY_CTRL_0r_EXT_PWRDOWNf_SET(r,f) (r).top_qgphy_ctrl_0[0]=(((r).top_qgphy_ctrl_0[0] & ~((uint32)0xffffff)) | (((uint32)f) & 0xffffff))
#define TOP_QGPHY_CTRL_0r_CK25_DISABLEf_GET(r) ((((r).top_qgphy_ctrl_0[0]) >> 24) & 0x3f)
#define TOP_QGPHY_CTRL_0r_CK25_DISABLEf_SET(r,f) (r).top_qgphy_ctrl_0[0]=(((r).top_qgphy_ctrl_0[0] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))
#define TOP_QGPHY_CTRL_0r_RSVDf_GET(r) ((((r).top_qgphy_ctrl_0[0]) >> 30) & 0x3)
#define TOP_QGPHY_CTRL_0r_RSVDf_SET(r,f) (r).top_qgphy_ctrl_0[0]=(((r).top_qgphy_ctrl_0[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))

/*
 * These macros can be used to access TOP_QGPHY_CTRL_0.
 */
#define WRITE_TOP_QGPHY_CTRL_0r(u,r) bcm5354x_reg_set(u,R_TOP_QGPHY_CTRL_0,(r._top_qgphy_ctrl_0))
#define READ_TOP_QGPHY_CTRL_0r(u,r) bcm5354x_reg_get(u,R_TOP_QGPHY_CTRL_0,&(r._top_qgphy_ctrl_0))

/*******************************************************************************
 * End of 'TOP_QGPHY_CTRL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_QGPHY_CTRL_2
 * BLOCKS:   TOP
 * DESC:     QGPHY control register 0
 * SIZE:     32
 * FIELDS:
 *     IDDQ_BIAS        "1" will shut off IDDQ Bias, one of the 3 power management signal
 *     FORCE_DLL_EN     When set, will keep clk125 running even ext_pwrdown is asserted. Otherwise shut down clock to reduce power.
 *     PLL_SEL_DIV5     Select input refclk freq: 0 - 25MHz, 1 - 54MHz.
 *     GPHY_IDDQ_GLOBAL_PWR to enable isolation cell for each qgphy: 1 -enable , 0-disable
 *     RSVD             Reserved
 */
#define TOP_QGPHY_CTRL_2r_SIZE 4

/*
 * This structure should be used to declare and program TOP_QGPHY_CTRL_2.
 */
typedef union TOP_QGPHY_CTRL_2r_s {
	uint32 v[1];
	uint32 top_qgphy_ctrl_2[1];
	uint32 _top_qgphy_ctrl_2;
} TOP_QGPHY_CTRL_2r_t;

#define TOP_QGPHY_CTRL_2r_CLR(r) (r).top_qgphy_ctrl_2[0] = 0
#define TOP_QGPHY_CTRL_2r_SET(r,d) (r).top_qgphy_ctrl_2[0] = d
#define TOP_QGPHY_CTRL_2r_GET(r) (r).top_qgphy_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_QGPHY_CTRL_2r_IDDQ_BIASf_GET(r) (((r).top_qgphy_ctrl_2[0]) & 0x3f)
#define TOP_QGPHY_CTRL_2r_IDDQ_BIASf_SET(r,f) (r).top_qgphy_ctrl_2[0]=(((r).top_qgphy_ctrl_2[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define TOP_QGPHY_CTRL_2r_FORCE_DLL_ENf_GET(r) ((((r).top_qgphy_ctrl_2[0]) >> 6) & 0x3f)
#define TOP_QGPHY_CTRL_2r_FORCE_DLL_ENf_SET(r,f) (r).top_qgphy_ctrl_2[0]=(((r).top_qgphy_ctrl_2[0] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define TOP_QGPHY_CTRL_2r_PLL_SEL_DIV5f_GET(r) ((((r).top_qgphy_ctrl_2[0]) >> 12) & 0x1)
#define TOP_QGPHY_CTRL_2r_PLL_SEL_DIV5f_SET(r,f) (r).top_qgphy_ctrl_2[0]=(((r).top_qgphy_ctrl_2[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define TOP_QGPHY_CTRL_2r_GPHY_IDDQ_GLOBAL_PWRf_GET(r) ((((r).top_qgphy_ctrl_2[0]) >> 13) & 0x3f)
#define TOP_QGPHY_CTRL_2r_GPHY_IDDQ_GLOBAL_PWRf_SET(r,f) (r).top_qgphy_ctrl_2[0]=(((r).top_qgphy_ctrl_2[0] & ~((uint32)0x3f << 13)) | ((((uint32)f) & 0x3f) << 13))
#define TOP_QGPHY_CTRL_2r_RSVDf_GET(r) ((((r).top_qgphy_ctrl_2[0]) >> 19) & 0x1fff)
#define TOP_QGPHY_CTRL_2r_RSVDf_SET(r,f) (r).top_qgphy_ctrl_2[0]=(((r).top_qgphy_ctrl_2[0] & ~((uint32)0x1fff << 19)) | ((((uint32)f) & 0x1fff) << 19))

/*
 * These macros can be used to access TOP_QGPHY_CTRL_2.
 */
#define WRITE_TOP_QGPHY_CTRL_2r(u,r) bcm5354x_reg_set(u,R_TOP_QGPHY_CTRL_2,(r._top_qgphy_ctrl_2))
#define READ_TOP_QGPHY_CTRL_2r(u,r) bcm5354x_reg_get(u,R_TOP_QGPHY_CTRL_2,&(r._top_qgphy_ctrl_2))

/*******************************************************************************
 * End of 'TOP_QGPHY_CTRL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_SGMII_CTRL_REG
 * BLOCKS:   TOP
 * DESC:     Controls for TSC.  TOP_SGMII_CTRL_REG exists on a per PGW_GE12P basis to control quad-lane SGMII0.
 * SIZE:     32
 * FIELDS:
 *     RSTB_PLL         Resets PLL on SGMII0 (active low).
 *     RSTB_MDIOREGS    Resets MDIO on SGMII0 (active low).
 *     RSTB_HW          Resets the entire SGMII0 (active low)
 *     PWRDWN           TSC Power Down. Powers down TSC analog circuits.
 *     IDDQ             Shutdown analog clocks but leave analog section powered.  
 *     REFSEL           Reference clock selection:000: Internal REFCLK from on-die REFCLK rounting channel001: XTAL010: XTAL bypass / External REFCLK from pads011: XTAL bypass / External REFCLK from pads with 100 ohm termination1xx: internal single-ended REFCLK CMOS
 */
#define TOP_SGMII_CTRL_REGr_SIZE 4

/*
 * This structure should be used to declare and program TOP_SGMII_CTRL_REG.
 */
typedef union TOP_SGMII_CTRL_REGr_s {
	uint32 v[1];
	uint32 top_sgmii_ctrl_reg[1];
	uint32 _top_sgmii_ctrl_reg;
} TOP_SGMII_CTRL_REGr_t;

#define TOP_SGMII_CTRL_REGr_CLR(r) (r).top_sgmii_ctrl_reg[0] = 0
#define TOP_SGMII_CTRL_REGr_SET(r,d) (r).top_sgmii_ctrl_reg[0] = d
#define TOP_SGMII_CTRL_REGr_GET(r) (r).top_sgmii_ctrl_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_SGMII_CTRL_REGr_RSTB_PLLf_GET(r) (((r).top_sgmii_ctrl_reg[0]) & 0x1)
#define TOP_SGMII_CTRL_REGr_RSTB_PLLf_SET(r,f) (r).top_sgmii_ctrl_reg[0]=(((r).top_sgmii_ctrl_reg[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_SGMII_CTRL_REGr_RSTB_MDIOREGSf_GET(r) ((((r).top_sgmii_ctrl_reg[0]) >> 1) & 0x1)
#define TOP_SGMII_CTRL_REGr_RSTB_MDIOREGSf_SET(r,f) (r).top_sgmii_ctrl_reg[0]=(((r).top_sgmii_ctrl_reg[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TOP_SGMII_CTRL_REGr_RSTB_HWf_GET(r) ((((r).top_sgmii_ctrl_reg[0]) >> 2) & 0x1)
#define TOP_SGMII_CTRL_REGr_RSTB_HWf_SET(r,f) (r).top_sgmii_ctrl_reg[0]=(((r).top_sgmii_ctrl_reg[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define TOP_SGMII_CTRL_REGr_PWRDWNf_GET(r) ((((r).top_sgmii_ctrl_reg[0]) >> 3) & 0x1)
#define TOP_SGMII_CTRL_REGr_PWRDWNf_SET(r,f) (r).top_sgmii_ctrl_reg[0]=(((r).top_sgmii_ctrl_reg[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define TOP_SGMII_CTRL_REGr_IDDQf_GET(r) ((((r).top_sgmii_ctrl_reg[0]) >> 4) & 0x1)
#define TOP_SGMII_CTRL_REGr_IDDQf_SET(r,f) (r).top_sgmii_ctrl_reg[0]=(((r).top_sgmii_ctrl_reg[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define TOP_SGMII_CTRL_REGr_REFSELf_GET(r) ((((r).top_sgmii_ctrl_reg[0]) >> 5) & 0x7)
#define TOP_SGMII_CTRL_REGr_REFSELf_SET(r,f) (r).top_sgmii_ctrl_reg[0]=(((r).top_sgmii_ctrl_reg[0] & ~((uint32)0x7 << 5)) | ((((uint32)f) & 0x7) << 5))

/*
 * These macros can be used to access TOP_SGMII_CTRL_REG.
 */
#define WRITE_TOP_SGMII_CTRL_REGr(u,r) bcm5354x_reg_set(u,R_TOP_SGMII_CTRL_REG,(r._top_sgmii_ctrl_reg))
#define READ_TOP_SGMII_CTRL_REGr(u,r) bcm5354x_reg_get(u,R_TOP_SGMII_CTRL_REG,&(r._top_sgmii_ctrl_reg))

/*******************************************************************************
 * End of 'TOP_SGMII_CTRL_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_SGMII_STATUS1_REG
 * BLOCKS:   TOP
 * DESC:     Status1 from qual-lane SGMIIPLUS2_X4
 * SIZE:     32
 * FIELDS:
 *     SPEED_10         10M speed for four lanes.
 *     SPEED_100        100M speed for four lanes.
 *     SPEED_1000       1G speed for four lanes.
 *     SPEED_2500       2.5G speed for four lanes.
 *     SYNC_STATUS      iSymbol slignment for four lanes
 *     TXPLL_LOCK       PLL lock.
 */
#define TOP_SGMII_STATUS1_REGr_SIZE 4

/*
 * This structure should be used to declare and program TOP_SGMII_STATUS1_REG.
 */
typedef union TOP_SGMII_STATUS1_REGr_s {
	uint32 v[1];
	uint32 top_sgmii_status1_reg[1];
	uint32 _top_sgmii_status1_reg;
} TOP_SGMII_STATUS1_REGr_t;

#define TOP_SGMII_STATUS1_REGr_CLR(r) (r).top_sgmii_status1_reg[0] = 0
#define TOP_SGMII_STATUS1_REGr_SET(r,d) (r).top_sgmii_status1_reg[0] = d
#define TOP_SGMII_STATUS1_REGr_GET(r) (r).top_sgmii_status1_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_SGMII_STATUS1_REGr_SPEED_10f_GET(r) (((r).top_sgmii_status1_reg[0]) & 0xf)
#define TOP_SGMII_STATUS1_REGr_SPEED_10f_SET(r,f) (r).top_sgmii_status1_reg[0]=(((r).top_sgmii_status1_reg[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define TOP_SGMII_STATUS1_REGr_SPEED_100f_GET(r) ((((r).top_sgmii_status1_reg[0]) >> 4) & 0xf)
#define TOP_SGMII_STATUS1_REGr_SPEED_100f_SET(r,f) (r).top_sgmii_status1_reg[0]=(((r).top_sgmii_status1_reg[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define TOP_SGMII_STATUS1_REGr_SPEED_1000f_GET(r) ((((r).top_sgmii_status1_reg[0]) >> 8) & 0xf)
#define TOP_SGMII_STATUS1_REGr_SPEED_1000f_SET(r,f) (r).top_sgmii_status1_reg[0]=(((r).top_sgmii_status1_reg[0] & ~((uint32)0xf << 8)) | ((((uint32)f) & 0xf) << 8))
#define TOP_SGMII_STATUS1_REGr_SPEED_2500f_GET(r) ((((r).top_sgmii_status1_reg[0]) >> 12) & 0xf)
#define TOP_SGMII_STATUS1_REGr_SPEED_2500f_SET(r,f) (r).top_sgmii_status1_reg[0]=(((r).top_sgmii_status1_reg[0] & ~((uint32)0xf << 12)) | ((((uint32)f) & 0xf) << 12))
#define TOP_SGMII_STATUS1_REGr_SYNC_STATUSf_GET(r) ((((r).top_sgmii_status1_reg[0]) >> 16) & 0xf)
#define TOP_SGMII_STATUS1_REGr_SYNC_STATUSf_SET(r,f) (r).top_sgmii_status1_reg[0]=(((r).top_sgmii_status1_reg[0] & ~((uint32)0xf << 16)) | ((((uint32)f) & 0xf) << 16))
#define TOP_SGMII_STATUS1_REGr_TXPLL_LOCKf_GET(r) ((((r).top_sgmii_status1_reg[0]) >> 20) & 0x1)
#define TOP_SGMII_STATUS1_REGr_TXPLL_LOCKf_SET(r,f) (r).top_sgmii_status1_reg[0]=(((r).top_sgmii_status1_reg[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))

/*
 * These macros can be used to access TOP_SGMII_STATUS1_REG.
 */
#define WRITE_TOP_SGMII_STATUS1_REGr(u,r) bcm5354x_reg_set(u,R_TOP_SGMII_STATUS1_REG,(r._top_sgmii_status1_reg))
#define READ_TOP_SGMII_STATUS1_REGr(u,r) bcm5354x_reg_get(u,R_TOP_SGMII_STATUS1_REG,&(r._top_sgmii_status1_reg))

/*******************************************************************************
 * End of 'TOP_SGMII_STATUS1_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_SOFT_RESET_REG
 * BLOCKS:   TOP
 * DESC:     TOP Soft Reset register
 * SIZE:     32
 * FIELDS:
 *     TOP_IP_RST_L     IP Reset (active low)
 *     TOP_EP_RST_L     EP Reset (active low)
 *     TOP_MMU_RST_L    MMU Reset (active low)
 *     TOP_GXP2_RST_L   GXport2 Reset (active low)
 *     TOP_GXP0_RST_L   GXport0 Reset (active low)
 *     TOP_GXP1_RST_L   GXport1 Reset (active low)
 *     TOP_SPARE_RST_L  Reserved in HR3.
 *     RSVD_10          Reserved
 *     TOP_TS_RST_L     Network TimeSync Reset (active low)
 *     TOP_QGPHY_RST_L  QGPHY Reset (active low)
 *     TOP_LCPLL_SOFT_RESET Write 1 to this bit to reset all the LCPLL, LCPLL_RSTFSM goes to RESET state.
 *     TOP_QGPHY_REG_RST_L QGPHY CTRL REG Reset (active low)
 *     TOP_SGMII_REG_RST_L SGMII CTRL REG Reset (active low)
 *     RSVD             Reserved
 */
#define TOP_SOFT_RESET_REGr_SIZE 4

/*
 * This structure should be used to declare and program TOP_SOFT_RESET_REG.
 */
typedef union TOP_SOFT_RESET_REGr_s {
	uint32 v[1];
	uint32 top_soft_reset_reg[1];
	uint32 _top_soft_reset_reg;
} TOP_SOFT_RESET_REGr_t;

#define TOP_SOFT_RESET_REGr_CLR(r) (r).top_soft_reset_reg[0] = 0
#define TOP_SOFT_RESET_REGr_SET(r,d) (r).top_soft_reset_reg[0] = d
#define TOP_SOFT_RESET_REGr_GET(r) (r).top_soft_reset_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_SOFT_RESET_REGr_TOP_IP_RST_Lf_GET(r) (((r).top_soft_reset_reg[0]) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_IP_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_SOFT_RESET_REGr_TOP_EP_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 1) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_EP_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TOP_SOFT_RESET_REGr_TOP_MMU_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 2) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_MMU_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define TOP_SOFT_RESET_REGr_TOP_GXP2_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 4) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_GXP2_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define TOP_SOFT_RESET_REGr_TOP_GXP0_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 5) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_GXP0_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define TOP_SOFT_RESET_REGr_TOP_GXP1_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 6) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_GXP1_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define TOP_SOFT_RESET_REGr_TOP_SPARE_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 7) & 0x7)
#define TOP_SOFT_RESET_REGr_TOP_SPARE_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x7 << 7)) | ((((uint32)f) & 0x7) << 7))
#define TOP_SOFT_RESET_REGr_RSVD_10f_GET(r) ((((r).top_soft_reset_reg[0]) >> 10) & 0x1f)
#define TOP_SOFT_RESET_REGr_RSVD_10f_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1f << 10)) | ((((uint32)f) & 0x1f) << 10))
#define TOP_SOFT_RESET_REGr_TOP_TS_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 15) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_TS_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define TOP_SOFT_RESET_REGr_TOP_QGPHY_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 16) & 0x3f)
#define TOP_SOFT_RESET_REGr_TOP_QGPHY_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x3f << 16)) | ((((uint32)f) & 0x3f) << 16))
#define TOP_SOFT_RESET_REGr_TOP_LCPLL_SOFT_RESETf_GET(r) ((((r).top_soft_reset_reg[0]) >> 22) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_LCPLL_SOFT_RESETf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define TOP_SOFT_RESET_REGr_TOP_QGPHY_REG_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 23) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_QGPHY_REG_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define TOP_SOFT_RESET_REGr_TOP_SGMII_REG_RST_Lf_GET(r) ((((r).top_soft_reset_reg[0]) >> 24) & 0x1)
#define TOP_SOFT_RESET_REGr_TOP_SGMII_REG_RST_Lf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define TOP_SOFT_RESET_REGr_RSVDf_GET(r) ((((r).top_soft_reset_reg[0]) >> 25) & 0x7f)
#define TOP_SOFT_RESET_REGr_RSVDf_SET(r,f) (r).top_soft_reset_reg[0]=(((r).top_soft_reset_reg[0] & ~((uint32)0x7f << 25)) | ((((uint32)f) & 0x7f) << 25))

/*
 * These macros can be used to access TOP_SOFT_RESET_REG.
 */
#define WRITE_TOP_SOFT_RESET_REGr(u,r) bcm5354x_reg_set(u,R_TOP_SOFT_RESET_REG,(r._top_soft_reset_reg))
#define READ_TOP_SOFT_RESET_REGr(u,r) bcm5354x_reg_get(u,R_TOP_SOFT_RESET_REG,&(r._top_soft_reset_reg))

/*******************************************************************************
 * End of 'TOP_SOFT_RESET_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_SOFT_RESET_REG_2
 * BLOCKS:   TOP
 * DESC:     TOP Soft Reset register 2
 * SIZE:     32
 * FIELDS:
 *     TOP_XG_PLL0_RST_L XG_PLL0 (for GPHY and QSGMII) Reset (active low)
 *     TOP_XG_PLL0_POST_RST_L XG_PLL0 (for GPHY and QSGMII) Post Reset (active low)
 *     RSVD_0           Reserved
 *     TOP_TS_PLL_RST_L TS_PLL Reset (active low)
 *     TOP_TS_PLL_POST_RST_L TS_PLL Post Reset (active low)
 *     TOP_BS_PLL0_RST_L BS_PLL0 Reset (active low)
 *     TOP_BS_PLL0_POST_RST_L BS_PLL0 Post Reset (active low)
 *     RSVD_14          Reserved
 *     TOP_TEMP_MON_PEAK_RST_L Temperature Monitor peak value Reset (active low)
 *     RSVD_17          Reserved
 */
#define TOP_SOFT_RESET_REG_2r_SIZE 4

/*
 * This structure should be used to declare and program TOP_SOFT_RESET_REG_2.
 */
typedef union TOP_SOFT_RESET_REG_2r_s {
	uint32 v[1];
	uint32 top_soft_reset_reg_2[1];
	uint32 _top_soft_reset_reg_2;
} TOP_SOFT_RESET_REG_2r_t;

#define TOP_SOFT_RESET_REG_2r_CLR(r) (r).top_soft_reset_reg_2[0] = 0
#define TOP_SOFT_RESET_REG_2r_SET(r,d) (r).top_soft_reset_reg_2[0] = d
#define TOP_SOFT_RESET_REG_2r_GET(r) (r).top_soft_reset_reg_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_SOFT_RESET_REG_2r_TOP_XG_PLL0_RST_Lf_GET(r) (((r).top_soft_reset_reg_2[0]) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_XG_PLL0_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_SOFT_RESET_REG_2r_TOP_XG_PLL0_POST_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 1) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_XG_PLL0_POST_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TOP_SOFT_RESET_REG_2r_RSVD_0f_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 4) & 0xf)
#define TOP_SOFT_RESET_REG_2r_RSVD_0f_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0xf << 4)) | ((((uint32)f) & 0xf) << 4))
#define TOP_SOFT_RESET_REG_2r_TOP_TS_PLL_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 8) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_TS_PLL_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define TOP_SOFT_RESET_REG_2r_TOP_TS_PLL_POST_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 9) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_TS_PLL_POST_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TOP_SOFT_RESET_REG_2r_TOP_BS_PLL0_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 10) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_BS_PLL0_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 10)) | ((((uint32)f) & 0x1) << 10))
#define TOP_SOFT_RESET_REG_2r_TOP_BS_PLL0_POST_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 11) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_BS_PLL0_POST_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define TOP_SOFT_RESET_REG_2r_RSVD_14f_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 14) & 0x3)
#define TOP_SOFT_RESET_REG_2r_RSVD_14f_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define TOP_SOFT_RESET_REG_2r_TOP_TEMP_MON_PEAK_RST_Lf_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 16) & 0x1)
#define TOP_SOFT_RESET_REG_2r_TOP_TEMP_MON_PEAK_RST_Lf_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define TOP_SOFT_RESET_REG_2r_RSVD_17f_GET(r) ((((r).top_soft_reset_reg_2[0]) >> 17) & 0x7fff)
#define TOP_SOFT_RESET_REG_2r_RSVD_17f_SET(r,f) (r).top_soft_reset_reg_2[0]=(((r).top_soft_reset_reg_2[0] & ~((uint32)0x7fff << 17)) | ((((uint32)f) & 0x7fff) << 17))

/*
 * These macros can be used to access TOP_SOFT_RESET_REG_2.
 */
#define WRITE_TOP_SOFT_RESET_REG_2r(u,r) bcm5354x_reg_set(u,R_TOP_SOFT_RESET_REG_2,(r._top_soft_reset_reg_2))
#define READ_TOP_SOFT_RESET_REG_2r(u,r) bcm5354x_reg_get(u,R_TOP_SOFT_RESET_REG_2,&(r._top_soft_reset_reg_2))

/*******************************************************************************
 * End of 'TOP_SOFT_RESET_REG_2r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_STRAP_STATUS
 * BLOCKS:   TOP
 * DESC:     top strap pin status register
 * SIZE:     32
 * FIELDS:
 *     STRAP_STATUS     Bit 2-0: strap_boot_dev 0 : SPI NOR flash, starting at 0x1E00_0000 1 : NAND flash, starting at 0x1C00_0000 2 : Boot ROM, starting at 0xFFFD_0000 3 : Host processor (code are expected to be directly fetched and executed from external host memory) 4 : Parallel NOR flash 7: ATE modeBit 6-3: strap_nand_type 0 : NAND + ECC disabled & 16B spare - 512B sector 1 : NAND + 1 bit ECC & 16B spare - 512B sector 2 : NAND + 4 bit ECC & 16B spare - 512B sector 3 : NAND + 8 bit ECC & 16B spare - 512B sector 4 : NAND + 8 bit ECC & 27B spare - 512B sector 5 : NAND + 12 bit ECC & 27B spare - 512B sector 6 : NAND + 24 bit ECC & 27B spare - 1K sector 7 : NAND + 30 bit ECC & 27B spare - 1K sector 8 : NAND + 40 bit ECC & 45B spare - 1K sectorBit 8-7: strap_nand_page 0 : 1KB page 1 : 2KB page 2 : 4KB page 3 : 8KB pageBit 9: strap_lcpll1_refclk_sel 1 : from i_refclk, Xtal 0 : from LCPLL1 differential padBit 10: strap_dis_lvm 1 : Disable LVM 0 : Enable LVMBit 11: strap_qspi_4byte_addr 1 : SPI 4-byte addressing mode 0 : SPI 3-byte addressing modeBit 13:12: strap_cmicd_i2c_sa 0 : addr is 0x80 1 : addr is 0x81 2 : addr is 0x82 3 : addr is 0x83Bit 14: strap_pcie_rc_mode 1 : RC 0 : EPBit 15: strap_pcie_refclk_sel 1: External clock source 0: Internal clock sourceBit 16: strap_pcie_force_gen1 1 : Gen1 0 : Gen2Bit 17: strap_usb2_host_sel 1 : Host 0 : SlaveBit 18: strap_xtal_bypass 1 : OSC 0 : XtalBit 19: strap_all_pll_bypass 1 : Bypass PLL 0 : Use PLLBit 20: strap_bypass_autoload 1: Bypass 0: No bypassBit 21: strap_ddr_type 0 : DDR3Bit 22: strap_miim_voltage_sel1 1 : 3.3V/2.5V 0 : 1.2VBit 23: strap_miim_voltage_sel2 1 : 3.3V/2.5V 0 : 1.2VBit 24: strap_pnor_nand_mw 1 : 16 bit 0 : 8 bitBit 25:strap_wc_pwr_off[0] 0 : Indicate WarpCore 0 Power is On 1 : Indicate WarpCore 0 Power is OffBit 26:strap_wc_pwr_off[1] 0 : Indicate WarpCore 1 Power is On 1 : Indicate WarpCore 1 Power is OffBit 27:strap_wc_pwr_off[2] 0 : Indicate WarpCore 2 Power is On 1 : Indicate WarpCore 2 Power is OffBit 28:strap_wc_pwr_off[3] 0 : Indicate WarpCore 3 Power is On 1 : Indicate WarpCore 3 Power is OffBit 31, 30, 29: Reserved
 */
#define TOP_STRAP_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TOP_STRAP_STATUS.
 */
typedef union TOP_STRAP_STATUSr_s {
	uint32 v[1];
	uint32 top_strap_status[1];
	uint32 _top_strap_status;
} TOP_STRAP_STATUSr_t;

#define TOP_STRAP_STATUSr_CLR(r) (r).top_strap_status[0] = 0
#define TOP_STRAP_STATUSr_SET(r,d) (r).top_strap_status[0] = d
#define TOP_STRAP_STATUSr_GET(r) (r).top_strap_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_STRAP_STATUSr_STRAP_STATUSf_GET(r) ((r).top_strap_status[0])
#define TOP_STRAP_STATUSr_STRAP_STATUSf_SET(r,f) (r).top_strap_status[0]=((uint32)f)

/*
 * These macros can be used to access TOP_STRAP_STATUS.
 */
#define WRITE_TOP_STRAP_STATUSr(u,r) bcm5354x_reg_set(u,R_TOP_STRAP_STATUS,(r._top_strap_status))
#define READ_TOP_STRAP_STATUSr(u,r) bcm5354x_reg_get(u,R_TOP_STRAP_STATUS,&(r._top_strap_status))

/*******************************************************************************
 * End of 'TOP_STRAP_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_STRAP_STATUS_1
 * BLOCKS:   TOP
 * DESC:     top strap pin status 1 register
 * SIZE:     32
 * FIELDS:
 *     STRAP_STATUS     Bit 0:strap_xtal_freq_sel 0 : XTAL output clock frequence is 25MHz. 1 : XTAL output clock frequence is 50MHz.Bit 2: strap_gphy_sgmii_sel[1] 0 : Front ports select SGMII , OOB port select GPHY  1 : Front ports select GPHY  , OOB port select SGMIIBit 1: strap_gphy_sgmii_sel[0] 0 : Front ports select SGMII  1 : Front ports select GPHY  Bit 31-3: reserved
 */
#define TOP_STRAP_STATUS_1r_SIZE 4

/*
 * This structure should be used to declare and program TOP_STRAP_STATUS_1.
 */
typedef union TOP_STRAP_STATUS_1r_s {
	uint32 v[1];
	uint32 top_strap_status_1[1];
	uint32 _top_strap_status_1;
} TOP_STRAP_STATUS_1r_t;

#define TOP_STRAP_STATUS_1r_CLR(r) (r).top_strap_status_1[0] = 0
#define TOP_STRAP_STATUS_1r_SET(r,d) (r).top_strap_status_1[0] = d
#define TOP_STRAP_STATUS_1r_GET(r) (r).top_strap_status_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_STRAP_STATUS_1r_STRAP_STATUSf_GET(r) ((r).top_strap_status_1[0])
#define TOP_STRAP_STATUS_1r_STRAP_STATUSf_SET(r,f) (r).top_strap_status_1[0]=((uint32)f)

/*
 * These macros can be used to access TOP_STRAP_STATUS_1.
 */
#define WRITE_TOP_STRAP_STATUS_1r(u,r) bcm5354x_reg_set(u,R_TOP_STRAP_STATUS_1,(r._top_strap_status_1))
#define READ_TOP_STRAP_STATUS_1r(u,r) bcm5354x_reg_get(u,R_TOP_STRAP_STATUS_1,&(r._top_strap_status_1))

/*******************************************************************************
 * End of 'TOP_STRAP_STATUS_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_SW_BOND_OVERRIDE_CODE_REG
 * BLOCKS:   TOP
 * DESC:     TOP SW BOND Override code register
 * SIZE:     32
 * FIELDS:
 *     SW_BOND_OVERRIDE_VALUE SW BOND Override code register. 
 */
#define TOP_SW_BOND_OVERRIDE_CODE_REGr_SIZE 4

/*
 * This structure should be used to declare and program TOP_SW_BOND_OVERRIDE_CODE_REG.
 */
typedef union TOP_SW_BOND_OVERRIDE_CODE_REGr_s {
	uint32 v[1];
	uint32 top_sw_bond_override_code_reg[1];
	uint32 _top_sw_bond_override_code_reg;
} TOP_SW_BOND_OVERRIDE_CODE_REGr_t;

#define TOP_SW_BOND_OVERRIDE_CODE_REGr_CLR(r) (r).top_sw_bond_override_code_reg[0] = 0
#define TOP_SW_BOND_OVERRIDE_CODE_REGr_SET(r,d) (r).top_sw_bond_override_code_reg[0] = d
#define TOP_SW_BOND_OVERRIDE_CODE_REGr_GET(r) (r).top_sw_bond_override_code_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_SW_BOND_OVERRIDE_CODE_REGr_SW_BOND_OVERRIDE_VALUEf_GET(r) ((r).top_sw_bond_override_code_reg[0])
#define TOP_SW_BOND_OVERRIDE_CODE_REGr_SW_BOND_OVERRIDE_VALUEf_SET(r,f) (r).top_sw_bond_override_code_reg[0]=((uint32)f)

/*
 * These macros can be used to access TOP_SW_BOND_OVERRIDE_CODE_REG.
 */
#define WRITE_TOP_SW_BOND_OVERRIDE_CODE_REGr(u,r) bcm5354x_reg_set(u,R_TOP_SW_BOND_OVERRIDE_CODE_REG,(r._top_sw_bond_override_code_reg))
#define READ_TOP_SW_BOND_OVERRIDE_CODE_REGr(u,r) bcm5354x_reg_get(u,R_TOP_SW_BOND_OVERRIDE_CODE_REG,&(r._top_sw_bond_override_code_reg))

/*******************************************************************************
 * End of 'TOP_SW_BOND_OVERRIDE_CODE_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_SW_BOND_OVERRIDE_REG
 * BLOCKS:   TOP
 * DESC:     TOP SW BOND Override register_0
 * SIZE:     32
 * FIELDS:
 *     SW_BOND_OVERRIDE_VALUE SW BOND Override register_0. 
 */
#define TOP_SW_BOND_OVERRIDE_REGr_SIZE 4

/* TOP_SW_BOND_OVERRIDE_REGr is element of TOP_SW_BOND_OVERRIDE_REG */

/*
 * This structure should be used to declare and program TOP_SW_BOND_OVERRIDE_REG.
 */
typedef union TOP_SW_BOND_OVERRIDE_REGr_s {
	uint32 v[1];
	uint32 top_sw_bond_override_reg[1];
	uint32 _top_sw_bond_override_reg;
} TOP_SW_BOND_OVERRIDE_REGr_t;

#define TOP_SW_BOND_OVERRIDE_REGr_CLR(r) (r).top_sw_bond_override_reg[0] = 0
#define TOP_SW_BOND_OVERRIDE_REGr_SET(r,d) (r).top_sw_bond_override_reg[0] = d
#define TOP_SW_BOND_OVERRIDE_REGr_GET(r) (r).top_sw_bond_override_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_SW_BOND_OVERRIDE_REGr_SW_BOND_OVERRIDE_VALUEf_GET(r) ((r).top_sw_bond_override_reg[0])
#define TOP_SW_BOND_OVERRIDE_REGr_SW_BOND_OVERRIDE_VALUEf_SET(r,f) (r).top_sw_bond_override_reg[0]=((uint32)f)

/*
 * These macros can be used to access TOP_SW_BOND_OVERRIDE_REG.
 */
#define WRITE_TOP_SW_BOND_OVERRIDE_REGr(u,i,r) bcm5354x_reg_set(u,R_TOP_SW_BOND_OVERRIDE_REG(i),(r._top_sw_bond_override_reg))
#define READ_TOP_SW_BOND_OVERRIDE_REGr(u,i,r) bcm5354x_reg_get(u,R_TOP_SW_BOND_OVERRIDE_REG(i),&(r._top_sw_bond_override_reg))

/*******************************************************************************
 * End of 'TOP_SW_BOND_OVERRIDE_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_SW_BOND_OVERRIDE_REG_0
 * BLOCKS:   TOP
 * DESC:     TOP SW BOND Override register_0
 * SIZE:     32
 * FIELDS:
 *     SW_BOND_OVERRIDE_VALUE SW BOND Override register_0. 
 */
#define TOP_SW_BOND_OVERRIDE_REG_0r_SIZE 4

/* TOP_SW_BOND_OVERRIDE_REG_0r is element of TOP_SW_BOND_OVERRIDE_REG */

/*
 * This structure should be used to declare and program TOP_SW_BOND_OVERRIDE_REG_0.
 */
typedef union TOP_SW_BOND_OVERRIDE_REG_0r_s {
	uint32 v[1];
	uint32 top_sw_bond_override_reg_0[1];
	uint32 _top_sw_bond_override_reg_0;
} TOP_SW_BOND_OVERRIDE_REG_0r_t;

#define TOP_SW_BOND_OVERRIDE_REG_0r_CLR(r) (r).top_sw_bond_override_reg_0[0] = 0
#define TOP_SW_BOND_OVERRIDE_REG_0r_SET(r,d) (r).top_sw_bond_override_reg_0[0] = d
#define TOP_SW_BOND_OVERRIDE_REG_0r_GET(r) (r).top_sw_bond_override_reg_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_SW_BOND_OVERRIDE_REG_0r_SW_BOND_OVERRIDE_VALUEf_GET(r) ((r).top_sw_bond_override_reg_0[0])
#define TOP_SW_BOND_OVERRIDE_REG_0r_SW_BOND_OVERRIDE_VALUEf_SET(r,f) (r).top_sw_bond_override_reg_0[0]=((uint32)f)

/*
 * These macros can be used to access TOP_SW_BOND_OVERRIDE_REG_0.
 */
#define WRITE_TOP_SW_BOND_OVERRIDE_REG_0r(u,r) bcm5354x_reg_set(u,R_TOP_SW_BOND_OVERRIDE_REG_0,(r._top_sw_bond_override_reg_0))
#define READ_TOP_SW_BOND_OVERRIDE_REG_0r(u,r) bcm5354x_reg_get(u,R_TOP_SW_BOND_OVERRIDE_REG_0,&(r._top_sw_bond_override_reg_0))

/*******************************************************************************
 * End of 'TOP_SW_BOND_OVERRIDE_REG_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_SW_BOND_OVERRIDE_REG_1
 * BLOCKS:   TOP
 * DESC:     TOP SW BOND Override register_1
 * SIZE:     32
 * FIELDS:
 *     SW_BOND_OVERRIDE_VALUE SW BOND Override register_1. 
 */
#define TOP_SW_BOND_OVERRIDE_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program TOP_SW_BOND_OVERRIDE_REG_1.
 */
typedef union TOP_SW_BOND_OVERRIDE_REG_1r_s {
	uint32 v[1];
	uint32 top_sw_bond_override_reg_1[1];
	uint32 _top_sw_bond_override_reg_1;
} TOP_SW_BOND_OVERRIDE_REG_1r_t;

#define TOP_SW_BOND_OVERRIDE_REG_1r_CLR(r) (r).top_sw_bond_override_reg_1[0] = 0
#define TOP_SW_BOND_OVERRIDE_REG_1r_SET(r,d) (r).top_sw_bond_override_reg_1[0] = d
#define TOP_SW_BOND_OVERRIDE_REG_1r_GET(r) (r).top_sw_bond_override_reg_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_SW_BOND_OVERRIDE_REG_1r_SW_BOND_OVERRIDE_VALUEf_GET(r) ((r).top_sw_bond_override_reg_1[0])
#define TOP_SW_BOND_OVERRIDE_REG_1r_SW_BOND_OVERRIDE_VALUEf_SET(r,f) (r).top_sw_bond_override_reg_1[0]=((uint32)f)

/*
 * These macros can be used to access TOP_SW_BOND_OVERRIDE_REG_1.
 */
#define WRITE_TOP_SW_BOND_OVERRIDE_REG_1r(u,r) bcm5354x_reg_set(u,R_TOP_SW_BOND_OVERRIDE_REG_1,(r._top_sw_bond_override_reg_1))
#define READ_TOP_SW_BOND_OVERRIDE_REG_1r(u,r) bcm5354x_reg_get(u,R_TOP_SW_BOND_OVERRIDE_REG_1,&(r._top_sw_bond_override_reg_1))

/*******************************************************************************
 * End of 'TOP_SW_BOND_OVERRIDE_REG_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_TOP_CORE_PLL_STATUS_1
 * BLOCKS:   TOP
 * DESC:     TOP CORE PLL Status 1
 * SIZE:     32
 * FIELDS:
 *     MSTR_CORE_PLL_LOCK Master Core PLL Lock
 *     RSVD_1           Reserved
 *     MSTR_CORE_PLL_STAT Master Core PLL Stat_Out [11:0]
 *     MSTR_CORE_PLL_LOCK_LOST Master Core PLL Lock Lost
 *     RSVD_0           Reserved
 */
#define TOP_TOP_CORE_PLL_STATUS_1r_SIZE 4

/*
 * This structure should be used to declare and program TOP_TOP_CORE_PLL_STATUS_1.
 */
typedef union TOP_TOP_CORE_PLL_STATUS_1r_s {
	uint32 v[1];
	uint32 top_top_core_pll_status_1[1];
	uint32 _top_top_core_pll_status_1;
} TOP_TOP_CORE_PLL_STATUS_1r_t;

#define TOP_TOP_CORE_PLL_STATUS_1r_CLR(r) (r).top_top_core_pll_status_1[0] = 0
#define TOP_TOP_CORE_PLL_STATUS_1r_SET(r,d) (r).top_top_core_pll_status_1[0] = d
#define TOP_TOP_CORE_PLL_STATUS_1r_GET(r) (r).top_top_core_pll_status_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_TOP_CORE_PLL_STATUS_1r_MSTR_CORE_PLL_LOCKf_GET(r) (((r).top_top_core_pll_status_1[0]) & 0x1)
#define TOP_TOP_CORE_PLL_STATUS_1r_MSTR_CORE_PLL_LOCKf_SET(r,f) (r).top_top_core_pll_status_1[0]=(((r).top_top_core_pll_status_1[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TOP_TOP_CORE_PLL_STATUS_1r_RSVD_1f_GET(r) ((((r).top_top_core_pll_status_1[0]) >> 1) & 0xf)
#define TOP_TOP_CORE_PLL_STATUS_1r_RSVD_1f_SET(r,f) (r).top_top_core_pll_status_1[0]=(((r).top_top_core_pll_status_1[0] & ~((uint32)0xf << 1)) | ((((uint32)f) & 0xf) << 1))
#define TOP_TOP_CORE_PLL_STATUS_1r_MSTR_CORE_PLL_STATf_GET(r) ((((r).top_top_core_pll_status_1[0]) >> 5) & 0xfff)
#define TOP_TOP_CORE_PLL_STATUS_1r_MSTR_CORE_PLL_STATf_SET(r,f) (r).top_top_core_pll_status_1[0]=(((r).top_top_core_pll_status_1[0] & ~((uint32)0xfff << 5)) | ((((uint32)f) & 0xfff) << 5))
#define TOP_TOP_CORE_PLL_STATUS_1r_MSTR_CORE_PLL_LOCK_LOSTf_GET(r) ((((r).top_top_core_pll_status_1[0]) >> 17) & 0x1)
#define TOP_TOP_CORE_PLL_STATUS_1r_MSTR_CORE_PLL_LOCK_LOSTf_SET(r,f) (r).top_top_core_pll_status_1[0]=(((r).top_top_core_pll_status_1[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define TOP_TOP_CORE_PLL_STATUS_1r_RSVD_0f_GET(r) ((((r).top_top_core_pll_status_1[0]) >> 18) & 0x3fff)
#define TOP_TOP_CORE_PLL_STATUS_1r_RSVD_0f_SET(r,f) (r).top_top_core_pll_status_1[0]=(((r).top_top_core_pll_status_1[0] & ~((uint32)0x3fff << 18)) | ((((uint32)f) & 0x3fff) << 18))

/*
 * These macros can be used to access TOP_TOP_CORE_PLL_STATUS_1.
 */
#define WRITE_TOP_TOP_CORE_PLL_STATUS_1r(u,r) bcm5354x_reg_set(u,R_TOP_TOP_CORE_PLL_STATUS_1,(r._top_top_core_pll_status_1))
#define READ_TOP_TOP_CORE_PLL_STATUS_1r(u,r) bcm5354x_reg_get(u,R_TOP_TOP_CORE_PLL_STATUS_1,&(r._top_top_core_pll_status_1))

/*******************************************************************************
 * End of 'TOP_TOP_CORE_PLL_STATUS_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_XG1_LCPLL_FBDIV_CTRL_0
 * BLOCKS:   TOP
 * DESC:     XG1 LCPLL feedback divider control register 0
 * SIZE:     32
 * FIELDS:
 *     XG1_LCPLL_FBDIV_0 Serdes LCPLL feedback div control value-0 (First 32-bits)
 */
#define TOP_XG1_LCPLL_FBDIV_CTRL_0r_SIZE 4

/* TOP_XG1_LCPLL_FBDIV_CTRL_0r is element of TOP_XG1_LCPLL_FBDIV_CTRL */

/*
 * This structure should be used to declare and program TOP_XG1_LCPLL_FBDIV_CTRL_0.
 */
typedef union TOP_XG1_LCPLL_FBDIV_CTRL_0r_s {
	uint32 v[1];
	uint32 top_xg1_lcpll_fbdiv_ctrl_0[1];
	uint32 _top_xg1_lcpll_fbdiv_ctrl_0;
} TOP_XG1_LCPLL_FBDIV_CTRL_0r_t;

#define TOP_XG1_LCPLL_FBDIV_CTRL_0r_CLR(r) (r).top_xg1_lcpll_fbdiv_ctrl_0[0] = 0
#define TOP_XG1_LCPLL_FBDIV_CTRL_0r_SET(r,d) (r).top_xg1_lcpll_fbdiv_ctrl_0[0] = d
#define TOP_XG1_LCPLL_FBDIV_CTRL_0r_GET(r) (r).top_xg1_lcpll_fbdiv_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG1_LCPLL_FBDIV_CTRL_0r_XG1_LCPLL_FBDIV_0f_GET(r) ((r).top_xg1_lcpll_fbdiv_ctrl_0[0])
#define TOP_XG1_LCPLL_FBDIV_CTRL_0r_XG1_LCPLL_FBDIV_0f_SET(r,f) (r).top_xg1_lcpll_fbdiv_ctrl_0[0]=((uint32)f)

/*
 * These macros can be used to access TOP_XG1_LCPLL_FBDIV_CTRL_0.
 */
#define WRITE_TOP_XG1_LCPLL_FBDIV_CTRL_0r(u,r) bcm5354x_reg_set(u,R_TOP_XG1_LCPLL_FBDIV_CTRL_0,(r._top_xg1_lcpll_fbdiv_ctrl_0))
#define READ_TOP_XG1_LCPLL_FBDIV_CTRL_0r(u,r) bcm5354x_reg_get(u,R_TOP_XG1_LCPLL_FBDIV_CTRL_0,&(r._top_xg1_lcpll_fbdiv_ctrl_0))

/*******************************************************************************
 * End of 'TOP_XG1_LCPLL_FBDIV_CTRL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOP_XG1_LCPLL_FBDIV_CTRL_1
 * BLOCKS:   TOP
 * DESC:     XG1 LCPLL feedback divider control register 1
 * SIZE:     32
 * FIELDS:
 *     XG1_LCPLL_FBDIV_1 Serdes LCPLL feedback div control value-1 (last 16-bits)
 *     RESERVED         Reserved
 */
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_SIZE 4

/* TOP_XG1_LCPLL_FBDIV_CTRL_1r is element of TOP_XG1_LCPLL_FBDIV_CTRL */

/*
 * This structure should be used to declare and program TOP_XG1_LCPLL_FBDIV_CTRL_1.
 */
typedef union TOP_XG1_LCPLL_FBDIV_CTRL_1r_s {
	uint32 v[1];
	uint32 top_xg1_lcpll_fbdiv_ctrl_1[1];
	uint32 _top_xg1_lcpll_fbdiv_ctrl_1;
} TOP_XG1_LCPLL_FBDIV_CTRL_1r_t;

#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_CLR(r) (r).top_xg1_lcpll_fbdiv_ctrl_1[0] = 0
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_SET(r,d) (r).top_xg1_lcpll_fbdiv_ctrl_1[0] = d
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_GET(r) (r).top_xg1_lcpll_fbdiv_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_XG1_LCPLL_FBDIV_1f_GET(r) (((r).top_xg1_lcpll_fbdiv_ctrl_1[0]) & 0xffff)
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_XG1_LCPLL_FBDIV_1f_SET(r,f) (r).top_xg1_lcpll_fbdiv_ctrl_1[0]=(((r).top_xg1_lcpll_fbdiv_ctrl_1[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_RESERVEDf_GET(r) ((((r).top_xg1_lcpll_fbdiv_ctrl_1[0]) >> 16) & 0xffff)
#define TOP_XG1_LCPLL_FBDIV_CTRL_1r_RESERVEDf_SET(r,f) (r).top_xg1_lcpll_fbdiv_ctrl_1[0]=(((r).top_xg1_lcpll_fbdiv_ctrl_1[0] & ~((uint32)0xffff << 16)) | ((((uint32)f) & 0xffff) << 16))

/*
 * These macros can be used to access TOP_XG1_LCPLL_FBDIV_CTRL_1.
 */
#define WRITE_TOP_XG1_LCPLL_FBDIV_CTRL_1r(u,r) bcm5354x_reg_set(u,R_TOP_XG1_LCPLL_FBDIV_CTRL_1,(r._top_xg1_lcpll_fbdiv_ctrl_1))
#define READ_TOP_XG1_LCPLL_FBDIV_CTRL_1r(u,r) bcm5354x_reg_get(u,R_TOP_XG1_LCPLL_FBDIV_CTRL_1,&(r._top_xg1_lcpll_fbdiv_ctrl_1))

/*******************************************************************************
 * End of 'TOP_XG1_LCPLL_FBDIV_CTRL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOTALDYNCELLRESETLIMIT
 * BLOCKS:   MMU
 * DESC:     Cell based dynamic (shared buffer pool) memory usage resume threshold When MISCCONFIG.DYNAMIC_MEMORY_EN=0, this register is not used.

 * SIZE:     32
 * FIELDS:
 *     TOTALDYNCELLRESETLIMIT To reset a cos queue's HOL status, it must meet following conditions:((DYNCELLCOUNT(port) < DYNCELLLIMIT.RESETLIMIT(port))AND(TOTALDYNCELLLUSED < TOTALDYNCELLRESETLIMIT.TOTALDYNCELLRESETLIMIT))OR(COSLCCOUNT(port,cos) <LWMCOSCELLSETLIMIT.CELLRESETLIMIT(port,cos)) 
 */
#define TOTALDYNCELLRESETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program TOTALDYNCELLRESETLIMIT.
 */
typedef union TOTALDYNCELLRESETLIMITr_s {
	uint32 v[1];
	uint32 totaldyncellresetlimit[1];
	uint32 _totaldyncellresetlimit;
} TOTALDYNCELLRESETLIMITr_t;

#define TOTALDYNCELLRESETLIMITr_CLR(r) (r).totaldyncellresetlimit[0] = 0
#define TOTALDYNCELLRESETLIMITr_SET(r,d) (r).totaldyncellresetlimit[0] = d
#define TOTALDYNCELLRESETLIMITr_GET(r) (r).totaldyncellresetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_GET(r) (((r).totaldyncellresetlimit[0]) & 0x3ffff)
#define TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_SET(r,f) (r).totaldyncellresetlimit[0]=(((r).totaldyncellresetlimit[0] & ~((uint32)0x3ffff)) | (((uint32)f) & 0x3ffff))

/*
 * These macros can be used to access TOTALDYNCELLRESETLIMIT.
 */
#define WRITE_TOTALDYNCELLRESETLIMITr(u,r) bcm5354x_reg_set(u,R_TOTALDYNCELLRESETLIMIT,(r._totaldyncellresetlimit))
#define READ_TOTALDYNCELLRESETLIMITr(u,r) bcm5354x_reg_get(u,R_TOTALDYNCELLRESETLIMIT,&(r._totaldyncellresetlimit))

/*******************************************************************************
 * End of 'TOTALDYNCELLRESETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TOTALDYNCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     Cell-based dynamic (shared buffer pool) memory usage drop threshold. When MISCCONFIG.DYNAMIC_MEMORY_EN=0, this register is not used. 

 * SIZE:     32
 * FIELDS:
 *     TOTALDYNCELLSETLIMIT The TOTALDYNCELLLIMIT register limits the maximum cells in the chips global pool for use as dynamic memory.When TOTALDYNCELLUSED >= TOTALDYNCELLSETLIMIT.TOTALDYNCELLSETLIMIT ports that require dynamic memory will be set in HOL status and stop admitting any new incoming cells. 
 */
#define TOTALDYNCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program TOTALDYNCELLSETLIMIT.
 */
typedef union TOTALDYNCELLSETLIMITr_s {
	uint32 v[1];
	uint32 totaldyncellsetlimit[1];
	uint32 _totaldyncellsetlimit;
} TOTALDYNCELLSETLIMITr_t;

#define TOTALDYNCELLSETLIMITr_CLR(r) (r).totaldyncellsetlimit[0] = 0
#define TOTALDYNCELLSETLIMITr_SET(r,d) (r).totaldyncellsetlimit[0] = d
#define TOTALDYNCELLSETLIMITr_GET(r) (r).totaldyncellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 */
#define TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_GET(r) (((r).totaldyncellsetlimit[0]) & 0x3ffff)
#define TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_SET(r,f) (r).totaldyncellsetlimit[0]=(((r).totaldyncellsetlimit[0] & ~((uint32)0x3ffff)) | (((uint32)f) & 0x3ffff))

/*
 * These macros can be used to access TOTALDYNCELLSETLIMIT.
 */
#define WRITE_TOTALDYNCELLSETLIMITr(u,r) bcm5354x_reg_set(u,R_TOTALDYNCELLSETLIMIT,(r._totaldyncellsetlimit))
#define READ_TOTALDYNCELLSETLIMITr(u,r) bcm5354x_reg_get(u,R_TOTALDYNCELLSETLIMIT,&(r._totaldyncellsetlimit))

/*******************************************************************************
 * End of 'TOTALDYNCELLSETLIMITr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  TRUNK32_CONFIG_TABLE
 * BLOCKS:   IPIPE
 * DESC:      TRUNK32_CONFIG_TABLE holds fields necessary to further parse a HiGig packet when the
source is a TrunkID \(no src_modid/port are present\).
This table is indexed via TGID[4:0]
 * SIZE:     7
 * FIELDS:
 *     OUTER_TPID_ENABLE Indicates if ING_OUTER_TPID[3] to ING_OUTER_TPID[0] are allowed outer TPID values.
 *     INNER_TPID_ENABLE .
 *     MIML_ENABLE      Enable MIML feature.
 *     CUSTOM_HEADER_ENABLE Enable CUSTOME_HEADER feature.
 */
#define TRUNK32_CONFIG_TABLEm_MIN 0
#define TRUNK32_CONFIG_TABLEm_MAX 31
#define TRUNK32_CONFIG_TABLEm_CMAX(u) 31
#define TRUNK32_CONFIG_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program TRUNK32_CONFIG_TABLE.
 */
typedef union TRUNK32_CONFIG_TABLEm_s {
	uint32 v[1];
	uint32 trunk32_config_table[1];
	uint32 _trunk32_config_table;
} TRUNK32_CONFIG_TABLEm_t;

#define TRUNK32_CONFIG_TABLEm_CLR(r) (r).trunk32_config_table[0] = 0
#define TRUNK32_CONFIG_TABLEm_SET(r,d) (r).trunk32_config_table[0] = d
#define TRUNK32_CONFIG_TABLEm_GET(r) (r).trunk32_config_table[0]

/*
 * These macros can be used to access individual fields.
 */
#define TRUNK32_CONFIG_TABLEm_OUTER_TPID_ENABLEf_GET(r) (((r).trunk32_config_table[0]) & 0xf)
#define TRUNK32_CONFIG_TABLEm_OUTER_TPID_ENABLEf_SET(r,f) (r).trunk32_config_table[0]=(((r).trunk32_config_table[0] & ~((uint32)0xf)) | (((uint32)f) & 0xf))
#define TRUNK32_CONFIG_TABLEm_INNER_TPID_ENABLEf_GET(r) ((((r).trunk32_config_table[0]) >> 4) & 0x1)
#define TRUNK32_CONFIG_TABLEm_INNER_TPID_ENABLEf_SET(r,f) (r).trunk32_config_table[0]=(((r).trunk32_config_table[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define TRUNK32_CONFIG_TABLEm_MIML_ENABLEf_GET(r) ((((r).trunk32_config_table[0]) >> 5) & 0x1)
#define TRUNK32_CONFIG_TABLEm_MIML_ENABLEf_SET(r,f) (r).trunk32_config_table[0]=(((r).trunk32_config_table[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define TRUNK32_CONFIG_TABLEm_CUSTOM_HEADER_ENABLEf_GET(r) ((((r).trunk32_config_table[0]) >> 6) & 0x1)
#define TRUNK32_CONFIG_TABLEm_CUSTOM_HEADER_ENABLEf_SET(r,f) (r).trunk32_config_table[0]=(((r).trunk32_config_table[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))

/*
 * These macros can be used to access TRUNK32_CONFIG_TABLE.
 */
#define WRITE_TRUNK32_CONFIG_TABLEm(u,i,r) bcm5354x_mem_set(u, M_TRUNK32_CONFIG_TABLE(i), &(r._trunk32_config_table), 1)
#define READ_TRUNK32_CONFIG_TABLEm(u,i,r) bcm5354x_mem_get(u, M_TRUNK32_CONFIG_TABLE(i), &(r._trunk32_config_table), 1)

/*******************************************************************************
 * End of 'TRUNK32_CONFIG_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  TRUNK32_PORT_TABLE
 * BLOCKS:   IPIPE
 * DESC:      Trunks 32 mode Port table
This table is used when supporting 32 trunk group mode to provide port profiles for HiGig lookup based on source port
The index into this table is the TGID.
 * SIZE:     41
 * FIELDS:
 *     LPORT_PROFILE_IDX Index to LPORT PROFILE Table.
 *     CLASS_ID         Source port Class ID
 *     VLAN_RANGE_IDX   Source port vlan range table index
 *     RESERVED_19      Reserved
 *     MA_BASE_POINTER  MA_BASE_POINTER.
 *     PACKET_MODIFICATION_DISABLE .
 *     DISABLE_VLAN_CHECKS If set, then spanning tree and VLAN memberships checks are not performed.  This should be set if PORT_OPERATION is for VPWS, VPLS or L3 VPN (note: the checks should remain enabled for a GPON SVP)
 *     L3_IIF           L3 Interface.
 *     RESERVED_37      Reserved
 */
#define TRUNK32_PORT_TABLEm_MIN 0
#define TRUNK32_PORT_TABLEm_MAX 31
#define TRUNK32_PORT_TABLEm_CMAX(u) 31
#define TRUNK32_PORT_TABLEm_SIZE 6

/*
 * This structure should be used to declare and program TRUNK32_PORT_TABLE.
 */
typedef union TRUNK32_PORT_TABLEm_s {
	uint32 v[2];
	uint32 trunk32_port_table[2];
	uint32 _trunk32_port_table;
} TRUNK32_PORT_TABLEm_t;

#define TRUNK32_PORT_TABLEm_CLR(r) sal_memset(&((r)._trunk32_port_table), 0, sizeof(TRUNK32_PORT_TABLEm_t))
#define TRUNK32_PORT_TABLEm_SET(r,i,d) (r).trunk32_port_table[i] = d
#define TRUNK32_PORT_TABLEm_GET(r,i) (r).trunk32_port_table[i]

/*
 * These macros can be used to access individual fields.
 */
#define TRUNK32_PORT_TABLEm_LPORT_PROFILE_IDXf_GET(r) (((r).trunk32_port_table[0]) & 0x3f)
#define TRUNK32_PORT_TABLEm_LPORT_PROFILE_IDXf_SET(r,f) (r).trunk32_port_table[0]=(((r).trunk32_port_table[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define TRUNK32_PORT_TABLEm_CLASS_IDf_GET(r) ((((r).trunk32_port_table[0]) >> 6) & 0xff)
#define TRUNK32_PORT_TABLEm_CLASS_IDf_SET(r,f) (r).trunk32_port_table[0]=(((r).trunk32_port_table[0] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define TRUNK32_PORT_TABLEm_VLAN_RANGE_IDXf_GET(r) ((((r).trunk32_port_table[0]) >> 14) & 0x1f)
#define TRUNK32_PORT_TABLEm_VLAN_RANGE_IDXf_SET(r,f) (r).trunk32_port_table[0]=(((r).trunk32_port_table[0] & ~((uint32)0x1f << 14)) | ((((uint32)f) & 0x1f) << 14))
#define TRUNK32_PORT_TABLEm_RESERVED_19f_GET(r) ((((r).trunk32_port_table[0]) >> 19) & 0x3)
#define TRUNK32_PORT_TABLEm_RESERVED_19f_SET(r,f) (r).trunk32_port_table[0]=(((r).trunk32_port_table[0] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define TRUNK32_PORT_TABLEm_MA_BASE_POINTERf_GET(r) ((((r).trunk32_port_table[0]) >> 21) & 0x1ff)
#define TRUNK32_PORT_TABLEm_MA_BASE_POINTERf_SET(r,f) (r).trunk32_port_table[0]=(((r).trunk32_port_table[0] & ~((uint32)0x1ff << 21)) | ((((uint32)f) & 0x1ff) << 21))
#define TRUNK32_PORT_TABLEm_PACKET_MODIFICATION_DISABLEf_GET(r) ((((r).trunk32_port_table[0]) >> 30) & 0x1)
#define TRUNK32_PORT_TABLEm_PACKET_MODIFICATION_DISABLEf_SET(r,f) (r).trunk32_port_table[0]=(((r).trunk32_port_table[0] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))
#define TRUNK32_PORT_TABLEm_DISABLE_VLAN_CHECKSf_GET(r) ((((r).trunk32_port_table[0]) >> 31) & 0x1)
#define TRUNK32_PORT_TABLEm_DISABLE_VLAN_CHECKSf_SET(r,f) (r).trunk32_port_table[0]=(((r).trunk32_port_table[0] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define TRUNK32_PORT_TABLEm_L3_IIFf_GET(r) (((r).trunk32_port_table[1]) & 0x1f)
#define TRUNK32_PORT_TABLEm_L3_IIFf_SET(r,f) (r).trunk32_port_table[1]=(((r).trunk32_port_table[1] & ~((uint32)0x1f)) | (((uint32)f) & 0x1f))
#define TRUNK32_PORT_TABLEm_RESERVED_37f_GET(r) ((((r).trunk32_port_table[1]) >> 5) & 0xf)
#define TRUNK32_PORT_TABLEm_RESERVED_37f_SET(r,f) (r).trunk32_port_table[1]=(((r).trunk32_port_table[1] & ~((uint32)0xf << 5)) | ((((uint32)f) & 0xf) << 5))

/*
 * These macros can be used to access TRUNK32_PORT_TABLE.
 */
#define WRITE_TRUNK32_PORT_TABLEm(u,i,r) bcm5354x_mem_set(u, M_TRUNK32_PORT_TABLE(i), &(r._trunk32_port_table), 2)
#define READ_TRUNK32_PORT_TABLEm(u,i,r) bcm5354x_mem_get(u, M_TRUNK32_PORT_TABLE(i), &(r._trunk32_port_table), 2)

/*******************************************************************************
 * End of 'TRUNK32_PORT_TABLEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  TRUNK_BITMAP
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Bitmap Table
The trunk group table is 128 entries deep and 30 bits wide, with one entry for each trunk group. Each entry consists of a port bitmap of the member ports. If the packet comes in from one of the trunk ports, the TGID is used as the index into this table to drive the trunk group.
 * SIZE:     33
 * FIELDS:
 *     TRUNK_BITMAP     Source Trunk (LAG) Bitmap Table
 *     TRUNK_BITMAP_LO  Overlay bitmap for ports 31:0
 *     EVEN_PARITY      Even parity.
 */
#define TRUNK_BITMAPm_MIN 0
#define TRUNK_BITMAPm_MAX 7
#define TRUNK_BITMAPm_CMAX(u) 7
#define TRUNK_BITMAPm_SIZE 5

/*
 * This structure should be used to declare and program TRUNK_BITMAP.
 */
typedef union TRUNK_BITMAPm_s {
	uint32 v[2];
	uint32 trunk_bitmap[2];
	uint32 _trunk_bitmap;
} TRUNK_BITMAPm_t;

#define TRUNK_BITMAPm_CLR(r) sal_memset(&((r)._trunk_bitmap), 0, sizeof(TRUNK_BITMAPm_t))
#define TRUNK_BITMAPm_SET(r,i,d) (r).trunk_bitmap[i] = d
#define TRUNK_BITMAPm_GET(r,i) (r).trunk_bitmap[i]

/*
 * These macros can be used to access individual fields.
 */
#define TRUNK_BITMAPm_TRUNK_BITMAPf_GET(r) ((r).trunk_bitmap[0])
#define TRUNK_BITMAPm_TRUNK_BITMAPf_SET(r,f) (r).trunk_bitmap[0]=((uint32)f)
#define TRUNK_BITMAPm_TRUNK_BITMAP_LOf_GET(r) ((r).trunk_bitmap[0])
#define TRUNK_BITMAPm_TRUNK_BITMAP_LOf_SET(r,f) (r).trunk_bitmap[0]=((uint32)f)
#define TRUNK_BITMAPm_EVEN_PARITYf_GET(r) (((r).trunk_bitmap[1]) & 0x1)
#define TRUNK_BITMAPm_EVEN_PARITYf_SET(r,f) (r).trunk_bitmap[1]=(((r).trunk_bitmap[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access TRUNK_BITMAP.
 */
#define WRITE_TRUNK_BITMAPm(u,i,r) bcm5354x_mem_set(u, M_TRUNK_BITMAP(i), &(r._trunk_bitmap), 2)
#define READ_TRUNK_BITMAPm(u,i,r) bcm5354x_mem_get(u, M_TRUNK_BITMAP(i), &(r._trunk_bitmap), 2)

/*******************************************************************************
 * End of 'TRUNK_BITMAPm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  TRUNK_GROUP
 * BLOCKS:   IPIPE
 * DESC:     Trunk Group Table 
The trunk group table contains the information for up to 128 trunk groups. Each trunk group table entry contains up to eight different ports, which can be trunked together. Each entry consists of eight port addresses of the member ports. Each trunk port address consists of a 7-bit module ID and 6-bit port number. Search this table with TGID to drive the trunk group. RTAG is used as the criterion to drive a trunk port index, which points to the egress port address (TPn) in the trunk group. Trunking over stacking links is supported on this device. The trunk group table is consistently accessed using a destination trunk group, and rather than bind the source RTAG to a table used solely for destination trunking (the trunk group table), the source RTAG is bound to the table used solely for source trunking (the trunk bitmap table). The RTAGs for each entry in the trunk bitmap table must be identical to the RTAGs for each corresponding entry in the trunk group table.
 * SIZE:     120
 * FIELDS:
 *     PORT0            trunk port 0
 *     MODULE0          module id 0
 *     PORT1            trunk port 1
 *     MODULE1          module id 1
 *     PORT2            trunk port 2
 *     MODULE2          module id 2
 *     PORT3            trunk port 3
 *     MODULE3          module id 3
 *     PORT4            trunk port 4
 *     MODULE4          module id 4
 *     PORT5            trunk port 5
 *     MODULE5          module id 5
 *     PORT6            trunk port 6
 *     MODULE6          module id 6
 *     PORT7            trunk port 7
 *     MODULE7          module id 7
 *     RTAG             Supported RTAG values
 *     RESERVED         reserved field.
 *     EVEN_PARITY      Even parity.
 */
#define TRUNK_GROUPm_MIN 0
#define TRUNK_GROUPm_MAX 7
#define TRUNK_GROUPm_CMAX(u) 7
#define TRUNK_GROUPm_SIZE 15

/*
 * This structure should be used to declare and program TRUNK_GROUP.
 */
typedef union TRUNK_GROUPm_s {
	uint32 v[4];
	uint32 trunk_group[4];
	uint32 _trunk_group;
} TRUNK_GROUPm_t;

#define TRUNK_GROUPm_CLR(r) sal_memset(&((r)._trunk_group), 0, sizeof(TRUNK_GROUPm_t))
#define TRUNK_GROUPm_SET(r,i,d) (r).trunk_group[i] = d
#define TRUNK_GROUPm_GET(r,i) (r).trunk_group[i]

/*
 * These macros can be used to access individual fields.
 */
#define TRUNK_GROUPm_PORT0f_GET(r) (((r).trunk_group[0]) & 0x3f)
#define TRUNK_GROUPm_PORT0f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32)0x3f)) | (((uint32)f) & 0x3f))
#define TRUNK_GROUPm_MODULE0f_GET(r) ((((r).trunk_group[0]) >> 6) & 0xff)
#define TRUNK_GROUPm_MODULE0f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32)0xff << 6)) | ((((uint32)f) & 0xff) << 6))
#define TRUNK_GROUPm_PORT1f_GET(r) ((((r).trunk_group[0]) >> 14) & 0x3f)
#define TRUNK_GROUPm_PORT1f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32)0x3f << 14)) | ((((uint32)f) & 0x3f) << 14))
#define TRUNK_GROUPm_MODULE1f_GET(r) ((((r).trunk_group[0]) >> 20) & 0xff)
#define TRUNK_GROUPm_MODULE1f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32)0xff << 20)) | ((((uint32)f) & 0xff) << 20))
#define TRUNK_GROUPm_PORT2f_GET(r) field32_get((r).trunk_group,28,33)
#define TRUNK_GROUPm_PORT2f_SET(r,f) field32_set((r).trunk_group,28,33,f)
#define TRUNK_GROUPm_MODULE2f_GET(r) ((((r).trunk_group[1]) >> 2) & 0xff)
#define TRUNK_GROUPm_MODULE2f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32)0xff << 2)) | ((((uint32)f) & 0xff) << 2))
#define TRUNK_GROUPm_PORT3f_GET(r) ((((r).trunk_group[1]) >> 10) & 0x3f)
#define TRUNK_GROUPm_PORT3f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32)0x3f << 10)) | ((((uint32)f) & 0x3f) << 10))
#define TRUNK_GROUPm_MODULE3f_GET(r) ((((r).trunk_group[1]) >> 16) & 0xff)
#define TRUNK_GROUPm_MODULE3f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define TRUNK_GROUPm_PORT4f_GET(r) ((((r).trunk_group[1]) >> 24) & 0x3f)
#define TRUNK_GROUPm_PORT4f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))
#define TRUNK_GROUPm_MODULE4f_GET(r) field32_get((r).trunk_group,62,69)
#define TRUNK_GROUPm_MODULE4f_SET(r,f) field32_set((r).trunk_group,62,69,f)
#define TRUNK_GROUPm_PORT5f_GET(r) ((((r).trunk_group[2]) >> 6) & 0x3f)
#define TRUNK_GROUPm_PORT5f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32)0x3f << 6)) | ((((uint32)f) & 0x3f) << 6))
#define TRUNK_GROUPm_MODULE5f_GET(r) ((((r).trunk_group[2]) >> 12) & 0xff)
#define TRUNK_GROUPm_MODULE5f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32)0xff << 12)) | ((((uint32)f) & 0xff) << 12))
#define TRUNK_GROUPm_PORT6f_GET(r) ((((r).trunk_group[2]) >> 20) & 0x3f)
#define TRUNK_GROUPm_PORT6f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32)0x3f << 20)) | ((((uint32)f) & 0x3f) << 20))
#define TRUNK_GROUPm_MODULE6f_GET(r) field32_get((r).trunk_group,90,97)
#define TRUNK_GROUPm_MODULE6f_SET(r,f) field32_set((r).trunk_group,90,97,f)
#define TRUNK_GROUPm_PORT7f_GET(r) ((((r).trunk_group[3]) >> 2) & 0x3f)
#define TRUNK_GROUPm_PORT7f_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32)0x3f << 2)) | ((((uint32)f) & 0x3f) << 2))
#define TRUNK_GROUPm_MODULE7f_GET(r) ((((r).trunk_group[3]) >> 8) & 0xff)
#define TRUNK_GROUPm_MODULE7f_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define TRUNK_GROUPm_RTAGf_GET(r) ((((r).trunk_group[3]) >> 16) & 0x7)
#define TRUNK_GROUPm_RTAGf_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32)0x7 << 16)) | ((((uint32)f) & 0x7) << 16))
#define TRUNK_GROUPm_RESERVEDf_GET(r) ((((r).trunk_group[3]) >> 22) & 0x1)
#define TRUNK_GROUPm_RESERVEDf_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define TRUNK_GROUPm_EVEN_PARITYf_GET(r) ((((r).trunk_group[3]) >> 23) & 0x1)
#define TRUNK_GROUPm_EVEN_PARITYf_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))

/*
 * These macros can be used to access TRUNK_GROUP.
 */
#define WRITE_TRUNK_GROUPm(u,i,r) bcm5354x_mem_set(u, M_TRUNK_GROUP(i), &(r._trunk_group), 4)
#define READ_TRUNK_GROUPm(u,i,r) bcm5354x_mem_get(u, M_TRUNK_GROUP(i), &(r._trunk_group), 4)

/*******************************************************************************
 * End of 'TRUNK_GROUPm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TS_STATUS_CNTRL
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Timestamp control/status
 * SIZE:     32
 * FIELDS:
 *     TX_TS_FIFO_FULL  Read-only field assertion shows that the transmit timestamp FIFO is full. 
 *     TX_TS_FIFO_EMPTY Read-only field assertion shows that the transmit timestamp FIFO is empty. 
 *     WORD_AVAIL       Indicates number of cells filled in the TX timestamp FIFO.
 */
#define TS_STATUS_CNTRLr_SIZE 4

/*
 * This structure should be used to declare and program TS_STATUS_CNTRL.
 */
typedef union TS_STATUS_CNTRLr_s {
	uint32 v[1];
	uint32 ts_status_cntrl[1];
	uint32 _ts_status_cntrl;
} TS_STATUS_CNTRLr_t;

#define TS_STATUS_CNTRLr_CLR(r) (r).ts_status_cntrl[0] = 0
#define TS_STATUS_CNTRLr_SET(r,d) (r).ts_status_cntrl[0] = d
#define TS_STATUS_CNTRLr_GET(r) (r).ts_status_cntrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define TS_STATUS_CNTRLr_TX_TS_FIFO_FULLf_GET(r) (((r).ts_status_cntrl[0]) & 0x1)
#define TS_STATUS_CNTRLr_TX_TS_FIFO_FULLf_SET(r,f) (r).ts_status_cntrl[0]=(((r).ts_status_cntrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define TS_STATUS_CNTRLr_TX_TS_FIFO_EMPTYf_GET(r) ((((r).ts_status_cntrl[0]) >> 1) & 0x1)
#define TS_STATUS_CNTRLr_TX_TS_FIFO_EMPTYf_SET(r,f) (r).ts_status_cntrl[0]=(((r).ts_status_cntrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define TS_STATUS_CNTRLr_WORD_AVAILf_GET(r) ((((r).ts_status_cntrl[0]) >> 2) & 0x7)
#define TS_STATUS_CNTRLr_WORD_AVAILf_SET(r,f) (r).ts_status_cntrl[0]=(((r).ts_status_cntrl[0] & ~((uint32)0x7 << 2)) | ((((uint32)f) & 0x7) << 2))

/*
 * These macros can be used to access TS_STATUS_CNTRL.
 */
#define WRITE_TS_STATUS_CNTRLr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_TS_STATUS_CNTRL(bcm5354x_gport_lport_to_index_in_block[p]), (r._ts_status_cntrl))
#define READ_TS_STATUS_CNTRLr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_TS_STATUS_CNTRL(bcm5354x_gport_lport_to_index_in_block[p]), &(r._ts_status_cntrl))

/*******************************************************************************
 * End of 'TS_STATUS_CNTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * SWFORMAT:  TX_DCB
 * BLOCKS:  
 * DESC:     Packet DMA TX descriptor.
 * SIZE:     512
 * FIELDS:
 *     BYTES_TRANSFERRED Actual number of bytes transferred
 *     DONE             Done bit
 *     UNUSED           Unused
 *     MODULE_HEADER_WD3 Unused
 *     SOBMH_CELL_LENGTH CELL_LENGTH (set by hardware - in Iarb).
 *     SOBMH_EOP        EOP indicator (set by hardware - in Iarb).
 *     SOBMH_SOP        SOP indicator (set by hardware - in Iarb).
 *     SOBMH_PKT_LENGTH PKT_LENGTH (set by hardware - in Iarb).
 *     SOBMH_IPCF_PTR   Pointer to cell buffer of this SOBMH cell. (Set by hardware)
 *     SOBMH_RESERVED_IPCF_PTR Pointer to cell buffer of this SOBMH cell. (Set by hardware)
 *     MODULE_HEADER_WD2 Module Header, bits 95:64.Valid only if HIGIG_PKT bit is set to 1 in this descriptor. 
 *     SOBMH_SRC_MODID  Source module ID, must be programmed to MY_MODID.
 *     SOBMH_QUEUE_NUM  Queue number to be used for unicast queuing and CPU queue (CPU_COS).
 *     SOBMH_NLF_PORT_NUMBER Logical Egress port number provided by the EP
 *     SOBMH_UNICAST    Indicates that PBI.UNICAST should be set to queue as unicast packet.
 *     SOBMH_SPAP       For PBI.SPAP - Service Pool Priority (color)
 *     SOBMH_SPID       For PBI.SPID - Service Pool ID
 *     SOBMH_SPID_OVERRIDE For PBI.SPID_Override
 *     SOBMH_COS        Class of service for MMU queueing for this packet - sets COS values, PBI.UC_COS, PBI.MC_COS1, and PBI.MC_COS2.
 *     SOBMH_INT_PRI    Internal Priority used for CPU_COS_MAP TCAM lookups for EP COPY TO CPU (header type 0) to generate CPU_COS
 *     SOBMH_INPUT_PRI  Traffic priority to be applied to MMU via PBI.INPUT_PRIORITY.
 *     MODULE_HEADER_WD1 Module Header, bits 63:32.Valid only if HIGIG_PKT bit is set to 1 in this descriptor. 
 *     SOBMH_LOCAL_DEST_PORT Indicates the local port to send a SOBMH packet out.
 *     SOBMH_SET_L2BM   Indicates that PBI.L2_BITMAP should be set (to queue as L2MC packet).
 *     SOBMH_IEEE1588_TIMESTAMP_HDR_OFFSET HDR_OFFSET
 *     SOBMH_SET_L3BM   Indicates that PBI.L3_BITMAP should be set (to queue as IPMC packet).
 *     SOBMH_TX_TS      Indicates for TS packet transmitted from CPU into IP that the outgoing packet needs to have its transmit timestamp captured by the port.
 *     SOBMH_IEEE1588_INGRESS_TIMESTAMP_SIGN ITS_SIGN
 *     SOBMH_IEEE1588_REGEN_UDP_CHECKSUM Regenerate UDP Checksum
 *     SOBMH_IEEE1588_ONE_STEP_ENABLE ONE STEP TIME STAMPING ENABLE
 *     SOBMH_RESERVED_4 Reserved
 *     SOBMH_OAM_REPLACEMENT_TYPE 00:NOP 01:DM 10:NTP 11:LM
 *     SOBMH_CELL_ERROR CELL_ERROR or PURGE
 *     SOBMH_RESERVED_1 RESERVED
 *     SOBMH_OAM_REPLACEMENT_OFFSET From CPU indicatinf insertion point in packet for LM count or DM Timestamp. Has 14 Byte offset with 2 byte increments
 *     SOBMH_QUEUE_NUM_UPPER Holds upper 2 bit of the QUEUE_NUM field.
 *     MODULE_HEADER_WD0 Module Header, bits 31:0.Valid only if HIGIG_PKT bit is set to 1 in this descriptor. 
 *     SOBMH_EP_CPU_REASON_CODE EP Copy to CPU Reasons
 *     SOBMH_LM_COUNTER_INDEX From CPU indicating LM Counter Index
 *     SOBMH_RESERVED_3 Reserved
 *     SOBMH_RESERVED_5 Reserved
 *     SOBMH_HEADER_TYPE 64 Header Types Supported
 *     SOBMH_START      Start of frame indicator. 
 *     BYTE_COUNT       Byte count for the transfer
 *     CHAIN            Chain bit
 *     GATHER           Gather bit
 *     RELOAD           Reload bit
 *     HIGIG_PKT        Specifies whether the current packet is in Higig format.0=Regular Ethernet format, 1=Higig format
 *     STAT_UPDATE      Stat Update bit
 *     PAUSE_PACKET     Pause packet bit
 *     PURGE_PACKET     Stat Update bit
 *     INTERRUPT        SW controlled Interrupt generation.This control is required for Continuous DMA support. bit[0]: 1 - HW asserts descriptor done interrupt after descriptor completion. 0 - Interrupt disabled.  bit[1]: 1 - HW asserts IRQ_STAT0.CH3_DESC_CONTROLLED_INTR after descriptor completion. 0 - interrupt disabled. 1  Output mode (output time values)
 *     MEM_ADDR         Physical memory address for the transfer.Note: The packet contents starting at this address should not havethe module header, and hence must always start with the DA.The module header must be specified in the descriptor for Higig packets.
 */
#define TX_DCB_SIZE 64

/*
 * This structure should be used to declare and program TX_DCB.
 */
typedef union TX_DCB_s {
	uint32 v[16];
	uint32 tx_dcb[16];
	uint32 _tx_dcb;
} TX_DCB_t;

#define TX_DCB_CLR(r) sal_memset(&((r)._tx_dcb), 0, sizeof(TX_DCB_t))
#define TX_DCB_SET(r,i,d) (r).tx_dcb[i] = d
#define TX_DCB_GET(r,i) (r).tx_dcb[i]

/*
 * These macros can be used to access individual fields.
 */
#define TX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).tx_dcb[15]) & 0xffff)
#define TX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).tx_dcb[15]=(((r).tx_dcb[15] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define TX_DCB_DONEf_GET(r) ((((r).tx_dcb[15]) >> 31) & 0x1)
#define TX_DCB_DONEf_SET(r,f) (r).tx_dcb[15]=(((r).tx_dcb[15] & ~((uint32)0x1 << 31)) | ((((uint32)f) & 0x1) << 31))
#define TX_DCB_UNUSEDf_GET(r) ((r).tx_dcb[14])
#define TX_DCB_UNUSEDf_SET(r,f) (r).tx_dcb[14]=((uint32)f)
#define TX_DCB_MODULE_HEADER_WD3f_GET(r) ((r).tx_dcb[5])
#define TX_DCB_MODULE_HEADER_WD3f_SET(r,f) (r).tx_dcb[5]=((uint32)f)
#define TX_DCB_SOBMH_CELL_LENGTHf_GET(r) (((r).tx_dcb[5]) & 0xff)
#define TX_DCB_SOBMH_CELL_LENGTHf_SET(r,f) (r).tx_dcb[5]=(((r).tx_dcb[5] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define TX_DCB_SOBMH_EOPf_GET(r) ((((r).tx_dcb[5]) >> 8) & 0x1)
#define TX_DCB_SOBMH_EOPf_SET(r,f) (r).tx_dcb[5]=(((r).tx_dcb[5] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define TX_DCB_SOBMH_SOPf_GET(r) ((((r).tx_dcb[5]) >> 9) & 0x1)
#define TX_DCB_SOBMH_SOPf_SET(r,f) (r).tx_dcb[5]=(((r).tx_dcb[5] & ~((uint32)0x1 << 9)) | ((((uint32)f) & 0x1) << 9))
#define TX_DCB_SOBMH_PKT_LENGTHf_GET(r) ((((r).tx_dcb[5]) >> 10) & 0x3fff)
#define TX_DCB_SOBMH_PKT_LENGTHf_SET(r,f) (r).tx_dcb[5]=(((r).tx_dcb[5] & ~((uint32)0x3fff << 10)) | ((((uint32)f) & 0x3fff) << 10))
#define TX_DCB_SOBMH_IPCF_PTRf_GET(r) ((((r).tx_dcb[5]) >> 24) & 0xff)
#define TX_DCB_SOBMH_IPCF_PTRf_SET(r,f) (r).tx_dcb[5]=(((r).tx_dcb[5] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define TX_DCB_SOBMH_RESERVED_IPCF_PTRf_GET(r) ((((r).tx_dcb[5]) >> 24) & 0xff)
#define TX_DCB_SOBMH_RESERVED_IPCF_PTRf_SET(r,f) (r).tx_dcb[5]=(((r).tx_dcb[5] & ~((uint32)0xff << 24)) | ((((uint32)f) & 0xff) << 24))
#define TX_DCB_MODULE_HEADER_WD2f_GET(r) ((r).tx_dcb[4])
#define TX_DCB_MODULE_HEADER_WD2f_SET(r,f) (r).tx_dcb[4]=((uint32)f)
#define TX_DCB_SOBMH_SRC_MODIDf_GET(r) (((r).tx_dcb[4]) & 0xff)
#define TX_DCB_SOBMH_SRC_MODIDf_SET(r,f) (r).tx_dcb[4]=(((r).tx_dcb[4] & ~((uint32)0xff)) | (((uint32)f) & 0xff))
#define TX_DCB_SOBMH_QUEUE_NUMf_GET(r) ((((r).tx_dcb[4]) >> 8) & 0x3ff)
#define TX_DCB_SOBMH_QUEUE_NUMf_SET(r,f) (r).tx_dcb[4]=(((r).tx_dcb[4] & ~((uint32)0x3ff << 8)) | ((((uint32)f) & 0x3ff) << 8))
#define TX_DCB_SOBMH_NLF_PORT_NUMBERf_GET(r) ((((r).tx_dcb[4]) >> 18) & 0x3f)
#define TX_DCB_SOBMH_NLF_PORT_NUMBERf_SET(r,f) (r).tx_dcb[4]=(((r).tx_dcb[4] & ~((uint32)0x3f << 18)) | ((((uint32)f) & 0x3f) << 18))
#define TX_DCB_SOBMH_UNICASTf_GET(r) ((((r).tx_dcb[4]) >> 18) & 0x1)
#define TX_DCB_SOBMH_UNICASTf_SET(r,f) (r).tx_dcb[4]=(((r).tx_dcb[4] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define TX_DCB_SOBMH_SPAPf_GET(r) ((((r).tx_dcb[4]) >> 19) & 0x3)
#define TX_DCB_SOBMH_SPAPf_SET(r,f) (r).tx_dcb[4]=(((r).tx_dcb[4] & ~((uint32)0x3 << 19)) | ((((uint32)f) & 0x3) << 19))
#define TX_DCB_SOBMH_SPIDf_GET(r) ((((r).tx_dcb[4]) >> 21) & 0x3)
#define TX_DCB_SOBMH_SPIDf_SET(r,f) (r).tx_dcb[4]=(((r).tx_dcb[4] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define TX_DCB_SOBMH_SPID_OVERRIDEf_GET(r) ((((r).tx_dcb[4]) >> 23) & 0x1)
#define TX_DCB_SOBMH_SPID_OVERRIDEf_SET(r,f) (r).tx_dcb[4]=(((r).tx_dcb[4] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define TX_DCB_SOBMH_COSf_GET(r) ((((r).tx_dcb[4]) >> 24) & 0xf)
#define TX_DCB_SOBMH_COSf_SET(r,f) (r).tx_dcb[4]=(((r).tx_dcb[4] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define TX_DCB_SOBMH_INT_PRIf_GET(r) ((((r).tx_dcb[4]) >> 24) & 0xf)
#define TX_DCB_SOBMH_INT_PRIf_SET(r,f) (r).tx_dcb[4]=(((r).tx_dcb[4] & ~((uint32)0xf << 24)) | ((((uint32)f) & 0xf) << 24))
#define TX_DCB_SOBMH_INPUT_PRIf_GET(r) ((((r).tx_dcb[4]) >> 28) & 0xf)
#define TX_DCB_SOBMH_INPUT_PRIf_SET(r,f) (r).tx_dcb[4]=(((r).tx_dcb[4] & ~((uint32)0xf << 28)) | ((((uint32)f) & 0xf) << 28))
#define TX_DCB_MODULE_HEADER_WD1f_GET(r) ((r).tx_dcb[3])
#define TX_DCB_MODULE_HEADER_WD1f_SET(r,f) (r).tx_dcb[3]=((uint32)f)
#define TX_DCB_SOBMH_LOCAL_DEST_PORTf_GET(r) (((r).tx_dcb[3]) & 0x7f)
#define TX_DCB_SOBMH_LOCAL_DEST_PORTf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define TX_DCB_SOBMH_SET_L2BMf_GET(r) ((((r).tx_dcb[3]) >> 7) & 0x1)
#define TX_DCB_SOBMH_SET_L2BMf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define TX_DCB_SOBMH_IEEE1588_TIMESTAMP_HDR_OFFSETf_GET(r) ((((r).tx_dcb[3]) >> 8) & 0xff)
#define TX_DCB_SOBMH_IEEE1588_TIMESTAMP_HDR_OFFSETf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0xff << 8)) | ((((uint32)f) & 0xff) << 8))
#define TX_DCB_SOBMH_SET_L3BMf_GET(r) ((((r).tx_dcb[3]) >> 16) & 0x1)
#define TX_DCB_SOBMH_SET_L3BMf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define TX_DCB_SOBMH_TX_TSf_GET(r) ((((r).tx_dcb[3]) >> 17) & 0x1)
#define TX_DCB_SOBMH_TX_TSf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define TX_DCB_SOBMH_IEEE1588_INGRESS_TIMESTAMP_SIGNf_GET(r) ((((r).tx_dcb[3]) >> 18) & 0x1)
#define TX_DCB_SOBMH_IEEE1588_INGRESS_TIMESTAMP_SIGNf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define TX_DCB_SOBMH_IEEE1588_REGEN_UDP_CHECKSUMf_GET(r) ((((r).tx_dcb[3]) >> 19) & 0x1)
#define TX_DCB_SOBMH_IEEE1588_REGEN_UDP_CHECKSUMf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define TX_DCB_SOBMH_IEEE1588_ONE_STEP_ENABLEf_GET(r) ((((r).tx_dcb[3]) >> 20) & 0x1)
#define TX_DCB_SOBMH_IEEE1588_ONE_STEP_ENABLEf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define TX_DCB_SOBMH_RESERVED_4f_GET(r) ((((r).tx_dcb[3]) >> 21) & 0x7ff)
#define TX_DCB_SOBMH_RESERVED_4f_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x7ff << 21)) | ((((uint32)f) & 0x7ff) << 21))
#define TX_DCB_SOBMH_OAM_REPLACEMENT_TYPEf_GET(r) ((((r).tx_dcb[3]) >> 21) & 0x3)
#define TX_DCB_SOBMH_OAM_REPLACEMENT_TYPEf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x3 << 21)) | ((((uint32)f) & 0x3) << 21))
#define TX_DCB_SOBMH_CELL_ERRORf_GET(r) ((((r).tx_dcb[3]) >> 23) & 0x1)
#define TX_DCB_SOBMH_CELL_ERRORf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define TX_DCB_SOBMH_RESERVED_1f_GET(r) ((((r).tx_dcb[3]) >> 23) & 0x1)
#define TX_DCB_SOBMH_RESERVED_1f_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define TX_DCB_SOBMH_OAM_REPLACEMENT_OFFSETf_GET(r) ((((r).tx_dcb[3]) >> 24) & 0x3f)
#define TX_DCB_SOBMH_OAM_REPLACEMENT_OFFSETf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))
#define TX_DCB_SOBMH_QUEUE_NUM_UPPERf_GET(r) ((((r).tx_dcb[3]) >> 30) & 0x3)
#define TX_DCB_SOBMH_QUEUE_NUM_UPPERf_SET(r,f) (r).tx_dcb[3]=(((r).tx_dcb[3] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define TX_DCB_MODULE_HEADER_WD0f_GET(r) ((r).tx_dcb[2])
#define TX_DCB_MODULE_HEADER_WD0f_SET(r,f) (r).tx_dcb[2]=((uint32)f)
#define TX_DCB_SOBMH_EP_CPU_REASON_CODEf_GET(r) (((r).tx_dcb[2]) & 0xfffff)
#define TX_DCB_SOBMH_EP_CPU_REASON_CODEf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0xfffff)) | (((uint32)f) & 0xfffff))
#define TX_DCB_SOBMH_LM_COUNTER_INDEXf_GET(r) (((r).tx_dcb[2]) & 0xffff)
#define TX_DCB_SOBMH_LM_COUNTER_INDEXf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define TX_DCB_SOBMH_RESERVED_3f_GET(r) ((((r).tx_dcb[2]) >> 16) & 0xff)
#define TX_DCB_SOBMH_RESERVED_3f_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0xff << 16)) | ((((uint32)f) & 0xff) << 16))
#define TX_DCB_SOBMH_RESERVED_5f_GET(r) ((((r).tx_dcb[2]) >> 20) & 0xf)
#define TX_DCB_SOBMH_RESERVED_5f_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0xf << 20)) | ((((uint32)f) & 0xf) << 20))
#define TX_DCB_SOBMH_HEADER_TYPEf_GET(r) ((((r).tx_dcb[2]) >> 24) & 0x3f)
#define TX_DCB_SOBMH_HEADER_TYPEf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0x3f << 24)) | ((((uint32)f) & 0x3f) << 24))
#define TX_DCB_SOBMH_STARTf_GET(r) ((((r).tx_dcb[2]) >> 30) & 0x3)
#define TX_DCB_SOBMH_STARTf_SET(r,f) (r).tx_dcb[2]=(((r).tx_dcb[2] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define TX_DCB_BYTE_COUNTf_GET(r) (((r).tx_dcb[1]) & 0xffff)
#define TX_DCB_BYTE_COUNTf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define TX_DCB_CHAINf_GET(r) ((((r).tx_dcb[1]) >> 16) & 0x1)
#define TX_DCB_CHAINf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define TX_DCB_GATHERf_GET(r) ((((r).tx_dcb[1]) >> 17) & 0x1)
#define TX_DCB_GATHERf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define TX_DCB_RELOADf_GET(r) ((((r).tx_dcb[1]) >> 18) & 0x1)
#define TX_DCB_RELOADf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define TX_DCB_HIGIG_PKTf_GET(r) ((((r).tx_dcb[1]) >> 19) & 0x1)
#define TX_DCB_HIGIG_PKTf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define TX_DCB_STAT_UPDATEf_GET(r) ((((r).tx_dcb[1]) >> 20) & 0x1)
#define TX_DCB_STAT_UPDATEf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define TX_DCB_PAUSE_PACKETf_GET(r) ((((r).tx_dcb[1]) >> 21) & 0x1)
#define TX_DCB_PAUSE_PACKETf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define TX_DCB_PURGE_PACKETf_GET(r) ((((r).tx_dcb[1]) >> 22) & 0x1)
#define TX_DCB_PURGE_PACKETf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define TX_DCB_INTERRUPTf_GET(r) ((((r).tx_dcb[1]) >> 23) & 0x3)
#define TX_DCB_INTERRUPTf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32)0x3 << 23)) | ((((uint32)f) & 0x3) << 23))
#define TX_DCB_MEM_ADDRf_GET(r) ((r).tx_dcb[0])
#define TX_DCB_MEM_ADDRf_SET(r,f) (r).tx_dcb[0]=((uint32)f)

/*******************************************************************************
 * End of 'TX_DCB'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TX_IPG_LENGTH
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Programmable Inter-Packet-Gap (IPG).
 * SIZE:     32
 * FIELDS:
 *     TX_IPG_LENGTH    Set the Transmit minimum IPG from 8 to 64 Byte-times. If a value below 8 or above 64 isprogrammed, the minimum IPG is set to 12 byte-times.
 */
#define TX_IPG_LENGTHr_SIZE 4

/*
 * This structure should be used to declare and program TX_IPG_LENGTH.
 */
typedef union TX_IPG_LENGTHr_s {
	uint32 v[1];
	uint32 tx_ipg_length[1];
	uint32 _tx_ipg_length;
} TX_IPG_LENGTHr_t;

#define TX_IPG_LENGTHr_CLR(r) (r).tx_ipg_length[0] = 0
#define TX_IPG_LENGTHr_SET(r,d) (r).tx_ipg_length[0] = d
#define TX_IPG_LENGTHr_GET(r) (r).tx_ipg_length[0]

/*
 * These macros can be used to access individual fields.
 */
#define TX_IPG_LENGTHr_TX_IPG_LENGTHf_GET(r) (((r).tx_ipg_length[0]) & 0x7f)
#define TX_IPG_LENGTHr_TX_IPG_LENGTHf_SET(r,f) (r).tx_ipg_length[0]=(((r).tx_ipg_length[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))

/*
 * These macros can be used to access TX_IPG_LENGTH.
 */
#define WRITE_TX_IPG_LENGTHr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_TX_IPG_LENGTH(bcm5354x_gport_lport_to_index_in_block[p]), (r._tx_ipg_length))
#define READ_TX_IPG_LENGTHr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_TX_IPG_LENGTH(bcm5354x_gport_lport_to_index_in_block[p]), &(r._tx_ipg_length))

/*******************************************************************************
 * End of 'TX_IPG_LENGTHr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TX_TS_DATA
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Transmit Timestamp data
 * SIZE:     32
 * FIELDS:
 *     TX_TS_DATA       Every read of this register will fetch out one timestamp value corresponding to the preceding seq_id read from the transmit FIFO.Every 49 bit, val_bit + seq_id + timestamp is read in two steps, i.e., one read from 0x10f (val_bit + seq_id) followed by another read from 0x1c7 (timestamp).Timestamp read without a preceding seq_id read will fetch stale timestamp value.
 */
#define TX_TS_DATAr_SIZE 4

/*
 * This structure should be used to declare and program TX_TS_DATA.
 */
typedef union TX_TS_DATAr_s {
	uint32 v[1];
	uint32 tx_ts_data[1];
	uint32 _tx_ts_data;
} TX_TS_DATAr_t;

#define TX_TS_DATAr_CLR(r) (r).tx_ts_data[0] = 0
#define TX_TS_DATAr_SET(r,d) (r).tx_ts_data[0] = d
#define TX_TS_DATAr_GET(r) (r).tx_ts_data[0]

/*
 * These macros can be used to access individual fields.
 */
#define TX_TS_DATAr_TX_TS_DATAf_GET(r) ((r).tx_ts_data[0])
#define TX_TS_DATAr_TX_TS_DATAf_SET(r,f) (r).tx_ts_data[0]=((uint32)f)

/*
 * These macros can be used to access TX_TS_DATA.
 */
#define WRITE_TX_TS_DATAr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_TX_TS_DATA(bcm5354x_gport_lport_to_index_in_block[p]), (r._tx_ts_data))
#define READ_TX_TS_DATAr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_TX_TS_DATA(bcm5354x_gport_lport_to_index_in_block[p]), &(r._tx_ts_data))

/*******************************************************************************
 * End of 'TX_TS_DATAr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  TX_TS_SEQ_ID
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     Transmit Two Step Timestamp Sequence ID
 * SIZE:     32
 * FIELDS:
 *     TSTS_SEQ_ID      Every read of this register will fetch out one seq_id from the transmit FIFO.(One seq_id per one read command on the sbus).Every 49 bit val_bit + seq_id + timestamp is read in two steps, i.e., one read from 0x10f (val_bit + seq_id) followed by another read from 0x1c7 (timestamp).Timestamp read without a preceding seq_id read will fetch stale timestamp value.
 *     TSTS_VALID       Indicates that a timestamp was captured and is valid. if the cpu reads an empty fifo the VALID bit will be 0.
 */
#define TX_TS_SEQ_IDr_SIZE 4

/*
 * This structure should be used to declare and program TX_TS_SEQ_ID.
 */
typedef union TX_TS_SEQ_IDr_s {
	uint32 v[1];
	uint32 tx_ts_seq_id[1];
	uint32 _tx_ts_seq_id;
} TX_TS_SEQ_IDr_t;

#define TX_TS_SEQ_IDr_CLR(r) (r).tx_ts_seq_id[0] = 0
#define TX_TS_SEQ_IDr_SET(r,d) (r).tx_ts_seq_id[0] = d
#define TX_TS_SEQ_IDr_GET(r) (r).tx_ts_seq_id[0]

/*
 * These macros can be used to access individual fields.
 */
#define TX_TS_SEQ_IDr_TSTS_SEQ_IDf_GET(r) (((r).tx_ts_seq_id[0]) & 0xffff)
#define TX_TS_SEQ_IDr_TSTS_SEQ_IDf_SET(r,f) (r).tx_ts_seq_id[0]=(((r).tx_ts_seq_id[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))
#define TX_TS_SEQ_IDr_TSTS_VALIDf_GET(r) ((((r).tx_ts_seq_id[0]) >> 16) & 0x1)
#define TX_TS_SEQ_IDr_TSTS_VALIDf_SET(r,f) (r).tx_ts_seq_id[0]=(((r).tx_ts_seq_id[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))

/*
 * These macros can be used to access TX_TS_SEQ_ID.
 */
#define WRITE_TX_TS_SEQ_IDr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_TX_TS_SEQ_ID(bcm5354x_gport_lport_to_index_in_block[p]), (r._tx_ts_seq_id))
#define READ_TX_TS_SEQ_IDr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_TX_TS_SEQ_ID(bcm5354x_gport_lport_to_index_in_block[p]), &(r._tx_ts_seq_id))

/*******************************************************************************
 * End of 'TX_TS_SEQ_IDr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  UMAC_EEE_CTRL
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     control configs for EEE feature
 * SIZE:     32
 * FIELDS:
 *     EEE_EN           If set, the TX LPI policy control engine is enabled and the MAC inserts LPI_idle codes if the link is idle. The rx_lpi_detect assertion is independent of this configuration. Reset default depends on EEE_en_strap input, which if tied to 1, defaults to enabled, otherwise if tied to 0, defaults to disabled.
 *     RX_FIFO_CHECK    If enabled, lpi_rx_detect is set whenever the LPI_IDLES are being received on the RX line and Unimac Rx FIFO is empty.By default, lpi_rx_detect is set only when whenever the LPI_IDLES are being received on the RX line.
 *     EEE_TXCLK_DIS    If enabled, UNIMAC will shut down TXCLK to PHY, when in LPI state.
 *     DIS_EEE_10M      When this bit is set and link is established at 10Mbps, LPI is not supported (saving is achieved by reduced PHY's output swing). UNIMAC ignores EEE feature on both Tx & Rx in 10Mbps.When cleared, Unimac doesn't differentiate between speeds for EEE feature.
 *     LP_IDLE_PREDICTION_MODE When set to 1, enables LP_IDLE Prediction. When set to 0, disables LP_IDLE Prediction.  
 */
#define UMAC_EEE_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program UMAC_EEE_CTRL.
 */
typedef union UMAC_EEE_CTRLr_s {
	uint32 v[1];
	uint32 umac_eee_ctrl[1];
	uint32 _umac_eee_ctrl;
} UMAC_EEE_CTRLr_t;

#define UMAC_EEE_CTRLr_CLR(r) (r).umac_eee_ctrl[0] = 0
#define UMAC_EEE_CTRLr_SET(r,d) (r).umac_eee_ctrl[0] = d
#define UMAC_EEE_CTRLr_GET(r) (r).umac_eee_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define UMAC_EEE_CTRLr_EEE_ENf_GET(r) ((((r).umac_eee_ctrl[0]) >> 3) & 0x1)
#define UMAC_EEE_CTRLr_EEE_ENf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define UMAC_EEE_CTRLr_RX_FIFO_CHECKf_GET(r) ((((r).umac_eee_ctrl[0]) >> 4) & 0x1)
#define UMAC_EEE_CTRLr_RX_FIFO_CHECKf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define UMAC_EEE_CTRLr_EEE_TXCLK_DISf_GET(r) ((((r).umac_eee_ctrl[0]) >> 5) & 0x1)
#define UMAC_EEE_CTRLr_EEE_TXCLK_DISf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define UMAC_EEE_CTRLr_DIS_EEE_10Mf_GET(r) ((((r).umac_eee_ctrl[0]) >> 6) & 0x1)
#define UMAC_EEE_CTRLr_DIS_EEE_10Mf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define UMAC_EEE_CTRLr_LP_IDLE_PREDICTION_MODEf_GET(r) ((((r).umac_eee_ctrl[0]) >> 7) & 0x1)
#define UMAC_EEE_CTRLr_LP_IDLE_PREDICTION_MODEf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access UMAC_EEE_CTRL.
 */
#define WRITE_UMAC_EEE_CTRLr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_UMAC_EEE_CTRL(bcm5354x_gport_lport_to_index_in_block[p]), (r._umac_eee_ctrl))
#define READ_UMAC_EEE_CTRLr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_UMAC_EEE_CTRL(bcm5354x_gport_lport_to_index_in_block[p]), &(r._umac_eee_ctrl))

/*******************************************************************************
 * End of 'UMAC_EEE_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  UMAC_EEE_REF_COUNT
 * BLOCKS:   GPORT0 GPORT1 GPORT2 GPORT3 GPORT4
 * DESC:     clock divider for 1 us quanta count in EEE 
 * SIZE:     32
 * FIELDS:
 *     EEE_REF_COUNT    This field controls clock divider used to generate ~1us reference pulses used by EEE timers. It specifies integer number of timer clock cycles contained within 1us.We may consider having 0.5us reference, as timeout values in 802.3az/D1.3 are not always integer number of 1us.
 */
#define UMAC_EEE_REF_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program UMAC_EEE_REF_COUNT.
 */
typedef union UMAC_EEE_REF_COUNTr_s {
	uint32 v[1];
	uint32 umac_eee_ref_count[1];
	uint32 _umac_eee_ref_count;
} UMAC_EEE_REF_COUNTr_t;

#define UMAC_EEE_REF_COUNTr_CLR(r) (r).umac_eee_ref_count[0] = 0
#define UMAC_EEE_REF_COUNTr_SET(r,d) (r).umac_eee_ref_count[0] = d
#define UMAC_EEE_REF_COUNTr_GET(r) (r).umac_eee_ref_count[0]

/*
 * These macros can be used to access individual fields.
 */
#define UMAC_EEE_REF_COUNTr_EEE_REF_COUNTf_GET(r) (((r).umac_eee_ref_count[0]) & 0xffff)
#define UMAC_EEE_REF_COUNTr_EEE_REF_COUNTf_SET(r,f) (r).umac_eee_ref_count[0]=(((r).umac_eee_ref_count[0] & ~((uint32)0xffff)) | (((uint32)f) & 0xffff))

/*
 * These macros can be used to access UMAC_EEE_REF_COUNT.
 */
#define WRITE_UMAC_EEE_REF_COUNTr(u,p,r) bcm5354x_reg_set(u, bcm5354x_gport_lport_to_blockid[p], R_UMAC_EEE_REF_COUNT(bcm5354x_gport_lport_to_index_in_block[p]), (r._umac_eee_ref_count))
#define READ_UMAC_EEE_REF_COUNTr(u,p,r) bcm5354x_reg_get(u, bcm5354x_gport_lport_to_blockid[p], R_UMAC_EEE_REF_COUNT(bcm5354x_gport_lport_to_index_in_block[p]), &(r._umac_eee_ref_count))

/*******************************************************************************
 * End of 'UMAC_EEE_REF_COUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  UNKNOWN_MCAST_BLOCK_MASK_64
 * BLOCKS:   IPIPE
 * DESC:     Unknown Multicast Block Mask
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked. 1=Block, 0=Allow
 *     BLK_BITMAP_0     Overlay bitmap for ports 31:0. 1=Block, 0=Allow
 */
#define UNKNOWN_MCAST_BLOCK_MASK_64r_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_MCAST_BLOCK_MASK_64.
 */
typedef union UNKNOWN_MCAST_BLOCK_MASK_64r_s {
	uint32 v[1];
	uint32 unknown_mcast_block_mask_64[1];
	uint32 _unknown_mcast_block_mask_64;
} UNKNOWN_MCAST_BLOCK_MASK_64r_t;

#define UNKNOWN_MCAST_BLOCK_MASK_64r_CLR(r) (r).unknown_mcast_block_mask_64[0] = 0
#define UNKNOWN_MCAST_BLOCK_MASK_64r_SET(r,d) (r).unknown_mcast_block_mask_64[0] = d
#define UNKNOWN_MCAST_BLOCK_MASK_64r_GET(r) (r).unknown_mcast_block_mask_64[0]

/*
 * These macros can be used to access individual fields.
 */
#define UNKNOWN_MCAST_BLOCK_MASK_64r_BLK_BITMAPf_GET(r) ((r).unknown_mcast_block_mask_64[0])
#define UNKNOWN_MCAST_BLOCK_MASK_64r_BLK_BITMAPf_SET(r,f) (r).unknown_mcast_block_mask_64[0]=((uint32)f)
#define UNKNOWN_MCAST_BLOCK_MASK_64r_BLK_BITMAP_0f_GET(r) ((r).unknown_mcast_block_mask_64[0])
#define UNKNOWN_MCAST_BLOCK_MASK_64r_BLK_BITMAP_0f_SET(r,f) (r).unknown_mcast_block_mask_64[0]=((uint32)f)

/*
 * These macros can be used to access UNKNOWN_MCAST_BLOCK_MASK_64.
 */
#define WRITE_UNKNOWN_MCAST_BLOCK_MASK_64r(u,p,r) bcm5354x_reg_set(u,R_UNKNOWN_MCAST_BLOCK_MASK_64(p),(r._unknown_mcast_block_mask_64))
#define READ_UNKNOWN_MCAST_BLOCK_MASK_64r(u,p,r) bcm5354x_reg_get(u,R_UNKNOWN_MCAST_BLOCK_MASK_64(p),&(r._unknown_mcast_block_mask_64))

/*******************************************************************************
 * End of 'UNKNOWN_MCAST_BLOCK_MASK_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  UNKNOWN_UCAST_BLOCK_MASK_64
 * BLOCKS:   IPIPE
 * DESC:     Unknown Unicast Block Mask
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked. 1=Block, 0=Allow
 *     BLK_BITMAP_0     Overlay bitmap for ports 31:0. 1=Block, 0=Allow
 */
#define UNKNOWN_UCAST_BLOCK_MASK_64r_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_UCAST_BLOCK_MASK_64.
 */
typedef union UNKNOWN_UCAST_BLOCK_MASK_64r_s {
	uint32 v[1];
	uint32 unknown_ucast_block_mask_64[1];
	uint32 _unknown_ucast_block_mask_64;
} UNKNOWN_UCAST_BLOCK_MASK_64r_t;

#define UNKNOWN_UCAST_BLOCK_MASK_64r_CLR(r) (r).unknown_ucast_block_mask_64[0] = 0
#define UNKNOWN_UCAST_BLOCK_MASK_64r_SET(r,d) (r).unknown_ucast_block_mask_64[0] = d
#define UNKNOWN_UCAST_BLOCK_MASK_64r_GET(r) (r).unknown_ucast_block_mask_64[0]

/*
 * These macros can be used to access individual fields.
 */
#define UNKNOWN_UCAST_BLOCK_MASK_64r_BLK_BITMAPf_GET(r) ((r).unknown_ucast_block_mask_64[0])
#define UNKNOWN_UCAST_BLOCK_MASK_64r_BLK_BITMAPf_SET(r,f) (r).unknown_ucast_block_mask_64[0]=((uint32)f)
#define UNKNOWN_UCAST_BLOCK_MASK_64r_BLK_BITMAP_0f_GET(r) ((r).unknown_ucast_block_mask_64[0])
#define UNKNOWN_UCAST_BLOCK_MASK_64r_BLK_BITMAP_0f_SET(r,f) (r).unknown_ucast_block_mask_64[0]=((uint32)f)

/*
 * These macros can be used to access UNKNOWN_UCAST_BLOCK_MASK_64.
 */
#define WRITE_UNKNOWN_UCAST_BLOCK_MASK_64r(u,p,r) bcm5354x_reg_set(u,R_UNKNOWN_UCAST_BLOCK_MASK_64(p),(r._unknown_ucast_block_mask_64))
#define READ_UNKNOWN_UCAST_BLOCK_MASK_64r(u,p,r) bcm5354x_reg_get(u,R_UNKNOWN_UCAST_BLOCK_MASK_64(p),&(r._unknown_ucast_block_mask_64))

/*******************************************************************************
 * End of 'UNKNOWN_UCAST_BLOCK_MASK_64r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  VFP_CAM_CONTROL_TM_7_THRU_0
 * BLOCKS:   IPIPE
 * DESC:     VFP_CAM_CONTROL_TM_7_THRU_0
 * SIZE:     32
 * FIELDS:
 *     TM               VFP_CAM_CONTROL FOR VFP SLICE 0,1,2,3 
 */
#define VFP_CAM_CONTROL_TM_7_THRU_0r_SIZE 4

/*
 * This structure should be used to declare and program VFP_CAM_CONTROL_TM_7_THRU_0.
 */
typedef union VFP_CAM_CONTROL_TM_7_THRU_0r_s {
	uint32 v[1];
	uint32 vfp_cam_control_tm_7_thru_0[1];
	uint32 _vfp_cam_control_tm_7_thru_0;
} VFP_CAM_CONTROL_TM_7_THRU_0r_t;

#define VFP_CAM_CONTROL_TM_7_THRU_0r_CLR(r) (r).vfp_cam_control_tm_7_thru_0[0] = 0
#define VFP_CAM_CONTROL_TM_7_THRU_0r_SET(r,d) (r).vfp_cam_control_tm_7_thru_0[0] = d
#define VFP_CAM_CONTROL_TM_7_THRU_0r_GET(r) (r).vfp_cam_control_tm_7_thru_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define VFP_CAM_CONTROL_TM_7_THRU_0r_TMf_GET(r) (((r).vfp_cam_control_tm_7_thru_0[0]) & 0xff)
#define VFP_CAM_CONTROL_TM_7_THRU_0r_TMf_SET(r,f) (r).vfp_cam_control_tm_7_thru_0[0]=(((r).vfp_cam_control_tm_7_thru_0[0] & ~((uint32)0xff)) | (((uint32)f) & 0xff))

/*
 * These macros can be used to access VFP_CAM_CONTROL_TM_7_THRU_0.
 */
#define WRITE_VFP_CAM_CONTROL_TM_7_THRU_0r(u,r) bcm5354x_reg_set(u,R_VFP_CAM_CONTROL_TM_7_THRU_0,(r._vfp_cam_control_tm_7_thru_0))
#define READ_VFP_CAM_CONTROL_TM_7_THRU_0r(u,r) bcm5354x_reg_get(u,R_VFP_CAM_CONTROL_TM_7_THRU_0,&(r._vfp_cam_control_tm_7_thru_0))

/*******************************************************************************
 * End of 'VFP_CAM_CONTROL_TM_7_THRU_0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  VLAN
 * BLOCKS:   IPIPE
 * DESC:     Contains controls associated with the 4K VLANs.
Identifies the VLAN membership and associated spanning tree group. Support for IEEE 802.1Q VLAN. Port Taggedness information is stored in the EGR_VLAN table. This table is indexed using the VLAN ID.
 * SIZE:     127
 * FIELDS:
 *     PORT_BITMAP      VLAN port membership bitmap
 *     PORT_BITMAP_LO   VLAN port membership bitmap
 *     HIGIG_TRUNK_OVERRIDE Add the VLAN ID
 *     RESERVED_33      Reserved
 *     VALID            Valid VLAN ID
 *     STG              Spanning Tree Group ID
 *     RESERVED_48      Reserved
 *     FID_ID           Forwarding database ID
 *     VLAN_PROFILE_PTR VLAN profile pointer to get VLAN-specific properties
 *     L3_IIF           L3 Interface for L3 routing lookups -- note that VRF and Intf CLASS_ID come fro mthe L3_IIF table
 *     RESERVED_71      Reserved
 *     VLAN_CLASS_ID    VLAN CLass ID for IFP keys
 *     L2_ENTRY_KEY_TYPE Indicates the forwarding behavior for this VLAN ID.  This is the KEY_TYPE to the L2_ENTRY table.
 *     BC_IDX           The L3MC_IDX used to represent a broadcast into the associated VLAN.
 *     RESERVED_95      Reserved
 *     UUC_IDX          The L3MC_IDX used to represent an unknown unicast flood into the associated VLAN. (typically does not include AC2WTP destinations)
 *     RESERVED_107     Reserved
 *     UMC_IDX          The L3MC_IDX used to represent an unknown multicast flood into the associated VLAN. (typically does not include AC2WTP destinations)
 *     RESERVED_119     Reserved
 *     EVEN_PARITY      Even parity for the  VLAN RAM
 */
#define VLANm_MIN 0
#define VLANm_MAX 4095
#define VLANm_CMAX(u) 4095
#define VLANm_SIZE 16

/*
 * This structure should be used to declare and program VLAN.
 */
typedef union VLANm_s {
	uint32 v[4];
	uint32 vlan[4];
	uint32 _vlan;
} VLANm_t;

#define VLANm_CLR(r) sal_memset(&((r)._vlan), 0, sizeof(VLANm_t))
#define VLANm_SET(r,i,d) (r).vlan[i] = d
#define VLANm_GET(r,i) (r).vlan[i]

/*
 * These macros can be used to access individual fields.
 */
#define VLANm_PORT_BITMAPf_GET(r) ((r).vlan[0])
#define VLANm_PORT_BITMAPf_SET(r,f) (r).vlan[0]=((uint32)f)
#define VLANm_PORT_BITMAP_LOf_GET(r) ((r).vlan[0])
#define VLANm_PORT_BITMAP_LOf_SET(r,f) (r).vlan[0]=((uint32)f)
#define VLANm_HIGIG_TRUNK_OVERRIDEf_GET(r) (((r).vlan[1]) & 0x1)
#define VLANm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).vlan[1]=(((r).vlan[1] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define VLANm_RESERVED_33f_GET(r) ((((r).vlan[1]) >> 1) & 0x7f)
#define VLANm_RESERVED_33f_SET(r,f) (r).vlan[1]=(((r).vlan[1] & ~((uint32)0x7f << 1)) | ((((uint32)f) & 0x7f) << 1))
#define VLANm_VALIDf_GET(r) ((((r).vlan[1]) >> 8) & 0x1)
#define VLANm_VALIDf_SET(r,f) (r).vlan[1]=(((r).vlan[1] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define VLANm_STGf_GET(r) ((((r).vlan[1]) >> 9) & 0x7f)
#define VLANm_STGf_SET(r,f) (r).vlan[1]=(((r).vlan[1] & ~((uint32)0x7f << 9)) | ((((uint32)f) & 0x7f) << 9))
#define VLANm_RESERVED_48f_GET(r) ((((r).vlan[1]) >> 16) & 0x3)
#define VLANm_RESERVED_48f_SET(r,f) (r).vlan[1]=(((r).vlan[1] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define VLANm_FID_IDf_GET(r) ((((r).vlan[1]) >> 18) & 0xfff)
#define VLANm_FID_IDf_SET(r,f) (r).vlan[1]=(((r).vlan[1] & ~((uint32)0xfff << 18)) | ((((uint32)f) & 0xfff) << 18))
#define VLANm_VLAN_PROFILE_PTRf_GET(r) field32_get((r).vlan,62,65)
#define VLANm_VLAN_PROFILE_PTRf_SET(r,f) field32_set((r).vlan,62,65,f)
#define VLANm_L3_IIFf_GET(r) ((((r).vlan[2]) >> 2) & 0x1f)
#define VLANm_L3_IIFf_SET(r,f) (r).vlan[2]=(((r).vlan[2] & ~((uint32)0x1f << 2)) | ((((uint32)f) & 0x1f) << 2))
#define VLANm_RESERVED_71f_GET(r) ((((r).vlan[2]) >> 7) & 0x7f)
#define VLANm_RESERVED_71f_SET(r,f) (r).vlan[2]=(((r).vlan[2] & ~((uint32)0x7f << 7)) | ((((uint32)f) & 0x7f) << 7))
#define VLANm_VLAN_CLASS_IDf_GET(r) ((((r).vlan[2]) >> 14) & 0xff)
#define VLANm_VLAN_CLASS_IDf_SET(r,f) (r).vlan[2]=(((r).vlan[2] & ~((uint32)0xff << 14)) | ((((uint32)f) & 0xff) << 14))
#define VLANm_L2_ENTRY_KEY_TYPEf_GET(r) ((((r).vlan[2]) >> 22) & 0x7)
#define VLANm_L2_ENTRY_KEY_TYPEf_SET(r,f) (r).vlan[2]=(((r).vlan[2] & ~((uint32)0x7 << 22)) | ((((uint32)f) & 0x7) << 22))
#define VLANm_BC_IDXf_GET(r) ((((r).vlan[2]) >> 25) & 0x3f)
#define VLANm_BC_IDXf_SET(r,f) (r).vlan[2]=(((r).vlan[2] & ~((uint32)0x3f << 25)) | ((((uint32)f) & 0x3f) << 25))
#define VLANm_RESERVED_95f_GET(r) field32_get((r).vlan,95,100)
#define VLANm_RESERVED_95f_SET(r,f) field32_set((r).vlan,95,100,f)
#define VLANm_UUC_IDXf_GET(r) ((((r).vlan[3]) >> 5) & 0x3f)
#define VLANm_UUC_IDXf_SET(r,f) (r).vlan[3]=(((r).vlan[3] & ~((uint32)0x3f << 5)) | ((((uint32)f) & 0x3f) << 5))
#define VLANm_RESERVED_107f_GET(r) ((((r).vlan[3]) >> 11) & 0x3f)
#define VLANm_RESERVED_107f_SET(r,f) (r).vlan[3]=(((r).vlan[3] & ~((uint32)0x3f << 11)) | ((((uint32)f) & 0x3f) << 11))
#define VLANm_UMC_IDXf_GET(r) ((((r).vlan[3]) >> 17) & 0x3f)
#define VLANm_UMC_IDXf_SET(r,f) (r).vlan[3]=(((r).vlan[3] & ~((uint32)0x3f << 17)) | ((((uint32)f) & 0x3f) << 17))
#define VLANm_RESERVED_119f_GET(r) ((((r).vlan[3]) >> 23) & 0x3f)
#define VLANm_RESERVED_119f_SET(r,f) (r).vlan[3]=(((r).vlan[3] & ~((uint32)0x3f << 23)) | ((((uint32)f) & 0x3f) << 23))
#define VLANm_EVEN_PARITYf_GET(r) ((((r).vlan[3]) >> 30) & 0x1)
#define VLANm_EVEN_PARITYf_SET(r,f) (r).vlan[3]=(((r).vlan[3] & ~((uint32)0x1 << 30)) | ((((uint32)f) & 0x1) << 30))

/*
 * These macros can be used to access VLAN.
 */
#define WRITE_VLANm(u,i,r) bcm5354x_mem_set(u, M_VLAN(i), &(r._vlan), 4)
#define READ_VLANm(u,i,r) bcm5354x_mem_get(u, M_VLAN(i), &(r._vlan), 4)

/*******************************************************************************
 * End of 'VLANm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  VLAN_CTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN Control Register 1
 * SIZE:     32
 * FIELDS:
 *     LEARN_VID        LEARN_VID for ARL learning
 *     USE_LEARN_VID    If set to 1, use LEARN_VID field from this register for ARL learning/lookups
 *     INNER_TPID       TPID for inner VLAN, used for double tagging modes only
 */
#define VLAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_CTRL.
 */
typedef union VLAN_CTRLr_s {
	uint32 v[1];
	uint32 vlan_ctrl[1];
	uint32 _vlan_ctrl;
} VLAN_CTRLr_t;

#define VLAN_CTRLr_CLR(r) (r).vlan_ctrl[0] = 0
#define VLAN_CTRLr_SET(r,d) (r).vlan_ctrl[0] = d
#define VLAN_CTRLr_GET(r) (r).vlan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define VLAN_CTRLr_LEARN_VIDf_GET(r) (((r).vlan_ctrl[0]) & 0xfff)
#define VLAN_CTRLr_LEARN_VIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32)0xfff)) | (((uint32)f) & 0xfff))
#define VLAN_CTRLr_USE_LEARN_VIDf_GET(r) ((((r).vlan_ctrl[0]) >> 12) & 0x1)
#define VLAN_CTRLr_USE_LEARN_VIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define VLAN_CTRLr_INNER_TPIDf_GET(r) ((((r).vlan_ctrl[0]) >> 13) & 0xffff)
#define VLAN_CTRLr_INNER_TPIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32)0xffff << 13)) | ((((uint32)f) & 0xffff) << 13))

/*
 * These macros can be used to access VLAN_CTRL.
 */
#define WRITE_VLAN_CTRLr(u,r) bcm5354x_reg_set(u,R_VLAN_CTRL,(r._vlan_ctrl))
#define READ_VLAN_CTRLr(u,r) bcm5354x_reg_get(u,R_VLAN_CTRL,&(r._vlan_ctrl))

/*******************************************************************************
 * End of 'VLAN_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  VLAN_DEFAULT_PBM
 * BLOCKS:   IPIPE
 * DESC:     default VLAN Port Bit Map.
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      default VLAN Port Bit Map.
 */
#define VLAN_DEFAULT_PBMr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_DEFAULT_PBM.
 */
typedef union VLAN_DEFAULT_PBMr_s {
	uint32 v[1];
	uint32 vlan_default_pbm[1];
	uint32 _vlan_default_pbm;
} VLAN_DEFAULT_PBMr_t;

#define VLAN_DEFAULT_PBMr_CLR(r) (r).vlan_default_pbm[0] = 0
#define VLAN_DEFAULT_PBMr_SET(r,d) (r).vlan_default_pbm[0] = d
#define VLAN_DEFAULT_PBMr_GET(r) (r).vlan_default_pbm[0]

/*
 * These macros can be used to access individual fields.
 */
#define VLAN_DEFAULT_PBMr_PORT_BITMAPf_GET(r) ((r).vlan_default_pbm[0])
#define VLAN_DEFAULT_PBMr_PORT_BITMAPf_SET(r,f) (r).vlan_default_pbm[0]=((uint32)f)

/*
 * These macros can be used to access VLAN_DEFAULT_PBM.
 */
#define WRITE_VLAN_DEFAULT_PBMr(u,r) bcm5354x_reg_set(u,R_VLAN_DEFAULT_PBM,(r._vlan_default_pbm))
#define READ_VLAN_DEFAULT_PBMr(u,r) bcm5354x_reg_get(u,R_VLAN_DEFAULT_PBM,&(r._vlan_default_pbm))

/*******************************************************************************
 * End of 'VLAN_DEFAULT_PBMr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  VLAN_PROFILE
 * BLOCKS:   IPIPE
 * DESC:     VLAN profile table. 
This table provides additional controls for VLANs. The index into this table is provided by VLAN.VLAN_PROFILE_PTR.
 * SIZE:     34
 * FIELDS:
 *     L2_PFM           PFM value for L2 multicast lookups
 *     L3_IPV4_PFM      PFM value for IPv4 multicast lookups
 *     L3_IPV6_PFM      PFM value for IPv6 multicast lookups
 *     UNKNOWN_IPV4_MC_TOCPU Unknown IPMC (IPMC miss) for IPv4 packets sent to CPU enable
 *     UNKNOWN_IPV6_MC_TOCPU Unknown IPMC (IPMC miss) for IPv6 packets sent to CPU enable
 *     LEARN_DISABLE    Disable learning on this VLAN
 *     OUTER_TPID_INDEX Used when PORT_TABLE.OUTER_TPID_VERIFY is enabled and indicates which of the ING_OUTER_TPID[xx] register is expected to match for this VLAN
 *     ICMP_REDIRECT_TOCPU Enables copy to cpu when ICMP redirect packet is needed
 *     IPMCV6_ENABLE    IPMC Enable for IPV6 packets on the VLAN
 *     IPMCV4_ENABLE    IPMC Enable for IPV4 packets on the VLAN
 *     IPMCV6_L2_ENABLE Enables L2-only forwarding of IPMCv6 packets on this VLAN based on (SGV,*GV) lookups  
 *     IPMCV4_L2_ENABLE Enables L2-only forwarding of IPMCv4 packets on this VLAN based on (SGV,*GV) lookups  
 *     IPV6L3_ENABLE    L3 Enable for IPV6 packets on the VLAN
 *     IPV4L3_ENABLE    L3 Enable for IPV4 packets on the VLAN
 *     L2_MISS_TOCPU    Copy to CPU packets that miss L2 lookup.
 *     L2_MISS_DROP     Drop packets that miss L2 lookup.
 *     L2_NON_UCAST_TOCPU Copy to CPU packets that are non-unicast.
 *     L2_NON_UCAST_DROP Drop non-unicast, broadcast or multicast packets that miss L2 lookup.
 *     IPV6_ROUTING_HEADER_TYPE_0_DROP .
 *     IPMCV4_UNICAST_MACDA_ENABLE Enable Routing IPMCV4 packet with unicast MACDA.
 *     IPMCV6_UNICAST_MACDA_ENABLE Enable Routing IPMCV6 packet with unicast MACDA.
 *     CML_FLAGS_MOVE   CPU managed learning control for station moves		    What to do when a L2 station move is detected:		    bit[0] = Drop the packet		    bit[1] = Copy to CPU		    bit[2] = Set the Pending bit on HW Station Move		    bit[3] = Do HW Station Move
 *     CML_FLAGS_NEW    CPU managed learning control for new entries		    What to do when a L2 miss occurs:		    bit[0] = Drop the packet		    bit[1] = Copy to CPU		    bit[2] = Set the Pending bit on HW Learn		    bit[3] = Do HW Learn
 *     USE_VLAN_CML     Override Port based CML_FLAGS_NEW/ CML_FLAGS_MOVE.
 */
#define VLAN_PROFILEm_MIN 0
#define VLAN_PROFILEm_MAX 15
#define VLAN_PROFILEm_CMAX(u) 15
#define VLAN_PROFILEm_SIZE 5

/*
 * This structure should be used to declare and program VLAN_PROFILE.
 */
typedef union VLAN_PROFILEm_s {
	uint32 v[2];
	uint32 vlan_profile[2];
	uint32 _vlan_profile;
} VLAN_PROFILEm_t;

#define VLAN_PROFILEm_CLR(r) sal_memset(&((r)._vlan_profile), 0, sizeof(VLAN_PROFILEm_t))
#define VLAN_PROFILEm_SET(r,i,d) (r).vlan_profile[i] = d
#define VLAN_PROFILEm_GET(r,i) (r).vlan_profile[i]

/*
 * These macros can be used to access individual fields.
 */
#define VLAN_PROFILEm_L2_PFMf_GET(r) (((r).vlan_profile[0]) & 0x3)
#define VLAN_PROFILEm_L2_PFMf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define VLAN_PROFILEm_L3_IPV4_PFMf_GET(r) ((((r).vlan_profile[0]) >> 2) & 0x3)
#define VLAN_PROFILEm_L3_IPV4_PFMf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define VLAN_PROFILEm_L3_IPV6_PFMf_GET(r) ((((r).vlan_profile[0]) >> 4) & 0x3)
#define VLAN_PROFILEm_L3_IPV6_PFMf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define VLAN_PROFILEm_UNKNOWN_IPV4_MC_TOCPUf_GET(r) ((((r).vlan_profile[0]) >> 6) & 0x1)
#define VLAN_PROFILEm_UNKNOWN_IPV4_MC_TOCPUf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define VLAN_PROFILEm_UNKNOWN_IPV6_MC_TOCPUf_GET(r) ((((r).vlan_profile[0]) >> 7) & 0x1)
#define VLAN_PROFILEm_UNKNOWN_IPV6_MC_TOCPUf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))
#define VLAN_PROFILEm_LEARN_DISABLEf_GET(r) ((((r).vlan_profile[0]) >> 8) & 0x1)
#define VLAN_PROFILEm_LEARN_DISABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 8)) | ((((uint32)f) & 0x1) << 8))
#define VLAN_PROFILEm_OUTER_TPID_INDEXf_GET(r) ((((r).vlan_profile[0]) >> 9) & 0x3)
#define VLAN_PROFILEm_OUTER_TPID_INDEXf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x3 << 9)) | ((((uint32)f) & 0x3) << 9))
#define VLAN_PROFILEm_ICMP_REDIRECT_TOCPUf_GET(r) ((((r).vlan_profile[0]) >> 11) & 0x1)
#define VLAN_PROFILEm_ICMP_REDIRECT_TOCPUf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 11)) | ((((uint32)f) & 0x1) << 11))
#define VLAN_PROFILEm_IPMCV6_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 12) & 0x1)
#define VLAN_PROFILEm_IPMCV6_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 12)) | ((((uint32)f) & 0x1) << 12))
#define VLAN_PROFILEm_IPMCV4_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 13) & 0x1)
#define VLAN_PROFILEm_IPMCV4_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 13)) | ((((uint32)f) & 0x1) << 13))
#define VLAN_PROFILEm_IPMCV6_L2_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 14) & 0x1)
#define VLAN_PROFILEm_IPMCV6_L2_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 14)) | ((((uint32)f) & 0x1) << 14))
#define VLAN_PROFILEm_IPMCV4_L2_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 15) & 0x1)
#define VLAN_PROFILEm_IPMCV4_L2_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 15)) | ((((uint32)f) & 0x1) << 15))
#define VLAN_PROFILEm_IPV6L3_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 16) & 0x1)
#define VLAN_PROFILEm_IPV6L3_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 16)) | ((((uint32)f) & 0x1) << 16))
#define VLAN_PROFILEm_IPV4L3_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 17) & 0x1)
#define VLAN_PROFILEm_IPV4L3_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 17)) | ((((uint32)f) & 0x1) << 17))
#define VLAN_PROFILEm_L2_MISS_TOCPUf_GET(r) ((((r).vlan_profile[0]) >> 18) & 0x1)
#define VLAN_PROFILEm_L2_MISS_TOCPUf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 18)) | ((((uint32)f) & 0x1) << 18))
#define VLAN_PROFILEm_L2_MISS_DROPf_GET(r) ((((r).vlan_profile[0]) >> 19) & 0x1)
#define VLAN_PROFILEm_L2_MISS_DROPf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 19)) | ((((uint32)f) & 0x1) << 19))
#define VLAN_PROFILEm_L2_NON_UCAST_TOCPUf_GET(r) ((((r).vlan_profile[0]) >> 20) & 0x1)
#define VLAN_PROFILEm_L2_NON_UCAST_TOCPUf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 20)) | ((((uint32)f) & 0x1) << 20))
#define VLAN_PROFILEm_L2_NON_UCAST_DROPf_GET(r) ((((r).vlan_profile[0]) >> 21) & 0x1)
#define VLAN_PROFILEm_L2_NON_UCAST_DROPf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 21)) | ((((uint32)f) & 0x1) << 21))
#define VLAN_PROFILEm_IPV6_ROUTING_HEADER_TYPE_0_DROPf_GET(r) ((((r).vlan_profile[0]) >> 22) & 0x1)
#define VLAN_PROFILEm_IPV6_ROUTING_HEADER_TYPE_0_DROPf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 22)) | ((((uint32)f) & 0x1) << 22))
#define VLAN_PROFILEm_IPMCV4_UNICAST_MACDA_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 23) & 0x1)
#define VLAN_PROFILEm_IPMCV4_UNICAST_MACDA_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 23)) | ((((uint32)f) & 0x1) << 23))
#define VLAN_PROFILEm_IPMCV6_UNICAST_MACDA_ENABLEf_GET(r) ((((r).vlan_profile[0]) >> 24) & 0x1)
#define VLAN_PROFILEm_IPMCV6_UNICAST_MACDA_ENABLEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0x1 << 24)) | ((((uint32)f) & 0x1) << 24))
#define VLAN_PROFILEm_CML_FLAGS_MOVEf_GET(r) ((((r).vlan_profile[0]) >> 25) & 0xf)
#define VLAN_PROFILEm_CML_FLAGS_MOVEf_SET(r,f) (r).vlan_profile[0]=(((r).vlan_profile[0] & ~((uint32)0xf << 25)) | ((((uint32)f) & 0xf) << 25))
#define VLAN_PROFILEm_CML_FLAGS_NEWf_GET(r) field32_get((r).vlan_profile,29,32)
#define VLAN_PROFILEm_CML_FLAGS_NEWf_SET(r,f) field32_set((r).vlan_profile,29,32,f)
#define VLAN_PROFILEm_USE_VLAN_CMLf_GET(r) ((((r).vlan_profile[1]) >> 1) & 0x1)
#define VLAN_PROFILEm_USE_VLAN_CMLf_SET(r,f) (r).vlan_profile[1]=(((r).vlan_profile[1] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))

/*
 * These macros can be used to access VLAN_PROFILE.
 */
#define WRITE_VLAN_PROFILEm(u,i,r) bcm5354x_mem_set(u, M_VLAN_PROFILE(i), &(r._vlan_profile), 2)
#define READ_VLAN_PROFILEm(u,i,r) bcm5354x_mem_get(u, M_VLAN_PROFILE(i), &(r._vlan_profile), 2)

/*******************************************************************************
 * End of 'VLAN_PROFILEm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * MEMORY:  VLAN_STG
 * BLOCKS:   IPIPE
 * DESC:      Spanning Tree Group state table
This table is indexed by Spanning Tree Group from the VLAN table (VLAN.STG) and the ingress port number. It is used to get the spanning tree state of the ingress port for a particular VLAN.
The following are the spanning tree states:
0 = Disabled. All packets are dropped, including control packets, even BPDUs.
1 = Blocking. All control/BPDU packets are sent to the CPU, all other packets are dropped (no L2 address learning).
2 = Learning. All control/BPDU packets are sent to the CPU, all other packets are dropped (L2 addresses are learned).
3 = Forwarding. All control/BPDU packets are sent to the CPU, all other packets are forwarded as normal.
 * SIZE:     65
 * FIELDS:
 *     SP_TREE_PORT0    Spanning Tree State for port 0
 *     SP_TREE_PORT1    Spanning Tree State for port 1
 *     SP_TREE_PORT2    Spanning Tree State for port 2
 *     SP_TREE_PORT3    Spanning Tree State for port 3
 *     SP_TREE_PORT4    Spanning Tree State for port 4
 *     SP_TREE_PORT5    Spanning Tree State for port 5
 *     SP_TREE_PORT6    Spanning Tree State for port 6
 *     SP_TREE_PORT7    Spanning Tree State for port 7
 *     SP_TREE_PORT8    Spanning Tree State for port 8
 *     SP_TREE_PORT9    Spanning Tree State for port 9
 *     SP_TREE_PORT10   Spanning Tree State for port 10
 *     SP_TREE_PORT11   Spanning Tree State for port 11
 *     SP_TREE_PORT12   Spanning Tree State for port 12
 *     SP_TREE_PORT13   Spanning Tree State for port 13
 *     SP_TREE_PORT14   Spanning Tree State for port 14
 *     SP_TREE_PORT15   Spanning Tree State for port 15
 *     SP_TREE_PORT16   Spanning Tree State for port 16
 *     SP_TREE_PORT17   Spanning Tree State for port 17
 *     SP_TREE_PORT18   Spanning Tree State for port 18
 *     SP_TREE_PORT19   Spanning Tree State for port 19
 *     SP_TREE_PORT20   Spanning Tree State for port 20
 *     SP_TREE_PORT21   Spanning Tree State for port 21
 *     SP_TREE_PORT22   Spanning Tree State for port 22
 *     SP_TREE_PORT23   Spanning Tree State for port 23
 *     SP_TREE_PORT24   Spanning Tree State for port 24
 *     SP_TREE_PORT25   Spanning Tree State for port 25
 *     SP_TREE_PORT26   Spanning Tree State for port 26
 *     SP_TREE_PORT27   Spanning Tree State for port 27
 *     SP_TREE_PORT28   Spanning Tree State for port 28
 *     SP_TREE_PORT29   Spanning Tree State for port 29
 *     SP_TREE_PORT30   Spanning Tree State for port 30
 *     SP_TREE_PORT31   Spanning Tree State for port 31
 *     EVEN_PARITY      Even Parity for the VLAN_STG table.
 */
#define VLAN_STGm_MIN 0
#define VLAN_STGm_MAX 127
#define VLAN_STGm_CMAX(u) 127
#define VLAN_STGm_SIZE 9

/*
 * This structure should be used to declare and program VLAN_STG.
 */
typedef union VLAN_STGm_s {
	uint32 v[3];
	uint32 vlan_stg[3];
	uint32 _vlan_stg;
} VLAN_STGm_t;

#define VLAN_STGm_CLR(r) sal_memset(&((r)._vlan_stg), 0, sizeof(VLAN_STGm_t))
#define VLAN_STGm_SET(r,i,d) (r).vlan_stg[i] = d
#define VLAN_STGm_GET(r,i) (r).vlan_stg[i]

/*
 * These macros can be used to access individual fields.
 */
#define VLAN_STGm_SP_TREE_PORT0f_GET(r) (((r).vlan_stg[0]) & 0x3)
#define VLAN_STGm_SP_TREE_PORT0f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define VLAN_STGm_SP_TREE_PORT1f_GET(r) ((((r).vlan_stg[0]) >> 2) & 0x3)
#define VLAN_STGm_SP_TREE_PORT1f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define VLAN_STGm_SP_TREE_PORT2f_GET(r) ((((r).vlan_stg[0]) >> 4) & 0x3)
#define VLAN_STGm_SP_TREE_PORT2f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define VLAN_STGm_SP_TREE_PORT3f_GET(r) ((((r).vlan_stg[0]) >> 6) & 0x3)
#define VLAN_STGm_SP_TREE_PORT3f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define VLAN_STGm_SP_TREE_PORT4f_GET(r) ((((r).vlan_stg[0]) >> 8) & 0x3)
#define VLAN_STGm_SP_TREE_PORT4f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define VLAN_STGm_SP_TREE_PORT5f_GET(r) ((((r).vlan_stg[0]) >> 10) & 0x3)
#define VLAN_STGm_SP_TREE_PORT5f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define VLAN_STGm_SP_TREE_PORT6f_GET(r) ((((r).vlan_stg[0]) >> 12) & 0x3)
#define VLAN_STGm_SP_TREE_PORT6f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define VLAN_STGm_SP_TREE_PORT7f_GET(r) ((((r).vlan_stg[0]) >> 14) & 0x3)
#define VLAN_STGm_SP_TREE_PORT7f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define VLAN_STGm_SP_TREE_PORT8f_GET(r) ((((r).vlan_stg[0]) >> 16) & 0x3)
#define VLAN_STGm_SP_TREE_PORT8f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define VLAN_STGm_SP_TREE_PORT9f_GET(r) ((((r).vlan_stg[0]) >> 18) & 0x3)
#define VLAN_STGm_SP_TREE_PORT9f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define VLAN_STGm_SP_TREE_PORT10f_GET(r) ((((r).vlan_stg[0]) >> 20) & 0x3)
#define VLAN_STGm_SP_TREE_PORT10f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define VLAN_STGm_SP_TREE_PORT11f_GET(r) ((((r).vlan_stg[0]) >> 22) & 0x3)
#define VLAN_STGm_SP_TREE_PORT11f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define VLAN_STGm_SP_TREE_PORT12f_GET(r) ((((r).vlan_stg[0]) >> 24) & 0x3)
#define VLAN_STGm_SP_TREE_PORT12f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define VLAN_STGm_SP_TREE_PORT13f_GET(r) ((((r).vlan_stg[0]) >> 26) & 0x3)
#define VLAN_STGm_SP_TREE_PORT13f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define VLAN_STGm_SP_TREE_PORT14f_GET(r) ((((r).vlan_stg[0]) >> 28) & 0x3)
#define VLAN_STGm_SP_TREE_PORT14f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define VLAN_STGm_SP_TREE_PORT15f_GET(r) ((((r).vlan_stg[0]) >> 30) & 0x3)
#define VLAN_STGm_SP_TREE_PORT15f_SET(r,f) (r).vlan_stg[0]=(((r).vlan_stg[0] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define VLAN_STGm_SP_TREE_PORT16f_GET(r) (((r).vlan_stg[1]) & 0x3)
#define VLAN_STGm_SP_TREE_PORT16f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define VLAN_STGm_SP_TREE_PORT17f_GET(r) ((((r).vlan_stg[1]) >> 2) & 0x3)
#define VLAN_STGm_SP_TREE_PORT17f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))
#define VLAN_STGm_SP_TREE_PORT18f_GET(r) ((((r).vlan_stg[1]) >> 4) & 0x3)
#define VLAN_STGm_SP_TREE_PORT18f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 4)) | ((((uint32)f) & 0x3) << 4))
#define VLAN_STGm_SP_TREE_PORT19f_GET(r) ((((r).vlan_stg[1]) >> 6) & 0x3)
#define VLAN_STGm_SP_TREE_PORT19f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 6)) | ((((uint32)f) & 0x3) << 6))
#define VLAN_STGm_SP_TREE_PORT20f_GET(r) ((((r).vlan_stg[1]) >> 8) & 0x3)
#define VLAN_STGm_SP_TREE_PORT20f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 8)) | ((((uint32)f) & 0x3) << 8))
#define VLAN_STGm_SP_TREE_PORT21f_GET(r) ((((r).vlan_stg[1]) >> 10) & 0x3)
#define VLAN_STGm_SP_TREE_PORT21f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 10)) | ((((uint32)f) & 0x3) << 10))
#define VLAN_STGm_SP_TREE_PORT22f_GET(r) ((((r).vlan_stg[1]) >> 12) & 0x3)
#define VLAN_STGm_SP_TREE_PORT22f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 12)) | ((((uint32)f) & 0x3) << 12))
#define VLAN_STGm_SP_TREE_PORT23f_GET(r) ((((r).vlan_stg[1]) >> 14) & 0x3)
#define VLAN_STGm_SP_TREE_PORT23f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 14)) | ((((uint32)f) & 0x3) << 14))
#define VLAN_STGm_SP_TREE_PORT24f_GET(r) ((((r).vlan_stg[1]) >> 16) & 0x3)
#define VLAN_STGm_SP_TREE_PORT24f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 16)) | ((((uint32)f) & 0x3) << 16))
#define VLAN_STGm_SP_TREE_PORT25f_GET(r) ((((r).vlan_stg[1]) >> 18) & 0x3)
#define VLAN_STGm_SP_TREE_PORT25f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 18)) | ((((uint32)f) & 0x3) << 18))
#define VLAN_STGm_SP_TREE_PORT26f_GET(r) ((((r).vlan_stg[1]) >> 20) & 0x3)
#define VLAN_STGm_SP_TREE_PORT26f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 20)) | ((((uint32)f) & 0x3) << 20))
#define VLAN_STGm_SP_TREE_PORT27f_GET(r) ((((r).vlan_stg[1]) >> 22) & 0x3)
#define VLAN_STGm_SP_TREE_PORT27f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 22)) | ((((uint32)f) & 0x3) << 22))
#define VLAN_STGm_SP_TREE_PORT28f_GET(r) ((((r).vlan_stg[1]) >> 24) & 0x3)
#define VLAN_STGm_SP_TREE_PORT28f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 24)) | ((((uint32)f) & 0x3) << 24))
#define VLAN_STGm_SP_TREE_PORT29f_GET(r) ((((r).vlan_stg[1]) >> 26) & 0x3)
#define VLAN_STGm_SP_TREE_PORT29f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 26)) | ((((uint32)f) & 0x3) << 26))
#define VLAN_STGm_SP_TREE_PORT30f_GET(r) ((((r).vlan_stg[1]) >> 28) & 0x3)
#define VLAN_STGm_SP_TREE_PORT30f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 28)) | ((((uint32)f) & 0x3) << 28))
#define VLAN_STGm_SP_TREE_PORT31f_GET(r) ((((r).vlan_stg[1]) >> 30) & 0x3)
#define VLAN_STGm_SP_TREE_PORT31f_SET(r,f) (r).vlan_stg[1]=(((r).vlan_stg[1] & ~((uint32)0x3 << 30)) | ((((uint32)f) & 0x3) << 30))
#define VLAN_STGm_EVEN_PARITYf_GET(r) (((r).vlan_stg[2]) & 0x1)
#define VLAN_STGm_EVEN_PARITYf_SET(r,f) (r).vlan_stg[2]=(((r).vlan_stg[2] & ~((uint32)0x1)) | (((uint32)f) & 0x1))

/*
 * These macros can be used to access VLAN_STG.
 */
#define WRITE_VLAN_STGm(u,i,r) bcm5354x_mem_set(u, M_VLAN_STG(i), &(r._vlan_stg), 3)
#define READ_VLAN_STGm(u,i,r) bcm5354x_mem_get(u, M_VLAN_STG(i), &(r._vlan_stg), 3)

/*******************************************************************************
 * End of 'VLAN_STGm'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  VLAN_SUBNET_CAM_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_CONTROL 
 * SIZE:     32
 * FIELDS:
 *     BIST_EN          BIST enable for cam engine
 *     DEBUG_EN         Set to put cam engine into debug mode
 *     TM               TM debug bits
 */
#define VLAN_SUBNET_CAM_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_DBGCTRL.
 */
typedef union VLAN_SUBNET_CAM_DBGCTRLr_s {
	uint32 v[1];
	uint32 vlan_subnet_cam_dbgctrl[1];
	uint32 _vlan_subnet_cam_dbgctrl;
} VLAN_SUBNET_CAM_DBGCTRLr_t;

#define VLAN_SUBNET_CAM_DBGCTRLr_CLR(r) (r).vlan_subnet_cam_dbgctrl[0] = 0
#define VLAN_SUBNET_CAM_DBGCTRLr_SET(r,d) (r).vlan_subnet_cam_dbgctrl[0] = d
#define VLAN_SUBNET_CAM_DBGCTRLr_GET(r) (r).vlan_subnet_cam_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define VLAN_SUBNET_CAM_DBGCTRLr_BIST_ENf_GET(r) (((r).vlan_subnet_cam_dbgctrl[0]) & 0x1)
#define VLAN_SUBNET_CAM_DBGCTRLr_BIST_ENf_SET(r,f) (r).vlan_subnet_cam_dbgctrl[0]=(((r).vlan_subnet_cam_dbgctrl[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define VLAN_SUBNET_CAM_DBGCTRLr_DEBUG_ENf_GET(r) ((((r).vlan_subnet_cam_dbgctrl[0]) >> 1) & 0x1)
#define VLAN_SUBNET_CAM_DBGCTRLr_DEBUG_ENf_SET(r,f) (r).vlan_subnet_cam_dbgctrl[0]=(((r).vlan_subnet_cam_dbgctrl[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define VLAN_SUBNET_CAM_DBGCTRLr_TMf_GET(r) ((((r).vlan_subnet_cam_dbgctrl[0]) >> 2) & 0xfffff)
#define VLAN_SUBNET_CAM_DBGCTRLr_TMf_SET(r,f) (r).vlan_subnet_cam_dbgctrl[0]=(((r).vlan_subnet_cam_dbgctrl[0] & ~((uint32)0xfffff << 2)) | ((((uint32)f) & 0xfffff) << 2))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_DBGCTRL.
 */
#define WRITE_VLAN_SUBNET_CAM_DBGCTRLr(u,r) bcm5354x_reg_set(u,R_VLAN_SUBNET_CAM_DBGCTRL,(r._vlan_subnet_cam_dbgctrl))
#define READ_VLAN_SUBNET_CAM_DBGCTRLr(u,r) bcm5354x_reg_get(u,R_VLAN_SUBNET_CAM_DBGCTRL,&(r._vlan_subnet_cam_dbgctrl))

/*******************************************************************************
 * End of 'VLAN_SUBNET_CAM_DBGCTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  WRRWEIGHT_COS0
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS0r_SIZE 4

/* WRRWEIGHT_COS0r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS0.
 */
typedef union WRRWEIGHT_COS0r_s {
	uint32 v[1];
	uint32 wrrweight_cos0[1];
	uint32 _wrrweight_cos0;
} WRRWEIGHT_COS0r_t;

#define WRRWEIGHT_COS0r_CLR(r) (r).wrrweight_cos0[0] = 0
#define WRRWEIGHT_COS0r_SET(r,d) (r).wrrweight_cos0[0] = d
#define WRRWEIGHT_COS0r_GET(r) (r).wrrweight_cos0[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS0r_WEIGHTf_GET(r) (((r).wrrweight_cos0[0]) & 0x7f)
#define WRRWEIGHT_COS0r_WEIGHTf_SET(r,f) (r).wrrweight_cos0[0]=(((r).wrrweight_cos0[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS0r_ENABLEf_GET(r) ((((r).wrrweight_cos0[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS0r_ENABLEf_SET(r,f) (r).wrrweight_cos0[0]=(((r).wrrweight_cos0[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS0.
 */
#define WRITE_WRRWEIGHT_COS0r(u,p,r) bcm5354x_reg_set(u,R_WRRWEIGHT_COS0(p),(r._wrrweight_cos0))
#define READ_WRRWEIGHT_COS0r(u,p,r) bcm5354x_reg_get(u,R_WRRWEIGHT_COS0(p),&(r._wrrweight_cos0))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS0r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  WRRWEIGHT_COS1
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS1r_SIZE 4

/* WRRWEIGHT_COS1r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS1.
 */
typedef union WRRWEIGHT_COS1r_s {
	uint32 v[1];
	uint32 wrrweight_cos1[1];
	uint32 _wrrweight_cos1;
} WRRWEIGHT_COS1r_t;

#define WRRWEIGHT_COS1r_CLR(r) (r).wrrweight_cos1[0] = 0
#define WRRWEIGHT_COS1r_SET(r,d) (r).wrrweight_cos1[0] = d
#define WRRWEIGHT_COS1r_GET(r) (r).wrrweight_cos1[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS1r_WEIGHTf_GET(r) (((r).wrrweight_cos1[0]) & 0x7f)
#define WRRWEIGHT_COS1r_WEIGHTf_SET(r,f) (r).wrrweight_cos1[0]=(((r).wrrweight_cos1[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS1r_ENABLEf_GET(r) ((((r).wrrweight_cos1[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS1r_ENABLEf_SET(r,f) (r).wrrweight_cos1[0]=(((r).wrrweight_cos1[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS1.
 */
#define WRITE_WRRWEIGHT_COS1r(u,p,r) bcm5354x_reg_set(u,R_WRRWEIGHT_COS1(p),(r._wrrweight_cos1))
#define READ_WRRWEIGHT_COS1r(u,p,r) bcm5354x_reg_get(u,R_WRRWEIGHT_COS1(p),&(r._wrrweight_cos1))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS1r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  WRRWEIGHT_COS2
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS2r_SIZE 4

/* WRRWEIGHT_COS2r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS2.
 */
typedef union WRRWEIGHT_COS2r_s {
	uint32 v[1];
	uint32 wrrweight_cos2[1];
	uint32 _wrrweight_cos2;
} WRRWEIGHT_COS2r_t;

#define WRRWEIGHT_COS2r_CLR(r) (r).wrrweight_cos2[0] = 0
#define WRRWEIGHT_COS2r_SET(r,d) (r).wrrweight_cos2[0] = d
#define WRRWEIGHT_COS2r_GET(r) (r).wrrweight_cos2[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS2r_WEIGHTf_GET(r) (((r).wrrweight_cos2[0]) & 0x7f)
#define WRRWEIGHT_COS2r_WEIGHTf_SET(r,f) (r).wrrweight_cos2[0]=(((r).wrrweight_cos2[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS2r_ENABLEf_GET(r) ((((r).wrrweight_cos2[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS2r_ENABLEf_SET(r,f) (r).wrrweight_cos2[0]=(((r).wrrweight_cos2[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS2.
 */
#define WRITE_WRRWEIGHT_COS2r(u,p,r) bcm5354x_reg_set(u,R_WRRWEIGHT_COS2(p),(r._wrrweight_cos2))
#define READ_WRRWEIGHT_COS2r(u,p,r) bcm5354x_reg_get(u,R_WRRWEIGHT_COS2(p),&(r._wrrweight_cos2))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS2r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  WRRWEIGHT_COS3
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS3r_SIZE 4

/* WRRWEIGHT_COS3r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS3.
 */
typedef union WRRWEIGHT_COS3r_s {
	uint32 v[1];
	uint32 wrrweight_cos3[1];
	uint32 _wrrweight_cos3;
} WRRWEIGHT_COS3r_t;

#define WRRWEIGHT_COS3r_CLR(r) (r).wrrweight_cos3[0] = 0
#define WRRWEIGHT_COS3r_SET(r,d) (r).wrrweight_cos3[0] = d
#define WRRWEIGHT_COS3r_GET(r) (r).wrrweight_cos3[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS3r_WEIGHTf_GET(r) (((r).wrrweight_cos3[0]) & 0x7f)
#define WRRWEIGHT_COS3r_WEIGHTf_SET(r,f) (r).wrrweight_cos3[0]=(((r).wrrweight_cos3[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS3r_ENABLEf_GET(r) ((((r).wrrweight_cos3[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS3r_ENABLEf_SET(r,f) (r).wrrweight_cos3[0]=(((r).wrrweight_cos3[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS3.
 */
#define WRITE_WRRWEIGHT_COS3r(u,p,r) bcm5354x_reg_set(u,R_WRRWEIGHT_COS3(p),(r._wrrweight_cos3))
#define READ_WRRWEIGHT_COS3r(u,p,r) bcm5354x_reg_get(u,R_WRRWEIGHT_COS3(p),&(r._wrrweight_cos3))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS3r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  WRRWEIGHT_COS4
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS4r_SIZE 4

/* WRRWEIGHT_COS4r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS4.
 */
typedef union WRRWEIGHT_COS4r_s {
	uint32 v[1];
	uint32 wrrweight_cos4[1];
	uint32 _wrrweight_cos4;
} WRRWEIGHT_COS4r_t;

#define WRRWEIGHT_COS4r_CLR(r) (r).wrrweight_cos4[0] = 0
#define WRRWEIGHT_COS4r_SET(r,d) (r).wrrweight_cos4[0] = d
#define WRRWEIGHT_COS4r_GET(r) (r).wrrweight_cos4[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS4r_WEIGHTf_GET(r) (((r).wrrweight_cos4[0]) & 0x7f)
#define WRRWEIGHT_COS4r_WEIGHTf_SET(r,f) (r).wrrweight_cos4[0]=(((r).wrrweight_cos4[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS4r_ENABLEf_GET(r) ((((r).wrrweight_cos4[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS4r_ENABLEf_SET(r,f) (r).wrrweight_cos4[0]=(((r).wrrweight_cos4[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS4.
 */
#define WRITE_WRRWEIGHT_COS4r(u,p,r) bcm5354x_reg_set(u,R_WRRWEIGHT_COS4(p),(r._wrrweight_cos4))
#define READ_WRRWEIGHT_COS4r(u,p,r) bcm5354x_reg_get(u,R_WRRWEIGHT_COS4(p),&(r._wrrweight_cos4))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS4r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  WRRWEIGHT_COS5
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS5r_SIZE 4

/* WRRWEIGHT_COS5r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS5.
 */
typedef union WRRWEIGHT_COS5r_s {
	uint32 v[1];
	uint32 wrrweight_cos5[1];
	uint32 _wrrweight_cos5;
} WRRWEIGHT_COS5r_t;

#define WRRWEIGHT_COS5r_CLR(r) (r).wrrweight_cos5[0] = 0
#define WRRWEIGHT_COS5r_SET(r,d) (r).wrrweight_cos5[0] = d
#define WRRWEIGHT_COS5r_GET(r) (r).wrrweight_cos5[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS5r_WEIGHTf_GET(r) (((r).wrrweight_cos5[0]) & 0x7f)
#define WRRWEIGHT_COS5r_WEIGHTf_SET(r,f) (r).wrrweight_cos5[0]=(((r).wrrweight_cos5[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS5r_ENABLEf_GET(r) ((((r).wrrweight_cos5[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS5r_ENABLEf_SET(r,f) (r).wrrweight_cos5[0]=(((r).wrrweight_cos5[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS5.
 */
#define WRITE_WRRWEIGHT_COS5r(u,p,r) bcm5354x_reg_set(u,R_WRRWEIGHT_COS5(p),(r._wrrweight_cos5))
#define READ_WRRWEIGHT_COS5r(u,p,r) bcm5354x_reg_get(u,R_WRRWEIGHT_COS5(p),&(r._wrrweight_cos5))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS5r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  WRRWEIGHT_COS6
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS6r_SIZE 4

/* WRRWEIGHT_COS6r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS6.
 */
typedef union WRRWEIGHT_COS6r_s {
	uint32 v[1];
	uint32 wrrweight_cos6[1];
	uint32 _wrrweight_cos6;
} WRRWEIGHT_COS6r_t;

#define WRRWEIGHT_COS6r_CLR(r) (r).wrrweight_cos6[0] = 0
#define WRRWEIGHT_COS6r_SET(r,d) (r).wrrweight_cos6[0] = d
#define WRRWEIGHT_COS6r_GET(r) (r).wrrweight_cos6[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS6r_WEIGHTf_GET(r) (((r).wrrweight_cos6[0]) & 0x7f)
#define WRRWEIGHT_COS6r_WEIGHTf_SET(r,f) (r).wrrweight_cos6[0]=(((r).wrrweight_cos6[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS6r_ENABLEf_GET(r) ((((r).wrrweight_cos6[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS6r_ENABLEf_SET(r,f) (r).wrrweight_cos6[0]=(((r).wrrweight_cos6[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS6.
 */
#define WRITE_WRRWEIGHT_COS6r(u,p,r) bcm5354x_reg_set(u,R_WRRWEIGHT_COS6(p),(r._wrrweight_cos6))
#define READ_WRRWEIGHT_COS6r(u,p,r) bcm5354x_reg_get(u,R_WRRWEIGHT_COS6(p),&(r._wrrweight_cos6))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS6r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  WRRWEIGHT_COS7
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weight defines how many packets can be trasmitted in one run.0 = Treat this queue as a strict priority queue.1-128 = This will be the multiplication factor with the chosen MTU quanta specified in XQCOSARBSEL.MTU_QUANTA when in Weighted Deficit Round Robin mode, or the chosen packet number when in Weighted Round Robin mode. 
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: Disable1: Enable
 */
#define WRRWEIGHT_COS7r_SIZE 4

/* WRRWEIGHT_COS7r is element of WRRWEIGHT_COS */

/*
 * This structure should be used to declare and program WRRWEIGHT_COS7.
 */
typedef union WRRWEIGHT_COS7r_s {
	uint32 v[1];
	uint32 wrrweight_cos7[1];
	uint32 _wrrweight_cos7;
} WRRWEIGHT_COS7r_t;

#define WRRWEIGHT_COS7r_CLR(r) (r).wrrweight_cos7[0] = 0
#define WRRWEIGHT_COS7r_SET(r,d) (r).wrrweight_cos7[0] = d
#define WRRWEIGHT_COS7r_GET(r) (r).wrrweight_cos7[0]

/*
 * These macros can be used to access individual fields.
 */
#define WRRWEIGHT_COS7r_WEIGHTf_GET(r) (((r).wrrweight_cos7[0]) & 0x7f)
#define WRRWEIGHT_COS7r_WEIGHTf_SET(r,f) (r).wrrweight_cos7[0]=(((r).wrrweight_cos7[0] & ~((uint32)0x7f)) | (((uint32)f) & 0x7f))
#define WRRWEIGHT_COS7r_ENABLEf_GET(r) ((((r).wrrweight_cos7[0]) >> 7) & 0x1)
#define WRRWEIGHT_COS7r_ENABLEf_SET(r,f) (r).wrrweight_cos7[0]=(((r).wrrweight_cos7[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS7.
 */
#define WRITE_WRRWEIGHT_COS7r(u,p,r) bcm5354x_reg_set(u,R_WRRWEIGHT_COS7(p),(r._wrrweight_cos7))
#define READ_WRRWEIGHT_COS7r(u,p,r) bcm5354x_reg_get(u,R_WRRWEIGHT_COS7(p),&(r._wrrweight_cos7))

/*******************************************************************************
 * End of 'WRRWEIGHT_COS7r'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  XQCOSARBSEL
 * BLOCKS:   MMU
 * DESC:     Scheduler Control Selection
 * SIZE:     32
 * FIELDS:
 *     COSARB           Scheduler Control Options as cosArb value: 0: Strict priority among valid COSs. (default value)1: Round Robin Queueing among valid COSs.2: Weightd Round Robin Queueing, WRR, scheduling according to WRRWEIGHT_COS.3: Weighted Deficit Round Robin Queueing, WDRR, scheduling according to WRRWEIGHT_COS.
 *     MTU_QUANTA_SELECT Selected MTU_QUANTA when in Weighted Deficit Round Robin mode:0: MTU Quanta is 2048 bytes. 1: MTU Quanta is 4096 bytes.2: MTU Quanta is 8192 bytes.3: MTU Quanta is 16384 bytes (default value)
 */
#define XQCOSARBSELr_SIZE 4

/*
 * This structure should be used to declare and program XQCOSARBSEL.
 */
typedef union XQCOSARBSELr_s {
	uint32 v[1];
	uint32 xqcosarbsel[1];
	uint32 _xqcosarbsel;
} XQCOSARBSELr_t;

#define XQCOSARBSELr_CLR(r) (r).xqcosarbsel[0] = 0
#define XQCOSARBSELr_SET(r,d) (r).xqcosarbsel[0] = d
#define XQCOSARBSELr_GET(r) (r).xqcosarbsel[0]

/*
 * These macros can be used to access individual fields.
 */
#define XQCOSARBSELr_COSARBf_GET(r) (((r).xqcosarbsel[0]) & 0x3)
#define XQCOSARBSELr_COSARBf_SET(r,f) (r).xqcosarbsel[0]=(((r).xqcosarbsel[0] & ~((uint32)0x3)) | (((uint32)f) & 0x3))
#define XQCOSARBSELr_MTU_QUANTA_SELECTf_GET(r) ((((r).xqcosarbsel[0]) >> 2) & 0x3)
#define XQCOSARBSELr_MTU_QUANTA_SELECTf_SET(r,f) (r).xqcosarbsel[0]=(((r).xqcosarbsel[0] & ~((uint32)0x3 << 2)) | ((((uint32)f) & 0x3) << 2))

/*
 * These macros can be used to access XQCOSARBSEL.
 */
#define WRITE_XQCOSARBSELr(u,p,r) bcm5354x_reg_set(u,R_XQCOSARBSEL(p),(r._xqcosarbsel))
#define READ_XQCOSARBSELr(u,p,r) bcm5354x_reg_get(u,R_XQCOSARBSEL(p),&(r._xqcosarbsel))

/*******************************************************************************
 * End of 'XQCOSARBSELr'
 */




/*******************************************************************************
 * CHIP:  BCM5354X
 * REGISTER:  XQEMPTY
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     COS0             COS0 has no entries for this port
 *     COS1             COS1 has no entries for this port
 *     COS2             COS2 has no entries for this port
 *     COS3             COS3 has no entries for this port
 *     COS4             COS4 has no entries for this port
 *     COS5             COS5 has no entries for this port
 *     COS6             COS6 has no entries for this port
 *     COS7             COS7 has no entries for this port
 */
#define XQEMPTYr_SIZE 4

/*
 * This structure should be used to declare and program XQEMPTY.
 */
typedef union XQEMPTYr_s {
	uint32 v[1];
	uint32 xqempty[1];
	uint32 _xqempty;
} XQEMPTYr_t;

#define XQEMPTYr_CLR(r) (r).xqempty[0] = 0
#define XQEMPTYr_SET(r,d) (r).xqempty[0] = d
#define XQEMPTYr_GET(r) (r).xqempty[0]

/*
 * These macros can be used to access individual fields.
 */
#define XQEMPTYr_COS0f_GET(r) (((r).xqempty[0]) & 0x1)
#define XQEMPTYr_COS0f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32)0x1)) | (((uint32)f) & 0x1))
#define XQEMPTYr_COS1f_GET(r) ((((r).xqempty[0]) >> 1) & 0x1)
#define XQEMPTYr_COS1f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32)0x1 << 1)) | ((((uint32)f) & 0x1) << 1))
#define XQEMPTYr_COS2f_GET(r) ((((r).xqempty[0]) >> 2) & 0x1)
#define XQEMPTYr_COS2f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32)0x1 << 2)) | ((((uint32)f) & 0x1) << 2))
#define XQEMPTYr_COS3f_GET(r) ((((r).xqempty[0]) >> 3) & 0x1)
#define XQEMPTYr_COS3f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32)0x1 << 3)) | ((((uint32)f) & 0x1) << 3))
#define XQEMPTYr_COS4f_GET(r) ((((r).xqempty[0]) >> 4) & 0x1)
#define XQEMPTYr_COS4f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32)0x1 << 4)) | ((((uint32)f) & 0x1) << 4))
#define XQEMPTYr_COS5f_GET(r) ((((r).xqempty[0]) >> 5) & 0x1)
#define XQEMPTYr_COS5f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32)0x1 << 5)) | ((((uint32)f) & 0x1) << 5))
#define XQEMPTYr_COS6f_GET(r) ((((r).xqempty[0]) >> 6) & 0x1)
#define XQEMPTYr_COS6f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32)0x1 << 6)) | ((((uint32)f) & 0x1) << 6))
#define XQEMPTYr_COS7f_GET(r) ((((r).xqempty[0]) >> 7) & 0x1)
#define XQEMPTYr_COS7f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32)0x1 << 7)) | ((((uint32)f) & 0x1) << 7))

/*
 * These macros can be used to access XQEMPTY.
 */
#define WRITE_XQEMPTYr(u,p,r) bcm5354x_reg_set(u,R_XQEMPTY(p),(r._xqempty))
#define READ_XQEMPTYr(u,p,r) bcm5354x_reg_get(u,R_XQEMPTY(p),&(r._xqempty))

/*******************************************************************************
 * End of 'XQEMPTYr'
 */




#endif /* __BCM5354X_REGS_H__ */
