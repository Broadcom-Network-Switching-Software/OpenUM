/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenUM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * File:        bcm53540_a0.c
 * Purpose:     bcm53540_a0 chip specific information (register, memories, etc)
 */


#include <sal/core/libc.h>
#include <soc/defs.h>
#include <soc/mem.h>
#include <soc/mcm/driver.h>
#include <soc/mcm/allenum.h>
#include <soc/mcm/intenum.h>
#include <soc/drv.h>
#include <shared/bsl.h>


#if defined(BCM_53540_A0)
static const soc_block_info_t soc_blocks_bcm53540_a0[] = {
    { SOC_BLK_AVS,          0,   17,  17   }, /* 0 A0 */
    { SOC_BLK_CMIC,         0,   14,  14   }, /* 1 C0 */
    { SOC_BLK_EPIPE,        0,   11,  11   }, /* 2 E0 */
    { SOC_BLK_GPORT,        0,   33,  33   }, /* 3 G0 */
    { SOC_BLK_GPORT,        1,   34,  34   }, /* 4 G1 */
    { SOC_BLK_GPORT,        2,   37,  37   }, /* 5 G2 */
    { SOC_BLK_GPORT,        3,   38,  38   }, /* 6 G3 */
    { SOC_BLK_GPORT,        4,   41,  41   }, /* 7 G4 */
    { SOC_BLK_IPIPE,        0,   10,  10   }, /* 8 I0 */
    { SOC_BLK_IPROC,        0,   15,  15   }, /* 9 I0 */
    { SOC_BLK_MMU,          0,   12,  12   }, /* 10 M0 */
    { SOC_BLK_OTPC,         0,   13,  13   }, /* 11 O0 */
    { SOC_BLK_PGW_GE,       0,   32,  32   }, /* 12 P0 */
    { SOC_BLK_PGW_GE,       1,   36,  36   }, /* 13 P1 */
    { SOC_BLK_PGW_GE,       2,   40,  40   }, /* 14 P2 */
    { SOC_BLK_PMQ,          0,   35,  35   }, /* 15 P0 */
    { SOC_BLK_PMQ,          1,   39,  39   }, /* 16 P1 */
    { SOC_BLK_PMQ,          2,   42,  42   }, /* 17 P2 */
    { SOC_BLK_SER,          0,   19,  19   }, /* 18 S0 */
    { SOC_BLK_TOP,          0,   16,  16   }, /* 19 T0 */
    { -1,                   -1,  -1,  -1   }  /* end */
};

static const soc_port_info_t soc_ports_bcm53540_a0[] = {
    { 1,   0   }, /* 0 C0.0 */
    { -1,  0   }, /* 0 - */
    { -1,  0   }, /* 1 - */
    { -1,  0   }, /* 1 - */
    { 3,   0   }, /* 2 G0.0 */
    { 12,  0   }, /* 2 P0.0 */
    { 3,   1   }, /* 3 G0.1 */
    { 12,  1   }, /* 3 P0.1 */
    { 3,   2   }, /* 4 G0.2 */
    { 12,  2   }, /* 4 P0.2 */
    { 3,   3   }, /* 5 G0.3 */
    { 12,  3   }, /* 5 P0.3 */
    { 3,   4   }, /* 6 G0.4 */
    { 12,  4   }, /* 6 P0.4 */
    { 3,   5   }, /* 7 G0.5 */
    { 12,  5   }, /* 7 P0.5 */
    { 3,   6   }, /* 8 G0.6 */
    { 12,  6   }, /* 8 P0.6 */
    { 3,   7   }, /* 9 G0.7 */
    { 12,  7   }, /* 9 P0.7 */
    { 4,   0   }, /* 10 G1.0 */
    { 12,  8   }, /* 10 P0.8 */
    { 4,   1   }, /* 11 G1.1 */
    { 12,  9   }, /* 11 P0.9 */
    { 4,   2   }, /* 12 G1.2 */
    { 12,  10  }, /* 12 P0.10 */
    { 4,   3   }, /* 13 G1.3 */
    { 12,  11  }, /* 13 P0.11 */
    { 4,   4   }, /* 14 G1.4 */
    { 12,  12  }, /* 14 P0.12 */
    { 4,   5   }, /* 15 G1.5 */
    { 12,  13  }, /* 15 P0.13 */
    { 4,   6   }, /* 16 G1.6 */
    { 12,  14  }, /* 16 P0.14 */
    { 4,   7   }, /* 17 G1.7 */
    { 12,  15  }, /* 17 P0.15 */
    { 5,   0   }, /* 18 G2.0 */
    { 13,  0   }, /* 18 P1.0 */
    { 5,   1   }, /* 19 G2.1 */
    { 13,  1   }, /* 19 P1.1 */
    { 5,   2   }, /* 20 G2.2 */
    { 13,  2   }, /* 20 P1.2 */
    { 5,   3   }, /* 21 G2.3 */
    { 13,  3   }, /* 21 P1.3 */
    { 5,   4   }, /* 22 G2.4 */
    { 13,  4   }, /* 22 P1.4 */
    { 5,   5   }, /* 23 G2.5 */
    { 13,  5   }, /* 23 P1.5 */
    { 5,   6   }, /* 24 G2.6 */
    { 13,  6   }, /* 24 P1.6 */
    { 5,   7   }, /* 25 G2.7 */
    { 13,  7   }, /* 25 P1.7 */
    { 6,   0   }, /* 26 G3.0 */
    { 13,  8   }, /* 26 P1.8 */
    { 6,   1   }, /* 27 G3.1 */
    { 13,  9   }, /* 27 P1.9 */
    { 6,   2   }, /* 28 G3.2 */
    { 13,  10  }, /* 28 P1.10 */
    { 6,   3   }, /* 29 G3.3 */
    { 13,  11  }, /* 29 P1.11 */
    { 6,   4   }, /* 30 G3.4 */
    { 13,  12  }, /* 30 P1.12 */
    { 6,   5   }, /* 31 G3.5 */
    { 13,  13  }, /* 31 P1.13 */
    { 6,   6   }, /* 32 G3.6 */
    { 13,  14  }, /* 32 P1.14 */
    { 6,   7   }, /* 33 G3.7 */
    { 13,  15  }, /* 33 P1.15 */
    { 7,   0   }, /* 34 G4.0 */
    { 14,  0   }, /* 34 P2.0 */
    { 7,   1   }, /* 35 G4.1 */
    { 14,  1   }, /* 35 P2.1 */
    { 7,   2   }, /* 36 G4.2 */
    { 14,  2   }, /* 36 P2.2 */
    { 7,   3   }, /* 37 G4.3 */
    { 14,  3   }, /* 37 P2.3 */
    { -1,  -1  }  /* end */
};

soc_driver_t soc_driver_bcm53540_a0 = {
    /* type                   */ SOC_CHIP_BCM53540_A0,
    /* chip_string            */ "wolfhound2",
    /* origin                 */ "Id: //depot/wolfhound2/regsfile/chip_top.regs#1 ",
    /* pci_vendor             */ BROADCOM_VENDOR_ID,
    /* pci_device             */ BCM53540_DEVICE_ID,
    /* pci_revision           */ BCM53540_A0_REV_ID,
    /* num_cos                */ 8,
    /* reg_info               */ NULL,
    /* reg_unique_acc         */ NULL,
    /* reg_above_64_info      */ NULL,
    /* reg_array_info         */ NULL,
    /* mem_info               */ NULL,
    /* mem_unique_acc         */ NULL,
    /* mem_aggr               */ NULL,
    /* mem_array_info         */ NULL,
    /* block_info             */ (soc_block_info_t *)soc_blocks_bcm53540_a0,
    /* port_info              */ (soc_port_info_t *)soc_ports_bcm53540_a0,
    /* counter_maps           */ NULL,
    /* features               */ NULL,
    /* init                   */ NULL,
    /* services               */ NULL,
    /* port_num_blktype       */ 2,
    /* cmicd_base             */ 0x03200000
};  /* soc_driver             */

/*
 * Function:    soc_feature_init
 * Purpose:     initialize features into the SOC_CONTROL cache
 * Parameters:  unit    - the device
 * Returns:     void
 */
void
soc_feature_init(int unit)
{
    sal_memset(SOC_CONTROL(unit)->features, 0, sizeof(SOC_CONTROL(unit)->features));

    SOC_FEATURE_SET(unit, soc_feature_logical_port_num);
    SOC_FEATURE_SET(unit, soc_feature_wh2);
}


soc_driver_t *soc_chip_driver_find(uint16 dev_id, uint8 rev_id) {	    
      return &soc_driver_bcm53540_a0;
}

/*
 * Function:
 *      soc_info_config
 * Parameters:
 *      unit - Unit number
 *      soc - soc_control_t associated with this unit
 * Purpose:
 *      Fill in soc_info structure for a newly attached unit.
 *      Generates bitmaps and various arrays based on block and
 *      ports that the hardware has enabled.
 *
 *      This isn't STATIC so that pcid can get at it.
 */

int
soc_wolfhound2_info_config(int unit, soc_control_t *soc)
{
    soc_info_t          *si;
    
    uint16              dev_id;
    uint8               rev_id;
    int                 port, phy_port, blk, bindex;
    int                 port_idx;

    SOC_CONTROL(unit) = soc;
    si = &soc->info;
    
    soc_cm_get_id(unit, &dev_id, &rev_id);

    /*
     * Instantiate the driver -- Verify chip revision matches driver
     * compilation revision.
     */
    soc->chip_driver = soc_chip_driver_find(dev_id, rev_id);

    soc->soc_functions = soc_chip_drv_funs_find(dev_id, rev_id);

    /* Set feature cache, since used by mutex creation */
    soc_feature_init(unit);

    /*
     * Attached flag must be true during initialization.
     * If initialization fails, the flag is cleared by soc_detach (below).
     */
    soc->soc_flags |= SOC_F_ATTACHED;

    /*
     * Used to implement the SOC_IS_*(unit) macros
     */    
    si->chip_type = SOC_INFO_CHIP_TYPE_HURRICANE3;

#if UM_DEBUG
    bsl_printf("si = %p si->port_p2l_mapping=%p\n", si, si->port_p2l_mapping);
    bsl_printf("SOC_MAX_NUM_PORTS = %x SOC_MAX_NUM_BLKS=%x sizeof(pbmp_t)=%x\n", SOC_MAX_NUM_PORTS, SOC_MAX_NUM_BLKS, sizeof(pbmp_t));
#endif

    for (phy_port = 0; ; phy_port++) {
        blk = SOC_PORT_IDX_BLOCK(unit, phy_port, 0);
        bindex = SOC_PORT_IDX_BINDEX(unit, phy_port, 0);

        if (blk < 0 && bindex < 0) { /* end of regsfile port list */
            break;
        }
        port = si->port_p2l_mapping[phy_port];
        if (port < 0) { /* not used in user config */
            continue;
        }
		    LOG_ERROR(BSL_LS_SOC_COMMON, 
		             (BSL_META_U(unit, " %d port\n"), port));

        if (blk < 0) { /* disabled port */
            continue;
        }

        for (port_idx = 0; port_idx < SOC_DRIVER(unit)->port_num_blktype;
             port_idx++) {

            blk = SOC_PORT_IDX_BLOCK(unit, phy_port, port_idx);
            if (blk < 0) { /* end of block list of each port */
                break;
            }            
            SOC_PBMP_PORT_ADD(si->block_bitmap[blk], port);

        }
    }
    return SOC_E_NONE;
}
#endif /* BCM_53540_A0 */
